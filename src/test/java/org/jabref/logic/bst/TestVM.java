begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.jabref.logic.bst
package|package
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|bst
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|bst
operator|.
name|VM
operator|.
name|BstEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|bst
operator|.
name|VM
operator|.
name|StackFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|importer
operator|.
name|ImportFormatPreferences
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|importer
operator|.
name|ParserResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|importer
operator|.
name|fileformat
operator|.
name|BibtexParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|BibEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|RecognitionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|Answers
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|mock
import|;
end_import

begin_class
DECL|class|TestVM
specifier|public
class|class
name|TestVM
block|{
annotation|@
name|Test
DECL|method|testAbbrv ()
specifier|public
name|void
name|testAbbrv
parameter_list|()
throws|throws
name|RecognitionException
throws|,
name|IOException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
operator|new
name|File
argument_list|(
literal|"src/test/resources/org/jabref/logic/bst/abbrv.bst"
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|v
operator|.
name|add
argument_list|(
name|t1BibtexEntry
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|expected
init|=
literal|"\\begin{thebibliography}{1}\\bibitem{canh05}K.~Crowston, H.~Annabi, J.~Howison, and C.~Masango.\\newblock Effective work practices for floss development: A model and  propositions.\\newblock In {\\em Hawaii International Conference On System Sciences (HICSS)}, 2005.\\end{thebibliography}"
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|expected
operator|.
name|replaceAll
argument_list|(
literal|"\\s"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\s"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testVMSimple ()
specifier|public
name|void
name|testVMSimple
parameter_list|()
throws|throws
name|RecognitionException
throws|,
name|IOException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"ENTRY  { "
operator|+
literal|"  address "
operator|+
literal|"  author "
operator|+
literal|"  title "
operator|+
literal|"  type "
operator|+
literal|"}  {}  { label }"
operator|+
literal|"INTEGERS { output.state before.all"
operator|+
literal|" mid.sentence after.sentence after.block }"
operator|+
literal|"FUNCTION {init.state.consts}{ #0 'before.all := "
operator|+
literal|" #1 'mid.sentence :=  #2 'after.sentence :=  #3 'after.block := } "
operator|+
literal|"STRINGS { s t } "
operator|+
literal|"READ"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|v
operator|.
name|add
argument_list|(
name|t1BibtexEntry
argument_list|()
argument_list|)
expr_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|vm
operator|.
name|getStrings
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|7
argument_list|,
name|vm
operator|.
name|getIntegers
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|vm
operator|.
name|getEntries
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|vm
operator|.
name|getEntries
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getFields
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|38
argument_list|,
name|vm
operator|.
name|getFunctions
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testLabel ()
specifier|public
name|void
name|testLabel
parameter_list|()
throws|throws
name|RecognitionException
throws|,
name|IOException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"ENTRY  { title }  {}  { label } "
operator|+
literal|"FUNCTION { test } { label #0 = title 'label := #5 label #6 pop$ } "
operator|+
literal|"READ "
operator|+
literal|"ITERATE { test }"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|v
operator|.
name|add
argument_list|(
name|t1BibtexEntry
argument_list|()
argument_list|)
expr_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Effective work practices for floss development: A model and propositions"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testQuote ()
specifier|public
name|void
name|testQuote
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"FUNCTION {a}{ quote$ quote$ * } EXECUTE {a}"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"\"\""
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testVMFunction1 ()
specifier|public
name|void
name|testVMFunction1
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"FUNCTION {init.state.consts}{ #0 'before.all := } "
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|38
argument_list|,
name|vm
operator|.
name|getFunctions
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|vm
operator|.
name|getFunctions
argument_list|()
operator|.
name|get
argument_list|(
literal|"init.state.consts"
argument_list|)
operator|instanceof
name|StackFunction
argument_list|)
expr_stmt|;
name|StackFunction
name|fun
init|=
operator|(
name|StackFunction
operator|)
name|vm
operator|.
name|getFunctions
argument_list|()
operator|.
name|get
argument_list|(
literal|"init.state.consts"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|fun
operator|.
name|getTree
argument_list|()
operator|.
name|getChildCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testVMExecuteSimple ()
specifier|public
name|void
name|testVMExecuteSimple
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"INTEGERS { variable.a } "
operator|+
literal|"FUNCTION {init.state.consts}{ #5 'variable.a := } "
operator|+
literal|"EXECUTE {init.state.consts}"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
literal|5
argument_list|)
argument_list|,
name|vm
operator|.
name|getIntegers
argument_list|()
operator|.
name|get
argument_list|(
literal|"variable.a"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testVMExecuteSimple2 ()
specifier|public
name|void
name|testVMExecuteSimple2
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"FUNCTION {a}{ #5 #5 = "
operator|+
literal|"#1 #2 = "
operator|+
literal|"#3 #4< "
operator|+
literal|"#4 #3< "
operator|+
literal|"#4 #4< "
operator|+
literal|"#3 #4> "
operator|+
literal|"#4 #3> "
operator|+
literal|"#4 #4> "
operator|+
literal|"\"H\" \"H\" = "
operator|+
literal|"\"H\" \"Ha\" = } "
operator|+
literal|"EXECUTE {a}"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testVMIfSkipPop ()
specifier|public
name|void
name|testVMIfSkipPop
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"FUNCTION {not}	{   { #0 }	    { #1 }  if$	}"
operator|+
literal|"FUNCTION {and}	{   'skip$	    { pop$ #0 }	  if$	}"
operator|+
literal|"FUNCTION {or}	{   { pop$ #1 }	    'skip$	  if$	}"
operator|+
literal|"FUNCTION {test} { "
operator|+
literal|"#1 #1 and #0 #1 and #1 #0 and #0 #0 and "
operator|+
literal|"#0 not #1 not "
operator|+
literal|"#1 #1 or #0 #1 or #1 #0 or #0 #0 or }"
operator|+
literal|"EXECUTE {test}"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testVMArithmetic ()
specifier|public
name|void
name|testVMArithmetic
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"FUNCTION {test} { "
operator|+
literal|"#1 #1 + #5 #2 - }"
operator|+
literal|"EXECUTE {test}"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testVMArithmetic2 ()
specifier|public
name|void
name|testVMArithmetic2
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"FUNCTION {test} { "
operator|+
literal|"#1 \"HELLO\" + #5 #2 - }"
operator|+
literal|"EXECUTE {test}"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|VMException
name|ignored
parameter_list|)
block|{
comment|// Ignored
block|}
block|}
annotation|@
name|Test
DECL|method|testNumNames ()
specifier|public
name|void
name|testNumNames
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"FUNCTION {test} { \"Johnny Foo and Mary Bar\" num.names$ }"
operator|+
literal|"EXECUTE {test}"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testNumNames2 ()
specifier|public
name|void
name|testNumNames2
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"FUNCTION {test} { \"Johnny Foo { and } Mary Bar\" num.names$ }"
operator|+
literal|"EXECUTE {test}"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testVMStringOps1 ()
specifier|public
name|void
name|testVMStringOps1
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"FUNCTION {test} { \"H\" \"allo\" * \"Johnny\" add.period$ \"Johnny.\" add.period$"
operator|+
literal|"\"Johnny!\" add.period$ \"Johnny?\" add.period$ \"Johnny} }}}\" add.period$"
operator|+
literal|"\"Johnny!}\" add.period$ \"Johnny?}\" add.period$ \"Johnny.}\" add.period$ }"
operator|+
literal|"EXECUTE {test}"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Johnny.}"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Johnny?}"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Johnny!}"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Johnny.}"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Johnny?"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Johnny!"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Johnny."
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Johnny."
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Hallo"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSubstring ()
specifier|public
name|void
name|testSubstring
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"FUNCTION {test} "
operator|+
literal|"{ \"123456789\" #2  #1  substring$ "
operator|+
comment|// 2
literal|"  \"123456789\" #4 global.max$ substring$ "
operator|+
comment|// 456789
literal|"  \"123456789\" #1  #9  substring$ "
operator|+
comment|// 123456789
literal|"  \"123456789\" #1  #10 substring$ "
operator|+
comment|// 123456789
literal|"  \"123456789\" #1  #99 substring$ "
operator|+
comment|// 123456789
literal|"  \"123456789\" #-7 #3  substring$ "
operator|+
comment|// 123
literal|"  \"123456789\" #-1 #1  substring$ "
operator|+
comment|// 9
literal|"  \"123456789\" #-1 #3  substring$ "
operator|+
comment|// 789
literal|"  \"123456789\" #-2 #2  substring$ "
operator|+
comment|// 78
literal|"} EXECUTE {test} "
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"78"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"789"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"9"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"123"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"123456789"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"123456789"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"123456789"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"456789"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"2"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testEmpty ()
specifier|public
name|void
name|testEmpty
parameter_list|()
throws|throws
name|RecognitionException
throws|,
name|IOException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"ENTRY {title}{}{} READ STRINGS { s } FUNCTION {test} "
operator|+
literal|"{ s empty$ "
operator|+
comment|// FALSE
literal|"\"\" empty$ "
operator|+
comment|// FALSE
literal|"\"   \" empty$ "
operator|+
comment|// FALSE
literal|" title empty$ "
operator|+
comment|// FALSE
literal|" \" HALLO \" empty$ } ITERATE {test} "
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|v
operator|.
name|add
argument_list|(
name|TestVM
operator|.
name|bibtexString2BibtexEntry
argument_list|(
literal|"@article{a, author=\"AAA\"}"
argument_list|)
argument_list|)
expr_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testDuplicateEmptyPopSwapIf ()
specifier|public
name|void
name|testDuplicateEmptyPopSwapIf
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"FUNCTION {emphasize} "
operator|+
literal|"{ duplicate$ empty$ "
operator|+
literal|"  { pop$ \"\" } "
operator|+
literal|"  { \"{\\em \" swap$ * \"}\" * } "
operator|+
literal|"  if$ "
operator|+
literal|"} "
operator|+
literal|"FUNCTION {test} {"
operator|+
literal|"  \"\" emphasize "
operator|+
literal|"  \"Hello\" emphasize "
operator|+
literal|"}"
operator|+
literal|"EXECUTE {test} "
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"{\\em Hello}"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|""
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testChangeCase ()
specifier|public
name|void
name|testChangeCase
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"STRINGS { title } "
operator|+
literal|"READ "
operator|+
literal|"FUNCTION {format.title}"
operator|+
literal|" { duplicate$ empty$ "
operator|+
literal|"    { pop$ \"\" } "
operator|+
literal|"    { \"t\" change.case$ } "
operator|+
literal|"  if$ "
operator|+
literal|"} "
operator|+
literal|"FUNCTION {test} {"
operator|+
literal|"  \"hello world\" \"u\" change.case$ format.title "
operator|+
literal|"  \"Hello World\" format.title "
operator|+
literal|"  \"\" format.title "
operator|+
literal|"  \"{A}{D}/{C}ycle: {I}{B}{M}'s {F}ramework for {A}pplication {D}evelopment and {C}ase\" \"u\" change.case$ format.title "
operator|+
literal|"}"
operator|+
literal|"EXECUTE {test} "
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"{A}{D}/{C}ycle: {I}{B}{M}'s {F}ramework for {A}pplication {D}evelopment and {C}ase"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|""
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Hello world"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Hello world"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testTextLength ()
specifier|public
name|void
name|testTextLength
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"FUNCTION {test} {"
operator|+
literal|"  \"hello world\" text.length$ "
operator|+
literal|"  \"Hello {W}orld\" text.length$ "
operator|+
literal|"  \"\" text.length$ "
operator|+
literal|"  \"{A}{D}/{Cycle}\" text.length$ "
operator|+
literal|"  \"{\\This is one character}\" text.length$ "
operator|+
literal|"  \"{\\This {is} {one} {c{h}}aracter as well}\" text.length$ "
operator|+
literal|"  \"{\\And this too\" text.length$ "
operator|+
literal|"  \"These are {\\11}\" text.length$ "
operator|+
literal|"} "
operator|+
literal|"EXECUTE {test} "
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|11
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|8
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|11
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|11
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testVMIntToStr ()
specifier|public
name|void
name|testVMIntToStr
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"FUNCTION {test} { #3 int.to.str$ #9999 int.to.str$}"
operator|+
literal|"EXECUTE {test}"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"9999"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"3"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testVMChrToInt ()
specifier|public
name|void
name|testVMChrToInt
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"FUNCTION {test} { \"H\" chr.to.int$ }"
operator|+
literal|"EXECUTE {test}"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|72
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testVMChrToIntIntToChr ()
specifier|public
name|void
name|testVMChrToIntIntToChr
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"FUNCTION {test} { \"H\" chr.to.int$ int.to.chr$ }"
operator|+
literal|"EXECUTE {test}"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"H"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSort ()
specifier|public
name|void
name|testSort
parameter_list|()
throws|throws
name|RecognitionException
throws|,
name|IOException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"ENTRY  { title }  { }  { label }"
operator|+
literal|"FUNCTION {presort} { cite$ 'sort.key$ := } ITERATE { presort } SORT"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|v
operator|.
name|add
argument_list|(
name|TestVM
operator|.
name|bibtexString2BibtexEntry
argument_list|(
literal|"@article{a, author=\"AAA\"}"
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|.
name|add
argument_list|(
name|TestVM
operator|.
name|bibtexString2BibtexEntry
argument_list|(
literal|"@article{b, author=\"BBB\"}"
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|.
name|add
argument_list|(
name|TestVM
operator|.
name|bibtexString2BibtexEntry
argument_list|(
literal|"@article{d, author=\"DDD\"}"
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|.
name|add
argument_list|(
name|TestVM
operator|.
name|bibtexString2BibtexEntry
argument_list|(
literal|"@article{c, author=\"CCC\"}"
argument_list|)
argument_list|)
expr_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|BstEntry
argument_list|>
name|v2
init|=
name|vm
operator|.
name|getEntries
argument_list|()
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|Optional
operator|.
name|of
argument_list|(
literal|"a"
argument_list|)
argument_list|,
name|v2
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getBibtexEntry
argument_list|()
operator|.
name|getCiteKeyOptional
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|Optional
operator|.
name|of
argument_list|(
literal|"b"
argument_list|)
argument_list|,
name|v2
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getBibtexEntry
argument_list|()
operator|.
name|getCiteKeyOptional
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|Optional
operator|.
name|of
argument_list|(
literal|"c"
argument_list|)
argument_list|,
name|v2
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|getBibtexEntry
argument_list|()
operator|.
name|getCiteKeyOptional
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|Optional
operator|.
name|of
argument_list|(
literal|"d"
argument_list|)
argument_list|,
name|v2
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|.
name|getBibtexEntry
argument_list|()
operator|.
name|getCiteKeyOptional
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testBuildIn ()
specifier|public
name|void
name|testBuildIn
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"EXECUTE {global.max$}"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testVariables ()
specifier|public
name|void
name|testVariables
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|" STRINGS { t }                          "
operator|+
literal|" FUNCTION {not}	{ { #0 } { #1 }  if$ } "
operator|+
literal|" FUNCTION {n.dashify} { \"HELLO-WORLD\" 't := t empty$ not } "
operator|+
literal|" EXECUTE {n.dashify}                    "
argument_list|)
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testWhile ()
specifier|public
name|void
name|testWhile
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"STRINGS { t }            "
operator|+
literal|"FUNCTION {not}	{   "
operator|+
literal|" { #0 } { #1 }  if$ } "
operator|+
literal|"FUNCTION {n.dashify}              "
operator|+
literal|"{ \"HELLO-WORLD\"                 "
operator|+
literal|"  't :=                           "
operator|+
literal|" \"\"                                                 "
operator|+
literal|"	   { t empty$ not }                 "
operator|+
literal|"	   { t #1 #1 substring$ \"-\" =                      "
operator|+
literal|"	     { t #1 #2 substring$ \"--\" = not "
operator|+
literal|"	          { \"--\" *                                       "
operator|+
literal|"	            t #2 global.max$ substring$ 't :=                 "
operator|+
literal|"	          }                                                    "
operator|+
literal|"	          {   { t #1 #1 substring$ \"-\" = }                "
operator|+
literal|"	              { \"-\" *                                         "
operator|+
literal|"	                t #2 global.max$ substring$ 't :=               "
operator|+
literal|"	              }                                                  "
operator|+
literal|"	            while$                                                                  "
operator|+
literal|"	          }                                                                  "
operator|+
literal|"	        if$                                                                  "
operator|+
literal|"	      }                                                                  "
operator|+
literal|"	      { t #1 #1 substring$ *                                       "
operator|+
literal|"	        t #2 global.max$ substring$ 't :=                          "
operator|+
literal|"	      }                                                                  "
operator|+
literal|"	      if$                                                                  "
operator|+
literal|"	    }                                                                  "
operator|+
literal|"	  while$                                                                  "
operator|+
literal|"	}                                                                  "
operator|+
literal|" EXECUTE {n.dashify} "
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"HELLO--WORLD"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testType ()
specifier|public
name|void
name|testType
parameter_list|()
throws|throws
name|RecognitionException
throws|,
name|IOException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"ENTRY  { title }  { }  { label }"
operator|+
literal|"FUNCTION {presort} { cite$ 'sort.key$ := } ITERATE { presort } SORT FUNCTION {test} { type$ } ITERATE { test }"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|v
operator|.
name|add
argument_list|(
name|TestVM
operator|.
name|bibtexString2BibtexEntry
argument_list|(
literal|"@article{a, author=\"AAA\"}"
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|.
name|add
argument_list|(
name|TestVM
operator|.
name|bibtexString2BibtexEntry
argument_list|(
literal|"@book{b, author=\"BBB\"}"
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|.
name|add
argument_list|(
name|TestVM
operator|.
name|bibtexString2BibtexEntry
argument_list|(
literal|"@misc{c, author=\"CCC\"}"
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|.
name|add
argument_list|(
name|TestVM
operator|.
name|bibtexString2BibtexEntry
argument_list|(
literal|"@inproceedings{d, author=\"DDD\"}"
argument_list|)
argument_list|)
expr_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"inproceedings"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"misc"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"book"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"article"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testMissing ()
specifier|public
name|void
name|testMissing
parameter_list|()
throws|throws
name|RecognitionException
throws|,
name|IOException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
comment|//
literal|"ENTRY    { title }  { }  { label } "
operator|+
comment|//
literal|"FUNCTION {presort} { cite$ 'sort.key$ := } "
operator|+
comment|//
literal|"ITERATE  {presort} "
operator|+
comment|//
literal|"READ SORT "
operator|+
comment|//
literal|"FUNCTION {test}{ title missing$ cite$ } "
operator|+
comment|//
literal|"ITERATE  { test }"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|v
operator|.
name|add
argument_list|(
name|t1BibtexEntry
argument_list|()
argument_list|)
expr_stmt|;
name|v
operator|.
name|add
argument_list|(
name|TestVM
operator|.
name|bibtexString2BibtexEntry
argument_list|(
literal|"@article{test, author=\"No title\"}"
argument_list|)
argument_list|)
expr_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"test"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"canh05"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFormatName ()
specifier|public
name|void
name|testFormatName
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"FUNCTION {format}{ \"Charles Louis Xavier Joseph de la Vall{\\'e}e Poussin\" #1 \"{vv~}{ll}{, jj}{, f}?\" format.name$ }"
operator|+
literal|"EXECUTE {format}"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"de~la Vall{\\'e}e~Poussin, C.~L. X.~J?"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFormatName2 ()
specifier|public
name|void
name|testFormatName2
parameter_list|()
throws|throws
name|RecognitionException
throws|,
name|IOException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"ENTRY  { author }  { }  { label } "
operator|+
literal|"FUNCTION {presort} { cite$ 'sort.key$ := } "
operator|+
literal|"ITERATE { presort } "
operator|+
literal|"READ "
operator|+
literal|"SORT "
operator|+
literal|"FUNCTION {format}{ author #2 \"{vv~}{ll}{, jj}{, f}?\" format.name$ }"
operator|+
literal|"ITERATE {format}"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|v
operator|.
name|add
argument_list|(
name|t1BibtexEntry
argument_list|()
argument_list|)
expr_stmt|;
name|v
operator|.
name|add
argument_list|(
name|TestVM
operator|.
name|bibtexString2BibtexEntry
argument_list|(
literal|"@book{test, author=\"Jonathan Meyer and Charles Louis Xavier Joseph de la Vall{\\'e}e Poussin\"}"
argument_list|)
argument_list|)
expr_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"de~la Vall{\\'e}e~Poussin, C.~L. X.~J?"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Annabi, H?"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testCallType ()
specifier|public
name|void
name|testCallType
parameter_list|()
throws|throws
name|RecognitionException
throws|,
name|IOException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"ENTRY  { title }  { }  { label } FUNCTION {presort} { cite$ 'sort.key$ := } ITERATE { presort } READ SORT "
operator|+
literal|"FUNCTION {inproceedings}{ \"InProceedings called on \" title * } "
operator|+
literal|"FUNCTION {book}{ \"Book called on \" title * } "
operator|+
literal|" ITERATE { call.type$ }"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|v
operator|.
name|add
argument_list|(
name|t1BibtexEntry
argument_list|()
argument_list|)
expr_stmt|;
name|v
operator|.
name|add
argument_list|(
name|TestVM
operator|.
name|bibtexString2BibtexEntry
argument_list|(
literal|"@book{test, title=\"Test\"}"
argument_list|)
argument_list|)
expr_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Book called on Test"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"InProceedings called on Effective work practices for floss development: A model and propositions"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testIterate ()
specifier|public
name|void
name|testIterate
parameter_list|()
throws|throws
name|RecognitionException
throws|,
name|IOException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"ENTRY  { "
operator|+
literal|"  address "
operator|+
literal|"  author "
operator|+
literal|"  title "
operator|+
literal|"  type "
operator|+
literal|"}  {}  { label } "
operator|+
literal|"FUNCTION {test}{ cite$ } "
operator|+
literal|"READ "
operator|+
literal|"ITERATE { test }"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|v
operator|.
name|add
argument_list|(
name|t1BibtexEntry
argument_list|()
argument_list|)
expr_stmt|;
name|v
operator|.
name|add
argument_list|(
name|TestVM
operator|.
name|bibtexString2BibtexEntry
argument_list|(
literal|"@article{test, title=\"BLA\"}"
argument_list|)
argument_list|)
expr_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|s1
init|=
operator|(
name|String
operator|)
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
decl_stmt|;
name|String
name|s2
init|=
operator|(
name|String
operator|)
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"canh05"
operator|.
name|equals
argument_list|(
name|s1
argument_list|)
condition|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"test"
argument_list|,
name|s2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"canh05"
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"test"
argument_list|,
name|s1
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testWidth ()
specifier|public
name|void
name|testWidth
parameter_list|()
throws|throws
name|RecognitionException
throws|,
name|IOException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"ENTRY  { "
operator|+
literal|"  address "
operator|+
literal|"  author "
operator|+
literal|"  title "
operator|+
literal|"  type "
operator|+
literal|"}  {}  { label } "
operator|+
comment|//
literal|"STRINGS { longest.label } "
operator|+
comment|//
literal|"INTEGERS { number.label longest.label.width } "
operator|+
comment|//
literal|"FUNCTION {initialize.longest.label} "
operator|+
comment|//
literal|"{ \"\" 'longest.label := "
operator|+
comment|//
literal|"  #1 'number.label := "
operator|+
comment|//
literal|"  #0 'longest.label.width := "
operator|+
comment|//
literal|"} "
operator|+
comment|//
literal|" "
operator|+
comment|//
literal|"		FUNCTION {longest.label.pass} "
operator|+
comment|//
literal|"		{ number.label int.to.str$ 'label := "
operator|+
comment|//
literal|"		  number.label #1 + 'number.label := "
operator|+
comment|//
literal|"		  label width$ longest.label.width> "
operator|+
comment|//
literal|"		    { label 'longest.label := "
operator|+
comment|//
literal|"		      label width$ 'longest.label.width := "
operator|+
comment|//
literal|"		    } "
operator|+
comment|//
literal|"		    'skip$ "
operator|+
comment|//
literal|"		  if$ "
operator|+
comment|//
literal|"		} "
operator|+
comment|//
literal|" "
operator|+
comment|//
literal|"		EXECUTE {initialize.longest.label} "
operator|+
comment|//
literal|" "
operator|+
comment|//
literal|"		ITERATE {longest.label.pass} "
operator|+
comment|//
literal|"FUNCTION {begin.bib} "
operator|+
comment|//
literal|"{ preamble$ empty$"
operator|+
comment|//
literal|"    'skip$"
operator|+
comment|//
literal|"    { preamble$ write$ newline$ }"
operator|+
comment|//
literal|"  if$"
operator|+
comment|//
literal|"  \"\\begin{thebibliography}{\"  longest.label  * \"}\" *"
operator|+
comment|//
literal|"}"
operator|+
comment|//
literal|"EXECUTE {begin.bib}"
argument_list|)
decl_stmt|;
comment|//
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|v
operator|.
name|add
argument_list|(
name|t1BibtexEntry
argument_list|()
argument_list|)
expr_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|vm
operator|.
name|getIntegers
argument_list|()
operator|.
name|containsKey
argument_list|(
literal|"longest.label.width"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"\\begin{thebibliography}{1}"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testVMSwap ()
specifier|public
name|void
name|testVMSwap
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
literal|"FUNCTION {a}{ #3 \"Hallo\" swap$ } EXECUTE { a }"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Hallo"
argument_list|,
name|vm
operator|.
name|getStack
argument_list|()
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|bibtexString2BibtexEntry (String s)
specifier|private
specifier|static
name|BibEntry
name|bibtexString2BibtexEntry
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|IOException
block|{
name|ParserResult
name|result
init|=
operator|new
name|BibtexParser
argument_list|(
name|mock
argument_list|(
name|ImportFormatPreferences
operator|.
name|class
argument_list|,
name|Answers
operator|.
name|RETURNS_DEEP_STUBS
argument_list|)
argument_list|)
operator|.
name|parse
argument_list|(
operator|new
name|StringReader
argument_list|(
name|s
argument_list|)
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|BibEntry
argument_list|>
name|c
init|=
name|result
operator|.
name|getDatabase
argument_list|()
operator|.
name|getEntries
argument_list|()
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|c
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|c
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
comment|/* TEST DATA */
DECL|method|t1BibtexString ()
specifier|private
name|String
name|t1BibtexString
parameter_list|()
block|{
return|return
literal|"@inproceedings{canh05,\n"
operator|+
literal|"  author = {Crowston, K. and Annabi, H. and Howison, J. and Masango, C.},\n"
operator|+
literal|"  title = {Effective work practices for floss development: A model and propositions},\n"
operator|+
literal|"  booktitle = {Hawaii International Conference On System Sciences (HICSS)},\n"
operator|+
literal|"  year = {2005},\n"
operator|+
literal|"  owner = {oezbek},\n"
operator|+
literal|"  timestamp = {2006.05.29},\n"
operator|+
literal|"  url = {http://james.howison.name/publications.html}}\n"
return|;
block|}
annotation|@
name|Test
DECL|method|testHypthenatedName ()
specifier|public
name|void
name|testHypthenatedName
parameter_list|()
throws|throws
name|RecognitionException
throws|,
name|IOException
block|{
name|VM
name|vm
init|=
operator|new
name|VM
argument_list|(
operator|new
name|File
argument_list|(
literal|"src/test/resources/org/jabref/logic/bst/abbrv.bst"
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|v
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|v
operator|.
name|add
argument_list|(
name|TestVM
operator|.
name|bibtexString2BibtexEntry
argument_list|(
literal|"@article{canh05, author = \"Jean-Paul Sartre\" }"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|vm
operator|.
name|run
argument_list|(
name|v
argument_list|)
operator|.
name|contains
argument_list|(
literal|"J.-P. Sartre"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|t1BibtexEntry ()
specifier|private
name|BibEntry
name|t1BibtexEntry
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|TestVM
operator|.
name|bibtexString2BibtexEntry
argument_list|(
name|t1BibtexString
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

end_unit

