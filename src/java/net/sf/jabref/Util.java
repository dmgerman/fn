begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003 Morten O. Alver   All programs in this directory and  subdirectories are published under the GNU General Public License as  described below.   This program is free software; you can redistribute it and/or modify  it under the terms of the GNU General Public License as published by  the Free Software Foundation; either version 2 of the License, or (at  your option) any later version.   This program is distributed in the hope that it will be useful, but  WITHOUT ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  General Public License for more details.   You should have received a copy of the GNU General Public License  along with this program; if not, write to the Free Software  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA   Further information about the GNU GPL is available at:  http://www.gnu.org/copyleft/gpl.ja.html   */
end_comment

begin_comment
comment|// created by : Morten O. Alver 2003
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// function : utility functions
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// todo     :
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// modified :  - r.nagel 20.04.2006
end_comment

begin_comment
comment|//               make the DateFormatter abstract and splitt the easyDate methode
end_comment

begin_comment
comment|//               (now we cannot change the dateformat dynamicly, sorry)
end_comment

begin_package
DECL|package|net.sf.jabref
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|BorderLayout
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|CardLayout
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Color
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Dimension
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Font
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Point
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|ActionEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|ActionListener
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilenameFilter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLDecoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharsetEncoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|Box
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JButton
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JFrame
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JLabel
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JOptionPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JPanel
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JScrollPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JTextArea
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|undo
operator|.
name|UndoableEdit
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|undo
operator|.
name|CompoundEdit
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|LayoutEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|LayoutFormatter
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|ExternalFileType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|AbstractGroup
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|KeywordGroup
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|imports
operator|.
name|CiteSeerFetcher
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|NamedCompound
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|UndoableFieldChange
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|AutoCompleter
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|FileListTableModel
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|FileListEditor
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|FileListEntry
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jgoodies
operator|.
name|forms
operator|.
name|builder
operator|.
name|DefaultFormBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jgoodies
operator|.
name|forms
operator|.
name|layout
operator|.
name|FormLayout
import|;
end_import

begin_comment
comment|/**  * Describe class<code>Util</code> here.  *   * @author<a href="mailto:"></a>  * @version 1.0  */
end_comment

begin_class
DECL|class|Util
specifier|public
class|class
name|Util
block|{
comment|/** 	 * A static Object for date formatting. Please do not create the object 	 * here, because there are some references from the Globals class..... 	 *  	 */
DECL|field|dateFormatter
specifier|private
specifier|static
name|SimpleDateFormat
name|dateFormatter
init|=
literal|null
decl_stmt|;
comment|/* 	 * Colors are defined here. 	 *  	 */
DECL|field|fieldsCol
specifier|public
specifier|static
name|Color
name|fieldsCol
init|=
operator|new
name|Color
argument_list|(
literal|180
argument_list|,
literal|180
argument_list|,
literal|200
argument_list|)
decl_stmt|;
comment|/* 	 * Integer values for indicating result of duplicate check (for entries): 	 *  	 */
DECL|field|TYPE_MISMATCH
DECL|field|NOT_EQUAL
DECL|field|EQUAL
DECL|field|EMPTY_IN_ONE
specifier|final
specifier|static
name|int
name|TYPE_MISMATCH
init|=
operator|-
literal|1
decl_stmt|,
name|NOT_EQUAL
init|=
literal|0
decl_stmt|,
name|EQUAL
init|=
literal|1
decl_stmt|,
name|EMPTY_IN_ONE
init|=
literal|2
decl_stmt|,
DECL|field|EMPTY_IN_TWO
name|EMPTY_IN_TWO
init|=
literal|3
decl_stmt|;
DECL|field|idFormat
specifier|final
specifier|static
name|NumberFormat
name|idFormat
decl_stmt|;
static|static
block|{
name|idFormat
operator|=
name|NumberFormat
operator|.
name|getInstance
argument_list|()
expr_stmt|;
name|idFormat
operator|.
name|setMinimumIntegerDigits
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|idFormat
operator|.
name|setGroupingUsed
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|bool (boolean b)
specifier|public
specifier|static
name|void
name|bool
parameter_list|(
name|boolean
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"true"
argument_list|)
expr_stmt|;
else|else
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"false"
argument_list|)
expr_stmt|;
block|}
DECL|method|pr (String s)
specifier|public
specifier|static
name|void
name|pr
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
DECL|method|pr_ (String s)
specifier|public
specifier|static
name|void
name|pr_
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
DECL|method|nCase (String s)
specifier|public
specifier|static
name|String
name|nCase
parameter_list|(
name|String
name|s
parameter_list|)
block|{
comment|// Make first character of String uppercase, and the
comment|// rest lowercase.
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
return|return
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|.
name|toUpperCase
argument_list|()
operator|+
name|s
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
return|;
else|else
return|return
name|s
operator|.
name|toUpperCase
argument_list|()
return|;
block|}
DECL|method|checkName (String s)
specifier|public
specifier|static
name|String
name|checkName
parameter_list|(
name|String
name|s
parameter_list|)
block|{
comment|// Append '.bib' to the string unless it ends with that.
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|<
literal|4
operator|||
operator|!
name|s
operator|.
name|substring
argument_list|(
name|s
operator|.
name|length
argument_list|()
operator|-
literal|4
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|".bib"
argument_list|)
condition|)
block|{
return|return
name|s
operator|+
literal|".bib"
return|;
block|}
return|return
name|s
return|;
block|}
DECL|field|idCounter
specifier|private
specifier|static
name|int
name|idCounter
init|=
literal|0
decl_stmt|;
DECL|method|createNeutralId ()
specifier|public
specifier|synchronized
specifier|static
name|String
name|createNeutralId
parameter_list|()
block|{
return|return
name|idFormat
operator|.
name|format
argument_list|(
name|idCounter
operator|++
argument_list|)
return|;
block|}
comment|/** 	 * This method sets the location of a Dialog such that it is centered with 	 * regard to another window, but not outside the screen on the left and the 	 * top. 	 */
DECL|method|placeDialog (java.awt.Dialog diag, java.awt.Container win)
specifier|public
specifier|static
name|void
name|placeDialog
parameter_list|(
name|java
operator|.
name|awt
operator|.
name|Dialog
name|diag
parameter_list|,
name|java
operator|.
name|awt
operator|.
name|Container
name|win
parameter_list|)
block|{
name|Dimension
name|ds
init|=
name|diag
operator|.
name|getSize
argument_list|()
decl_stmt|,
name|df
init|=
name|win
operator|.
name|getSize
argument_list|()
decl_stmt|;
name|Point
name|pf
init|=
name|win
operator|.
name|getLocation
argument_list|()
decl_stmt|;
name|diag
operator|.
name|setLocation
argument_list|(
operator|new
name|Point
argument_list|(
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|pf
operator|.
name|x
operator|+
operator|(
name|df
operator|.
name|width
operator|-
name|ds
operator|.
name|width
operator|)
operator|/
literal|2
argument_list|)
argument_list|,
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|pf
operator|.
name|y
operator|+
operator|(
name|df
operator|.
name|height
operator|-
name|ds
operator|.
name|height
operator|)
operator|/
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * This method translates a field or string from Bibtex notation, with 	 * possibly text contained in " " or { }, and string references, 	 * concatenated by '#' characters, into Bibkeeper notation, where string 	 * references are enclosed in a pair of '#' characters. 	 */
DECL|method|parseField (String content)
specifier|public
specifier|static
name|String
name|parseField
parameter_list|(
name|String
name|content
parameter_list|)
block|{
if|if
condition|(
name|content
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
name|content
return|;
name|String
index|[]
name|strings
init|=
name|content
operator|.
name|split
argument_list|(
literal|"#"
argument_list|)
decl_stmt|;
name|StringBuffer
name|result
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strings
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|s
init|=
name|strings
index|[
name|i
index|]
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// String reference or not?
if|if
condition|(
name|c
operator|==
literal|'{'
operator|||
name|c
operator|==
literal|'"'
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|shaveString
argument_list|(
name|strings
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This part should normally be a string reference, but if it's
comment|// a pure number, it is not.
name|String
name|s2
init|=
name|shaveString
argument_list|(
name|s
argument_list|)
decl_stmt|;
try|try
block|{
name|Integer
operator|.
name|parseInt
argument_list|(
name|s2
argument_list|)
expr_stmt|;
comment|// If there's no exception, it's a number.
name|result
operator|.
name|append
argument_list|(
name|s2
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|ex
parameter_list|)
block|{
comment|// otherwise append with hashes...
name|result
operator|.
name|append
argument_list|(
literal|"#"
argument_list|)
operator|.
name|append
argument_list|(
name|s2
argument_list|)
operator|.
name|append
argument_list|(
literal|"#"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** 	 * Will return the publication date of the given bibtex entry in conformance 	 * to ISO 8601, i.e. either YYYY or YYYY-MM. 	 *  	 * @param entry 	 * @return will return the publication date of the entry or null if no year 	 *         was found. 	 */
DECL|method|getPublicationDate (BibtexEntry entry)
specifier|public
specifier|static
name|String
name|getPublicationDate
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|)
block|{
name|Object
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
literal|"year"
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|String
name|year
init|=
name|toFourDigitYear
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|o
operator|=
name|entry
operator|.
name|getField
argument_list|(
literal|"month"
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|int
name|month
init|=
name|Util
operator|.
name|getMonthNumber
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|month
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
name|year
operator|+
literal|"-"
operator|+
operator|(
name|month
operator|+
literal|1
operator|<
literal|10
condition|?
literal|"0"
else|:
literal|""
operator|)
operator|+
operator|(
name|month
operator|+
literal|1
operator|)
return|;
block|}
block|}
return|return
name|year
return|;
block|}
DECL|method|shaveString (String s)
specifier|public
specifier|static
name|String
name|shaveString
parameter_list|(
name|String
name|s
parameter_list|)
block|{
comment|// returns the string, after shaving off whitespace at the beginning
comment|// and end, and removing (at most) one pair of braces or " surrounding
comment|// it.
if|if
condition|(
name|s
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|char
name|ch
decl_stmt|,
name|ch2
decl_stmt|;
name|int
name|beg
init|=
literal|0
decl_stmt|,
name|end
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// We start out assuming nothing will be removed.
name|boolean
name|begok
init|=
literal|false
decl_stmt|,
name|endok
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|begok
condition|)
block|{
if|if
condition|(
name|beg
operator|<
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|beg
argument_list|)
expr_stmt|;
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|ch
argument_list|)
condition|)
name|beg
operator|++
expr_stmt|;
else|else
name|begok
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|begok
operator|=
literal|true
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|endok
condition|)
block|{
if|if
condition|(
name|end
operator|>
name|beg
operator|+
literal|1
condition|)
block|{
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|end
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|ch
argument_list|)
condition|)
name|end
operator|--
expr_stmt|;
else|else
name|endok
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|endok
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|>
name|beg
operator|+
literal|1
condition|)
block|{
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|beg
argument_list|)
expr_stmt|;
name|ch2
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|end
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ch
operator|==
literal|'{'
operator|)
operator|&&
operator|(
name|ch2
operator|==
literal|'}'
operator|)
operator|)
operator|||
operator|(
operator|(
name|ch
operator|==
literal|'"'
operator|)
operator|&&
operator|(
name|ch2
operator|==
literal|'"'
operator|)
operator|)
condition|)
block|{
name|beg
operator|++
expr_stmt|;
name|end
operator|--
expr_stmt|;
block|}
block|}
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
name|beg
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
comment|/** 	 * This method returns a String similar to the one passed in, except that it 	 * is molded into a form that is acceptable for bibtex. 	 *  	 * Watch-out that the returned string might be of length 0 afterwards. 	 *  	 * @param key 	 *            mayBeNull 	 */
DECL|method|checkLegalKey (String key)
specifier|public
specifier|static
name|String
name|checkLegalKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|StringBuffer
name|newKey
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|key
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|key
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|c
operator|!=
literal|'#'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'{'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\\'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'"'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'}'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'~'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|','
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'^'
operator|)
condition|)
name|newKey
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|// Replace non-english characters like umlauts etc. with a sensible
comment|// letter or letter combination that bibtex can accept.
name|String
name|newKeyS
init|=
name|replaceSpecialCharacters
argument_list|(
name|newKey
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|newKeyS
return|;
block|}
comment|/** 	 * Replace non-english characters like umlauts etc. with a sensible letter 	 * or letter combination that bibtex can accept. The basis for replacement 	 * is the HashMap GLobals.UNICODE_CHARS. 	 */
DECL|method|replaceSpecialCharacters (String s)
specifier|public
specifier|static
name|String
name|replaceSpecialCharacters
parameter_list|(
name|String
name|s
parameter_list|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|Globals
operator|.
name|UNICODE_CHARS
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|chr
init|=
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|,
name|replacer
init|=
operator|(
name|String
operator|)
name|Globals
operator|.
name|UNICODE_CHARS
operator|.
name|get
argument_list|(
name|chr
argument_list|)
decl_stmt|;
comment|// pr(chr+" "+replacer);
name|s
operator|=
name|s
operator|.
name|replaceAll
argument_list|(
name|chr
argument_list|,
name|replacer
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
DECL|method|_wrap2 (String in, int wrapAmount)
specifier|static
specifier|public
name|String
name|_wrap2
parameter_list|(
name|String
name|in
parameter_list|,
name|int
name|wrapAmount
parameter_list|)
block|{
comment|// The following line cuts out all whitespace and replaces them with
comment|// single
comment|// spaces:
comment|// in = in.replaceAll("[ ]+"," ").replaceAll("[\\t]+"," ");
comment|// StringBuffer out = new StringBuffer(in);
name|StringBuffer
name|out
init|=
operator|new
name|StringBuffer
argument_list|(
name|in
operator|.
name|replaceAll
argument_list|(
literal|"[ \\t\\r]+"
argument_list|,
literal|" "
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|p
init|=
name|in
operator|.
name|length
argument_list|()
operator|-
name|wrapAmount
decl_stmt|;
name|int
name|lastInserted
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|p
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|out
operator|.
name|lastIndexOf
argument_list|(
literal|" "
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|<=
literal|0
operator|||
name|p
operator|<=
literal|20
condition|)
break|break;
name|int
name|lbreak
init|=
name|out
operator|.
name|indexOf
argument_list|(
literal|"\n"
argument_list|,
name|p
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|lbreak
operator|+
literal|" "
operator|+
name|lastInserted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lbreak
operator|>
name|p
operator|)
operator|&&
operator|(
operator|(
name|lastInserted
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|lbreak
operator|<
name|lastInserted
operator|)
operator|)
condition|)
block|{
name|p
operator|=
name|lbreak
operator|-
name|wrapAmount
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|insert
argument_list|(
name|p
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|lastInserted
operator|=
name|p
expr_stmt|;
name|p
operator|-=
name|wrapAmount
expr_stmt|;
block|}
block|}
return|return
name|out
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|wrap2 (String in, int wrapAmount)
specifier|static
specifier|public
name|String
name|wrap2
parameter_list|(
name|String
name|in
parameter_list|,
name|int
name|wrapAmount
parameter_list|)
block|{
return|return
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|imports
operator|.
name|FieldContentParser
operator|.
name|wrap
argument_list|(
name|in
argument_list|,
name|wrapAmount
argument_list|)
return|;
block|}
DECL|method|__wrap2 (String in, int wrapAmount)
specifier|static
specifier|public
name|String
name|__wrap2
parameter_list|(
name|String
name|in
parameter_list|,
name|int
name|wrapAmount
parameter_list|)
block|{
comment|// The following line cuts out all whitespace except line breaks, and
comment|// replaces
comment|// with single spaces. Line breaks are padded with a tab character:
name|StringBuffer
name|out
init|=
operator|new
name|StringBuffer
argument_list|(
name|in
operator|.
name|replaceAll
argument_list|(
literal|"[ \\t\\r]+"
argument_list|,
literal|" "
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|p
init|=
literal|0
decl_stmt|;
comment|// int lastInserted = -1;
while|while
condition|(
name|p
operator|<
name|out
operator|.
name|length
argument_list|()
condition|)
block|{
name|int
name|q
init|=
name|out
operator|.
name|indexOf
argument_list|(
literal|" "
argument_list|,
name|p
operator|+
name|wrapAmount
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|q
operator|<
literal|0
operator|)
operator|||
operator|(
name|q
operator|>=
name|out
operator|.
name|length
argument_list|()
operator|)
condition|)
break|break;
name|int
name|lbreak
init|=
name|out
operator|.
name|indexOf
argument_list|(
literal|"\n"
argument_list|,
name|p
argument_list|)
decl_stmt|;
comment|// System.out.println(lbreak);
if|if
condition|(
operator|(
name|lbreak
operator|>
name|p
operator|)
operator|&&
operator|(
name|lbreak
operator|<
name|q
operator|)
condition|)
block|{
name|p
operator|=
name|lbreak
operator|+
literal|1
expr_stmt|;
name|int
name|piv
init|=
name|lbreak
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|out
operator|.
name|length
argument_list|()
operator|>
name|piv
operator|)
operator|&&
operator|!
operator|(
name|out
operator|.
name|charAt
argument_list|(
name|piv
argument_list|)
operator|==
literal|'\t'
operator|)
condition|)
name|out
operator|.
name|insert
argument_list|(
name|piv
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// System.out.println(q+" "+out.length());
name|out
operator|.
name|deleteCharAt
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|out
operator|.
name|insert
argument_list|(
name|q
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
name|out
operator|.
name|toString
argument_list|()
return|;
comment|// .replaceAll("\n", "\n\t");
block|}
DECL|method|findDeliminatedWordsInField (BibtexDatabase db, String field, String deliminator)
specifier|public
specifier|static
name|HashSet
name|findDeliminatedWordsInField
parameter_list|(
name|BibtexDatabase
name|db
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|deliminator
parameter_list|)
block|{
name|HashSet
name|res
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
name|Iterator
name|i
init|=
name|db
operator|.
name|getKeySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BibtexEntry
name|be
init|=
name|db
operator|.
name|getEntryById
argument_list|(
name|i
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Object
name|o
init|=
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|String
name|fieldValue
init|=
name|o
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|StringTokenizer
name|tok
init|=
operator|new
name|StringTokenizer
argument_list|(
name|fieldValue
argument_list|,
name|deliminator
argument_list|)
decl_stmt|;
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
name|res
operator|.
name|add
argument_list|(
name|tok
operator|.
name|nextToken
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
comment|/** 	 * Returns a HashMap containing all words used in the database in the given 	 * field type. Characters in 	 *  	 * @param remove 	 *            are not included. 	 * @param db 	 *            a<code>BibtexDatabase</code> value 	 * @param field 	 *            a<code>String</code> value 	 * @param remove 	 *            a<code>String</code> value 	 * @return a<code>HashSet</code> value 	 */
DECL|method|findAllWordsInField (BibtexDatabase db, String field, String remove)
specifier|public
specifier|static
name|HashSet
name|findAllWordsInField
parameter_list|(
name|BibtexDatabase
name|db
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|remove
parameter_list|)
block|{
name|HashSet
name|res
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
name|StringTokenizer
name|tok
decl_stmt|;
name|Iterator
name|i
init|=
name|db
operator|.
name|getKeySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BibtexEntry
name|be
init|=
name|db
operator|.
name|getEntryById
argument_list|(
name|i
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Object
name|o
init|=
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|tok
operator|=
operator|new
name|StringTokenizer
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|,
name|remove
argument_list|,
literal|false
argument_list|)
expr_stmt|;
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
name|res
operator|.
name|add
argument_list|(
name|tok
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
comment|/** 	 * Takes a String array and returns a string with the array's elements 	 * delimited by a certain String. 	 *  	 * @param strs 	 *            String array to convert. 	 * @param delimiter 	 *            String to use as delimiter. 	 * @return Delimited String. 	 */
DECL|method|stringArrayToDelimited (String[] strs, String delimiter)
specifier|public
specifier|static
name|String
name|stringArrayToDelimited
parameter_list|(
name|String
index|[]
name|strs
parameter_list|,
name|String
name|delimiter
parameter_list|)
block|{
if|if
condition|(
operator|(
name|strs
operator|==
literal|null
operator|)
operator|||
operator|(
name|strs
operator|.
name|length
operator|==
literal|0
operator|)
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|strs
operator|.
name|length
operator|==
literal|1
condition|)
return|return
name|strs
index|[
literal|0
index|]
return|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strs
operator|.
name|length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|strs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|delimiter
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|strs
index|[
name|strs
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** 	 * Takes a delimited string, splits it and returns 	 *  	 * @param names 	 *            a<code>String</code> value 	 * @return a<code>String[]</code> value 	 */
DECL|method|delimToStringArray (String names, String delimiter)
specifier|public
specifier|static
name|String
index|[]
name|delimToStringArray
parameter_list|(
name|String
name|names
parameter_list|,
name|String
name|delimiter
parameter_list|)
block|{
if|if
condition|(
name|names
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|names
operator|.
name|split
argument_list|(
name|delimiter
argument_list|)
return|;
block|}
comment|/** 	 * Open a http/pdf/ps viewer for the given link string. 	 */
DECL|method|openExternalViewer (MetaData metaData, String link, String fieldName)
specifier|public
specifier|static
name|void
name|openExternalViewer
parameter_list|(
name|MetaData
name|metaData
parameter_list|,
name|String
name|link
parameter_list|,
name|String
name|fieldName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"ps"
argument_list|)
operator|||
name|fieldName
operator|.
name|equals
argument_list|(
literal|"pdf"
argument_list|)
condition|)
block|{
comment|// Find the default directory for this field type:
name|String
name|dir
init|=
name|metaData
operator|.
name|getFileDirectory
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|File
name|file
init|=
name|expandFilename
argument_list|(
name|link
argument_list|,
operator|new
name|String
index|[]
block|{
name|dir
block|,
literal|"."
block|}
argument_list|)
decl_stmt|;
comment|// Check that the file exists:
if|if
condition|(
operator|(
name|file
operator|==
literal|null
operator|)
operator|||
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"File not found"
argument_list|)
operator|+
literal|" ("
operator|+
name|fieldName
operator|+
literal|"): '"
operator|+
name|link
operator|+
literal|"'."
argument_list|)
throw|;
block|}
name|link
operator|=
name|file
operator|.
name|getCanonicalPath
argument_list|()
expr_stmt|;
comment|// Use the correct viewer even if pdf and ps are mixed up:
name|String
index|[]
name|split
init|=
name|file
operator|.
name|getName
argument_list|()
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
decl_stmt|;
if|if
condition|(
name|split
operator|.
name|length
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|split
index|[
name|split
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"pdf"
argument_list|)
condition|)
name|fieldName
operator|=
literal|"pdf"
expr_stmt|;
elseif|else
if|if
condition|(
name|split
index|[
name|split
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"ps"
argument_list|)
operator|||
operator|(
name|split
operator|.
name|length
operator|>=
literal|3
operator|&&
name|split
index|[
name|split
operator|.
name|length
operator|-
literal|2
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"ps"
argument_list|)
operator|)
condition|)
name|fieldName
operator|=
literal|"ps"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"doi"
argument_list|)
condition|)
block|{
name|fieldName
operator|=
literal|"url"
expr_stmt|;
comment|// Check to see if link field already contains a well formated URL
if|if
condition|(
operator|!
name|link
operator|.
name|startsWith
argument_list|(
literal|"http://"
argument_list|)
condition|)
block|{
name|link
operator|=
name|Globals
operator|.
name|DOI_LOOKUP_PREFIX
operator|+
name|link
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"citeseerurl"
argument_list|)
condition|)
block|{
name|fieldName
operator|=
literal|"url"
expr_stmt|;
name|String
name|canonicalLink
init|=
name|CiteSeerFetcher
operator|.
name|generateCanonicalURL
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|canonicalLink
operator|!=
literal|null
condition|)
name|link
operator|=
name|canonicalLink
expr_stmt|;
block|}
name|String
name|cmdArray
index|[]
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"url"
argument_list|)
condition|)
block|{
comment|// html
try|try
block|{
comment|// First check if the url is enclosed in \\url{}. If so, remove
comment|// the wrapper.
if|if
condition|(
name|link
operator|.
name|startsWith
argument_list|(
literal|"\\url{"
argument_list|)
operator|&&
name|link
operator|.
name|endsWith
argument_list|(
literal|"}"
argument_list|)
condition|)
name|link
operator|=
name|link
operator|.
name|substring
argument_list|(
literal|5
argument_list|,
name|link
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|link
operator|=
name|sanitizeUrl
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|Globals
operator|.
name|ON_MAC
condition|)
block|{
name|String
index|[]
name|cmd
init|=
block|{
literal|"/usr/bin/open"
block|,
literal|"-a"
block|,
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"htmlviewer"
argument_list|)
block|,
name|link
block|}
decl_stmt|;
name|Process
name|child
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
block|}
elseif|else
if|if
condition|(
name|Globals
operator|.
name|ON_WIN
condition|)
block|{
name|openFileOnWindows
argument_list|(
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|/* 					 * cmdArray[0] = Globals.prefs.get("htmlviewer"); 					 * cmdArray[1] = link; Process child = 					 * Runtime.getRuntime().exec( cmdArray[0] + " " + 					 * cmdArray[1]); 					 */
block|}
else|else
block|{
name|cmdArray
index|[
literal|0
index|]
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"htmlviewer"
argument_list|)
expr_stmt|;
name|cmdArray
index|[
literal|1
index|]
operator|=
name|link
expr_stmt|;
name|Process
name|child
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmdArray
argument_list|)
decl_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"An error occured on the command: "
operator|+
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"htmlviewer"
argument_list|)
operator|+
literal|" "
operator|+
name|link
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"ps"
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
name|Globals
operator|.
name|ON_MAC
condition|)
block|{
name|String
index|[]
name|cmd
init|=
block|{
literal|"/usr/bin/open"
block|,
literal|"-a"
block|,
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"psviewer"
argument_list|)
block|,
name|link
block|}
decl_stmt|;
name|Process
name|child
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
block|}
elseif|else
if|if
condition|(
name|Globals
operator|.
name|ON_WIN
condition|)
block|{
name|openFileOnWindows
argument_list|(
name|link
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|/* 					 * cmdArray[0] = Globals.prefs.get("psviewer"); cmdArray[1] = 					 * link; Process child = Runtime.getRuntime().exec( 					 * cmdArray[0] + " " + cmdArray[1]); 					 */
block|}
else|else
block|{
name|cmdArray
index|[
literal|0
index|]
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"psviewer"
argument_list|)
expr_stmt|;
name|cmdArray
index|[
literal|1
index|]
operator|=
name|link
expr_stmt|;
name|Process
name|child
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmdArray
argument_list|)
decl_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"An error occured on the command: "
operator|+
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"psviewer"
argument_list|)
operator|+
literal|" "
operator|+
name|link
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"pdf"
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
name|Globals
operator|.
name|ON_MAC
condition|)
block|{
name|String
index|[]
name|cmd
init|=
block|{
literal|"/usr/bin/open"
block|,
literal|"-a"
block|,
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"pdfviewer"
argument_list|)
block|,
name|link
block|}
decl_stmt|;
name|Process
name|child
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
block|}
elseif|else
if|if
condition|(
name|Globals
operator|.
name|ON_WIN
condition|)
block|{
name|openFileOnWindows
argument_list|(
name|link
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|/* 					 * String[] spl = link.split("\\\\"); StringBuffer sb = new 					 * StringBuffer(); for (int i = 0; i< spl.length; i++) { if 					 * (i> 0) sb.append("\\"); if (spl[i].indexOf(" ")>= 0) 					 * spl[i] = "\"" + spl[i] + "\""; sb.append(spl[i]); } 					 * //pr(sb.toString()); link = sb.toString(); 					 *  					 * String cmd = "cmd.exe /c start " + link; 					 *  					 * Process child = Runtime.getRuntime().exec(cmd); 					 */
block|}
else|else
block|{
name|cmdArray
index|[
literal|0
index|]
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"pdfviewer"
argument_list|)
expr_stmt|;
name|cmdArray
index|[
literal|1
index|]
operator|=
name|link
expr_stmt|;
comment|// Process child = Runtime.getRuntime().exec(cmdArray[0]+"
comment|// "+cmdArray[1]);
name|Process
name|child
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmdArray
argument_list|)
decl_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"An error occured on the command: "
operator|+
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"pdfviewer"
argument_list|)
operator|+
literal|" #"
operator|+
name|link
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Message: currently only PDF, PS and HTML files can be opened by double clicking"
argument_list|)
expr_stmt|;
comment|// ignore
block|}
block|}
comment|/** 	 * Opens a file on a Windows system, using its default viewer. 	 *  	 * @param link 	 *            The file name. 	 * @param localFile 	 *            true if it is a local file, not an URL. 	 * @throws IOException 	 */
DECL|method|openFileOnWindows (String link, boolean localFile)
specifier|public
specifier|static
name|void
name|openFileOnWindows
parameter_list|(
name|String
name|link
parameter_list|,
name|boolean
name|localFile
parameter_list|)
throws|throws
name|IOException
block|{
comment|/* 		 * if (localFile) { String[] spl = link.split("\\\\"); StringBuffer sb = 		 * new StringBuffer(); for (int i = 0; i< spl.length; i++) { if (i> 0) 		 * sb.append("\\"); if (spl[i].indexOf(" ")>= 0) spl[i] = "\"" + spl[i] + 		 * "\""; sb.append(spl[i]); } link = sb.toString(); } 		 */
name|link
operator|=
name|link
operator|.
name|replaceAll
argument_list|(
literal|"&"
argument_list|,
literal|"\"&\""
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|" "
argument_list|,
literal|"\" \""
argument_list|)
expr_stmt|;
comment|// Bug fix for:
comment|// http://sourceforge.net/tracker/index.php?func=detail&aid=1489454&group_id=92314&atid=600306
name|String
name|cmd
decl_stmt|;
if|if
condition|(
name|Globals
operator|.
name|osName
operator|.
name|startsWith
argument_list|(
literal|"Windows 9"
argument_list|)
condition|)
block|{
name|cmd
operator|=
literal|"command.com /c start "
operator|+
name|link
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
literal|"cmd.exe /c start "
operator|+
name|link
expr_stmt|;
block|}
name|Process
name|child
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
block|}
comment|/** 	 * Open an external file, attempting to use the correct viewer for it. 	 *  	 * @param metaData 	 *            The MetaData for the database this file belongs to. 	 * @param link 	 *            The file name. 	 */
DECL|method|openExternalFileAnyFormat (MetaData metaData, String link, ExternalFileType fileType)
specifier|public
specifier|static
name|void
name|openExternalFileAnyFormat
parameter_list|(
name|MetaData
name|metaData
parameter_list|,
name|String
name|link
parameter_list|,
name|ExternalFileType
name|fileType
parameter_list|)
throws|throws
name|IOException
block|{
comment|// For other platforms we'll try to find the file type:
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|link
argument_list|)
decl_stmt|;
comment|// We try to check the extension for the file:
name|String
name|name
init|=
name|file
operator|.
name|getName
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|name
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|String
name|extension
init|=
operator|(
operator|(
name|pos
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|pos
operator|<
name|name
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
operator|)
condition|?
name|name
operator|.
name|substring
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|.
name|trim
argument_list|()
operator|.
name|toLowerCase
argument_list|()
else|:
literal|null
decl_stmt|;
comment|/* 		 * if ((extension == null) || (extension.length() == 0)) { // No 		 * extension. What to do? throw new IOException(Globals.lang("No file 		 * extension. Could not find viewer for file.")); } 		 */
comment|// Find the default directory for this field type, if any:
name|String
name|dir
init|=
name|metaData
operator|.
name|getFileDirectory
argument_list|(
name|extension
argument_list|)
decl_stmt|;
if|if
condition|(
name|dir
operator|!=
literal|null
condition|)
block|{
name|File
name|tmp
init|=
name|expandFilename
argument_list|(
name|link
argument_list|,
operator|new
name|String
index|[]
block|{
name|dir
block|,
literal|"."
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|null
condition|)
name|file
operator|=
name|tmp
expr_stmt|;
block|}
comment|// Check if we have arrived at an existing file:
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
operator|&&
operator|(
name|fileType
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// Open the file:
try|try
block|{
if|if
condition|(
name|Globals
operator|.
name|ON_MAC
condition|)
block|{
name|String
index|[]
name|cmd
init|=
block|{
literal|"/usr/bin/open"
block|,
literal|"-a"
block|,
name|fileType
operator|.
name|getOpenWith
argument_list|()
block|,
name|file
operator|.
name|getPath
argument_list|()
block|}
decl_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Globals
operator|.
name|ON_WIN
condition|)
block|{
name|openFileOnWindows
argument_list|(
name|file
operator|.
name|getPath
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
index|[]
name|cmdArray
init|=
operator|new
name|String
index|[]
block|{
name|fileType
operator|.
name|getOpenWith
argument_list|()
block|,
name|file
operator|.
name|getPath
argument_list|()
block|}
decl_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmdArray
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"An error occured on the command: "
operator|+
name|fileType
operator|.
name|getOpenWith
argument_list|()
operator|+
literal|" #"
operator|+
name|link
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// No file matched the name, or we didn't know the file type.
comment|// Perhaps it is an URL thing.
comment|// First check if it is enclosed in \\url{}. If so, remove
comment|// the wrapper.
if|if
condition|(
name|link
operator|.
name|startsWith
argument_list|(
literal|"\\url{"
argument_list|)
operator|&&
name|link
operator|.
name|endsWith
argument_list|(
literal|"}"
argument_list|)
condition|)
name|link
operator|=
name|link
operator|.
name|substring
argument_list|(
literal|5
argument_list|,
name|link
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|.
name|startsWith
argument_list|(
literal|"doi:"
argument_list|)
condition|)
name|link
operator|=
name|Globals
operator|.
name|DOI_LOOKUP_PREFIX
operator|+
name|link
expr_stmt|;
name|link
operator|=
name|sanitizeUrl
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|Globals
operator|.
name|ON_MAC
condition|)
block|{
name|String
index|[]
name|cmd
init|=
block|{
literal|"/usr/bin/open"
block|,
literal|"-a"
block|,
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"htmlviewer"
argument_list|)
block|,
name|link
block|}
decl_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Globals
operator|.
name|ON_WIN
condition|)
block|{
name|openFileOnWindows
argument_list|(
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
index|[]
name|cmdArray
init|=
operator|new
name|String
index|[]
block|{
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"htmlviewer"
argument_list|)
block|,
name|link
block|}
decl_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmdArray
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** 	 * Make sure an URL is "portable", in that it doesn't contain bad characters 	 * that break the open command in some OSes. 	 *  	 * Old Version can be found in CVS version 114 of Util.java. 	 *  	 * @param link 	 *            The URL to sanitize. 	 * @return Sanitized URL 	 */
DECL|method|sanitizeUrl (String link)
specifier|public
specifier|static
name|String
name|sanitizeUrl
parameter_list|(
name|String
name|link
parameter_list|)
block|{
name|link
operator|=
name|link
operator|.
name|replaceAll
argument_list|(
literal|"\\+"
argument_list|,
literal|"%2B"
argument_list|)
expr_stmt|;
try|try
block|{
name|link
operator|=
name|URLDecoder
operator|.
name|decode
argument_list|(
name|link
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{ 		}
comment|/** 		 * Fix for: [ 1574773 ] sanitizeUrl() breaks ftp:// and file:/// 		 *  		 * http://sourceforge.net/tracker/index.php?func=detail&aid=1574773&group_id=92314&atid=600306 		 */
try|try
block|{
return|return
operator|new
name|URI
argument_list|(
literal|null
argument_list|,
name|link
argument_list|,
literal|null
argument_list|)
operator|.
name|toASCIIString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
return|return
name|link
return|;
block|}
block|}
comment|/** 	 * Searches the given directory and subdirectories for a pdf file with name 	 * as given + ".pdf" 	 */
DECL|method|findPdf (String key, String extension, String directory, OpenFileFilter off)
specifier|public
specifier|static
name|String
name|findPdf
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|extension
parameter_list|,
name|String
name|directory
parameter_list|,
name|OpenFileFilter
name|off
parameter_list|)
block|{
comment|// String filename = key + "."+extension;
comment|/* 		 * Simon Fischer's patch for replacing a regexp in keys before 		 * converting to filename: 		 *  		 * String regex = Globals.prefs.get("basenamePatternRegex"); if ((regex != 		 * null)&& (regex.trim().length()> 0)) { String replacement = 		 * Globals.prefs.get("basenamePatternReplacement"); key = 		 * key.replaceAll(regex, replacement); } 		 */
if|if
condition|(
operator|!
name|directory
operator|.
name|endsWith
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
argument_list|)
condition|)
name|directory
operator|+=
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
expr_stmt|;
name|String
name|found
init|=
name|findInDir
argument_list|(
name|key
argument_list|,
name|directory
argument_list|,
name|off
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
operator|!=
literal|null
condition|)
return|return
name|found
operator|.
name|substring
argument_list|(
name|directory
operator|.
name|length
argument_list|()
argument_list|)
return|;
else|else
return|return
literal|null
return|;
block|}
comment|/** 	 * New version of findPdf that uses findFiles. 	 *  	 * The search pattern will be read from the preferences. 	 *  	 * The [extension]-tags in this pattern will be replace by the given 	 * extension parameter. 	 *  	 */
DECL|method|findPdf (BibtexEntry entry, String extension, String directory)
specifier|public
specifier|static
name|String
name|findPdf
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|String
name|extension
parameter_list|,
name|String
name|directory
parameter_list|)
block|{
return|return
name|findPdf
argument_list|(
name|entry
argument_list|,
name|extension
argument_list|,
operator|new
name|String
index|[]
block|{
name|directory
block|}
argument_list|)
return|;
block|}
comment|/** 	 * Convenience method for findPDF. Can search multiple PDF directories. 	 */
DECL|method|findPdf (BibtexEntry entry, String extension, String[] directories)
specifier|public
specifier|static
name|String
name|findPdf
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|String
name|extension
parameter_list|,
name|String
index|[]
name|directories
parameter_list|)
block|{
name|String
name|regularExpression
decl_stmt|;
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|USE_REG_EXP_SEARCH_KEY
argument_list|)
condition|)
block|{
name|regularExpression
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|REG_EXP_SEARCH_EXPRESSION_KEY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|regularExpression
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|DEFAULT_REG_EXP_SEARCH_EXPRESSION_KEY
argument_list|)
expr_stmt|;
block|}
name|regularExpression
operator|=
name|regularExpression
operator|.
name|replaceAll
argument_list|(
literal|"\\[extension\\]"
argument_list|,
name|extension
argument_list|)
expr_stmt|;
return|return
name|findFile
argument_list|(
name|entry
argument_list|,
literal|null
argument_list|,
name|directories
argument_list|,
name|regularExpression
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Convenience menthod for findPDF. Searches for a file of the given type.      * @param entry The BibtexEntry to search for a link for.      * @param fileType The file type to search for.      * @return The link to the file found, or null if not found.      */
DECL|method|findFile (BibtexEntry entry, ExternalFileType fileType, List extraDirs)
specifier|public
specifier|static
name|String
name|findFile
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|ExternalFileType
name|fileType
parameter_list|,
name|List
name|extraDirs
parameter_list|)
block|{
name|List
name|dirs
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|dirs
operator|.
name|addAll
argument_list|(
name|extraDirs
argument_list|)
expr_stmt|;
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|hasKey
argument_list|(
name|fileType
operator|.
name|getExtension
argument_list|()
operator|+
literal|"Directory"
argument_list|)
condition|)
block|{
name|dirs
operator|.
name|add
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|fileType
operator|.
name|getExtension
argument_list|()
operator|+
literal|"Directory"
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|fileType
operator|.
name|getExtension
argument_list|()
operator|+
literal|"Directory"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
name|directories
init|=
operator|(
name|String
index|[]
operator|)
name|dirs
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|dirs
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
return|return
name|findPdf
argument_list|(
name|entry
argument_list|,
name|fileType
operator|.
name|getExtension
argument_list|()
argument_list|,
name|directories
argument_list|)
return|;
block|}
comment|/** 	 * Searches the given directory and file name pattern for a file for the 	 * bibtexentry. 	 *  	 * Used to fix: 	 *  	 * http://sourceforge.net/tracker/index.php?func=detail&aid=1503410&group_id=92314&atid=600309 	 *  	 * Requirements: 	 *  - Be able to find the associated PDF in a set of given directories. 	 *  - Be able to return a relative path or absolute path. 	 *  - Be fast. 	 *  - Allow for flexible naming schemes in the PDFs. 	 *  	 * Syntax scheme for file: 	 *<ul> 	 *<li>* Any subDir</li> 	 *<li>** Any subDir (recursiv)</li> 	 *<li>[key] Key from bibtex file and database</li> 	 *<li>.* Anything else is taken to be a Regular expression.</li> 	 *</ul> 	 *  	 * @param entry 	 *            non-null 	 * @param database 	 *            non-null 	 * @param directory 	 *            A set of root directories to start the search from. Paths are 	 *            returned relative to these directories if relative is set to 	 *            true. These directories will not be expanded or anything. Use 	 *            the file attribute for this. 	 * @param file 	 *            non-null 	 *  	 * @param relative 	 *            whether to return relative file paths or absolute ones 	 *  	 * @return Will return the first file found to match the given criteria or 	 *         null if none was found. 	 */
DECL|method|findFile (BibtexEntry entry, BibtexDatabase database, String[] directory, String file, boolean relative)
specifier|public
specifier|static
name|String
name|findFile
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|,
name|String
index|[]
name|directory
parameter_list|,
name|String
name|file
parameter_list|,
name|boolean
name|relative
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|directory
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|result
init|=
name|findFile
argument_list|(
name|entry
argument_list|,
name|database
argument_list|,
name|directory
index|[
name|i
index|]
argument_list|,
name|file
argument_list|,
name|relative
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 * Removes optional square brackets from the string s 	 *  	 * @param s 	 * @return 	 */
DECL|method|stripBrackets (String s)
specifier|public
specifier|static
name|String
name|stripBrackets
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|int
name|beginIndex
init|=
operator|(
name|s
operator|.
name|startsWith
argument_list|(
literal|"["
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|endIndex
init|=
operator|(
name|s
operator|.
name|endsWith
argument_list|(
literal|"]"
argument_list|)
condition|?
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
else|:
name|s
operator|.
name|length
argument_list|()
operator|)
decl_stmt|;
return|return
name|s
operator|.
name|substring
argument_list|(
name|beginIndex
argument_list|,
name|endIndex
argument_list|)
return|;
block|}
DECL|method|parseMethodsCalls (String calls)
specifier|public
specifier|static
name|ArrayList
name|parseMethodsCalls
parameter_list|(
name|String
name|calls
parameter_list|)
throws|throws
name|RuntimeException
block|{
name|ArrayList
name|result
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|char
index|[]
name|c
init|=
name|calls
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|c
operator|.
name|length
condition|)
block|{
name|int
name|start
init|=
name|i
decl_stmt|;
if|if
condition|(
name|Character
operator|.
name|isJavaIdentifierStart
argument_list|(
name|c
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|c
operator|.
name|length
operator|&&
operator|(
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|c
index|[
name|i
index|]
argument_list|)
operator|||
name|c
index|[
name|i
index|]
operator|==
literal|'.'
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|c
operator|.
name|length
operator|&&
name|c
index|[
name|i
index|]
operator|==
literal|'('
condition|)
block|{
name|String
name|method
init|=
name|calls
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|i
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|int
name|startParam
init|=
name|i
decl_stmt|;
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|+
literal|1
operator|<
name|c
operator|.
name|length
operator|&&
operator|!
operator|(
name|c
index|[
name|i
index|]
operator|==
literal|'"'
operator|&&
name|c
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|')'
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
name|String
name|param
init|=
name|calls
operator|.
name|substring
argument_list|(
name|startParam
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
operator|new
name|String
index|[]
block|{
name|method
block|,
name|param
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|method
init|=
name|calls
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
operator|new
name|String
index|[]
block|{
name|method
block|}
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/** 	 * Accepts a string like [author:toLowerCase("escapedstring"),toUpperCase], 	 * whereas the first string signifies the bibtex-field to get while the 	 * others are the names of layouters that will be applied. 	 *  	 * @param fieldAndFormat 	 * @param entry 	 * @param database 	 * @return 	 */
DECL|method|getFieldAndFormat (String fieldAndFormat, BibtexEntry entry, BibtexDatabase database)
specifier|public
specifier|static
name|String
name|getFieldAndFormat
parameter_list|(
name|String
name|fieldAndFormat
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
block|{
name|fieldAndFormat
operator|=
name|stripBrackets
argument_list|(
name|fieldAndFormat
argument_list|)
expr_stmt|;
name|int
name|colon
init|=
name|fieldAndFormat
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
name|String
name|beforeColon
decl_stmt|,
name|afterColon
decl_stmt|;
if|if
condition|(
name|colon
operator|==
operator|-
literal|1
condition|)
block|{
name|beforeColon
operator|=
name|fieldAndFormat
expr_stmt|;
name|afterColon
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|beforeColon
operator|=
name|fieldAndFormat
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|afterColon
operator|=
name|fieldAndFormat
operator|.
name|substring
argument_list|(
name|colon
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|beforeColon
operator|=
name|beforeColon
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|beforeColon
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|fieldValue
init|=
name|getField
argument_list|(
name|beforeColon
argument_list|,
name|entry
argument_list|,
name|database
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldValue
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|afterColon
operator|==
literal|null
operator|||
name|afterColon
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
name|fieldValue
return|;
try|try
block|{
name|LayoutFormatter
index|[]
name|formatters
init|=
name|LayoutEntry
operator|.
name|getOptionalLayout
argument_list|(
name|afterColon
argument_list|,
literal|""
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|formatters
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|fieldValue
operator|=
name|formatters
index|[
name|i
index|]
operator|.
name|format
argument_list|(
name|fieldValue
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|fieldValue
return|;
block|}
DECL|method|getField (String field, BibtexEntry bibtex, BibtexDatabase database)
specifier|public
specifier|static
name|String
name|getField
parameter_list|(
name|String
name|field
parameter_list|,
name|BibtexEntry
name|bibtex
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"bibtextype"
argument_list|)
condition|)
return|return
name|bibtex
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
return|;
name|String
name|res
init|=
operator|(
name|String
operator|)
name|bibtex
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|res
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|database
operator|!=
literal|null
operator|)
condition|)
name|res
operator|=
name|database
operator|.
name|resolveForStrings
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
comment|/** 	 * Convenience function for absolute search. 	 *  	 * Uses findFile(BibtexEntry, BibtexDatabase, (String)null, String, false). 	 */
DECL|method|findFile (BibtexEntry entry, BibtexDatabase database, String file)
specifier|public
specifier|static
name|String
name|findFile
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|,
name|String
name|file
parameter_list|)
block|{
return|return
name|findFile
argument_list|(
name|entry
argument_list|,
name|database
argument_list|,
operator|(
name|String
operator|)
literal|null
argument_list|,
name|file
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** 	 * Internal Version of findFile, which also accepts a current directory to 	 * base the search on. 	 *  	 */
DECL|method|findFile (BibtexEntry entry, BibtexDatabase database, String directory, String file, boolean relative)
specifier|public
specifier|static
name|String
name|findFile
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|,
name|String
name|directory
parameter_list|,
name|String
name|file
parameter_list|,
name|boolean
name|relative
parameter_list|)
block|{
name|File
name|root
decl_stmt|;
if|if
condition|(
name|directory
operator|==
literal|null
condition|)
block|{
name|root
operator|=
operator|new
name|File
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|root
operator|=
operator|new
name|File
argument_list|(
name|directory
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|root
operator|.
name|exists
argument_list|()
condition|)
return|return
literal|null
return|;
name|String
name|found
init|=
name|findFile
argument_list|(
name|entry
argument_list|,
name|database
argument_list|,
name|root
argument_list|,
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|directory
operator|==
literal|null
operator|||
operator|!
name|relative
condition|)
block|{
return|return
name|found
return|;
block|}
if|if
condition|(
name|found
operator|!=
literal|null
condition|)
block|{
try|try
block|{
comment|/** 				 * [ 1601651 ] PDF subdirectory - missing first character 				 *  				 * http://sourceforge.net/tracker/index.php?func=detail&aid=1601651&group_id=92314&atid=600306 				 */
comment|// Changed by M. Alver 2007.01.04:
comment|// Remove first character if it is a directory separator character:
name|String
name|tmp
init|=
name|found
operator|.
name|substring
argument_list|(
name|root
operator|.
name|getCanonicalPath
argument_list|()
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|)
operator|&&
operator|(
name|tmp
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|File
operator|.
name|separatorChar
operator|)
condition|)
name|tmp
operator|=
name|tmp
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
comment|//return found.substring(root.getCanonicalPath().length());
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 * The actual work-horse. Will find absolute filepaths starting from the 	 * given directory using the given regular expression string for search. 	 */
DECL|method|findFile (BibtexEntry entry, BibtexDatabase database, File directory, String file)
specifier|protected
specifier|static
name|String
name|findFile
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|,
name|File
name|directory
parameter_list|,
name|String
name|file
parameter_list|)
block|{
if|if
condition|(
name|file
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|directory
operator|=
operator|new
name|File
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|file
operator|=
name|file
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Escape handling...
name|Matcher
name|m
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"([^\\\\])\\\\([^\\\\])"
argument_list|)
operator|.
name|matcher
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|StringBuffer
name|s
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
name|m
operator|.
name|appendReplacement
argument_list|(
name|s
argument_list|,
name|m
operator|.
name|group
argument_list|(
literal|1
argument_list|)
operator|+
literal|"/"
operator|+
name|m
operator|.
name|group
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|m
operator|.
name|appendTail
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|file
operator|=
name|s
operator|.
name|toString
argument_list|()
expr_stmt|;
name|String
index|[]
name|fileParts
init|=
name|file
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileParts
operator|.
name|length
operator|==
literal|0
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|fileParts
operator|.
name|length
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileParts
operator|.
name|length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|String
name|dirToProcess
init|=
name|fileParts
index|[
name|i
index|]
decl_stmt|;
name|dirToProcess
operator|=
name|expandBrackets
argument_list|(
name|dirToProcess
argument_list|,
name|entry
argument_list|,
name|database
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirToProcess
operator|.
name|matches
argument_list|(
literal|"^.:$"
argument_list|)
condition|)
block|{
comment|// Windows Drive Letter
name|directory
operator|=
operator|new
name|File
argument_list|(
name|dirToProcess
operator|+
literal|"/"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dirToProcess
operator|.
name|equals
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
comment|// Stay in current directory
continue|continue;
block|}
if|if
condition|(
name|dirToProcess
operator|.
name|equals
argument_list|(
literal|".."
argument_list|)
condition|)
block|{
name|directory
operator|=
operator|new
name|File
argument_list|(
name|directory
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dirToProcess
operator|.
name|equals
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
comment|// Do for all direct subdirs
name|File
index|[]
name|subDirs
init|=
name|directory
operator|.
name|listFiles
argument_list|()
decl_stmt|;
if|if
condition|(
name|subDirs
operator|==
literal|null
condition|)
return|return
literal|null
return|;
comment|// No permission?
name|String
name|restOfFileString
init|=
name|join
argument_list|(
name|fileParts
argument_list|,
literal|"/"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|fileParts
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|sub
init|=
literal|0
init|;
name|sub
operator|<
name|subDirs
operator|.
name|length
condition|;
name|sub
operator|++
control|)
block|{
if|if
condition|(
name|subDirs
index|[
name|sub
index|]
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|String
name|result
init|=
name|findFile
argument_list|(
name|entry
argument_list|,
name|database
argument_list|,
name|subDirs
index|[
name|sub
index|]
argument_list|,
name|restOfFileString
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
return|return
name|result
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|// Do for all direct and indirect subdirs
if|if
condition|(
name|dirToProcess
operator|.
name|equals
argument_list|(
literal|"**"
argument_list|)
condition|)
block|{
name|List
name|toDo
init|=
operator|new
name|LinkedList
argument_list|()
decl_stmt|;
name|toDo
operator|.
name|add
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|String
name|restOfFileString
init|=
name|join
argument_list|(
name|fileParts
argument_list|,
literal|"/"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|fileParts
operator|.
name|length
argument_list|)
decl_stmt|;
comment|// Before checking the subdirs, we first check the current
comment|// dir
name|String
name|result
init|=
name|findFile
argument_list|(
name|entry
argument_list|,
name|database
argument_list|,
name|directory
argument_list|,
name|restOfFileString
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
return|return
name|result
return|;
while|while
condition|(
operator|!
name|toDo
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Get all subdirs of each of the elements found in toDo
name|File
index|[]
name|subDirs
init|=
operator|(
operator|(
name|File
operator|)
name|toDo
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|listFiles
argument_list|()
decl_stmt|;
if|if
condition|(
name|subDirs
operator|==
literal|null
condition|)
comment|// No permission?
continue|continue;
name|toDo
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|subDirs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|sub
init|=
literal|0
init|;
name|sub
operator|<
name|subDirs
operator|.
name|length
condition|;
name|sub
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|subDirs
index|[
name|sub
index|]
operator|.
name|isDirectory
argument_list|()
condition|)
continue|continue;
name|result
operator|=
name|findFile
argument_list|(
name|entry
argument_list|,
name|database
argument_list|,
name|subDirs
index|[
name|sub
index|]
argument_list|,
name|restOfFileString
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
return|return
name|result
return|;
block|}
block|}
comment|// We already did the currentDirectory
return|return
literal|null
return|;
block|}
specifier|final
name|Pattern
name|toMatch
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|dirToProcess
operator|.
name|replaceAll
argument_list|(
literal|"\\\\\\\\"
argument_list|,
literal|"\\\\"
argument_list|)
argument_list|)
decl_stmt|;
name|File
index|[]
name|matches
init|=
name|directory
operator|.
name|listFiles
argument_list|(
operator|new
name|FilenameFilter
argument_list|()
block|{
specifier|public
name|boolean
name|accept
parameter_list|(
name|File
name|arg0
parameter_list|,
name|String
name|arg1
parameter_list|)
block|{
return|return
name|toMatch
operator|.
name|matcher
argument_list|(
name|arg1
argument_list|)
operator|.
name|matches
argument_list|()
return|;
block|}
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
name|matches
operator|==
literal|null
operator|||
name|matches
operator|.
name|length
operator|==
literal|0
condition|)
return|return
literal|null
return|;
name|directory
operator|=
name|matches
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|directory
operator|.
name|exists
argument_list|()
condition|)
return|return
literal|null
return|;
block|}
comment|// End process directory information
block|}
comment|// Last step check if the given file can be found in this directory
name|String
name|filenameToLookFor
init|=
name|expandBrackets
argument_list|(
name|fileParts
index|[
name|fileParts
operator|.
name|length
operator|-
literal|1
index|]
argument_list|,
name|entry
argument_list|,
name|database
argument_list|)
decl_stmt|;
specifier|final
name|Pattern
name|toMatch
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^"
operator|+
name|filenameToLookFor
operator|.
name|replaceAll
argument_list|(
literal|"\\\\\\\\"
argument_list|,
literal|"\\\\"
argument_list|)
operator|+
literal|"$"
argument_list|)
decl_stmt|;
name|File
index|[]
name|matches
init|=
name|directory
operator|.
name|listFiles
argument_list|(
operator|new
name|FilenameFilter
argument_list|()
block|{
specifier|public
name|boolean
name|accept
parameter_list|(
name|File
name|arg0
parameter_list|,
name|String
name|arg1
parameter_list|)
block|{
return|return
name|toMatch
operator|.
name|matcher
argument_list|(
name|arg1
argument_list|)
operator|.
name|matches
argument_list|()
return|;
block|}
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
name|matches
operator|==
literal|null
operator|||
name|matches
operator|.
name|length
operator|==
literal|0
condition|)
return|return
literal|null
return|;
try|try
block|{
return|return
name|matches
index|[
literal|0
index|]
operator|.
name|getCanonicalPath
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
DECL|field|squareBracketsPattern
specifier|static
name|Pattern
name|squareBracketsPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\[.*?\\]"
argument_list|)
decl_stmt|;
comment|/** 	 * Takes a string that contains bracketed expression and expands each of 	 * these using getFieldAndFormat. 	 *  	 * Unknown Bracket expressions are silently dropped. 	 *  	 * @param bracketString 	 * @param entry 	 * @param database 	 * @return 	 */
DECL|method|expandBrackets (String bracketString, BibtexEntry entry, BibtexDatabase database)
specifier|public
specifier|static
name|String
name|expandBrackets
parameter_list|(
name|String
name|bracketString
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
block|{
name|Matcher
name|m
init|=
name|squareBracketsPattern
operator|.
name|matcher
argument_list|(
name|bracketString
argument_list|)
decl_stmt|;
name|StringBuffer
name|s
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|replacement
init|=
name|getFieldAndFormat
argument_list|(
name|m
operator|.
name|group
argument_list|()
argument_list|,
name|entry
argument_list|,
name|database
argument_list|)
decl_stmt|;
if|if
condition|(
name|replacement
operator|==
literal|null
condition|)
name|replacement
operator|=
literal|""
expr_stmt|;
name|m
operator|.
name|appendReplacement
argument_list|(
name|s
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
block|}
name|m
operator|.
name|appendTail
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** 	 * Concatenate all strings in the array from index 'from' to 'to' (excluding 	 * to) with the given separator. 	 *  	 * Example: 	 *  	 * String[] s = "ab/cd/ed".split("/"); join(s, "\\", 0, s.length) -> 	 * "ab\\cd\\ed" 	 *  	 * @param strings 	 * @param separator 	 * @param from 	 * @param to 	 *            Excluding strings[to] 	 * @return 	 */
DECL|method|join (String[] strings, String separator, int from, int to)
specifier|public
specifier|static
name|String
name|join
parameter_list|(
name|String
index|[]
name|strings
parameter_list|,
name|String
name|separator
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
if|if
condition|(
name|strings
operator|.
name|length
operator|==
literal|0
operator|||
name|from
operator|>=
name|to
condition|)
return|return
literal|""
return|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|from
init|;
name|i
operator|<
name|to
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|strings
index|[
name|i
index|]
argument_list|)
operator|.
name|append
argument_list|(
name|separator
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|append
argument_list|(
name|strings
index|[
name|to
operator|-
literal|1
index|]
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** 	 * Converts a relative filename to an absolute one, if necessary. Returns 	 * null if the file does not exist. 	 *  	 * Will look in each of the given dirs starting from the beginning and 	 * returning the first found file to match if any. 	 */
DECL|method|expandFilename (String name, String[] dir)
specifier|public
specifier|static
name|File
name|expandFilename
parameter_list|(
name|String
name|name
parameter_list|,
name|String
index|[]
name|dir
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dir
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|File
name|result
init|=
name|expandFilename
argument_list|(
name|name
argument_list|,
name|dir
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 * Converts a relative filename to an absolute one, if necessary. Returns 	 * null if the file does not exist. 	 */
DECL|method|expandFilename (String name, String dir)
specifier|public
specifier|static
name|File
name|expandFilename
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|dir
parameter_list|)
block|{
comment|// System.out.println("expandFilename: name="+name+"\t dir="+dir);
name|File
name|file
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|null
operator|||
name|name
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
else|else
block|{
name|file
operator|=
operator|new
name|File
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
operator|&&
operator|(
name|dir
operator|!=
literal|null
operator|)
condition|)
block|{
if|if
condition|(
name|dir
operator|.
name|endsWith
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
argument_list|)
condition|)
name|name
operator|=
name|dir
operator|+
name|name
expr_stmt|;
else|else
name|name
operator|=
name|dir
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
operator|+
name|name
expr_stmt|;
comment|// System.out.println("expanded to: "+name);
comment|// if (name.startsWith("ftp"))
name|file
operator|=
operator|new
name|File
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
condition|)
return|return
name|file
return|;
comment|// Ok, try to fix / and \ problems:
if|if
condition|(
name|Globals
operator|.
name|ON_WIN
condition|)
block|{
comment|// workaround for catching Java bug in regexp replacer
comment|// and, why, why, why ... I don't get it - wegner 2006/01/22
try|try
block|{
name|name
operator|=
name|name
operator|.
name|replaceAll
argument_list|(
literal|"/"
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|StringIndexOutOfBoundsException
name|exc
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"An internal Java error was caused by the entry "
operator|+
literal|"\""
operator|+
name|name
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|name
operator|=
name|name
operator|.
name|replaceAll
argument_list|(
literal|"\\\\"
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
comment|// System.out.println("expandFilename: "+name);
name|file
operator|=
operator|new
name|File
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
name|file
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|return
name|file
return|;
block|}
DECL|method|findInDir (String key, String dir, OpenFileFilter off)
specifier|private
specifier|static
name|String
name|findInDir
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|dir
parameter_list|,
name|OpenFileFilter
name|off
parameter_list|)
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|File
index|[]
name|all
init|=
name|f
operator|.
name|listFiles
argument_list|()
decl_stmt|;
if|if
condition|(
name|all
operator|==
literal|null
condition|)
return|return
literal|null
return|;
comment|// An error occured. We may not have
comment|// permission to list the files.
name|int
name|numFiles
init|=
name|all
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFiles
condition|;
name|i
operator|++
control|)
block|{
name|File
name|curFile
init|=
name|all
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|curFile
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|String
name|name
init|=
name|curFile
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|key
operator|+
literal|"."
argument_list|)
operator|&&
name|off
operator|.
name|accept
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|curFile
operator|.
name|getPath
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|curFile
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|String
name|found
init|=
name|findInDir
argument_list|(
name|key
argument_list|,
name|curFile
operator|.
name|getPath
argument_list|()
argument_list|,
name|off
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
operator|!=
literal|null
condition|)
return|return
name|found
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 * Checks if the two entries represent the same publication. 	 *  	 * @param one 	 *            BibtexEntry 	 * @param two 	 *            BibtexEntry 	 * @return boolean 	 */
DECL|method|isDuplicate (BibtexEntry one, BibtexEntry two, float threshold)
specifier|public
specifier|static
name|boolean
name|isDuplicate
parameter_list|(
name|BibtexEntry
name|one
parameter_list|,
name|BibtexEntry
name|two
parameter_list|,
name|float
name|threshold
parameter_list|)
block|{
comment|// First check if they are of the same type - a necessary condition:
if|if
condition|(
name|one
operator|.
name|getType
argument_list|()
operator|!=
name|two
operator|.
name|getType
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// The check if they have the same required fields:
name|String
index|[]
name|fields
init|=
name|one
operator|.
name|getType
argument_list|()
operator|.
name|getRequiredFields
argument_list|()
decl_stmt|;
name|float
name|req
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
name|req
operator|=
literal|1
expr_stmt|;
else|else
name|req
operator|=
name|compareFieldSet
argument_list|(
name|fields
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
expr_stmt|;
name|fields
operator|=
name|one
operator|.
name|getType
argument_list|()
operator|.
name|getOptionalFields
argument_list|()
expr_stmt|;
if|if
condition|(
name|fields
operator|!=
literal|null
condition|)
block|{
name|float
name|opt
init|=
name|compareFieldSet
argument_list|(
name|fields
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
decl_stmt|;
return|return
operator|(
literal|2
operator|*
name|req
operator|+
name|opt
operator|)
operator|/
literal|3
operator|>=
name|threshold
return|;
block|}
else|else
block|{
return|return
operator|(
name|req
operator|>=
name|threshold
operator|)
return|;
block|}
block|}
comment|/** 	 * Goes through all entries in the given database, and if at least one of 	 * them is a duplicate of the given entry, as per 	 * Util.isDuplicate(BibtexEntry, BibtexEntry), the duplicate is returned. 	 * The search is terminated when the first duplicate is found. 	 *  	 * @param database 	 *            The database to search. 	 * @param entry 	 *            The entry of which we are looking for duplicates. 	 * @return The first duplicate entry found. null if no duplicates are found. 	 */
DECL|method|containsDuplicate (BibtexDatabase database, BibtexEntry entry)
specifier|public
specifier|static
name|BibtexEntry
name|containsDuplicate
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|)
block|{
name|Collection
name|entries
init|=
name|database
operator|.
name|getEntries
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|entries
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BibtexEntry
name|other
init|=
operator|(
name|BibtexEntry
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|isDuplicate
argument_list|(
name|entry
argument_list|,
name|other
argument_list|,
name|Globals
operator|.
name|duplicateThreshold
argument_list|)
condition|)
return|return
name|other
return|;
comment|// Duplicate found.
block|}
return|return
literal|null
return|;
comment|// No duplicate found.
block|}
DECL|method|compareFieldSet (String[] fields, BibtexEntry one, BibtexEntry two)
specifier|private
specifier|static
name|float
name|compareFieldSet
parameter_list|(
name|String
index|[]
name|fields
parameter_list|,
name|BibtexEntry
name|one
parameter_list|,
name|BibtexEntry
name|two
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// Util.pr(":"+compareSingleField(fields[i], one, two));
if|if
condition|(
name|compareSingleField
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
operator|==
name|EQUAL
condition|)
block|{
name|res
operator|++
expr_stmt|;
comment|// Util.pr(fields[i]);
block|}
block|}
return|return
operator|(
operator|(
name|float
operator|)
name|res
operator|)
operator|/
operator|(
operator|(
name|float
operator|)
name|fields
operator|.
name|length
operator|)
return|;
block|}
DECL|method|compareSingleField (String field, BibtexEntry one, BibtexEntry two)
specifier|private
specifier|static
name|int
name|compareSingleField
parameter_list|(
name|String
name|field
parameter_list|,
name|BibtexEntry
name|one
parameter_list|,
name|BibtexEntry
name|two
parameter_list|)
block|{
name|String
name|s1
init|=
operator|(
name|String
operator|)
name|one
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|,
name|s2
init|=
operator|(
name|String
operator|)
name|two
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|s1
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|s2
operator|==
literal|null
condition|)
return|return
name|EQUAL
return|;
else|else
return|return
name|EMPTY_IN_ONE
return|;
block|}
elseif|else
if|if
condition|(
name|s2
operator|==
literal|null
condition|)
return|return
name|EMPTY_IN_TWO
return|;
name|s1
operator|=
name|s1
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|s2
operator|=
name|s2
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
comment|// Util.pr(field+": '"+s1+"' vs '"+s2+"'");
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"author"
argument_list|)
operator|||
name|field
operator|.
name|equals
argument_list|(
literal|"editor"
argument_list|)
condition|)
block|{
comment|// Specific for name fields.
comment|// Harmonise case:
name|String
index|[]
name|aus1
init|=
name|AuthorList
operator|.
name|fixAuthor_lastNameFirst
argument_list|(
name|s1
argument_list|)
operator|.
name|split
argument_list|(
literal|" and "
argument_list|)
decl_stmt|,
name|aus2
init|=
name|AuthorList
operator|.
name|fixAuthor_lastNameFirst
argument_list|(
name|s2
argument_list|)
operator|.
name|split
argument_list|(
literal|" and "
argument_list|)
decl_stmt|,
name|au1
init|=
name|aus1
index|[
literal|0
index|]
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|,
name|au2
init|=
name|aus2
index|[
literal|0
index|]
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
comment|// Can check number of authors, all authors or only the first.
if|if
condition|(
operator|(
name|aus1
operator|.
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|aus1
operator|.
name|length
operator|==
name|aus2
operator|.
name|length
operator|)
operator|&&
name|au1
index|[
literal|0
index|]
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
name|au2
index|[
literal|0
index|]
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
return|return
name|EQUAL
return|;
else|else
return|return
name|NOT_EQUAL
return|;
block|}
else|else
block|{
if|if
condition|(
name|s1
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
name|s2
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
return|return
name|EQUAL
return|;
else|else
return|return
name|NOT_EQUAL
return|;
block|}
block|}
DECL|method|compareEntriesStrictly (BibtexEntry one, BibtexEntry two)
specifier|public
specifier|static
name|double
name|compareEntriesStrictly
parameter_list|(
name|BibtexEntry
name|one
parameter_list|,
name|BibtexEntry
name|two
parameter_list|)
block|{
name|HashSet
name|allFields
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
comment|// one.getAllFields());
name|Object
index|[]
name|o
init|=
name|one
operator|.
name|getAllFields
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|o
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|allFields
operator|.
name|add
argument_list|(
name|o
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|o
operator|=
name|two
operator|.
name|getAllFields
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|o
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|allFields
operator|.
name|add
argument_list|(
name|o
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|int
name|score
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
name|fld
init|=
name|allFields
operator|.
name|iterator
argument_list|()
init|;
name|fld
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|field
init|=
operator|(
name|String
operator|)
name|fld
operator|.
name|next
argument_list|()
decl_stmt|;
name|Object
name|en
init|=
name|one
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|,
name|to
init|=
name|two
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|en
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|to
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|en
operator|.
name|equals
argument_list|(
name|to
argument_list|)
operator|)
condition|)
name|score
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|en
operator|==
literal|null
operator|)
operator|&&
operator|(
name|to
operator|==
literal|null
operator|)
condition|)
name|score
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|score
operator|==
name|allFields
operator|.
name|size
argument_list|()
condition|)
return|return
literal|1.01
return|;
comment|// Just to make sure we can
comment|// use score>1 without
comment|// trouble.
else|else
return|return
operator|(
operator|(
name|double
operator|)
name|score
operator|)
operator|/
name|allFields
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * This methods assures all words in the given entry are recorded in their      * respective Completers, if any.      */
DECL|method|updateCompletersForEntry (HashMap autoCompleters, BibtexEntry be)
specifier|public
specifier|static
name|void
name|updateCompletersForEntry
parameter_list|(
name|HashMap
name|autoCompleters
parameter_list|,
name|BibtexEntry
name|be
parameter_list|)
block|{
for|for
control|(
name|Iterator
name|j
init|=
name|autoCompleters
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|field
init|=
operator|(
name|String
operator|)
name|j
operator|.
name|next
argument_list|()
decl_stmt|;
name|AutoCompleter
name|comp
init|=
operator|(
name|AutoCompleter
operator|)
name|autoCompleters
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|comp
operator|.
name|addAll
argument_list|(
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Sets empty or non-existing owner fields of bibtex entries inside a List 	 * to a specified default value. Timestamp field is also set. Preferences 	 * are checked to see if these options are enabled. 	 *  	 * @param bibs 	 *            List of bibtex entries 	 */
DECL|method|setAutomaticFields (List bibs)
specifier|public
specifier|static
name|void
name|setAutomaticFields
parameter_list|(
name|List
name|bibs
parameter_list|)
block|{
name|String
name|defaultOwner
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"defaultOwner"
argument_list|)
decl_stmt|;
name|String
name|timestamp
init|=
name|easyDateFormat
argument_list|()
decl_stmt|;
name|boolean
name|setOwner
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"useOwner"
argument_list|)
decl_stmt|,
name|setTimeStamp
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"useTimeStamp"
argument_list|)
decl_stmt|;
name|String
name|timeStampField
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"timeStampField"
argument_list|)
decl_stmt|;
comment|// Iterate through all entries
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bibs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// Get current entry
name|BibtexEntry
name|curEntry
init|=
operator|(
name|BibtexEntry
operator|)
name|bibs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|setAutomaticFields
argument_list|(
name|curEntry
argument_list|,
name|setOwner
argument_list|,
name|defaultOwner
argument_list|,
name|setTimeStamp
argument_list|,
name|timeStampField
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Sets empty or non-existing owner fields of a bibtex entry to a specified 	 * default value. Timestamp field is also set. Preferences are checked to 	 * see if these options are enabled. 	 *  	 * @param entry 	 *            The entry to set fields for. 	 */
DECL|method|setAutomaticFields (BibtexEntry entry)
specifier|public
specifier|static
name|void
name|setAutomaticFields
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|)
block|{
name|String
name|defaultOwner
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"defaultOwner"
argument_list|)
decl_stmt|;
name|String
name|timestamp
init|=
name|easyDateFormat
argument_list|()
decl_stmt|;
name|boolean
name|setOwner
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"useOwner"
argument_list|)
decl_stmt|,
name|setTimeStamp
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"useTimeStamp"
argument_list|)
decl_stmt|;
name|String
name|timeStampField
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"timeStampField"
argument_list|)
decl_stmt|;
name|setAutomaticFields
argument_list|(
name|entry
argument_list|,
name|setOwner
argument_list|,
name|defaultOwner
argument_list|,
name|setTimeStamp
argument_list|,
name|timeStampField
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
block|}
DECL|method|setAutomaticFields (BibtexEntry entry, boolean setOwner, String owner, boolean setTimeStamp, String timeStampField, String timeStamp)
specifier|private
specifier|static
name|void
name|setAutomaticFields
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|boolean
name|setOwner
parameter_list|,
name|String
name|owner
parameter_list|,
name|boolean
name|setTimeStamp
parameter_list|,
name|String
name|timeStampField
parameter_list|,
name|String
name|timeStamp
parameter_list|)
block|{
comment|// Set owner field if this option is enabled:
if|if
condition|(
name|setOwner
condition|)
block|{
comment|// No or empty owner field?
comment|// if (entry.getField(Globals.OWNER) == null
comment|// || ((String) entry.getField(Globals.OWNER)).length() == 0) {
comment|// Set owner field to default value
name|entry
operator|.
name|setField
argument_list|(
name|BibtexFields
operator|.
name|OWNER
argument_list|,
name|owner
argument_list|)
expr_stmt|;
comment|// }
block|}
if|if
condition|(
name|setTimeStamp
condition|)
name|entry
operator|.
name|setField
argument_list|(
name|timeStampField
argument_list|,
name|timeStamp
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Copies a file. 	 *  	 * @param source 	 *            File Source file 	 * @param dest 	 *            File Destination file 	 * @param deleteIfExists 	 *            boolean Determines whether the copy goes on even if the file 	 *            exists. 	 * @throws IOException 	 * @return boolean Whether the copy succeeded, or was stopped due to the 	 *         file already existing. 	 */
DECL|method|copyFile (File source, File dest, boolean deleteIfExists)
specifier|public
specifier|static
name|boolean
name|copyFile
parameter_list|(
name|File
name|source
parameter_list|,
name|File
name|dest
parameter_list|,
name|boolean
name|deleteIfExists
parameter_list|)
throws|throws
name|IOException
block|{
name|BufferedInputStream
name|in
init|=
literal|null
decl_stmt|;
name|BufferedOutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// Check if the file already exists.
if|if
condition|(
name|dest
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|deleteIfExists
condition|)
return|return
literal|false
return|;
comment|// else dest.delete();
block|}
name|in
operator|=
operator|new
name|BufferedInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|=
operator|new
name|BufferedOutputStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|el
decl_stmt|;
comment|// int tell = 0;
while|while
condition|(
operator|(
name|el
operator|=
name|in
operator|.
name|read
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|el
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
name|ex
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/** 	 * This method is called at startup, and makes necessary adaptations to 	 * preferences for users from an earlier version of Jabref. 	 */
DECL|method|performCompatibilityUpdate ()
specifier|public
specifier|static
name|void
name|performCompatibilityUpdate
parameter_list|()
block|{
comment|// Make sure "abstract" is not in General fields, because
comment|// Jabref 1.55 moves the abstract to its own tab.
name|String
name|genFields
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"generalFields"
argument_list|)
decl_stmt|;
comment|// pr(genFields+"\t"+genFields.indexOf("abstract"));
if|if
condition|(
name|genFields
operator|.
name|indexOf
argument_list|(
literal|"abstract"
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|// pr(genFields+"\t"+genFields.indexOf("abstract"));
name|String
name|newGen
decl_stmt|;
if|if
condition|(
name|genFields
operator|.
name|equals
argument_list|(
literal|"abstract"
argument_list|)
condition|)
name|newGen
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|genFields
operator|.
name|indexOf
argument_list|(
literal|";abstract;"
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|newGen
operator|=
name|genFields
operator|.
name|replaceAll
argument_list|(
literal|";abstract;"
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|genFields
operator|.
name|indexOf
argument_list|(
literal|"abstract;"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newGen
operator|=
name|genFields
operator|.
name|replaceAll
argument_list|(
literal|"abstract;"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|genFields
operator|.
name|indexOf
argument_list|(
literal|";abstract"
argument_list|)
operator|==
name|genFields
operator|.
name|length
argument_list|()
operator|-
literal|9
condition|)
block|{
name|newGen
operator|=
name|genFields
operator|.
name|replaceAll
argument_list|(
literal|";abstract"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|newGen
operator|=
name|genFields
expr_stmt|;
comment|// pr(newGen);
name|Globals
operator|.
name|prefs
operator|.
name|put
argument_list|(
literal|"generalFields"
argument_list|,
name|newGen
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Collect file links from the given set of fields, and add them to the list contained      * in the field GUIGlobals.FILE_FIELD.      * @param database The database to modify.      * @param fields The fields to find links in.      * @return A CompoundEdit specifying the undo operation for the whole operation.      */
DECL|method|upgradePdfPsToFile (BibtexDatabase database, String[] fields)
specifier|public
specifier|static
name|NamedCompound
name|upgradePdfPsToFile
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|String
index|[]
name|fields
parameter_list|)
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Move external links to 'file' field"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|database
operator|.
name|getEntryMap
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BibtexEntry
name|entry
init|=
operator|(
name|BibtexEntry
operator|)
name|database
operator|.
name|getEntryMap
argument_list|()
operator|.
name|get
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|FileListTableModel
name|tableModel
init|=
operator|new
name|FileListTableModel
argument_list|()
decl_stmt|;
comment|// If there are already links in the file field, keep those on top:
name|Object
name|oldFileContent
init|=
name|entry
operator|.
name|getField
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldFileContent
operator|!=
literal|null
condition|)
block|{
name|tableModel
operator|.
name|setContent
argument_list|(
operator|(
name|String
operator|)
name|oldFileContent
argument_list|)
expr_stmt|;
block|}
name|int
name|oldRowCount
init|=
name|tableModel
operator|.
name|getRowCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|fields
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|Object
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|fields
index|[
name|j
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|String
name|s
init|=
operator|(
name|String
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|String
name|extension
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|s
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
operator|<
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
name|extension
operator|=
name|s
operator|.
name|substring
argument_list|(
name|s
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|FileListEntry
name|flEntry
init|=
operator|new
name|FileListEntry
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|s
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeByExt
argument_list|(
name|fields
index|[
name|j
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|tableModel
operator|.
name|addEntry
argument_list|(
name|tableModel
operator|.
name|getRowCount
argument_list|()
argument_list|,
name|flEntry
argument_list|)
expr_stmt|;
name|entry
operator|.
name|clearField
argument_list|(
name|fields
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|fields
index|[
name|j
index|]
argument_list|,
name|o
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tableModel
operator|.
name|getRowCount
argument_list|()
operator|!=
name|oldRowCount
condition|)
block|{
name|String
name|newValue
init|=
name|tableModel
operator|.
name|getStringRepresentation
argument_list|()
decl_stmt|;
name|entry
operator|.
name|setField
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|,
name|oldFileContent
argument_list|,
name|newValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
return|return
name|ce
return|;
block|}
comment|// -------------------------------------------------------------------------------
comment|/** 	 * extends the filename with a default Extension, if no Extension '.x' could 	 * be found 	 */
DECL|method|getCorrectFileName (String orgName, String defaultExtension)
specifier|public
specifier|static
name|String
name|getCorrectFileName
parameter_list|(
name|String
name|orgName
parameter_list|,
name|String
name|defaultExtension
parameter_list|)
block|{
if|if
condition|(
name|orgName
operator|==
literal|null
condition|)
return|return
literal|""
return|;
name|String
name|back
init|=
name|orgName
decl_stmt|;
name|int
name|t
init|=
name|orgName
operator|.
name|indexOf
argument_list|(
literal|"."
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// hidden files Linux/Unix (?)
if|if
condition|(
name|t
operator|<
literal|1
condition|)
name|back
operator|=
name|back
operator|+
literal|"."
operator|+
name|defaultExtension
expr_stmt|;
return|return
name|back
return|;
block|}
comment|/** 	 * Quotes each and every character, e.g. '!' as&#33;. Used for verbatim 	 * display of arbitrary strings that may contain HTML entities. 	 */
DECL|method|quoteForHTML (String s)
specifier|public
specifier|static
name|String
name|quoteForHTML
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"&#"
operator|+
operator|(
name|int
operator|)
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|quote (String s, String specials, char quoteChar)
specifier|public
specifier|static
name|String
name|quote
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|specials
parameter_list|,
name|char
name|quoteChar
parameter_list|)
block|{
return|return
name|quote
argument_list|(
name|s
argument_list|,
name|specials
argument_list|,
name|quoteChar
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/** 	 * Quote special characters. 	 *  	 * @param s 	 *            The String which may contain special characters. 	 * @param specials 	 *            A String containing all special characters except the quoting 	 *            character itself, which is automatically quoted. 	 * @param quoteChar 	 *            The quoting character. 	 * @param linewrap 	 *            The number of characters after which a linebreak is inserted 	 *            (this linebreak is undone by unquote()). Set to 0 to disable. 	 * @return A String with every special character (including the quoting 	 *         character itself) quoted. 	 */
DECL|method|quote (String s, String specials, char quoteChar, int linewrap)
specifier|public
specifier|static
name|String
name|quote
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|specials
parameter_list|,
name|char
name|quoteChar
parameter_list|,
name|int
name|linewrap
parameter_list|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|linelength
init|=
literal|0
decl_stmt|;
name|boolean
name|isSpecial
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|c
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|isSpecial
operator|=
name|specials
operator|.
name|indexOf
argument_list|(
name|c
argument_list|)
operator|>=
literal|0
operator|||
name|c
operator|==
name|quoteChar
expr_stmt|;
comment|// linebreak?
if|if
condition|(
name|linewrap
operator|>
literal|0
operator|&&
operator|(
operator|++
name|linelength
operator|>=
name|linewrap
operator|||
operator|(
name|isSpecial
operator|&&
name|linelength
operator|>=
name|linewrap
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|quoteChar
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|linelength
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|isSpecial
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|quoteChar
argument_list|)
expr_stmt|;
operator|++
name|linelength
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** 	 * Unquote special characters. 	 *  	 * @param s 	 *            The String which may contain quoted special characters. 	 * @param quoteChar 	 *            The quoting character. 	 * @return A String with all quoted characters unquoted. 	 */
DECL|method|unquote (String s, char quoteChar)
specifier|public
specifier|static
name|String
name|unquote
parameter_list|(
name|String
name|s
parameter_list|,
name|char
name|quoteChar
parameter_list|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|char
name|c
decl_stmt|;
name|boolean
name|quoted
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|c
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|quoted
condition|)
block|{
comment|// append literally...
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
comment|// ...unless newline
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|quoted
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
name|quoteChar
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// quote char
name|quoted
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** 	 * Quote all regular expression meta characters in s, in order to search for 	 * s literally. 	 */
DECL|method|quoteMeta (String s)
specifier|public
specifier|static
name|String
name|quoteMeta
parameter_list|(
name|String
name|s
parameter_list|)
block|{
comment|// work around a bug: trailing backslashes have to be quoted
comment|// individually
name|int
name|i
init|=
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
name|StringBuffer
name|bs
init|=
operator|new
name|StringBuffer
argument_list|(
literal|""
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'\\'
operator|)
condition|)
block|{
operator|--
name|i
expr_stmt|;
name|bs
operator|.
name|append
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|"\\Q"
operator|+
name|s
operator|.
name|replaceAll
argument_list|(
literal|"\\\\E"
argument_list|,
literal|"\\\\E\\\\\\\\E\\\\Q"
argument_list|)
operator|+
literal|"\\E"
operator|+
name|bs
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/* 	 * This method "tidies" up e.g. a keyword string, by alphabetizing the words 	 * and removing all duplicates. 	 */
DECL|method|sortWordsAndRemoveDuplicates (String text)
specifier|public
specifier|static
name|String
name|sortWordsAndRemoveDuplicates
parameter_list|(
name|String
name|text
parameter_list|)
block|{
name|String
index|[]
name|words
init|=
name|text
operator|.
name|split
argument_list|(
literal|", "
argument_list|)
decl_stmt|;
name|SortedSet
name|set
init|=
operator|new
name|TreeSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|words
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|set
operator|.
name|add
argument_list|(
name|words
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|set
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|2
condition|)
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|result
init|=
name|sb
operator|.
name|toString
argument_list|()
decl_stmt|;
return|return
name|result
operator|.
name|length
argument_list|()
operator|>
literal|2
condition|?
name|result
else|:
literal|""
return|;
block|}
comment|/** 	 * Warns the user of undesired side effects of an explicit 	 * assignment/removal of entries to/from this group. Currently there are 	 * four types of groups: AllEntriesGroup, SearchGroup - do not support 	 * explicit assignment. ExplicitGroup - never modifies entries. KeywordGroup - 	 * only this modifies entries upon assignment/removal. Modifications are 	 * acceptable unless they affect a standard field (such as "author") besides 	 * the "keywords" field. 	 *  	 * @param parent 	 *            The Component used as a parent when displaying a confirmation 	 *            dialog. 	 * @return true if the assignment has no undesired side effects, or the user 	 *         chose to perform it anyway. false otherwise (this indicates that 	 *         the user has aborted the assignment). 	 */
DECL|method|warnAssignmentSideEffects (AbstractGroup[] groups, BibtexEntry[] entries, BibtexDatabase db, Component parent)
specifier|public
specifier|static
name|boolean
name|warnAssignmentSideEffects
parameter_list|(
name|AbstractGroup
index|[]
name|groups
parameter_list|,
name|BibtexEntry
index|[]
name|entries
parameter_list|,
name|BibtexDatabase
name|db
parameter_list|,
name|Component
name|parent
parameter_list|)
block|{
name|Vector
name|affectedFields
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|groups
operator|.
name|length
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
name|groups
index|[
name|k
index|]
operator|instanceof
name|KeywordGroup
condition|)
block|{
name|KeywordGroup
name|kg
init|=
operator|(
name|KeywordGroup
operator|)
name|groups
index|[
name|k
index|]
decl_stmt|;
name|String
name|field
init|=
name|kg
operator|.
name|getSearchField
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"keywords"
argument_list|)
condition|)
continue|continue;
comment|// this is not undesired
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|BibtexFields
operator|.
name|numberOfPublicFields
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
name|BibtexFields
operator|.
name|getFieldName
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|affectedFields
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|affectedFields
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|true
return|;
comment|// no side effects
comment|// show a warning, then return
name|StringBuffer
name|message
init|=
comment|// JZTODO lyrics...
operator|new
name|StringBuffer
argument_list|(
literal|"This action will modify the following field(s)\n"
operator|+
literal|"in at least one entry each:\n"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|affectedFields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|message
operator|.
name|append
argument_list|(
name|affectedFields
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"This could cause undesired changes to "
operator|+
literal|"your entries, so it is\nrecommended that you change the grouping field "
operator|+
literal|"in your group\ndefinition to \"keywords\" or a non-standard name."
operator|+
literal|"\n\nDo you still want to continue?"
argument_list|)
expr_stmt|;
name|int
name|choice
init|=
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|parent
argument_list|,
name|message
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Warning"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_OPTION
argument_list|,
name|JOptionPane
operator|.
name|WARNING_MESSAGE
argument_list|)
decl_stmt|;
return|return
name|choice
operator|!=
name|JOptionPane
operator|.
name|NO_OPTION
return|;
comment|// if (groups instanceof KeywordGroup) {
comment|// KeywordGroup kg = (KeywordGroup) groups;
comment|// String field = kg.getSearchField().toLowerCase();
comment|// if (field.equals("keywords"))
comment|// return true; // this is not undesired
comment|// for (int i = 0; i< GUIGlobals.ALL_FIELDS.length; ++i) {
comment|// if (field.equals(GUIGlobals.ALL_FIELDS[i])) {
comment|// // show a warning, then return
comment|// String message = Globals // JZTODO lyrics...
comment|// .lang(
comment|// "This action will modify the \"%0\" field "
comment|// + "of your entries.\nThis could cause undesired changes to "
comment|// + "your entries, so it is\nrecommended that you change the grouping
comment|// field "
comment|// + "in your group\ndefinition to \"keywords\" or a non-standard name."
comment|// + "\n\nDo you still want to continue?",
comment|// field);
comment|// int choice = JOptionPane.showConfirmDialog(parent, message,
comment|// Globals.lang("Warning"), JOptionPane.YES_NO_OPTION,
comment|// JOptionPane.WARNING_MESSAGE);
comment|// return choice != JOptionPane.NO_OPTION;
comment|// }
comment|// }
comment|// }
comment|// return true; // found no side effects
block|}
comment|// ========================================================
comment|// lot of abreviations in medline
comment|// PKC etc convert to {PKC} ...
comment|// ========================================================
DECL|field|titleCapitalPattern
specifier|static
name|Pattern
name|titleCapitalPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[A-Z]+"
argument_list|)
decl_stmt|;
comment|/** 	 * Wrap all uppercase letters, or sequences of uppercase letters, in curly 	 * braces. Ignore letters within a pair of # character, as these are part of 	 * a string label that should not be modified. 	 *  	 * @param s 	 *            The string to modify. 	 * @return The resulting string after wrapping capitals. 	 */
DECL|method|putBracesAroundCapitals (String s)
specifier|public
specifier|static
name|String
name|putBracesAroundCapitals
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|boolean
name|inString
init|=
literal|false
decl_stmt|,
name|isBracing
init|=
literal|false
decl_stmt|,
name|escaped
init|=
literal|false
decl_stmt|;
name|int
name|inBrace
init|=
literal|0
decl_stmt|;
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// Update variables based on special characters:
name|int
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|inBrace
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|inBrace
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|escaped
operator|&&
operator|(
name|c
operator|==
literal|'#'
operator|)
condition|)
name|inString
operator|=
operator|!
name|inString
expr_stmt|;
comment|// See if we should start bracing:
if|if
condition|(
operator|(
name|inBrace
operator|==
literal|0
operator|)
operator|&&
operator|!
name|isBracing
operator|&&
operator|!
name|inString
operator|&&
name|Character
operator|.
name|isLetter
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|&&
name|Character
operator|.
name|isUpperCase
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|isBracing
operator|=
literal|true
expr_stmt|;
block|}
comment|// See if we should close a brace set:
if|if
condition|(
name|isBracing
operator|&&
operator|!
operator|(
name|Character
operator|.
name|isLetter
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|&&
name|Character
operator|.
name|isUpperCase
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|isBracing
operator|=
literal|false
expr_stmt|;
block|}
comment|// Add the current character:
name|buf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
comment|// Check if we are entering an escape sequence:
if|if
condition|(
operator|(
name|c
operator|==
literal|'\\'
operator|)
operator|&&
operator|!
name|escaped
condition|)
name|escaped
operator|=
literal|true
expr_stmt|;
else|else
name|escaped
operator|=
literal|false
expr_stmt|;
block|}
comment|// Check if we have an unclosed brace:
if|if
condition|(
name|isBracing
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
comment|/* 		 * if (s.length() == 0) return s; // Protect against ArrayIndexOutOf.... 		 * StringBuffer buf = new StringBuffer(); 		 *  		 * Matcher mcr = titleCapitalPattern.matcher(s.substring(1)); while 		 * (mcr.find()) { String replaceStr = mcr.group(); 		 * mcr.appendReplacement(buf, "{" + replaceStr + "}"); } 		 * mcr.appendTail(buf); return s.substring(0, 1) + buf.toString(); 		 */
block|}
DECL|field|bracedTitleCapitalPattern
specifier|static
name|Pattern
name|bracedTitleCapitalPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\{[A-Z]+\\}"
argument_list|)
decl_stmt|;
comment|/** 	 * This method looks for occurences of capital letters enclosed in an 	 * arbitrary number of pairs of braces, e.g. "{AB}" or "{{T}}". All of these 	 * pairs of braces are removed. 	 *  	 * @param s 	 *            The String to analyze. 	 * @return A new String with braces removed. 	 */
DECL|method|removeBracesAroundCapitals (String s)
specifier|public
specifier|static
name|String
name|removeBracesAroundCapitals
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|String
name|previous
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|removeSingleBracesAroundCapitals
argument_list|(
name|s
argument_list|)
operator|)
operator|.
name|length
argument_list|()
operator|<
name|previous
operator|.
name|length
argument_list|()
condition|)
block|{
name|previous
operator|=
name|s
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/** 	 * This method looks for occurences of capital letters enclosed in one pair 	 * of braces, e.g. "{AB}". All these are replaced by only the capitals in 	 * between the braces. 	 *  	 * @param s 	 *            The String to analyze. 	 * @return A new String with braces removed. 	 */
DECL|method|removeSingleBracesAroundCapitals (String s)
specifier|public
specifier|static
name|String
name|removeSingleBracesAroundCapitals
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|Matcher
name|mcr
init|=
name|bracedTitleCapitalPattern
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
name|mcr
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|replaceStr
init|=
name|mcr
operator|.
name|group
argument_list|()
decl_stmt|;
name|mcr
operator|.
name|appendReplacement
argument_list|(
name|buf
argument_list|,
name|replaceStr
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|replaceStr
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mcr
operator|.
name|appendTail
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** 	 * This method looks up what kind of external binding is used for the given 	 * field, and constructs on OpenFileFilter suitable for browsing for an 	 * external file. 	 *  	 * @param fieldName 	 *            The BibTeX field in question. 	 * @return The file filter. 	 */
DECL|method|getFileFilterForField (String fieldName)
specifier|public
specifier|static
name|OpenFileFilter
name|getFileFilterForField
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|String
name|s
init|=
name|BibtexFields
operator|.
name|getFieldExtras
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
specifier|final
name|String
name|ext
init|=
literal|"."
operator|+
name|fieldName
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
specifier|final
name|OpenFileFilter
name|off
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"browseDocZip"
argument_list|)
condition|)
name|off
operator|=
operator|new
name|OpenFileFilter
argument_list|(
operator|new
name|String
index|[]
block|{
name|ext
block|,
name|ext
operator|+
literal|".gz"
block|,
name|ext
operator|+
literal|".bz2"
block|}
argument_list|)
expr_stmt|;
else|else
name|off
operator|=
operator|new
name|OpenFileFilter
argument_list|(
operator|new
name|String
index|[]
block|{
name|ext
block|}
argument_list|)
expr_stmt|;
return|return
name|off
return|;
block|}
comment|/** 	 * This method can be used to display a "rich" error dialog which offers the 	 * entire stack trace for an exception. 	 *  	 * @param parent 	 * @param e 	 */
DECL|method|showQuickErrorDialog (JFrame parent, String title, Exception e)
specifier|public
specifier|static
name|void
name|showQuickErrorDialog
parameter_list|(
name|JFrame
name|parent
parameter_list|,
name|String
name|title
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
comment|// create and configure a text area - fill it with exception text.
specifier|final
name|JPanel
name|pan
init|=
operator|new
name|JPanel
argument_list|()
decl_stmt|,
name|details
init|=
operator|new
name|JPanel
argument_list|()
decl_stmt|;
specifier|final
name|CardLayout
name|crd
init|=
operator|new
name|CardLayout
argument_list|()
decl_stmt|;
name|pan
operator|.
name|setLayout
argument_list|(
name|crd
argument_list|)
expr_stmt|;
specifier|final
name|JTextArea
name|textArea
init|=
operator|new
name|JTextArea
argument_list|()
decl_stmt|;
name|textArea
operator|.
name|setFont
argument_list|(
operator|new
name|Font
argument_list|(
literal|"Sans-Serif"
argument_list|,
name|Font
operator|.
name|PLAIN
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|textArea
operator|.
name|setEditable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|StringWriter
name|writer
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|(
operator|new
name|PrintWriter
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
name|textArea
operator|.
name|setText
argument_list|(
name|writer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|JLabel
name|lab
init|=
operator|new
name|JLabel
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
name|JButton
name|flip
init|=
operator|new
name|JButton
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Details"
argument_list|)
argument_list|)
decl_stmt|;
name|FormLayout
name|layout
init|=
operator|new
name|FormLayout
argument_list|(
literal|"left:pref"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|DefaultFormBuilder
name|builder
init|=
operator|new
name|DefaultFormBuilder
argument_list|(
name|layout
argument_list|)
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|builder
operator|.
name|nextLine
argument_list|()
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|Box
operator|.
name|createVerticalGlue
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|nextLine
argument_list|()
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|flip
argument_list|)
expr_stmt|;
specifier|final
name|JPanel
name|simple
init|=
name|builder
operator|.
name|getPanel
argument_list|()
decl_stmt|;
comment|// stuff it in a scrollpane with a controlled size.
name|JScrollPane
name|scrollPane
init|=
operator|new
name|JScrollPane
argument_list|(
name|textArea
argument_list|)
decl_stmt|;
name|scrollPane
operator|.
name|setPreferredSize
argument_list|(
operator|new
name|Dimension
argument_list|(
literal|350
argument_list|,
literal|150
argument_list|)
argument_list|)
expr_stmt|;
name|details
operator|.
name|setLayout
argument_list|(
operator|new
name|BorderLayout
argument_list|()
argument_list|)
expr_stmt|;
name|details
operator|.
name|add
argument_list|(
name|scrollPane
argument_list|,
name|BorderLayout
operator|.
name|CENTER
argument_list|)
expr_stmt|;
name|flip
operator|.
name|addActionListener
argument_list|(
operator|new
name|ActionListener
argument_list|()
block|{
specifier|public
name|void
name|actionPerformed
parameter_list|(
name|ActionEvent
name|event
parameter_list|)
block|{
name|crd
operator|.
name|show
argument_list|(
name|pan
argument_list|,
literal|"details"
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|pan
operator|.
name|add
argument_list|(
name|simple
argument_list|,
literal|"simple"
argument_list|)
expr_stmt|;
name|pan
operator|.
name|add
argument_list|(
name|details
argument_list|,
literal|"details"
argument_list|)
expr_stmt|;
comment|// pass the scrollpane to the joptionpane.
name|JOptionPane
operator|.
name|showMessageDialog
argument_list|(
name|parent
argument_list|,
name|pan
argument_list|,
name|title
argument_list|,
name|JOptionPane
operator|.
name|ERROR_MESSAGE
argument_list|)
expr_stmt|;
block|}
DECL|method|wrapHTML (String s, final int lineWidth)
specifier|public
specifier|static
name|String
name|wrapHTML
parameter_list|(
name|String
name|s
parameter_list|,
specifier|final
name|int
name|lineWidth
parameter_list|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|StringTokenizer
name|tok
init|=
operator|new
name|StringTokenizer
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|charsLeft
init|=
name|lineWidth
decl_stmt|;
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|word
init|=
name|tok
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|charsLeft
operator|==
name|lineWidth
condition|)
block|{
comment|// fresh line
name|sb
operator|.
name|append
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|charsLeft
operator|-=
name|word
operator|.
name|length
argument_list|()
expr_stmt|;
if|if
condition|(
name|charsLeft
operator|<=
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"<br>\n"
argument_list|)
expr_stmt|;
name|charsLeft
operator|=
name|lineWidth
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// continue previous line
if|if
condition|(
name|charsLeft
operator|<
name|word
operator|.
name|length
argument_list|()
operator|+
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"<br>\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|word
operator|.
name|length
argument_list|()
operator|>=
name|lineWidth
operator|-
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"<br>\n"
argument_list|)
expr_stmt|;
name|charsLeft
operator|=
name|lineWidth
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|charsLeft
operator|=
name|lineWidth
operator|-
name|word
operator|.
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
operator|.
name|append
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|charsLeft
operator|-=
name|word
operator|.
name|length
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** 	 * Creates a String containing the current date (and possibly time), 	 * formatted according to the format set in preferences under the key 	 * "timeStampFormat". 	 *  	 * @return The date string. 	 */
DECL|method|easyDateFormat ()
specifier|public
specifier|static
name|String
name|easyDateFormat
parameter_list|()
block|{
comment|// Date today = new Date();
return|return
name|easyDateFormat
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
return|;
block|}
comment|/** 	 * Creates a readable Date string from the parameter date. The format is set 	 * in preferences under the key "timeStampFormat". 	 *  	 * @return The formatted date string. 	 */
DECL|method|easyDateFormat (Date date)
specifier|public
specifier|static
name|String
name|easyDateFormat
parameter_list|(
name|Date
name|date
parameter_list|)
block|{
comment|// first use, create an instance
if|if
condition|(
name|dateFormatter
operator|==
literal|null
condition|)
block|{
name|String
name|format
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"timeStampFormat"
argument_list|)
decl_stmt|;
name|dateFormatter
operator|=
operator|new
name|SimpleDateFormat
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
return|return
name|dateFormatter
operator|.
name|format
argument_list|(
name|date
argument_list|)
return|;
block|}
DECL|method|markEntry (BibtexEntry be, NamedCompound ce)
specifier|public
specifier|static
name|void
name|markEntry
parameter_list|(
name|BibtexEntry
name|be
parameter_list|,
name|NamedCompound
name|ce
parameter_list|)
block|{
name|Object
name|o
init|=
name|be
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|MARKED
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|o
operator|.
name|toString
argument_list|()
operator|.
name|indexOf
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|WRAPPED_USERNAME
argument_list|)
operator|>=
literal|0
operator|)
condition|)
return|return;
name|String
name|newValue
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
name|newValue
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|WRAPPED_USERNAME
expr_stmt|;
block|}
else|else
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
comment|// sb.append(' ');
name|sb
operator|.
name|append
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|WRAPPED_USERNAME
argument_list|)
expr_stmt|;
name|newValue
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|be
argument_list|,
name|BibtexFields
operator|.
name|MARKED
argument_list|,
name|be
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|MARKED
argument_list|)
argument_list|,
name|newValue
argument_list|)
argument_list|)
expr_stmt|;
name|be
operator|.
name|setField
argument_list|(
name|BibtexFields
operator|.
name|MARKED
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
block|}
DECL|method|unmarkEntry (BibtexEntry be, BibtexDatabase database, NamedCompound ce)
specifier|public
specifier|static
name|void
name|unmarkEntry
parameter_list|(
name|BibtexEntry
name|be
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|,
name|NamedCompound
name|ce
parameter_list|)
block|{
name|Object
name|o
init|=
name|be
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|MARKED
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|String
name|s
init|=
name|o
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"0"
argument_list|)
condition|)
block|{
name|unmarkOldStyle
argument_list|(
name|be
argument_list|,
name|database
argument_list|,
name|ce
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|piv
init|=
literal|0
decl_stmt|,
name|hit
decl_stmt|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|hit
operator|=
name|s
operator|.
name|indexOf
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|WRAPPED_USERNAME
argument_list|,
name|piv
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|hit
operator|>
literal|0
condition|)
name|sb
operator|.
name|append
argument_list|(
name|s
operator|.
name|substring
argument_list|(
name|piv
argument_list|,
name|hit
argument_list|)
argument_list|)
expr_stmt|;
name|piv
operator|=
name|hit
operator|+
name|Globals
operator|.
name|prefs
operator|.
name|WRAPPED_USERNAME
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|piv
operator|<
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|s
operator|.
name|substring
argument_list|(
name|piv
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|newVal
init|=
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|?
name|sb
operator|.
name|toString
argument_list|()
else|:
literal|null
decl_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|be
argument_list|,
name|BibtexFields
operator|.
name|MARKED
argument_list|,
name|be
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|MARKED
argument_list|)
argument_list|,
name|newVal
argument_list|)
argument_list|)
expr_stmt|;
name|be
operator|.
name|setField
argument_list|(
name|BibtexFields
operator|.
name|MARKED
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * An entry is marked with a "0", not in the new style with user names. We 	 * want to unmark it as transparently as possible. Since this shouldn't 	 * happen too often, we do it by scanning the "owner" fields of the entire 	 * database, collecting all user names. We then mark the entry for all users 	 * except the current one. Thus only the user who unmarks will see that it 	 * is unmarked, and we get rid of the old-style marking. 	 *  	 * @param be 	 * @param ce 	 */
DECL|method|unmarkOldStyle (BibtexEntry be, BibtexDatabase database, NamedCompound ce)
specifier|private
specifier|static
name|void
name|unmarkOldStyle
parameter_list|(
name|BibtexEntry
name|be
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|,
name|NamedCompound
name|ce
parameter_list|)
block|{
name|TreeSet
name|owners
init|=
operator|new
name|TreeSet
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|database
operator|.
name|getEntries
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BibtexEntry
name|entry
init|=
operator|(
name|BibtexEntry
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Object
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|OWNER
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
name|owners
operator|.
name|add
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|// System.out.println("Owner: "+entry.getField(Globals.OWNER));
block|}
name|owners
operator|.
name|remove
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"defaultOwner"
argument_list|)
argument_list|)
expr_stmt|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|owners
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|i
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|String
name|newVal
init|=
name|sb
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|newVal
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
name|newVal
operator|=
literal|null
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|be
argument_list|,
name|BibtexFields
operator|.
name|MARKED
argument_list|,
name|be
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|MARKED
argument_list|)
argument_list|,
name|newVal
argument_list|)
argument_list|)
expr_stmt|;
name|be
operator|.
name|setField
argument_list|(
name|BibtexFields
operator|.
name|MARKED
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
block|}
DECL|method|isMarked (BibtexEntry be)
specifier|public
specifier|static
name|boolean
name|isMarked
parameter_list|(
name|BibtexEntry
name|be
parameter_list|)
block|{
name|Object
name|fieldVal
init|=
name|be
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|MARKED
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldVal
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|String
name|s
init|=
operator|(
name|String
operator|)
name|fieldVal
decl_stmt|;
return|return
operator|(
name|s
operator|.
name|equals
argument_list|(
literal|"0"
argument_list|)
operator|||
operator|(
name|s
operator|.
name|indexOf
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|WRAPPED_USERNAME
argument_list|)
operator|>=
literal|0
operator|)
operator|)
return|;
block|}
comment|/** 	 * Set a given field to a given value for all entries in a Collection. This 	 * method DOES NOT update any UndoManager, but returns a relevant 	 * CompoundEdit that should be registered by the caller. 	 *  	 * @param entries 	 *            The entries to set the field for. 	 * @param field 	 *            The name of the field to set. 	 * @param text 	 *            The value to set. This value can be null, indicating that the 	 *            field should be cleared. 	 * @param overwriteValues 	 *            Indicate whether the value should be set even if an entry 	 *            already has the field set. 	 * @return A CompoundEdit for the entire operation. 	 */
DECL|method|massSetField (Collection entries, String field, String text, boolean overwriteValues)
specifier|public
specifier|static
name|UndoableEdit
name|massSetField
parameter_list|(
name|Collection
name|entries
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|text
parameter_list|,
name|boolean
name|overwriteValues
parameter_list|)
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Set field"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|entries
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BibtexEntry
name|entry
init|=
operator|(
name|BibtexEntry
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Object
name|oldVal
init|=
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|// If we are not allowed to overwrite values, check if there is a
comment|// nonempty
comment|// value already for this entry:
if|if
condition|(
operator|!
name|overwriteValues
operator|&&
operator|(
name|oldVal
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|(
operator|(
name|String
operator|)
name|oldVal
operator|)
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|text
operator|!=
literal|null
condition|)
name|entry
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|text
argument_list|)
expr_stmt|;
else|else
name|entry
operator|.
name|clearField
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|field
argument_list|,
name|oldVal
argument_list|,
name|text
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
return|return
name|ce
return|;
block|}
comment|/** 	 * Make a list of supported character encodings that can encode all 	 * characters in the given String. 	 *  	 * @param characters 	 *            A String of characters that should be supported by the 	 *            encodings. 	 * @return A List of character encodings 	 */
DECL|method|findEncodingsForString (String characters)
specifier|public
specifier|static
name|List
name|findEncodingsForString
parameter_list|(
name|String
name|characters
parameter_list|)
block|{
name|List
name|encodings
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Globals
operator|.
name|ENCODINGS
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|CharsetEncoder
name|encoder
init|=
name|Charset
operator|.
name|forName
argument_list|(
name|Globals
operator|.
name|ENCODINGS
index|[
name|i
index|]
argument_list|)
operator|.
name|newEncoder
argument_list|()
decl_stmt|;
if|if
condition|(
name|encoder
operator|.
name|canEncode
argument_list|(
name|characters
argument_list|)
condition|)
name|encodings
operator|.
name|add
argument_list|(
name|Globals
operator|.
name|ENCODINGS
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|encodings
return|;
block|}
comment|/** 	 * Will convert a two digit year using the following scheme (describe at 	 * http://www.filemaker.com/help/02-Adding%20and%20view18.html): 	 *  	 * If a two digit year is encountered they are matched against the last 69 	 * years and future 30 years. 	 *  	 * For instance if it is the year 1992 then entering 23 is taken to be 1923 	 * but if you enter 23 in 1993 then it will evaluate to 2023. 	 *  	 * @param year 	 *            The year to convert to 4 digits. 	 * @return 	 */
DECL|method|toFourDigitYear (String year)
specifier|public
specifier|static
name|String
name|toFourDigitYear
parameter_list|(
name|String
name|year
parameter_list|)
block|{
if|if
condition|(
name|thisYear
operator|==
literal|0
condition|)
block|{
name|thisYear
operator|=
name|Calendar
operator|.
name|getInstance
argument_list|()
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
expr_stmt|;
block|}
return|return
name|toFourDigitYear
argument_list|(
name|year
argument_list|,
name|thisYear
argument_list|)
return|;
block|}
DECL|field|thisYear
specifier|public
specifier|static
name|int
name|thisYear
decl_stmt|;
comment|/** 	 * Will convert a two digit year using the following scheme (describe at 	 * http://www.filemaker.com/help/02-Adding%20and%20view18.html): 	 *  	 * If a two digit year is encountered they are matched against the last 69 	 * years and future 30 years. 	 *  	 * For instance if it is the year 1992 then entering 23 is taken to be 1923 	 * but if you enter 23 in 1993 then it will evaluate to 2023. 	 *  	 * @param year 	 *            The year to convert to 4 digits. 	 * @return 	 */
DECL|method|toFourDigitYear (String year, int thisYear)
specifier|public
specifier|static
name|String
name|toFourDigitYear
parameter_list|(
name|String
name|year
parameter_list|,
name|int
name|thisYear
parameter_list|)
block|{
if|if
condition|(
name|year
operator|.
name|length
argument_list|()
operator|!=
literal|2
condition|)
return|return
name|year
return|;
try|try
block|{
name|int
name|thisYearTwoDigits
init|=
name|thisYear
operator|%
literal|100
decl_stmt|;
name|int
name|thisCentury
init|=
name|thisYear
operator|-
name|thisYearTwoDigits
decl_stmt|;
name|int
name|yearNumber
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|year
argument_list|)
decl_stmt|;
if|if
condition|(
name|yearNumber
operator|==
name|thisYearTwoDigits
condition|)
block|{
return|return
name|String
operator|.
name|valueOf
argument_list|(
name|thisYear
argument_list|)
return|;
block|}
comment|// 20 , 90
comment|// 99> 30
if|if
condition|(
operator|(
name|yearNumber
operator|+
literal|100
operator|-
name|thisYearTwoDigits
operator|)
operator|%
literal|100
operator|>
literal|30
condition|)
block|{
if|if
condition|(
name|yearNumber
operator|<
name|thisYearTwoDigits
condition|)
block|{
return|return
name|String
operator|.
name|valueOf
argument_list|(
name|thisCentury
operator|+
name|yearNumber
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|String
operator|.
name|valueOf
argument_list|(
name|thisCentury
operator|-
literal|100
operator|+
name|yearNumber
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|yearNumber
operator|<
name|thisYearTwoDigits
condition|)
block|{
return|return
name|String
operator|.
name|valueOf
argument_list|(
name|thisCentury
operator|+
literal|100
operator|+
name|yearNumber
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|String
operator|.
name|valueOf
argument_list|(
name|thisCentury
operator|+
name|yearNumber
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
return|return
name|year
return|;
block|}
block|}
comment|/** 	 * Will return an integer indicating the month of the entry from 0 to 11. 	 *  	 * -1 signals a unknown month string. 	 *  	 * This method accepts three types of months given: 	 *  - Single and Double Digit months from 1 to 12 (01 to 12) 	 *  - 3 Digit BibTex strings (jan, feb, mar...) 	 *  - Full English Month identifiers. 	 *  	 * @param month 	 * @return 	 */
DECL|method|getMonthNumber (String month)
specifier|public
specifier|static
name|int
name|getMonthNumber
parameter_list|(
name|String
name|month
parameter_list|)
block|{
name|month
operator|=
name|month
operator|.
name|replaceAll
argument_list|(
literal|"#"
argument_list|,
literal|""
argument_list|)
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Globals
operator|.
name|MONTHS
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|month
operator|.
name|startsWith
argument_list|(
name|Globals
operator|.
name|MONTHS
index|[
name|i
index|]
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
try|try
block|{
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|month
argument_list|)
operator|-
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{ 		}
return|return
operator|-
literal|1
return|;
block|}
block|}
end_class

end_unit

