begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2003 Nizar N. Batada, Morten O. Alver  All programs in this directory and subdirectories are published under the GNU General Public License as described below.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA  Further information about the GNU GPL is available at: http://www.gnu.org/copyleft/gpl.ja.html  */
end_comment

begin_package
DECL|package|net.sf.jabref
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|*
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|border
operator|.
name|Border
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|event
operator|.
name|*
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|plaf
operator|.
name|basic
operator|.
name|BasicTableUI
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|table
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|EntryTableTransferHandler
import|;
end_import

begin_class
DECL|class|EntryTable
specifier|public
class|class
name|EntryTable
extends|extends
name|JTable
block|{
DECL|field|PREFERRED_WIDTH
DECL|field|PREFERRED_HEIGHT
specifier|final
name|int
name|PREFERRED_WIDTH
init|=
literal|400
decl_stmt|,
name|PREFERRED_HEIGHT
init|=
literal|30
decl_stmt|;
comment|// We use a subclassed JScrollPane with setBorder() overridden as
comment|// a no-op. This is done to avoid the JTable setting its border,
comment|// which it does whether we want it or not. And we don't. :)
DECL|field|sp
name|JScrollPane
name|sp
init|=
operator|new
name|JScrollPane
argument_list|(
operator|(
name|JTable
operator|)
name|this
argument_list|)
block|{
specifier|public
name|void
name|setBorder
parameter_list|(
name|Border
name|b
parameter_list|)
block|{}
block|}
decl_stmt|;
DECL|field|rightClickMenu
name|JPopupMenu
name|rightClickMenu
init|=
literal|null
decl_stmt|;
DECL|field|tableModel
name|EntryTableModel
name|tableModel
decl_stmt|;
DECL|field|prefs
name|JabRefPreferences
name|prefs
decl_stmt|;
DECL|field|showingSearchResults
specifier|protected
name|boolean
name|showingSearchResults
init|=
literal|false
decl_stmt|,
DECL|field|showingGroup
name|showingGroup
init|=
literal|false
decl_stmt|;
DECL|field|antialiasing
specifier|private
name|boolean
name|antialiasing
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"antialias"
argument_list|)
decl_stmt|,
DECL|field|ctrlClick
name|ctrlClick
init|=
literal|false
decl_stmt|,
DECL|field|selectionListenerOn
name|selectionListenerOn
init|=
literal|true
decl_stmt|,
DECL|field|tableColorCodes
name|tableColorCodes
init|=
literal|true
decl_stmt|;
comment|//RenderingHints renderingHints;
DECL|field|panel
specifier|private
name|BasePanel
name|panel
decl_stmt|;
DECL|field|lastSelection
name|Set
name|lastSelection
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
DECL|field|previewListener
specifier|private
name|ListSelectionListener
name|previewListener
init|=
literal|null
decl_stmt|;
DECL|field|activeRow
specifier|private
name|int
name|activeRow
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|groupsHighlightListener
name|ListSelectionListener
name|groupsHighlightListener
decl_stmt|;
DECL|method|EntryTable (EntryTableModel tm_, BasePanel panel_, JabRefPreferences prefs_)
specifier|public
name|EntryTable
parameter_list|(
name|EntryTableModel
name|tm_
parameter_list|,
name|BasePanel
name|panel_
parameter_list|,
name|JabRefPreferences
name|prefs_
parameter_list|)
block|{
name|super
argument_list|(
name|tm_
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableModel
operator|=
name|tm_
expr_stmt|;
name|setBorder
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|panel
operator|=
name|panel_
expr_stmt|;
comment|// Add the global focus listener, so a menu item can see if this table was focused when
comment|// an action was called.
name|addFocusListener
argument_list|(
name|Globals
operator|.
name|focusListener
argument_list|)
expr_stmt|;
comment|// enable DnD
name|setDragEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// The following line is commented because EntryTableTransferHandler's
comment|// constructor now only accepts MainTable which has replaced EntryTable.
comment|// setTransferHandler(new EntryTableTransferHandler(this));
comment|//renderingHints = g2.getRenderingHints();
comment|//renderingHints.put(RenderingHints.KEY_ANTIALIASING,
comment|//		   RenderingHints.VALUE_ANTIALIAS_ON);
comment|//renderingHints.put(RenderingHints.KEY_RENDERING,
comment|//		   RenderingHints.VALUE_RENDER_QUALITY);
name|prefs
operator|=
name|prefs_
expr_stmt|;
comment|//antialiasing =
comment|//System.out.println(antialiasing);
name|ctrlClick
operator|=
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"ctrlClick"
argument_list|)
expr_stmt|;
name|tableColorCodes
operator|=
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"tableColorCodesOn"
argument_list|)
expr_stmt|;
name|getTableHeader
argument_list|()
operator|.
name|setReorderingAllowed
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// To prevent color bugs. Must be fixed.
name|setGridColor
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|getColor
argument_list|(
literal|"gridColor"
argument_list|)
argument_list|)
expr_stmt|;
name|setShowVerticalLines
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setShowHorizontalLines
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|//setColumnSelectionAllowed(true);
name|setColumnSelectionAllowed
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|setRowSelectionAllowed
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setAutoResizeMode
argument_list|(
name|prefs
operator|.
name|getInt
argument_list|(
literal|"autoResizeMode"
argument_list|)
argument_list|)
expr_stmt|;
name|DefaultCellEditor
name|dce
init|=
operator|new
name|DefaultCellEditor
argument_list|(
operator|new
name|JTextField
argument_list|()
argument_list|)
decl_stmt|;
name|dce
operator|.
name|setClickCountToStart
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|setDefaultEditor
argument_list|(
name|String
operator|.
name|class
argument_list|,
name|dce
argument_list|)
expr_stmt|;
name|getTableHeader
argument_list|()
operator|.
name|addMouseListener
argument_list|(
operator|new
name|MouseAdapter
argument_list|()
block|{
specifier|public
name|void
name|mouseClicked
parameter_list|(
name|MouseEvent
name|e
parameter_list|)
block|{
name|int
name|col
init|=
name|getTableHeader
argument_list|()
operator|.
name|columnAtPoint
argument_list|(
name|e
operator|.
name|getPoint
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|col
operator|>=
literal|1
condition|)
block|{
comment|//tableModel.padleft) { // A valid column, but not the first.
name|String
name|s
init|=
name|tableModel
operator|.
name|getFieldName
argument_list|(
name|col
argument_list|)
decl_stmt|;
comment|/*                * If the user adjusts the header size the sort event is                * always triggered.                * To avoid this behaviour we check if the mouse is                * inside the label's bounds and has a certain distance (offset)                * to the label border.                *                * Sascha Hunold<hunoldinho@users.sourceforge.net>                */
name|Point
name|p
init|=
name|e
operator|.
name|getPoint
argument_list|()
decl_stmt|;
name|int
name|colindex
init|=
name|getTableHeader
argument_list|()
operator|.
name|columnAtPoint
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|colindex
operator|>=
literal|0
condition|)
block|{
specifier|final
name|int
name|initoffset
init|=
literal|3
decl_stmt|;
name|int
name|xoffset
init|=
name|initoffset
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colindex
condition|;
name|i
operator|++
control|)
block|{
name|xoffset
operator|+=
name|getColumnModel
argument_list|()
operator|.
name|getColumn
argument_list|(
name|i
argument_list|)
operator|.
name|getWidth
argument_list|()
expr_stmt|;
block|}
name|TableColumn
name|column
init|=
name|getColumnModel
argument_list|()
operator|.
name|getColumn
argument_list|(
name|col
argument_list|)
decl_stmt|;
name|int
name|cw
init|=
name|column
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|int
name|ch
init|=
name|getTableHeader
argument_list|()
operator|.
name|getHeight
argument_list|()
decl_stmt|;
name|Rectangle
name|r
init|=
operator|new
name|Rectangle
argument_list|()
decl_stmt|;
name|r
operator|.
name|setBounds
argument_list|(
name|xoffset
argument_list|,
literal|0
comment|/*offset*/
argument_list|,
name|cw
operator|-
literal|2
operator|*
name|initoffset
argument_list|,
name|ch
comment|/*-2*offset*/
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|contains
argument_list|(
name|p
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|s
operator|.
name|equals
argument_list|(
name|prefs
operator|.
name|get
argument_list|(
literal|"priSort"
argument_list|)
argument_list|)
condition|)
block|{
name|prefs
operator|.
name|put
argument_list|(
literal|"priSort"
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|// Now, if the selected column is an icon column, set the sort to binary mode,
comment|// meaning that it only separates set fields from empty fields, and does no
comment|// internal sorting of set fields:
if|if
condition|(
name|tableModel
operator|.
name|getIconTypeForColumn
argument_list|(
name|col
argument_list|)
operator|==
literal|null
condition|)
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"priBinary"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
else|else
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"priBinary"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// ... or change sort direction
else|else
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"priDescending"
argument_list|,
operator|!
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"priDescending"
argument_list|)
argument_list|)
expr_stmt|;
name|tableModel
operator|.
name|remap
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|addMouseListener
argument_list|(
operator|new
name|TableClickListener
argument_list|()
argument_list|)
expr_stmt|;
comment|// Add the listener that responds to clicks on the table.
comment|// Trying this to get better handling of the row selection stuff.
name|setSelectionModel
argument_list|(
operator|new
name|javax
operator|.
name|swing
operator|.
name|DefaultListSelectionModel
argument_list|()
block|{
specifier|public
name|void
name|setSelectionInterval
parameter_list|(
name|int
name|index0
parameter_list|,
name|int
name|index1
parameter_list|)
block|{
comment|// Prompt user here
comment|//Util.pr("Selection model: "+panel.entryEditorAllowsChange());
if|if
condition|(
name|panel
operator|.
name|entryEditorAllowsChange
argument_list|()
operator|==
literal|false
condition|)
block|{
name|panel
operator|.
name|moveFocusToEntryEditor
argument_list|()
expr_stmt|;
return|return;
block|}
name|super
operator|.
name|setSelectionInterval
argument_list|(
name|index0
argument_list|,
name|index1
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|addSelectionListener
argument_list|()
expr_stmt|;
comment|// Add the listener that responds to new entry selection.
name|groupsHighlightListener
operator|=
operator|new
name|ListSelectionListener
argument_list|()
block|{
specifier|public
name|void
name|valueChanged
parameter_list|(
name|ListSelectionEvent
name|e
parameter_list|)
block|{
comment|/*                 if (Globals.prefs.getBoolean("highlightGroupsMatchingAny"))                     panel.getGroupSelector().showMatchingGroups(                             panel.getSelectedEntries(), false);                 else if (Globals.prefs.getBoolean("highlightGroupsMatchingAll"))                     panel.getGroupSelector().showMatchingGroups(                             panel.getSelectedEntries(), true);                 else // no highlight                     panel.getGroupSelector().showMatchingGroups(null, true);                     */
block|}
block|}
expr_stmt|;
name|getSelectionModel
argument_list|()
operator|.
name|addListSelectionListener
argument_list|(
name|groupsHighlightListener
argument_list|)
expr_stmt|;
comment|// (to update entry editor or preview)
name|setWidths
argument_list|()
expr_stmt|;
name|sp
operator|.
name|getViewport
argument_list|()
operator|.
name|setBackground
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|getColor
argument_list|(
literal|"tableBackground"
argument_list|)
argument_list|)
expr_stmt|;
name|updateFont
argument_list|()
expr_stmt|;
block|}
comment|/**      * Get the row number for the row that is active, in the sense that the preview or      * entry editor should show the corresponding entry.      * @return The active row number, or -1 if no row is active.      */
DECL|method|getActiveRow ()
specifier|public
name|int
name|getActiveRow
parameter_list|()
block|{
return|return
name|activeRow
return|;
block|}
comment|/**      * Get the active entry, in the sense that the preview or entry editor should      * show it.      * @return The active entry, or null if no row is active.      */
DECL|method|getActiveEntry ()
specifier|public
name|BibtexEntry
name|getActiveEntry
parameter_list|()
block|{
comment|//System.out.println("EntryTable.getActiveEntry: "+activeRow);
return|return
operator|(
operator|(
name|activeRow
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|activeRow
operator|<
name|getRowCount
argument_list|()
operator|)
operator|)
condition|?
name|tableModel
operator|.
name|getEntryForRow
argument_list|(
name|activeRow
argument_list|)
else|:
literal|null
return|;
block|}
comment|/**      * Updates our Set containing the last row selection. Ckecks which rows were ADDED      * to the selection, to see what new entry should be previewed.      * Returns the number of the row that should be considered active, or -1 if none.      *      * This method may have some potential for optimization.      *      * @param rows      * @return      */
DECL|method|resolveNewSelection (int[] rows)
specifier|private
name|int
name|resolveNewSelection
parameter_list|(
name|int
index|[]
name|rows
parameter_list|)
block|{
name|HashSet
name|newSel
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rows
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Integer
name|row
init|=
operator|new
name|Integer
argument_list|(
name|rows
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|newSel
operator|.
name|add
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
comment|// Store a clone of this Set:
name|HashSet
name|tmp
init|=
operator|new
name|HashSet
argument_list|(
name|newSel
argument_list|)
decl_stmt|;
name|newSel
operator|.
name|removeAll
argument_list|(
name|lastSelection
argument_list|)
expr_stmt|;
comment|// Set the new selection as the last:
name|lastSelection
operator|=
name|tmp
expr_stmt|;
comment|// We return an appropriate row number if a single additional entry was selected:
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|newSel
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
name|result
operator|=
operator|(
operator|(
name|Integer
operator|)
name|newSel
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
comment|// .. or if the current selection is only one entry:
if|if
condition|(
operator|(
name|result
operator|<
literal|0
operator|)
operator|&&
operator|(
name|rows
operator|.
name|length
operator|==
literal|1
operator|)
condition|)
name|result
operator|=
name|rows
index|[
literal|0
index|]
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**        * A ListSelectionListener for updating the preview panel when the user selects an        * entry. Should only be active when preview is enabled.        */
DECL|method|addSelectionListener ()
specifier|public
name|void
name|addSelectionListener
parameter_list|()
block|{
if|if
condition|(
name|previewListener
operator|==
literal|null
condition|)
name|previewListener
operator|=
operator|new
name|ListSelectionListener
argument_list|()
block|{
specifier|public
name|void
name|valueChanged
parameter_list|(
specifier|final
name|ListSelectionEvent
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|selectionListenerOn
condition|)
return|return;
if|if
condition|(
operator|!
name|e
operator|.
name|getValueIsAdjusting
argument_list|()
condition|)
block|{
comment|// We must use invokeLater() to postpone the updating. This is because of
comment|// the situation where an EntryEditor has changes in one of the FieldEditors
comment|// that need to be stored. This storage is initiated by a focusLost() call,
comment|// and results in a call to refreshTable() in BasePanel, which messes
comment|// with the table selection. After that chain has finished, the selection
comment|// will have been reset correctly, so we make sure everything is ok by
comment|// putting the updating based on table selection behind it in the event queue.
name|SwingUtilities
operator|.
name|invokeLater
argument_list|(
operator|new
name|Thread
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// If a single new row was selected, set it as the active row:
name|activeRow
operator|=
name|resolveNewSelection
argument_list|(
name|getSelectedRows
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|getSelectedRowCount
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|//int row = getSelectedRow(); //e.getFirstIndex();
comment|//if (row>= 0) {
comment|// Update the value for which entry is shown:
comment|//  activeRow = row;
comment|//panel.updateViewToSelected();
comment|// guarantee that the the entry is visible
name|ensureVisible
argument_list|(
name|activeRow
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* With a multiple selection, there are three alternative behaviours:                                      1. Disable the entry editor. Do not update it.                                      2. Do not disable the entry editor, and do not update it.                                      3. Update the entry editor, and keep it enabled.                                       We currently implement 1 and 2, and choose between them based on                                      prefs.getBoolean("disableOnMultipleSelection");                                   */
if|if
condition|(
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"disableOnMultipleSelection"
argument_list|)
condition|)
block|{
comment|// 1.
name|panel
operator|.
name|setEntryEditorEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// We want the entry preview to update when the user expands the
comment|// selection one entry at a time:
comment|//if ((e.getLastIndex()-e.getFirstIndex())<= 1) {
comment|//if (activeRow>= 0)
comment|//panel.updateViewToSelected();
comment|//}
comment|// 2. Do nothing.
block|}
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"highlightGroupsMatchingAny"
argument_list|)
condition|)
name|panel
operator|.
name|getGroupSelector
argument_list|()
operator|.
name|showMatchingGroups
argument_list|(
name|panel
operator|.
name|getSelectedEntries
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"highlightGroupsMatchingAll"
argument_list|)
condition|)
name|panel
operator|.
name|getGroupSelector
argument_list|()
operator|.
name|showMatchingGroups
argument_list|(
name|panel
operator|.
name|getSelectedEntries
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
else|else
comment|// no highlight
name|panel
operator|.
name|getGroupSelector
argument_list|()
operator|.
name|showMatchingGroups
argument_list|(
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
expr_stmt|;
name|getSelectionModel
argument_list|()
operator|.
name|addListSelectionListener
argument_list|(
name|previewListener
argument_list|)
expr_stmt|;
block|}
comment|/**        * Remove the preview listener.        */
DECL|method|disablePreviewListener ()
specifier|public
name|void
name|disablePreviewListener
parameter_list|()
block|{
name|getSelectionModel
argument_list|()
operator|.
name|removeListSelectionListener
argument_list|(
name|previewListener
argument_list|)
expr_stmt|;
block|}
comment|/**        * This method overrides the superclass' to disable the selection listener while the        * row selection is adjusted.        */
DECL|method|setRowSelectionInterval (int row1, int row2)
specifier|public
name|void
name|setRowSelectionInterval
parameter_list|(
name|int
name|row1
parameter_list|,
name|int
name|row2
parameter_list|)
block|{
name|boolean
name|oldState
init|=
name|selectionListenerOn
decl_stmt|;
name|selectionListenerOn
operator|=
literal|false
expr_stmt|;
comment|// Introducing a try-catch here to maybe track down the preview update bug
comment|// that occurs sometimes (20050405 M. Alver):
try|try
block|{
name|super
operator|.
name|setRowSelectionInterval
argument_list|(
name|row1
argument_list|,
name|row2
argument_list|)
expr_stmt|;
name|activeRow
operator|=
name|resolveNewSelection
argument_list|(
name|getSelectedRows
argument_list|()
argument_list|)
expr_stmt|;
name|selectionListenerOn
operator|=
name|oldState
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Error occured. Trying to recover..."
argument_list|)
expr_stmt|;
comment|// Maybe try to remap the entry table:
name|tableModel
operator|.
name|remap
argument_list|()
expr_stmt|;
name|clearSelection
argument_list|()
expr_stmt|;
name|selectionListenerOn
operator|=
name|oldState
expr_stmt|;
block|}
block|}
DECL|method|addRowSelectionIntervalQuietly (int row1, int row2)
specifier|public
name|void
name|addRowSelectionIntervalQuietly
parameter_list|(
name|int
name|row1
parameter_list|,
name|int
name|row2
parameter_list|)
block|{
name|boolean
name|oldState
init|=
name|selectionListenerOn
decl_stmt|;
name|selectionListenerOn
operator|=
literal|false
expr_stmt|;
comment|//if (row2< getModel().getRowCount()) {
try|try
block|{
name|super
operator|.
name|addRowSelectionInterval
argument_list|(
name|row1
argument_list|,
name|row2
argument_list|)
expr_stmt|;
name|selectionListenerOn
operator|=
name|oldState
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Error occured. Trying to recover..."
argument_list|)
expr_stmt|;
comment|// Maybe try to remap the entry table:
name|tableModel
operator|.
name|remap
argument_list|()
expr_stmt|;
name|clearSelection
argument_list|()
expr_stmt|;
name|selectionListenerOn
operator|=
name|oldState
expr_stmt|;
block|}
block|}
comment|/*public boolean surrendersFocusOnKeystroke() {         return true;         }*/
comment|/**        * This method overrides the superclass' to disable the selection listener while the        * selection is cleared.        */
DECL|method|clearSelection ()
specifier|public
name|void
name|clearSelection
parameter_list|()
block|{
name|boolean
name|oldState
init|=
name|selectionListenerOn
decl_stmt|;
name|selectionListenerOn
operator|=
literal|false
expr_stmt|;
name|super
operator|.
name|clearSelection
argument_list|()
expr_stmt|;
name|selectionListenerOn
operator|=
name|oldState
expr_stmt|;
block|}
comment|/**        * Enables or disables the selectionlistener. Useful if the selection needs to be        * updated in several steps, without the table responding between each.        * @param enabled boolean        */
DECL|method|setSelectionListenerEnabled (boolean enabled)
specifier|public
name|void
name|setSelectionListenerEnabled
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
name|selectionListenerOn
operator|=
name|enabled
expr_stmt|;
block|}
comment|/**        * Turns off any cell editing going on.        */
DECL|method|assureNotEditing ()
specifier|protected
name|void
name|assureNotEditing
parameter_list|()
block|{
if|if
condition|(
name|isEditing
argument_list|()
condition|)
block|{
name|int
name|col
init|=
name|getEditingColumn
argument_list|()
decl_stmt|,
name|row
init|=
name|getEditingRow
argument_list|()
decl_stmt|;
name|getCellEditor
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
operator|.
name|stopCellEditing
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setWidths ()
specifier|public
name|void
name|setWidths
parameter_list|()
block|{
comment|// Setting column widths:
name|int
name|ncWidth
init|=
name|prefs
operator|.
name|getInt
argument_list|(
literal|"numberColWidth"
argument_list|)
decl_stmt|;
name|String
index|[]
name|widths
init|=
name|prefs
operator|.
name|getStringArray
argument_list|(
literal|"columnWidths"
argument_list|)
decl_stmt|;
name|TableColumnModel
name|cm
init|=
name|getColumnModel
argument_list|()
decl_stmt|;
name|cm
operator|.
name|getColumn
argument_list|(
literal|0
argument_list|)
operator|.
name|setPreferredWidth
argument_list|(
name|ncWidth
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|tableModel
operator|.
name|padleft
condition|;
name|i
operator|++
control|)
block|{
comment|// Lock the width of icon columns.
name|cm
operator|.
name|getColumn
argument_list|(
name|i
argument_list|)
operator|.
name|setPreferredWidth
argument_list|(
name|GUIGlobals
operator|.
name|WIDTH_ICON_COL
argument_list|)
expr_stmt|;
name|cm
operator|.
name|getColumn
argument_list|(
name|i
argument_list|)
operator|.
name|setMinWidth
argument_list|(
name|GUIGlobals
operator|.
name|WIDTH_ICON_COL
argument_list|)
expr_stmt|;
name|cm
operator|.
name|getColumn
argument_list|(
name|i
argument_list|)
operator|.
name|setMaxWidth
argument_list|(
name|GUIGlobals
operator|.
name|WIDTH_ICON_COL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|tableModel
operator|.
name|padleft
init|;
name|i
operator|<
name|getModel
argument_list|()
operator|.
name|getColumnCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|cm
operator|.
name|getColumn
argument_list|(
name|i
argument_list|)
operator|.
name|setPreferredWidth
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|widths
index|[
name|i
operator|-
name|tableModel
operator|.
name|padleft
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|Globals
operator|.
name|logger
argument_list|(
literal|"Exception while setting column widths. Choosing default."
argument_list|)
expr_stmt|;
name|cm
operator|.
name|getColumn
argument_list|(
name|i
argument_list|)
operator|.
name|setPreferredWidth
argument_list|(
name|GUIGlobals
operator|.
name|DEFAULT_FIELD_LENGTH
argument_list|)
expr_stmt|;
block|}
comment|//cm.getColumn(i).setPreferredWidth(GUIGlobals.getPreferredFieldLength(getModel().getColumnName(i)));
block|}
block|}
DECL|method|getPane ()
specifier|public
name|JScrollPane
name|getPane
parameter_list|()
block|{
return|return
name|sp
return|;
block|}
comment|/*public void setShowingSearchResults(boolean search,                                         boolean group) {         showingSearchResults = search;         showingGroup = group;     } */
DECL|method|setRightClickMenu (JPopupMenu rcm)
specifier|public
name|void
name|setRightClickMenu
parameter_list|(
name|JPopupMenu
name|rcm
parameter_list|)
block|{
name|rightClickMenu
operator|=
name|rcm
expr_stmt|;
block|}
comment|/**    * This class handles clicks on the EntryTable that should trigger specific    * events, like opening an entry editor, the context menu or a pdf file.    */
DECL|class|TableClickListener
class|class
name|TableClickListener
extends|extends
name|MouseAdapter
block|{
DECL|method|mouseReleased (MouseEvent e)
specifier|public
name|void
name|mouseReleased
parameter_list|(
name|MouseEvent
name|e
parameter_list|)
block|{
comment|// First find the column on which the user has clicked.
specifier|final
name|int
name|col
init|=
name|columnAtPoint
argument_list|(
name|e
operator|.
name|getPoint
argument_list|()
argument_list|)
decl_stmt|,
name|row
init|=
name|rowAtPoint
argument_list|(
name|e
operator|.
name|getPoint
argument_list|()
argument_list|)
decl_stmt|;
comment|// Check if the user has right-clicked. If so, open the right-click menu.
if|if
condition|(
name|e
operator|.
name|isPopupTrigger
argument_list|()
condition|)
block|{
name|processPopupTrigger
argument_list|(
name|e
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
DECL|method|processPopupTrigger (MouseEvent e, int row, int col)
specifier|protected
name|void
name|processPopupTrigger
parameter_list|(
name|MouseEvent
name|e
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|col
parameter_list|)
block|{
name|int
name|selRow
init|=
name|getSelectedRow
argument_list|()
decl_stmt|;
if|if
condition|(
name|selRow
operator|==
operator|-
literal|1
operator|||
comment|// (getSelectedRowCount() == 0))
operator|!
name|isRowSelected
argument_list|(
name|rowAtPoint
argument_list|(
name|e
operator|.
name|getPoint
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
name|setRowSelectionInterval
argument_list|(
name|row
argument_list|,
name|row
argument_list|)
expr_stmt|;
comment|//panel.updateViewToSelected();
block|}
name|rightClickMenu
operator|=
operator|new
name|RightClickMenu
argument_list|(
name|panel
argument_list|,
name|panel
operator|.
name|metaData
argument_list|)
expr_stmt|;
name|rightClickMenu
operator|.
name|show
argument_list|(
name|EntryTable
operator|.
name|this
argument_list|,
name|e
operator|.
name|getX
argument_list|()
argument_list|,
name|e
operator|.
name|getY
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|mousePressed (MouseEvent e)
specifier|public
name|void
name|mousePressed
parameter_list|(
name|MouseEvent
name|e
parameter_list|)
block|{
comment|// First find the column on which the user has clicked.
specifier|final
name|int
name|col
init|=
name|columnAtPoint
argument_list|(
name|e
operator|.
name|getPoint
argument_list|()
argument_list|)
decl_stmt|,
name|row
init|=
name|rowAtPoint
argument_list|(
name|e
operator|.
name|getPoint
argument_list|()
argument_list|)
decl_stmt|;
comment|// A double click on an entry should open the entry's editor.
if|if
condition|(
comment|/*(col == 0)*/
operator|!
name|isCellEditable
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
operator|&&
operator|(
name|e
operator|.
name|getClickCount
argument_list|()
operator|==
literal|2
operator|)
condition|)
block|{
try|try
block|{
name|panel
operator|.
name|runCommand
argument_list|(
literal|"edit"
argument_list|)
expr_stmt|;
return|return;
comment|/*showEntry(be);                      if (splitPane.getBottomComponent() != null) {                         new FocusRequester(splitPane.getBottomComponent());                     }                                                      */
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Check if the user has right-clicked. If so, open the right-click menu.
if|if
condition|(
name|e
operator|.
name|isPopupTrigger
argument_list|()
condition|)
block|{
name|processPopupTrigger
argument_list|(
name|e
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Check if the user has clicked on an icon cell to open url or pdf.
if|if
condition|(
name|tableModel
operator|.
name|getCellStatus
argument_list|(
literal|0
argument_list|,
name|col
argument_list|)
operator|==
name|EntryTableModel
operator|.
name|ICON_COL
condition|)
block|{
comment|// Get the row number also:
name|Object
name|value
init|=
name|getValueAt
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
return|return;
comment|// No icon here, so we do nothing.
comment|/*Util.pr("eouaeou");           JButton button = (JButton)value;            MouseEvent buttonEvent =               (MouseEvent)SwingUtilities.convertMouseEvent(ths, e, button);           button.dispatchEvent(buttonEvent);           // This is necessary so that when a button is pressed and released           // it gets rendered properly.  Otherwise, the button may still appear           // pressed down when it has been released.           ths.repaint();            */
comment|// Get the icon type. Corresponds to the field name.
specifier|final
name|String
index|[]
name|iconType
init|=
name|tableModel
operator|.
name|getIconTypeForColumn
argument_list|(
name|col
argument_list|)
decl_stmt|;
name|int
name|hasField
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|iconType
operator|.
name|length
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|tableModel
operator|.
name|hasField
argument_list|(
name|row
argument_list|,
name|iconType
index|[
name|i
index|]
argument_list|)
condition|)
name|hasField
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|hasField
operator|==
operator|-
literal|1
condition|)
return|return;
specifier|final
name|String
name|fieldName
init|=
name|iconType
index|[
name|hasField
index|]
decl_stmt|;
comment|// Open it now. We do this in a thread, so the program won't freeze during the wait.
operator|(
operator|new
name|Thread
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
name|panel
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"External viewer called"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|BibtexEntry
name|be
init|=
name|panel
operator|.
name|database
argument_list|()
operator|.
name|getEntryById
argument_list|(
name|tableModel
operator|.
name|getIdForRow
argument_list|(
name|row
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|be
operator|==
literal|null
condition|)
block|{
name|Globals
operator|.
name|logger
argument_list|(
literal|"Error: could not find entry."
argument_list|)
expr_stmt|;
return|return;
block|}
name|Object
name|link
init|=
name|be
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|iconType
operator|==
literal|null
condition|)
block|{
name|Globals
operator|.
name|logger
argument_list|(
literal|"Error: no link to "
operator|+
name|fieldName
operator|+
literal|"."
argument_list|)
expr_stmt|;
return|return;
comment|// There is an icon, but the field is not set.
block|}
try|try
block|{
name|Util
operator|.
name|openExternalViewer
argument_list|(
operator|(
name|String
operator|)
name|link
argument_list|,
name|fieldName
argument_list|,
name|prefs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|panel
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Error"
argument_list|)
operator|+
literal|": "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|)
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|getCellRenderer (int row, int column)
specifier|public
name|TableCellRenderer
name|getCellRenderer
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|)
block|{
comment|// This method asks the table model whether the given cell represents a
comment|// required or optional field, and returns the appropriate renderer.
name|int
name|score
init|=
operator|-
literal|3
decl_stmt|;
name|TableCellRenderer
name|renderer
decl_stmt|;
name|int
name|status
decl_stmt|;
try|try
block|{
comment|// This try clause is here to contain a bug.
name|status
operator|=
name|tableModel
operator|.
name|getCellStatus
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|ex
parameter_list|)
block|{
name|Globals
operator|.
name|logger
argument_list|(
literal|"Error happened in getCellRenderer method of EntryTable, for cell ("
operator|+
name|row
operator|+
literal|","
operator|+
name|column
operator|+
literal|")."
argument_list|)
expr_stmt|;
return|return
name|defRenderer
return|;
comment|// This should not occur.
block|}
if|if
condition|(
operator|!
name|panel
operator|.
name|coloringBySearchResults
operator|||
name|tableModel
operator|.
name|nonZeroField
argument_list|(
name|row
argument_list|,
name|Globals
operator|.
name|SEARCH
argument_list|)
condition|)
name|score
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|panel
operator|.
name|coloringByGroup
operator|||
name|tableModel
operator|.
name|nonZeroField
argument_list|(
name|row
argument_list|,
name|Globals
operator|.
name|GROUPSEARCH
argument_list|)
condition|)
name|score
operator|+=
literal|2
expr_stmt|;
comment|// Now, a grayed out renderer is for entries with -1, and
comment|// a very grayed out one for entries with -2
if|if
condition|(
name|score
operator|<
operator|-
literal|1
condition|)
name|renderer
operator|=
name|veryGrayedOutRenderer
expr_stmt|;
elseif|else
if|if
condition|(
name|score
operator|==
operator|-
literal|1
condition|)
name|renderer
operator|=
name|grayedOutRenderer
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|tableColorCodes
condition|)
name|renderer
operator|=
name|defRenderer
expr_stmt|;
elseif|else
if|if
condition|(
name|column
operator|==
literal|0
condition|)
block|{
comment|// Return a renderer with red background if the entry is incomplete.
name|renderer
operator|=
name|defRenderer
expr_stmt|;
if|if
condition|(
name|tableModel
operator|.
name|isComplete
argument_list|(
name|row
argument_list|)
condition|)
name|renderer
operator|=
name|defRenderer
expr_stmt|;
else|else
block|{
comment|//if (tableModel.hasCrossRef(row))
comment|//  renderer = maybeIncRenderer;
comment|//else
name|renderer
operator|=
name|incRenderer
expr_stmt|;
comment|//incompleteEntryRenderer;
block|}
comment|//return (tableModel.isComplete(row) ? defRenderer: incRenderer);
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|EntryTableModel
operator|.
name|REQUIRED
condition|)
name|renderer
operator|=
name|reqRenderer
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
name|EntryTableModel
operator|.
name|OPTIONAL
condition|)
name|renderer
operator|=
name|optRenderer
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
name|EntryTableModel
operator|.
name|BOOLEAN
condition|)
name|renderer
operator|=
name|getDefaultRenderer
argument_list|(
name|Boolean
operator|.
name|class
argument_list|)
expr_stmt|;
else|else
name|renderer
operator|=
name|defRenderer
expr_stmt|;
comment|//Util.pr("("+row+","+column+"). "+status+" "+renderer.toString());
comment|// For MARKED feature:
if|if
condition|(
name|tableModel
operator|.
name|isMarked
argument_list|(
name|row
argument_list|)
operator|&&
operator|(
name|renderer
operator|!=
name|incRenderer
operator|)
condition|)
block|{
return|return
name|markedRenderer
return|;
block|}
return|return
name|renderer
return|;
comment|/*         int test = row - 4*(row/4);         if (test<= 1)             return renderer;         else {             return renderer.darker();             }*/
block|}
DECL|method|scrollTo (int y)
specifier|public
name|void
name|scrollTo
parameter_list|(
name|int
name|y
parameter_list|)
block|{
name|JScrollBar
name|scb
init|=
name|sp
operator|.
name|getVerticalScrollBar
argument_list|()
decl_stmt|;
name|scb
operator|.
name|setValue
argument_list|(
name|y
operator|*
name|scb
operator|.
name|getUnitIncrement
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getSelectedEntries ()
specifier|public
name|BibtexEntry
index|[]
name|getSelectedEntries
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|rows
init|=
name|getSelectedRows
argument_list|()
decl_stmt|;
comment|//int[] cols = getSelectedColumns();
comment|// Entries are selected if only the first or multiple
comment|// columns are selected.
comment|//if (((cols.length == 1)&& (cols[0] == 0)) ||
comment|//(cols.length> 1)) { // entryTable.getColumnCount())) {
if|if
condition|(
name|rows
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|bes
operator|=
operator|new
name|BibtexEntry
index|[
name|rows
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rows
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|bes
index|[
name|i
index|]
operator|=
name|tableModel
operator|.
name|db
operator|.
name|getEntryById
argument_list|(
name|tableModel
operator|.
name|getIdForRow
argument_list|(
name|rows
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|bes
return|;
block|}
comment|// The following classes define the renderers used to render required
comment|// and optional fields in the table. The purpose of these renderers is
comment|// to visualize which fields are needed for each entry.
DECL|field|defRenderer
specifier|private
name|GeneralRenderer
name|defRenderer
init|=
operator|new
name|GeneralRenderer
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|getColor
argument_list|(
literal|"tableBackground"
argument_list|)
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|getColor
argument_list|(
literal|"tableText"
argument_list|)
argument_list|,
name|antialiasing
argument_list|)
decl_stmt|,
DECL|field|reqRenderer
name|reqRenderer
init|=
operator|new
name|GeneralRenderer
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|getColor
argument_list|(
literal|"tableReqFieldBackground"
argument_list|)
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|getColor
argument_list|(
literal|"tableText"
argument_list|)
argument_list|,
name|antialiasing
argument_list|)
decl_stmt|,
DECL|field|optRenderer
name|optRenderer
init|=
operator|new
name|GeneralRenderer
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|getColor
argument_list|(
literal|"tableOptFieldBackground"
argument_list|)
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|getColor
argument_list|(
literal|"tableText"
argument_list|)
argument_list|,
name|antialiasing
argument_list|)
decl_stmt|,
DECL|field|incRenderer
name|incRenderer
init|=
operator|new
name|IncompleteRenderer
argument_list|(
name|this
argument_list|,
name|antialiasing
argument_list|)
decl_stmt|,
comment|//new Renderer(GUIGlobals.tableIncompleteEntryBackground),
comment|//Globals.lang("This entry is incomplete")),
DECL|field|grayedOutRenderer
name|grayedOutRenderer
init|=
operator|new
name|GeneralRenderer
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|getColor
argument_list|(
literal|"grayedOutBackground"
argument_list|)
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|getColor
argument_list|(
literal|"grayedOutText"
argument_list|)
argument_list|,
name|antialiasing
argument_list|)
decl_stmt|,
DECL|field|veryGrayedOutRenderer
name|veryGrayedOutRenderer
init|=
operator|new
name|GeneralRenderer
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|getColor
argument_list|(
literal|"veryGrayedOutBackground"
argument_list|)
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|getColor
argument_list|(
literal|"veryGrayedOutText"
argument_list|)
argument_list|,
name|antialiasing
argument_list|)
decl_stmt|,
DECL|field|markedRenderer
name|markedRenderer
init|=
operator|new
name|GeneralRenderer
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|getColor
argument_list|(
literal|"markedEntryBackground"
argument_list|)
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|getColor
argument_list|(
literal|"tableText"
argument_list|)
argument_list|,
name|antialiasing
argument_list|)
decl_stmt|;
DECL|class|IncompleteRenderer
class|class
name|IncompleteRenderer
extends|extends
name|GeneralRenderer
block|{
DECL|method|IncompleteRenderer (JTable table, boolean antialiasing)
specifier|public
name|IncompleteRenderer
parameter_list|(
name|JTable
name|table
parameter_list|,
name|boolean
name|antialiasing
parameter_list|)
block|{
name|super
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|getColor
argument_list|(
literal|"incompleteEntryBackground"
argument_list|)
argument_list|,
name|antialiasing
argument_list|)
expr_stmt|;
block|}
DECL|method|setValue (Object value)
specifier|protected
name|void
name|setValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
name|super
operator|.
name|setValue
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|super
operator|.
name|setToolTipText
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"This entry is incomplete"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* public TableCellRenderer iconRenderer = new IconCellRenderer();         //new JTableButtonRenderer(getDefaultRenderer(JButton.class));     class IconCellRenderer extends DefaultTableCellRenderer {         protected void setValue(Object value) {             if (value instanceof Icon) {                 setIcon((Icon)value);                 super.setValue(null);             } else {                 setIcon(null);                 super.setValue(value);             }         }     }      class JTableButtonRenderer implements TableCellRenderer {       private TableCellRenderer __defaultRenderer;        public JTableButtonRenderer(TableCellRenderer renderer) {         __defaultRenderer = renderer;       }        public Component getTableCellRendererComponent(JTable table, Object value,                                                      boolean isSelected,                                                      boolean hasFocus,                                                      int row, int column)       {         if(value instanceof Component)           return (Component)value;         return __defaultRenderer.getTableCellRendererComponent(       table, value, isSelected, hasFocus, row, column);       }     }*/
DECL|method|ensureVisible (int row)
specifier|public
name|void
name|ensureVisible
parameter_list|(
name|int
name|row
parameter_list|)
block|{
name|JScrollBar
name|vert
init|=
name|sp
operator|.
name|getVerticalScrollBar
argument_list|()
decl_stmt|;
name|int
name|y
init|=
name|row
operator|*
name|getRowHeight
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|y
operator|<
name|vert
operator|.
name|getValue
argument_list|()
operator|)
operator|||
operator|(
name|y
operator|>
name|vert
operator|.
name|getValue
argument_list|()
operator|+
name|vert
operator|.
name|getVisibleAmount
argument_list|()
operator|)
condition|)
name|scrollToCenter
argument_list|(
name|row
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|scrollToCenter ( int rowIndex, int vColIndex)
specifier|public
name|void
name|scrollToCenter
parameter_list|(
name|int
name|rowIndex
parameter_list|,
name|int
name|vColIndex
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|this
operator|.
name|getParent
argument_list|()
operator|instanceof
name|JViewport
operator|)
condition|)
block|{
return|return;
block|}
name|JViewport
name|viewport
init|=
operator|(
name|JViewport
operator|)
name|this
operator|.
name|getParent
argument_list|()
decl_stmt|;
comment|// This rectangle is relative to the table where the
comment|// northwest corner of cell (0,0) is always (0,0).
name|Rectangle
name|rect
init|=
name|this
operator|.
name|getCellRect
argument_list|(
name|rowIndex
argument_list|,
name|vColIndex
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// The location of the view relative to the table
name|Rectangle
name|viewRect
init|=
name|viewport
operator|.
name|getViewRect
argument_list|()
decl_stmt|;
comment|// Translate the cell location so that it is relative
comment|// to the view, assuming the northwest corner of the
comment|// view is (0,0).
name|rect
operator|.
name|setLocation
argument_list|(
name|rect
operator|.
name|x
operator|-
name|viewRect
operator|.
name|x
argument_list|,
name|rect
operator|.
name|y
operator|-
name|viewRect
operator|.
name|y
argument_list|)
expr_stmt|;
comment|// Calculate location of rect if it were at the center of view
name|int
name|centerX
init|=
operator|(
name|viewRect
operator|.
name|width
operator|-
name|rect
operator|.
name|width
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|centerY
init|=
operator|(
name|viewRect
operator|.
name|height
operator|-
name|rect
operator|.
name|height
operator|)
operator|/
literal|2
decl_stmt|;
comment|// Fake the location of the cell so that scrollRectToVisible
comment|// will move the cell to the center
if|if
condition|(
name|rect
operator|.
name|x
operator|<
name|centerX
condition|)
block|{
name|centerX
operator|=
operator|-
name|centerX
expr_stmt|;
block|}
if|if
condition|(
name|rect
operator|.
name|y
operator|<
name|centerY
condition|)
block|{
name|centerY
operator|=
operator|-
name|centerY
expr_stmt|;
block|}
name|rect
operator|.
name|translate
argument_list|(
name|centerX
argument_list|,
name|centerY
argument_list|)
expr_stmt|;
comment|// Scroll the area into view.
name|viewport
operator|.
name|scrollRectToVisible
argument_list|(
name|rect
argument_list|)
expr_stmt|;
name|revalidate
argument_list|()
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
block|}
comment|/**    * updateFont    */
DECL|method|updateFont ()
specifier|public
name|void
name|updateFont
parameter_list|()
block|{
name|setFont
argument_list|(
name|GUIGlobals
operator|.
name|CURRENTFONT
argument_list|)
expr_stmt|;
name|setRowHeight
argument_list|(
name|GUIGlobals
operator|.
name|TABLE_ROW_PADDING
operator|+
name|GUIGlobals
operator|.
name|CURRENTFONT
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|updateUI ()
specifier|public
name|void
name|updateUI
parameter_list|()
block|{
name|super
operator|.
name|updateUI
argument_list|()
expr_stmt|;
name|setUI
argument_list|(
operator|new
name|CustomTableUI
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|class|CustomTableUI
class|class
name|CustomTableUI
extends|extends
name|BasicTableUI
block|{
DECL|method|installUI (JComponent c)
specifier|public
name|void
name|installUI
parameter_list|(
name|JComponent
name|c
parameter_list|)
block|{
name|super
operator|.
name|installUI
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|.
name|remove
argument_list|(
name|rendererPane
argument_list|)
expr_stmt|;
name|rendererPane
operator|=
operator|new
name|CustomCellRendererPane
argument_list|()
expr_stmt|;
name|c
operator|.
name|add
argument_list|(
name|rendererPane
argument_list|)
expr_stmt|;
block|}
comment|/**      * Overrides paintComponent to NOT clone the Graphics      * passed in and NOT validate the Component passed in.      * This is done for performance reasons.      */
DECL|class|CustomCellRendererPane
specifier|private
class|class
name|CustomCellRendererPane
extends|extends
name|CellRendererPane
block|{
DECL|field|tmpRect
specifier|private
name|Rectangle
name|tmpRect
init|=
operator|new
name|Rectangle
argument_list|()
decl_stmt|;
DECL|method|repaint ()
specifier|public
name|void
name|repaint
parameter_list|()
block|{         }
DECL|method|repaint (int x, int y, int width, int height)
specifier|public
name|void
name|repaint
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{         }
DECL|method|paintComponent (Graphics g, Component c, Container p, int x, int y, int w, int h, boolean shouldValidate)
specifier|public
name|void
name|paintComponent
parameter_list|(
name|Graphics
name|g
parameter_list|,
name|Component
name|c
parameter_list|,
name|Container
name|p
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|boolean
name|shouldValidate
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|Color
name|oldColor
init|=
name|g
operator|.
name|getColor
argument_list|()
decl_stmt|;
name|g
operator|.
name|setColor
argument_list|(
name|p
operator|.
name|getBackground
argument_list|()
argument_list|)
expr_stmt|;
name|g
operator|.
name|fillRect
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|g
operator|.
name|setColor
argument_list|(
name|oldColor
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|c
operator|.
name|getParent
argument_list|()
operator|!=
name|this
condition|)
block|{
name|this
operator|.
name|add
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|c
operator|.
name|setBounds
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|boolean
name|wasDoubleBuffered
init|=
literal|false
decl_stmt|;
name|JComponent
name|jc
init|=
operator|(
name|c
operator|instanceof
name|JComponent
operator|)
condition|?
operator|(
name|JComponent
operator|)
name|c
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|jc
operator|!=
literal|null
operator|&&
name|jc
operator|.
name|isDoubleBuffered
argument_list|()
condition|)
block|{
name|wasDoubleBuffered
operator|=
literal|true
expr_stmt|;
name|jc
operator|.
name|setDoubleBuffered
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Don't create a new Graphics, reset the clip and translate
comment|// the origin.
name|Rectangle
name|clip
init|=
name|g
operator|.
name|getClipBounds
argument_list|(
name|tmpRect
argument_list|)
decl_stmt|;
name|g
operator|.
name|clipRect
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|g
operator|.
name|translate
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|c
operator|.
name|paint
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|g
operator|.
name|translate
argument_list|(
operator|-
name|x
argument_list|,
operator|-
name|y
argument_list|)
expr_stmt|;
name|g
operator|.
name|setClip
argument_list|(
name|clip
operator|.
name|x
argument_list|,
name|clip
operator|.
name|y
argument_list|,
name|clip
operator|.
name|width
argument_list|,
name|clip
operator|.
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|wasDoubleBuffered
condition|)
block|{
name|jc
operator|.
name|setDoubleBuffered
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|c
operator|.
name|setBounds
argument_list|(
operator|-
name|w
argument_list|,
operator|-
name|h
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

