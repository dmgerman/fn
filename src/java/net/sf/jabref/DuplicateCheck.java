begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|net.sf.jabref
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_comment
comment|/**  * This class contains utility method for duplicate checking of entries.  */
end_comment

begin_class
DECL|class|DuplicateCheck
specifier|public
class|class
name|DuplicateCheck
block|{
comment|/**      * Checks if the two entries represent the same publication.      *      * @param one BibtexEntry      * @param two BibtexEntry      * @return boolean      */
DECL|method|isDuplicate (BibtexEntry one, BibtexEntry two)
specifier|public
specifier|static
name|boolean
name|isDuplicate
parameter_list|(
name|BibtexEntry
name|one
parameter_list|,
name|BibtexEntry
name|two
parameter_list|)
block|{
comment|// First check if they are of the same type - a necessary condition:
if|if
condition|(
name|one
operator|.
name|getType
argument_list|()
operator|!=
name|two
operator|.
name|getType
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// The check if they have the same required fields:
name|String
index|[]
name|fields
init|=
name|one
operator|.
name|getType
argument_list|()
operator|.
name|getRequiredFields
argument_list|()
decl_stmt|;
name|float
name|req
decl_stmt|,
name|reqWeight
init|=
literal|2
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
name|req
operator|=
literal|0
expr_stmt|;
name|reqWeight
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|req
operator|=
name|compareFieldSet
argument_list|(
name|fields
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
expr_stmt|;
name|fields
operator|=
name|one
operator|.
name|getType
argument_list|()
operator|.
name|getOptionalFields
argument_list|()
expr_stmt|;
if|if
condition|(
name|fields
operator|!=
literal|null
condition|)
block|{
name|float
name|opt
init|=
name|compareFieldSet
argument_list|(
name|fields
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
decl_stmt|;
return|return
operator|(
name|reqWeight
operator|*
name|req
operator|+
name|opt
operator|)
operator|/
operator|(
literal|1
operator|+
name|reqWeight
operator|)
operator|>=
name|Globals
operator|.
name|duplicateThreshold
return|;
block|}
else|else
block|{
return|return
operator|(
name|req
operator|>=
name|Globals
operator|.
name|duplicateThreshold
operator|)
return|;
block|}
block|}
DECL|method|compareFieldSet (String[] fields, BibtexEntry one, BibtexEntry two)
specifier|private
specifier|static
name|float
name|compareFieldSet
parameter_list|(
name|String
index|[]
name|fields
parameter_list|,
name|BibtexEntry
name|one
parameter_list|,
name|BibtexEntry
name|two
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|,
name|empty
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// Util.pr(":"+compareSingleField(fields[i], one, two));
name|int
name|result
init|=
name|compareSingleField
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|Util
operator|.
name|EQUAL
condition|)
block|{
name|res
operator|++
expr_stmt|;
comment|// Util.pr(fields[i]);
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|Util
operator|.
name|EMPTY_IN_BOTH
condition|)
name|empty
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fields
operator|.
name|length
operator|>
name|empty
condition|)
return|return
operator|(
operator|(
name|float
operator|)
name|res
operator|)
operator|/
operator|(
call|(
name|float
call|)
argument_list|(
name|fields
operator|.
name|length
operator|-
name|empty
argument_list|)
operator|)
return|;
else|else
comment|// no fields present. This points to a possible duplicate?
return|return
literal|0.5f
return|;
block|}
DECL|method|compareSingleField (String field, BibtexEntry one, BibtexEntry two)
specifier|private
specifier|static
name|int
name|compareSingleField
parameter_list|(
name|String
name|field
parameter_list|,
name|BibtexEntry
name|one
parameter_list|,
name|BibtexEntry
name|two
parameter_list|)
block|{
name|String
name|s1
init|=
name|one
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|,
name|s2
init|=
name|two
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|s1
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|s2
operator|==
literal|null
condition|)
return|return
name|Util
operator|.
name|EMPTY_IN_BOTH
return|;
else|else
return|return
name|Util
operator|.
name|EMPTY_IN_ONE
return|;
block|}
elseif|else
if|if
condition|(
name|s2
operator|==
literal|null
condition|)
return|return
name|Util
operator|.
name|EMPTY_IN_TWO
return|;
name|s1
operator|=
name|s1
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|s2
operator|=
name|s2
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
comment|// Util.pr(field+": '"+s1+"' vs '"+s2+"'");
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"author"
argument_list|)
operator|||
name|field
operator|.
name|equals
argument_list|(
literal|"editor"
argument_list|)
condition|)
block|{
comment|// Specific for name fields.
comment|// Harmonise case:
name|String
index|[]
name|aus1
init|=
name|AuthorList
operator|.
name|fixAuthor_lastNameFirst
argument_list|(
name|s1
argument_list|)
operator|.
name|split
argument_list|(
literal|" and "
argument_list|)
decl_stmt|,
name|aus2
init|=
name|AuthorList
operator|.
name|fixAuthor_lastNameFirst
argument_list|(
name|s2
argument_list|)
operator|.
name|split
argument_list|(
literal|" and "
argument_list|)
decl_stmt|,
name|au1
init|=
name|aus1
index|[
literal|0
index|]
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|,
name|au2
init|=
name|aus2
index|[
literal|0
index|]
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
comment|// Can check number of authors, all authors or only the first.
if|if
condition|(
operator|(
name|aus1
operator|.
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|aus1
operator|.
name|length
operator|==
name|aus2
operator|.
name|length
operator|)
operator|&&
name|au1
index|[
literal|0
index|]
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
name|au2
index|[
literal|0
index|]
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
return|return
name|Util
operator|.
name|EQUAL
return|;
else|else
return|return
name|Util
operator|.
name|NOT_EQUAL
return|;
block|}
else|else
block|{
name|double
name|similarity
init|=
name|correlateByWords
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
decl_stmt|;
if|if
condition|(
name|similarity
operator|>
literal|0.8
condition|)
return|return
name|Util
operator|.
name|EQUAL
return|;
else|else
return|return
name|Util
operator|.
name|NOT_EQUAL
return|;
comment|/*if (s1.trim().equals(s2.trim()))                 return Util.EQUAL;             else                 return Util.NOT_EQUAL;*/
block|}
block|}
DECL|method|compareEntriesStrictly (BibtexEntry one, BibtexEntry two)
specifier|public
specifier|static
name|double
name|compareEntriesStrictly
parameter_list|(
name|BibtexEntry
name|one
parameter_list|,
name|BibtexEntry
name|two
parameter_list|)
block|{
name|HashSet
argument_list|<
name|String
argument_list|>
name|allFields
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// one.getAllFields());
name|allFields
operator|.
name|addAll
argument_list|(
name|one
operator|.
name|getAllFields
argument_list|()
argument_list|)
expr_stmt|;
name|allFields
operator|.
name|addAll
argument_list|(
name|two
operator|.
name|getAllFields
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|score
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|fld
init|=
name|allFields
operator|.
name|iterator
argument_list|()
init|;
name|fld
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|field
init|=
name|fld
operator|.
name|next
argument_list|()
decl_stmt|;
name|Object
name|en
init|=
name|one
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|,
name|to
init|=
name|two
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|en
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|to
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|en
operator|.
name|equals
argument_list|(
name|to
argument_list|)
operator|)
condition|)
name|score
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|en
operator|==
literal|null
operator|)
operator|&&
operator|(
name|to
operator|==
literal|null
operator|)
condition|)
name|score
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|score
operator|==
name|allFields
operator|.
name|size
argument_list|()
condition|)
return|return
literal|1.01
return|;
comment|// Just to make sure we can
comment|// use score>1 without
comment|// trouble.
else|else
return|return
operator|(
operator|(
name|double
operator|)
name|score
operator|)
operator|/
name|allFields
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Goes through all entries in the given database, and if at least one of      * them is a duplicate of the given entry, as per      * Util.isDuplicate(BibtexEntry, BibtexEntry), the duplicate is returned.      * The search is terminated when the first duplicate is found.      *      * @param database The database to search.      * @param entry    The entry of which we are looking for duplicates.      * @return The first duplicate entry found. null if no duplicates are found.      */
DECL|method|containsDuplicate (BibtexDatabase database, BibtexEntry entry)
specifier|public
specifier|static
name|BibtexEntry
name|containsDuplicate
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|)
block|{
for|for
control|(
name|BibtexEntry
name|other
range|:
name|database
operator|.
name|getEntries
argument_list|()
control|)
block|{
if|if
condition|(
name|isDuplicate
argument_list|(
name|entry
argument_list|,
name|other
argument_list|)
condition|)
return|return
name|other
return|;
comment|// Duplicate found.
block|}
return|return
literal|null
return|;
comment|// No duplicate found.
block|}
DECL|method|correlateByWords (String s1, String s2)
specifier|public
specifier|static
name|double
name|correlateByWords
parameter_list|(
name|String
name|s1
parameter_list|,
name|String
name|s2
parameter_list|)
block|{
name|String
index|[]
name|w1
init|=
name|s1
operator|.
name|split
argument_list|(
literal|"\\s"
argument_list|)
decl_stmt|,
name|w2
init|=
name|s2
operator|.
name|split
argument_list|(
literal|"\\s"
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|Math
operator|.
name|min
argument_list|(
name|w1
operator|.
name|length
argument_list|,
name|w2
operator|.
name|length
argument_list|)
decl_stmt|;
name|int
name|misses
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|double
name|corr
init|=
name|correlateStrings
argument_list|(
name|w1
index|[
name|i
index|]
argument_list|,
name|w2
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|corr
operator|<
literal|0.75
condition|)
name|misses
operator|++
expr_stmt|;
block|}
name|double
name|missRate
init|=
operator|(
operator|(
name|double
operator|)
name|misses
operator|)
operator|/
operator|(
operator|(
name|double
operator|)
name|n
operator|)
decl_stmt|;
return|return
literal|1
operator|-
name|missRate
return|;
block|}
DECL|method|correlateStrings (String s1, String s2)
specifier|public
specifier|static
name|double
name|correlateStrings
parameter_list|(
name|String
name|s1
parameter_list|,
name|String
name|s2
parameter_list|)
block|{
if|if
condition|(
name|s1
operator|.
name|length
argument_list|()
operator|==
literal|1
operator|&&
name|s2
operator|.
name|length
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|s1
operator|.
name|equals
argument_list|(
name|s2
argument_list|)
condition|?
literal|1.0
else|:
literal|0.0
return|;
block|}
comment|// Convert strings to numbers and pad the shortest one with zeros:
name|double
index|[]
name|n1
init|=
name|numberizeString
argument_list|(
name|s1
argument_list|)
decl_stmt|,
name|n2
init|=
name|numberizeString
argument_list|(
name|s2
argument_list|)
decl_stmt|;
if|if
condition|(
name|n1
operator|.
name|length
operator|<
name|n2
operator|.
name|length
condition|)
name|n1
operator|=
name|stretchArray
argument_list|(
name|n1
argument_list|,
name|n2
operator|.
name|length
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n2
operator|.
name|length
operator|<
name|n1
operator|.
name|length
condition|)
name|n2
operator|=
name|stretchArray
argument_list|(
name|n2
argument_list|,
name|n1
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|corrCoef
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|)
return|;
block|}
DECL|method|corrCoef (double[] n1, double[] n2)
specifier|private
specifier|static
name|double
name|corrCoef
parameter_list|(
name|double
index|[]
name|n1
parameter_list|,
name|double
index|[]
name|n2
parameter_list|)
block|{
comment|// Calculate mean values:
name|double
name|mean1
init|=
literal|0
decl_stmt|,
name|mean2
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n1
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|mean1
operator|+=
name|n1
index|[
name|i
index|]
expr_stmt|;
name|mean2
operator|+=
name|n2
index|[
name|i
index|]
expr_stmt|;
block|}
name|mean1
operator|/=
operator|(
name|double
operator|)
name|n1
operator|.
name|length
expr_stmt|;
name|mean2
operator|/=
operator|(
name|double
operator|)
name|n2
operator|.
name|length
expr_stmt|;
name|double
name|sigma1
init|=
literal|0
decl_stmt|,
name|sigma2
init|=
literal|0
decl_stmt|;
comment|// Calculate correlation coefficient:
name|double
name|corr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n1
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sigma1
operator|+=
operator|(
name|n1
index|[
name|i
index|]
operator|-
name|mean1
operator|)
operator|*
operator|(
name|n1
index|[
name|i
index|]
operator|-
name|mean1
operator|)
expr_stmt|;
name|sigma2
operator|+=
operator|(
name|n2
index|[
name|i
index|]
operator|-
name|mean2
operator|)
operator|*
operator|(
name|n2
index|[
name|i
index|]
operator|-
name|mean2
operator|)
expr_stmt|;
name|corr
operator|+=
operator|(
name|n1
index|[
name|i
index|]
operator|-
name|mean1
operator|)
operator|*
operator|(
name|n2
index|[
name|i
index|]
operator|-
name|mean2
operator|)
expr_stmt|;
block|}
name|sigma1
operator|=
name|Math
operator|.
name|sqrt
argument_list|(
name|sigma1
argument_list|)
expr_stmt|;
name|sigma2
operator|=
name|Math
operator|.
name|sqrt
argument_list|(
name|sigma2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigma1
operator|>
literal|0
operator|&&
name|sigma2
operator|>
literal|0
condition|)
return|return
name|corr
operator|/
operator|(
name|sigma1
operator|*
name|sigma2
operator|)
return|;
else|else
return|return
literal|0
return|;
block|}
DECL|method|numberizeString (String s)
specifier|private
specifier|static
name|double
index|[]
name|numberizeString
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|double
index|[]
name|res
init|=
operator|new
name|double
index|[
name|s
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
name|res
index|[
name|i
index|]
operator|=
operator|(
name|double
operator|)
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
DECL|method|stretchArray (double[] array, int length)
specifier|private
specifier|static
name|double
index|[]
name|stretchArray
parameter_list|(
name|double
index|[]
name|array
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|length
operator|<=
name|array
operator|.
name|length
condition|)
return|return
name|array
return|;
name|double
name|multip
init|=
operator|(
operator|(
name|double
operator|)
name|array
operator|.
name|length
operator|)
operator|/
operator|(
operator|(
name|double
operator|)
name|length
operator|)
decl_stmt|;
name|double
index|[]
name|newArray
init|=
operator|new
name|double
index|[
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newArray
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|double
name|index
init|=
operator|(
operator|(
name|double
operator|)
name|i
operator|)
operator|*
name|multip
decl_stmt|;
name|int
name|baseInd
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|double
name|dist
init|=
name|index
operator|-
name|Math
operator|.
name|floor
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|newArray
index|[
name|i
index|]
operator|=
name|dist
operator|*
name|array
index|[
name|Math
operator|.
name|min
argument_list|(
name|array
operator|.
name|length
operator|-
literal|1
argument_list|,
name|baseInd
operator|+
literal|1
argument_list|)
index|]
operator|+
operator|(
literal|1.0
operator|-
name|dist
operator|)
operator|*
name|array
index|[
name|baseInd
index|]
expr_stmt|;
block|}
return|return
name|newArray
return|;
block|}
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|String
name|d1
init|=
literal|"Characterization of Calanus finmarchicus habitat in the North Sea"
decl_stmt|,
name|d2
init|=
literal|"Characterization of Calunus finmarchicus habitat in the North Sea"
decl_stmt|,
name|d3
init|=
literal|"Characterization of Calanus glacialissss habitat in the South Sea"
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|correlateByWords
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|correlateByWords
argument_list|(
name|d1
argument_list|,
name|d3
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|correlateByWords
argument_list|(
name|d2
argument_list|,
name|d3
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

