begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|net.sf.jabref
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_comment
comment|/**  * This class contains utility method for duplicate checking of entries.  */
end_comment

begin_class
DECL|class|DuplicateCheck
specifier|public
class|class
name|DuplicateCheck
block|{
comment|/**      * Checks if the two entries represent the same publication.      *      * @param one BibtexEntry      * @param two BibtexEntry      * @return boolean      */
DECL|method|isDuplicate (BibtexEntry one, BibtexEntry two)
specifier|public
specifier|static
name|boolean
name|isDuplicate
parameter_list|(
name|BibtexEntry
name|one
parameter_list|,
name|BibtexEntry
name|two
parameter_list|)
block|{
comment|// First check if they are of the same type - a necessary condition:
if|if
condition|(
name|one
operator|.
name|getType
argument_list|()
operator|!=
name|two
operator|.
name|getType
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// The check if they have the same required fields:
name|String
index|[]
name|fields
init|=
name|one
operator|.
name|getType
argument_list|()
operator|.
name|getRequiredFields
argument_list|()
decl_stmt|;
name|float
name|req
decl_stmt|,
name|reqWeight
init|=
literal|2
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
name|req
operator|=
literal|0
expr_stmt|;
name|reqWeight
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|req
operator|=
name|compareFieldSet
argument_list|(
name|fields
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
expr_stmt|;
name|fields
operator|=
name|one
operator|.
name|getType
argument_list|()
operator|.
name|getOptionalFields
argument_list|()
expr_stmt|;
if|if
condition|(
name|fields
operator|!=
literal|null
condition|)
block|{
name|float
name|opt
init|=
name|compareFieldSet
argument_list|(
name|fields
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
decl_stmt|;
return|return
operator|(
name|reqWeight
operator|*
name|req
operator|+
name|opt
operator|)
operator|/
operator|(
literal|1
operator|+
name|reqWeight
operator|)
operator|>=
name|Globals
operator|.
name|duplicateThreshold
return|;
block|}
else|else
block|{
return|return
operator|(
name|req
operator|>=
name|Globals
operator|.
name|duplicateThreshold
operator|)
return|;
block|}
block|}
DECL|method|compareFieldSet (String[] fields, BibtexEntry one, BibtexEntry two)
specifier|private
specifier|static
name|float
name|compareFieldSet
parameter_list|(
name|String
index|[]
name|fields
parameter_list|,
name|BibtexEntry
name|one
parameter_list|,
name|BibtexEntry
name|two
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|,
name|empty
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// Util.pr(":"+compareSingleField(fields[i], one, two));
name|int
name|result
init|=
name|compareSingleField
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|Util
operator|.
name|EQUAL
condition|)
block|{
name|res
operator|++
expr_stmt|;
comment|// Util.pr(fields[i]);
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|Util
operator|.
name|EMPTY_IN_BOTH
condition|)
name|empty
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fields
operator|.
name|length
operator|>
name|empty
condition|)
return|return
operator|(
operator|(
name|float
operator|)
name|res
operator|)
operator|/
operator|(
call|(
name|float
call|)
argument_list|(
name|fields
operator|.
name|length
operator|-
name|empty
argument_list|)
operator|)
return|;
else|else
comment|// no fields present. This points to a possible duplicate?
return|return
literal|0.5f
return|;
block|}
DECL|method|compareSingleField (String field, BibtexEntry one, BibtexEntry two)
specifier|private
specifier|static
name|int
name|compareSingleField
parameter_list|(
name|String
name|field
parameter_list|,
name|BibtexEntry
name|one
parameter_list|,
name|BibtexEntry
name|two
parameter_list|)
block|{
name|String
name|s1
init|=
name|one
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|,
name|s2
init|=
name|two
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|s1
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|s2
operator|==
literal|null
condition|)
return|return
name|Util
operator|.
name|EMPTY_IN_BOTH
return|;
else|else
return|return
name|Util
operator|.
name|EMPTY_IN_ONE
return|;
block|}
elseif|else
if|if
condition|(
name|s2
operator|==
literal|null
condition|)
return|return
name|Util
operator|.
name|EMPTY_IN_TWO
return|;
name|s1
operator|=
name|s1
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|s2
operator|=
name|s2
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
comment|// Util.pr(field+": '"+s1+"' vs '"+s2+"'");
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"author"
argument_list|)
operator|||
name|field
operator|.
name|equals
argument_list|(
literal|"editor"
argument_list|)
condition|)
block|{
comment|// Specific for name fields.
comment|// Harmonise case:
name|String
index|[]
name|aus1
init|=
name|AuthorList
operator|.
name|fixAuthor_lastNameFirst
argument_list|(
name|s1
argument_list|)
operator|.
name|split
argument_list|(
literal|" and "
argument_list|)
decl_stmt|,
name|aus2
init|=
name|AuthorList
operator|.
name|fixAuthor_lastNameFirst
argument_list|(
name|s2
argument_list|)
operator|.
name|split
argument_list|(
literal|" and "
argument_list|)
decl_stmt|,
name|au1
init|=
name|aus1
index|[
literal|0
index|]
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|,
name|au2
init|=
name|aus2
index|[
literal|0
index|]
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
comment|// Can check number of authors, all authors or only the first.
if|if
condition|(
operator|(
name|aus1
operator|.
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|aus1
operator|.
name|length
operator|==
name|aus2
operator|.
name|length
operator|)
operator|&&
name|au1
index|[
literal|0
index|]
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
name|au2
index|[
literal|0
index|]
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
return|return
name|Util
operator|.
name|EQUAL
return|;
else|else
return|return
name|Util
operator|.
name|NOT_EQUAL
return|;
block|}
else|else
block|{
if|if
condition|(
name|s1
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
name|s2
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
return|return
name|Util
operator|.
name|EQUAL
return|;
else|else
return|return
name|Util
operator|.
name|NOT_EQUAL
return|;
block|}
block|}
DECL|method|compareEntriesStrictly (BibtexEntry one, BibtexEntry two)
specifier|public
specifier|static
name|double
name|compareEntriesStrictly
parameter_list|(
name|BibtexEntry
name|one
parameter_list|,
name|BibtexEntry
name|two
parameter_list|)
block|{
name|HashSet
argument_list|<
name|String
argument_list|>
name|allFields
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// one.getAllFields());
name|allFields
operator|.
name|addAll
argument_list|(
name|one
operator|.
name|getAllFields
argument_list|()
argument_list|)
expr_stmt|;
name|allFields
operator|.
name|addAll
argument_list|(
name|two
operator|.
name|getAllFields
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|score
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|fld
init|=
name|allFields
operator|.
name|iterator
argument_list|()
init|;
name|fld
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|field
init|=
name|fld
operator|.
name|next
argument_list|()
decl_stmt|;
name|Object
name|en
init|=
name|one
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|,
name|to
init|=
name|two
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|en
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|to
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|en
operator|.
name|equals
argument_list|(
name|to
argument_list|)
operator|)
condition|)
name|score
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|en
operator|==
literal|null
operator|)
operator|&&
operator|(
name|to
operator|==
literal|null
operator|)
condition|)
name|score
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|score
operator|==
name|allFields
operator|.
name|size
argument_list|()
condition|)
return|return
literal|1.01
return|;
comment|// Just to make sure we can
comment|// use score>1 without
comment|// trouble.
else|else
return|return
operator|(
operator|(
name|double
operator|)
name|score
operator|)
operator|/
name|allFields
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Goes through all entries in the given database, and if at least one of      * them is a duplicate of the given entry, as per      * Util.isDuplicate(BibtexEntry, BibtexEntry), the duplicate is returned.      * The search is terminated when the first duplicate is found.      *      * @param database The database to search.      * @param entry    The entry of which we are looking for duplicates.      * @return The first duplicate entry found. null if no duplicates are found.      */
DECL|method|containsDuplicate (BibtexDatabase database, BibtexEntry entry)
specifier|public
specifier|static
name|BibtexEntry
name|containsDuplicate
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|)
block|{
for|for
control|(
name|BibtexEntry
name|other
range|:
name|database
operator|.
name|getEntries
argument_list|()
control|)
block|{
if|if
condition|(
name|isDuplicate
argument_list|(
name|entry
argument_list|,
name|other
argument_list|)
condition|)
return|return
name|other
return|;
comment|// Duplicate found.
block|}
return|return
literal|null
return|;
comment|// No duplicate found.
block|}
block|}
end_class

end_unit

