begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003 Morten O. Alver, Nizar N. Batada   All programs in this directory and  subdirectories are published under the GNU General Public License as  described below.   This program is free software; you can redistribute it and/or modify  it under the terms of the GNU General Public License as published by  the Free Software Foundation; either version 2 of the License, or (at  your option) any later version.   This program is distributed in the hope that it will be useful, but  WITHOUT ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  General Public License for more details.   You should have received a copy of the GNU General Public License  along with this program; if not, write to the Free Software  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA   Further information about the GNU GPL is available at:  http://www.gnu.org/copyleft/gpl.ja.html   */
end_comment

begin_package
DECL|package|net.sf.jabref
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|*
import|;
end_import

begin_class
DECL|class|MetaData
specifier|public
class|class
name|MetaData
block|{
DECL|field|metaData
specifier|private
name|HashMap
name|metaData
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
DECL|field|data
specifier|private
name|StringReader
name|data
decl_stmt|;
DECL|field|groupsRoot
specifier|private
name|GroupTreeNode
name|groupsRoot
init|=
literal|null
decl_stmt|;
comment|/**      * The MetaData object stores all meta data sets in Vectors. To ensure that      * the data is written correctly to string, the user of a meta data Vector      * must simply make sure the appropriate changes are reflected in the Vector      * it has been passed.      */
DECL|method|MetaData (HashMap inData, BibtexDatabase db)
specifier|public
name|MetaData
parameter_list|(
name|HashMap
name|inData
parameter_list|,
name|BibtexDatabase
name|db
parameter_list|)
block|{
name|this
argument_list|()
expr_stmt|;
name|boolean
name|groupsTreePresent
init|=
literal|false
decl_stmt|;
name|Vector
name|flatGroupsData
init|=
literal|null
decl_stmt|;
name|Vector
name|treeGroupsData
init|=
literal|null
decl_stmt|;
comment|// The first version (0) lacked a version specification,
comment|// thus this value defaults to 0.
name|int
name|groupsVersionOnDisk
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|inData
operator|!=
literal|null
condition|)
for|for
control|(
name|Iterator
name|i
init|=
name|inData
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|data
operator|=
operator|new
name|StringReader
argument_list|(
operator|(
name|String
operator|)
name|inData
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|unit
decl_stmt|;
name|Vector
name|orderedData
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
comment|// We must allow for ; and \ in escape sequences.
try|try
block|{
while|while
condition|(
operator|(
name|unit
operator|=
name|getNextUnit
argument_list|(
name|data
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|orderedData
operator|.
name|add
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Weird error while parsing meta data."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"groupsversion"
argument_list|)
condition|)
block|{
if|if
condition|(
name|orderedData
operator|.
name|size
argument_list|()
operator|>=
literal|1
condition|)
name|groupsVersionOnDisk
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|orderedData
operator|.
name|firstElement
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"groupstree"
argument_list|)
condition|)
block|{
name|groupsTreePresent
operator|=
literal|true
expr_stmt|;
name|treeGroupsData
operator|=
name|orderedData
expr_stmt|;
comment|// save for later user
comment|// actual import operation is handled later because "groupsversion"
comment|// tag might not yet have been read
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"groups"
argument_list|)
condition|)
block|{
name|flatGroupsData
operator|=
name|orderedData
expr_stmt|;
block|}
else|else
block|{
name|putData
argument_list|(
name|key
argument_list|,
name|orderedData
argument_list|)
expr_stmt|;
block|}
block|}
comment|// this possibly handles import of a previous groups version
if|if
condition|(
name|groupsTreePresent
condition|)
name|putGroups
argument_list|(
name|treeGroupsData
argument_list|,
name|db
argument_list|,
name|groupsVersionOnDisk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|groupsTreePresent
operator|&&
name|flatGroupsData
operator|!=
literal|null
condition|)
block|{
name|groupsRoot
operator|=
name|VersionHandling
operator|.
name|importFlatGroups
argument_list|(
name|flatGroupsData
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * The MetaData object can be constructed with no data in it.      */
DECL|method|MetaData ()
specifier|public
name|MetaData
parameter_list|()
block|{
name|metaData
operator|.
name|put
argument_list|(
name|Globals
operator|.
name|SELECTOR_META_PREFIX
operator|+
literal|"keywords"
argument_list|,
operator|new
name|Vector
argument_list|()
argument_list|)
expr_stmt|;
name|metaData
operator|.
name|put
argument_list|(
name|Globals
operator|.
name|SELECTOR_META_PREFIX
operator|+
literal|"journal"
argument_list|,
operator|new
name|Vector
argument_list|()
argument_list|)
expr_stmt|;
name|metaData
operator|.
name|put
argument_list|(
name|Globals
operator|.
name|SELECTOR_META_PREFIX
operator|+
literal|"publisher"
argument_list|,
operator|new
name|Vector
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|iterator ()
specifier|public
name|Iterator
name|iterator
parameter_list|()
block|{
return|return
name|metaData
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|method|getData (String key)
specifier|public
name|Vector
name|getData
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
operator|(
name|Vector
operator|)
name|metaData
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|remove (String key)
specifier|public
name|void
name|remove
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|metaData
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
comment|/**      * Stores the specified data in this object, using the specified key. For      * certain keys (e.g. "groupstree"), the objects in orderedData are      * reconstructed from their textual (String) representation if they are of      * type String, and stored as an actual instance.      */
DECL|method|putData (String key, Vector orderedData)
specifier|public
name|void
name|putData
parameter_list|(
name|String
name|key
parameter_list|,
name|Vector
name|orderedData
parameter_list|)
block|{
name|metaData
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|orderedData
argument_list|)
expr_stmt|;
block|}
DECL|method|putGroups (Vector orderedData, BibtexDatabase db, int version)
specifier|private
name|void
name|putGroups
parameter_list|(
name|Vector
name|orderedData
parameter_list|,
name|BibtexDatabase
name|db
parameter_list|,
name|int
name|version
parameter_list|)
block|{
try|try
block|{
name|groupsRoot
operator|=
name|VersionHandling
operator|.
name|importGroups
argument_list|(
name|orderedData
argument_list|,
name|db
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// we cannot really do anything about this here
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getGroups ()
specifier|public
name|GroupTreeNode
name|getGroups
parameter_list|()
block|{
return|return
name|groupsRoot
return|;
block|}
comment|/**      * Sets a new group root node.<b>WARNING</b>: This invalidates everything      * returned by getGroups() so far!!!      */
DECL|method|setGroups (GroupTreeNode root)
specifier|public
name|void
name|setGroups
parameter_list|(
name|GroupTreeNode
name|root
parameter_list|)
block|{
name|groupsRoot
operator|=
name|root
expr_stmt|;
block|}
comment|/**      * Writes all data to the specified writer, using each object's toString()      * method.      */
DECL|method|writeMetaData (Writer out)
specifier|public
name|void
name|writeMetaData
parameter_list|(
name|Writer
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|// write all meta data except groups
for|for
control|(
name|Iterator
name|i
init|=
name|metaData
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|Vector
name|orderedData
init|=
operator|(
name|Vector
operator|)
name|metaData
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|orderedData
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"@comment{"
operator|+
name|GUIGlobals
operator|.
name|META_FLAG
operator|+
name|key
operator|+
literal|":"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|orderedData
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|Util
operator|.
name|quote
argument_list|(
operator|(
name|String
operator|)
name|orderedData
operator|.
name|elementAt
argument_list|(
name|j
argument_list|)
argument_list|,
literal|";"
argument_list|,
literal|'\\'
argument_list|)
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
name|wrapStringBuffer
argument_list|(
name|sb
argument_list|,
name|Globals
operator|.
name|METADATA_LINE_LENGTH
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// write groups if present. skip this if only the root node exists
comment|// (which is always the AllEntriesGroup).
if|if
condition|(
name|groupsRoot
operator|!=
literal|null
operator|&&
name|groupsRoot
operator|.
name|getChildCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
comment|// write version first
name|sb
operator|.
name|append
argument_list|(
literal|"@comment{"
operator|+
name|GUIGlobals
operator|.
name|META_FLAG
operator|+
literal|"groupsversion:"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|""
operator|+
name|VersionHandling
operator|.
name|CURRENT_VERSION
operator|+
literal|";"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// now write actual groups
name|sb
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"@comment{"
operator|+
name|GUIGlobals
operator|.
name|META_FLAG
operator|+
literal|"groupstree:\n"
argument_list|)
expr_stmt|;
comment|// GroupsTreeNode.toString() uses "\n" for separation
name|StringTokenizer
name|tok
init|=
operator|new
name|StringTokenizer
argument_list|(
name|groupsRoot
operator|.
name|getTreeAsString
argument_list|()
argument_list|,
literal|"\n"
argument_list|)
decl_stmt|;
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|StringBuffer
name|s
init|=
operator|new
name|StringBuffer
argument_list|(
name|Util
operator|.
name|quote
argument_list|(
name|tok
operator|.
name|nextToken
argument_list|()
argument_list|,
literal|";"
argument_list|,
literal|'\\'
argument_list|)
operator|+
literal|";"
argument_list|)
decl_stmt|;
name|wrapStringBuffer
argument_list|(
name|s
argument_list|,
name|Globals
operator|.
name|METADATA_LINE_LENGTH
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|s
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|wrapStringBuffer (StringBuffer sb, int lineLength)
specifier|private
name|void
name|wrapStringBuffer
parameter_list|(
name|StringBuffer
name|sb
parameter_list|,
name|int
name|lineLength
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|lineLength
init|;
name|i
operator|<
name|sb
operator|.
name|length
argument_list|()
condition|;
name|i
operator|+=
name|lineLength
operator|+
literal|1
control|)
block|{
name|sb
operator|.
name|insert
argument_list|(
name|i
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Reads the next unit. Units are delimited by ';'.       */
DECL|method|getNextUnit (Reader reader)
specifier|private
name|String
name|getNextUnit
parameter_list|(
name|Reader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|c
decl_stmt|;
name|boolean
name|escape
init|=
literal|false
decl_stmt|;
name|StringBuffer
name|res
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|reader
operator|.
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|escape
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|escape
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|escape
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
break|break;
block|}
else|else
block|{
name|res
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|res
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
return|return
name|res
operator|.
name|toString
argument_list|()
return|;
return|return
literal|null
return|;
block|}
block|}
end_class

end_unit

