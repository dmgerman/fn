begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2003 Morten O. Alver, Nizar N. Batada  All programs in this directory and subdirectories are published under the GNU General Public License as described below.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA  Further information about the GNU GPL is available at: http://www.gnu.org/copyleft/gpl.ja.html  */
end_comment

begin_package
DECL|package|net.sf.jabref
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_class
DECL|class|MetaData
specifier|public
class|class
name|MetaData
block|{
DECL|field|metaData
specifier|private
name|HashMap
name|metaData
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
DECL|field|data
specifier|private
name|StringReader
name|data
decl_stmt|;
comment|/**      * The MetaData object stores all meta data sets in Vectors. To      * ensure that the data is written correctly to string, the user      * of a meta data Vector must simply make sure the appropriate      * changes are reflected in the Vector it has been passed.      */
DECL|method|MetaData (HashMap inData)
specifier|public
name|MetaData
parameter_list|(
name|HashMap
name|inData
parameter_list|)
block|{
name|this
argument_list|()
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|inData
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|data
operator|=
operator|new
name|StringReader
argument_list|(
operator|(
name|String
operator|)
name|inData
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|unit
decl_stmt|;
name|Vector
name|orderedData
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
comment|// We must allow for ; and \ in escape sequences.
try|try
block|{
while|while
condition|(
operator|(
name|unit
operator|=
name|getNextUnit
argument_list|(
name|data
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|orderedData
operator|.
name|add
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Weird error while parsing meta data."
argument_list|)
expr_stmt|;
block|}
name|metaData
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|orderedData
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * The MetaData object can be constructed with no data in it.      */
DECL|method|MetaData ()
specifier|public
name|MetaData
parameter_list|()
block|{
name|metaData
operator|.
name|put
argument_list|(
name|Globals
operator|.
name|SELECTOR_META_PREFIX
operator|+
literal|"keywords"
argument_list|,
operator|new
name|Vector
argument_list|()
argument_list|)
expr_stmt|;
name|metaData
operator|.
name|put
argument_list|(
name|Globals
operator|.
name|SELECTOR_META_PREFIX
operator|+
literal|"journal"
argument_list|,
operator|new
name|Vector
argument_list|()
argument_list|)
expr_stmt|;
name|metaData
operator|.
name|put
argument_list|(
name|Globals
operator|.
name|SELECTOR_META_PREFIX
operator|+
literal|"publisher"
argument_list|,
operator|new
name|Vector
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|iterator ()
specifier|public
name|Iterator
name|iterator
parameter_list|()
block|{
return|return
name|metaData
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|method|getData (String key)
specifier|public
name|Vector
name|getData
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
operator|(
name|Vector
operator|)
name|metaData
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|putData (String key, Vector orderedData)
specifier|public
name|void
name|putData
parameter_list|(
name|String
name|key
parameter_list|,
name|Vector
name|orderedData
parameter_list|)
block|{
name|metaData
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|orderedData
argument_list|)
expr_stmt|;
block|}
DECL|method|writeMetaData (Writer out)
specifier|public
name|void
name|writeMetaData
parameter_list|(
name|Writer
name|out
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|metaData
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Vector
name|orderedData
init|=
operator|(
name|Vector
operator|)
name|metaData
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|orderedData
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
literal|"@comment{"
operator|+
name|GUIGlobals
operator|.
name|META_FLAG
operator|+
name|key
operator|+
literal|":"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|orderedData
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|out
operator|.
name|write
argument_list|(
name|makeEscape
argument_list|(
operator|(
name|String
operator|)
name|orderedData
operator|.
name|elementAt
argument_list|(
name|j
argument_list|)
argument_list|)
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|write
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getNextUnit (Reader data)
specifier|private
name|String
name|getNextUnit
parameter_list|(
name|Reader
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|c
decl_stmt|;
name|boolean
name|escape
init|=
literal|false
decl_stmt|,
name|done
init|=
literal|false
decl_stmt|;
name|StringBuffer
name|res
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
operator|(
operator|(
name|c
operator|=
name|data
operator|.
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|!
name|escape
condition|)
name|escape
operator|=
literal|true
expr_stmt|;
else|else
block|{
name|escape
operator|=
literal|false
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
if|if
condition|(
operator|!
name|escape
condition|)
name|done
operator|=
literal|true
expr_stmt|;
else|else
name|res
operator|.
name|append
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
name|escape
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|res
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
return|return
name|res
operator|.
name|toString
argument_list|()
return|;
else|else
return|return
literal|null
return|;
block|}
DECL|method|makeEscape (String s)
specifier|private
name|String
name|makeEscape
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|int
name|c
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'\\'
operator|)
operator|||
operator|(
name|c
operator|==
literal|';'
operator|)
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

