begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2005 Andreas Rudert   All programs in this directory and  subdirectories are published under the GNU General Public License as  described below.   This program is free software; you can redistribute it and/or modify  it under the terms of the GNU General Public License as published by  the Free Software Foundation; either version 2 of the License, or (at  your option) any later version.   This program is distributed in the hope that it will be useful, but  WITHOUT ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  General Public License for more details.   You should have received a copy of the GNU General Public License  along with this program; if not, write to the Free Software  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA   Further information about the GNU GPL is available at:  http://www.gnu.org/copyleft/gpl.ja.html   */
end_comment

begin_package
DECL|package|net.sf.jabref.imports
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|imports
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|GregorianCalendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexEntryType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|Util
import|;
end_import

begin_comment
comment|/**  * Imports a New Economics Papers-Message from the REPEC-NEP Service.  *   *<p>{@link http://www.repec.org RePEc} (Research Papers in Economics)   * is a collaborative effort of over 100 volunteers in 49 countries   * to enhance the dissemination of research in economics. The heart of   * the project is a decentralized database of working papers, journal   * articles and software components. All RePEc material is freely available.</p>  * At the time of writing RePEc holds over 300.000 items.</p>  *   *<p>{@link http://nep.repec.org NEP} (New Economic Papers) is an announcement   * service which filters information on new additions to RePEc into edited   * reports. The goal is to provide subscribers with up-to-date information   * to the research literature.</p>  *   *<p>This importer is capable of importing NEP messages into JabRef.</p>  *   *<p>There is no officially defined message format for NEP. NEP messages are assumed to have   * (and almost always have) the form given by the following semi-formal grammar:  *<pre>  * NEPMessage:  *       MessageSection NEPMessage  *       MessageSection  *         * MessageSection:              *       OverviewMessageSection   *       OtherMessageSection  *  * # we skip the overview  * OverviewMessageSection:  *       'In this issue we have: ' SectionSeparator OtherStuff  *  * OtherMessageSection:  *       SectionSeparator  OtherMessageSectionContent  *  * # we skip other stuff and read only full working paper references  * OtherMessageSectionContent:  *       WorkingPaper EmptyLine OtherMessageSectionContent   *       OtherStuff EmptyLine OtherMessageSectionContent  *       ''  *         * OtherStuff:  *       NonEmptyLine OtherStuff  *       NonEmptyLine  *         * NonEmptyLine:  *       a non-empty String that does not start with a number followed by a '.'  *         * # working papers are recognized by a number followed by a '.'   * # in a non-overview section  * WorkingPaper:  *       Number'.' WhiteSpace TitleString EmptyLine Authors EmptyLine Abstract EmptyLine AdditionalFields  *         * TitleString:  *       a String that may span several lines and should be joined  *         * # there must be at least one author  * Authors:  *       Author '\n' Authors  *       Author '\n'  *   * # optionally, an institution is given for an author  * Author:  *       AuthorName  *       AuthorName '(' Institution ')'  *         * # there are no rules about the name, it may be firstname lastname or lastname, firstname or anything else  * AuthorName:  *       a non-empty String without '(' or ')' characters, not spanning more that one line  *         * Institution:  *       a non-empty String that may span several lines  *         * Abstract:  *       a (possibly empty) String that may span several lines  *  * AdditionalFields:  *       AdditionalField '\n' AdditionalFields  *       ''  *         * AdditionalField:  *       'Keywords:' KeywordList  *       'URL:' non-empty String  *       'Date:' DateString  *       'JEL:' JelClassificationList  *         * KeywordList:  *        Keyword ',' KeywordList  *        Keyword  *          * Keyword:  *        non-empty String that does not contain ',' (may contain whitespace)  *          * # if no date is given, the current year as given by the system clock is assumed  * DateString:  *        'yyyy-MM-dd'  *        'yyyy-MM'  *        'yyyy'  *          * JelClassificationList:  *        JelClassification JelClassificationList  *        JelClassification  *        * # the JEL Classifications are set into a new BIBTEX-field 'jel'  * # they will appear if you add it as a field to one of the BIBTex Entry sections  * JelClassification:  *        one of the allowed classes, see http://ideas.repec.org/j/  *         * SectionSeparator:  *       '\n-----------------------------'  *</pre>  *</p>  *   * @see http://nep.repec.org  * @author andreas_sf at rudert-home dot de  */
end_comment

begin_class
DECL|class|RepecNepImporter
specifier|public
class|class
name|RepecNepImporter
implements|implements
name|ImportFormat
block|{
DECL|field|recognizedFields
specifier|private
specifier|final
specifier|static
name|Collection
name|recognizedFields
init|=
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"Keywords"
block|,
literal|"JEL"
block|,
literal|"Date"
block|,
literal|"URL"
block|}
argument_list|)
decl_stmt|;
DECL|field|line
specifier|private
name|int
name|line
init|=
literal|0
decl_stmt|;
comment|/**    * Return the name of this import format.    */
DECL|method|getFormatName ()
specifier|public
name|String
name|getFormatName
parameter_list|()
block|{
return|return
literal|"REPEC New Economic Papers (NEP)"
return|;
block|}
comment|/**    * Check whether the source is in the correct format for this importer.    */
DECL|method|isRecognizedFormat (InputStream stream)
specifier|public
name|boolean
name|isRecognizedFormat
parameter_list|(
name|InputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
comment|// read the first couple of lines
comment|// NEP message usually contain the String 'NEP: New Economics Papers'
comment|// or, they are from nep.repec.org
name|BufferedReader
name|in
init|=
operator|new
name|BufferedReader
argument_list|(
name|ImportFormatReader
operator|.
name|getReaderDefaultEncoding
argument_list|(
name|stream
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|startOfMessage
init|=
literal|""
decl_stmt|;
name|String
name|line
init|=
name|in
operator|.
name|readLine
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|25
operator|&&
name|line
operator|!=
literal|null
condition|;
name|i
operator|++
control|)
block|{
name|startOfMessage
operator|+=
name|line
expr_stmt|;
name|line
operator|=
name|in
operator|.
name|readLine
argument_list|()
expr_stmt|;
block|}
return|return
name|startOfMessage
operator|.
name|indexOf
argument_list|(
literal|"NEP: New Economics Papers"
argument_list|)
operator|>=
literal|0
operator|||
name|startOfMessage
operator|.
name|indexOf
argument_list|(
literal|"nep.repec.org"
argument_list|)
operator|>=
literal|0
return|;
block|}
DECL|method|startsWithKeyword (String s, Collection keywords)
specifier|private
name|boolean
name|startsWithKeyword
parameter_list|(
name|String
name|s
parameter_list|,
name|Collection
name|keywords
parameter_list|)
block|{
name|boolean
name|result
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|String
name|possibleKeyword
init|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|s
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|=
name|keywords
operator|.
name|contains
argument_list|(
name|possibleKeyword
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|readLine (BufferedReader in)
specifier|private
name|String
name|readLine
parameter_list|(
name|BufferedReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|line
operator|++
expr_stmt|;
return|return
name|in
operator|.
name|readLine
argument_list|()
return|;
block|}
comment|/**    * Parse the entries in the source, and return a List of BibtexEntry    * objects.    */
DECL|method|importEntries (InputStream stream)
specifier|public
name|List
name|importEntries
parameter_list|(
name|InputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
name|bibitems
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|String
name|paperNoStr
init|=
literal|null
decl_stmt|;
name|this
operator|.
name|line
operator|=
literal|0
expr_stmt|;
try|try
block|{
name|String
name|s
init|=
literal|""
decl_stmt|;
name|BufferedReader
name|in
init|=
operator|new
name|BufferedReader
argument_list|(
name|ImportFormatReader
operator|.
name|getReaderDefaultEncoding
argument_list|(
name|stream
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|prevLine
init|=
literal|""
decl_stmt|;
name|boolean
name|inOverviewSection
init|=
literal|false
decl_stmt|;
comment|// skip header and editor information
name|s
operator|=
name|readLine
argument_list|(
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
literal|"-----------------------------"
argument_list|)
condition|)
block|{
name|inOverviewSection
operator|=
name|prevLine
operator|.
name|startsWith
argument_list|(
literal|"In this issue we have"
argument_list|)
expr_stmt|;
block|}
comment|// if line starts with a string of the form 'x. ' and we are not in the overview
comment|// section, we have a working paper entry we are interested in
if|if
condition|(
name|s
operator|.
name|matches
argument_list|(
literal|"\\d+\\.\\s.*"
argument_list|)
operator|&&
operator|!
name|inOverviewSection
condition|)
block|{
name|paperNoStr
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|s
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
name|BibtexEntry
name|be
init|=
operator|new
name|BibtexEntry
argument_list|(
name|Util
operator|.
name|createNeutralId
argument_list|()
argument_list|)
decl_stmt|;
name|be
operator|.
name|setType
argument_list|(
name|BibtexEntryType
operator|.
name|getType
argument_list|(
literal|"techreport"
argument_list|)
argument_list|)
expr_stmt|;
comment|// read title
name|String
name|title
init|=
name|s
operator|.
name|substring
argument_list|(
name|s
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
operator|+
literal|1
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|s
operator|=
name|readLine
argument_list|(
name|in
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
operator|&&
operator|!
name|s
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|title
operator|+=
literal|" "
operator|+
name|s
expr_stmt|;
name|s
operator|=
name|readLine
argument_list|(
name|in
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
name|be
operator|.
name|setField
argument_list|(
literal|"title"
argument_list|,
name|title
argument_list|)
expr_stmt|;
comment|// skip empty line
name|s
operator|=
name|readLine
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|// read authors and institutions
name|String
name|authors
init|=
literal|""
decl_stmt|;
name|String
name|institutions
init|=
literal|""
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
operator|&&
operator|!
name|s
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
comment|// read single author
name|String
name|author
init|=
literal|null
decl_stmt|;
name|String
name|institution
init|=
literal|null
decl_stmt|;
name|boolean
name|institutionDone
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|author
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|s
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
name|institutionDone
operator|=
name|s
operator|.
name|indexOf
argument_list|(
literal|')'
argument_list|)
operator|>
literal|0
expr_stmt|;
name|institution
operator|=
name|s
operator|.
name|substring
argument_list|(
name|s
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
operator|+
literal|1
argument_list|,
name|institutionDone
condition|?
name|s
operator|.
name|indexOf
argument_list|(
literal|')'
argument_list|)
else|:
name|s
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|author
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
name|institutionDone
operator|=
literal|true
expr_stmt|;
block|}
name|s
operator|=
name|readLine
argument_list|(
name|in
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|institutionDone
operator|&&
name|s
operator|!=
literal|null
condition|)
block|{
name|institutionDone
operator|=
name|s
operator|.
name|indexOf
argument_list|(
literal|')'
argument_list|)
operator|>
literal|0
expr_stmt|;
name|institution
operator|=
name|s
operator|.
name|substring
argument_list|(
name|s
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
operator|+
literal|1
argument_list|,
name|institutionDone
condition|?
name|s
operator|.
name|indexOf
argument_list|(
literal|')'
argument_list|)
else|:
name|s
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
name|s
operator|=
name|readLine
argument_list|(
name|in
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|author
operator|!=
literal|null
condition|)
block|{
name|authors
operator|+=
operator|!
name|authors
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|?
literal|" and "
operator|+
name|author
else|:
literal|""
operator|+
name|author
expr_stmt|;
block|}
if|if
condition|(
name|institution
operator|!=
literal|null
condition|)
block|{
name|institutions
operator|+=
operator|!
name|institutions
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|?
literal|"and "
operator|+
name|institution
else|:
literal|""
operator|+
name|institution
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|authors
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|be
operator|.
name|setField
argument_list|(
literal|"author"
argument_list|,
name|authors
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|institutions
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|be
operator|.
name|setField
argument_list|(
literal|"institution"
argument_list|,
name|institutions
argument_list|)
expr_stmt|;
block|}
comment|// skip empty line
name|s
operator|=
name|readLine
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|// read abstract
name|String
name|theabstract
init|=
literal|""
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
operator|&&
operator|!
name|s
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|&&
operator|!
name|startsWithKeyword
argument_list|(
name|s
argument_list|,
name|recognizedFields
argument_list|)
condition|)
block|{
name|theabstract
operator|+=
literal|" "
operator|+
name|s
operator|.
name|trim
argument_list|()
expr_stmt|;
name|s
operator|=
name|readLine
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
name|theabstract
operator|=
name|theabstract
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|theabstract
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|be
operator|.
name|setField
argument_list|(
literal|"abstract"
argument_list|,
name|theabstract
argument_list|)
expr_stmt|;
block|}
comment|// read other fields
while|while
condition|(
name|startsWithKeyword
argument_list|(
name|s
argument_list|,
name|recognizedFields
argument_list|)
condition|)
block|{
comment|// if field consists of multiple lines, join them
name|String
name|field
init|=
name|s
decl_stmt|;
name|s
operator|=
name|readLine
argument_list|(
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
operator|&&
operator|!
name|s
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|&&
operator|!
name|startsWithKeyword
argument_list|(
name|s
argument_list|,
name|recognizedFields
argument_list|)
condition|)
block|{
name|field
operator|+=
literal|" "
operator|+
name|s
operator|.
name|trim
argument_list|()
expr_stmt|;
name|s
operator|=
name|readLine
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
name|String
name|content
init|=
name|field
operator|.
name|substring
argument_list|(
name|field
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
operator|+
literal|1
argument_list|,
name|field
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
comment|// now field keyword-content
if|if
condition|(
name|field
operator|.
name|startsWith
argument_list|(
literal|"Keywords:"
argument_list|)
condition|)
block|{
name|String
index|[]
name|keywords
init|=
name|content
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|String
name|keywordStr
init|=
literal|""
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keywords
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|keywordStr
operator|+=
literal|" '"
operator|+
name|keywords
index|[
name|i
index|]
operator|.
name|trim
argument_list|()
operator|+
literal|"'"
expr_stmt|;
block|}
name|be
operator|.
name|setField
argument_list|(
literal|"keywords"
argument_list|,
name|keywordStr
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|startsWith
argument_list|(
literal|"JEL:"
argument_list|)
condition|)
block|{
name|be
operator|.
name|setField
argument_list|(
literal|"jel"
argument_list|,
name|content
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|startsWith
argument_list|(
literal|"Date:"
argument_list|)
condition|)
block|{
name|Date
name|date
init|=
literal|null
decl_stmt|;
try|try
block|{
name|date
operator|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyy-MM-dd"
argument_list|)
operator|.
name|parse
argument_list|(
name|content
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
comment|// wrong format
block|}
if|if
condition|(
name|date
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|date
operator|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyy-MM"
argument_list|)
operator|.
name|parse
argument_list|(
name|content
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
comment|// wrong format
block|}
block|}
name|Calendar
name|cal
init|=
operator|new
name|GregorianCalendar
argument_list|()
decl_stmt|;
if|if
condition|(
name|date
operator|!=
literal|null
condition|)
block|{
name|cal
operator|.
name|setTime
argument_list|(
name|date
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cal
operator|.
name|setTime
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|year
init|=
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
decl_stmt|;
name|int
name|month
init|=
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|)
decl_stmt|;
name|be
operator|.
name|setField
argument_list|(
literal|"year"
argument_list|,
literal|""
operator|+
name|year
argument_list|)
expr_stmt|;
name|be
operator|.
name|setField
argument_list|(
literal|"month"
argument_list|,
literal|""
operator|+
name|month
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|startsWith
argument_list|(
literal|"URL:"
argument_list|)
condition|)
block|{
name|be
operator|.
name|setField
argument_list|(
literal|"url"
argument_list|,
name|content
argument_list|)
expr_stmt|;
block|}
block|}
name|bibitems
operator|.
name|add
argument_list|(
name|be
argument_list|)
expr_stmt|;
name|paperNoStr
operator|=
literal|null
expr_stmt|;
block|}
name|prevLine
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|readLine
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|String
name|message
init|=
literal|"Error in REPEC-NEP import on line "
operator|+
name|this
operator|.
name|line
decl_stmt|;
if|if
condition|(
name|paperNoStr
operator|!=
literal|null
condition|)
block|{
name|message
operator|+=
literal|", paper no. "
operator|+
name|paperNoStr
operator|+
literal|": "
expr_stmt|;
block|}
name|message
operator|+=
name|e
operator|.
name|getMessage
argument_list|()
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|e
operator|instanceof
name|IOException
operator|)
condition|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|e
operator|=
operator|new
name|IOException
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|(
name|IOException
operator|)
name|e
throw|;
block|}
return|return
name|bibitems
return|;
block|}
block|}
end_class

end_unit

