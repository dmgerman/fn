begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2003 Morten O. Alver and Nizar N. Batada  *  * All programs in this directory and subdirectories are published under the GNU  * General Public License as described below.  *  * This program is free software; you can redistribute it and/or modify it under  * the terms of the GNU General Public License as published by the Free Software  * Foundation; either version 2 of the License, or (at your option) any later  * version.  *  * This program is distributed in the hope that it will be useful, but WITHOUT  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  * details.  *  * You should have received a copy of the GNU General Public License along with  * this program; if not, write to the Free Software Foundation, Inc., 59 Temple  * Place, Suite 330, Boston, MA 02111-1307 USA  *  * Further information about the GNU GPL is available at:  * http://www.gnu.org/copyleft/gpl.ja.html  *  */
end_comment

begin_package
DECL|package|net.sf.jabref.imports
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|imports
package|;
end_package

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexDatabase
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexEntryType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|GUIGlobals
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|Globals
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|KeyCollisionException
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|HttpURLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|WeakHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|*
import|;
end_import

begin_comment
comment|/*  * // int jabrefframe BibtexDatabase database=new BibtexDatabase(); String  * filename=Globals.getNewFile(); ArrayList bibitems=readISI(filename); // is  * there a getFileName(); Iterator it = bibitems.iterator();  * while(it.hasNext()){ BibtexEntry entry = (BibtexEntry)it.next();  * entry.setId(Util.createId(entry.getType(), database); try {  * database.insertEntry(entry); } catch (KeyCollisionException ex) {  *  } }  */
end_comment

begin_class
DECL|class|ImportFormatReader
specifier|public
class|class
name|ImportFormatReader
block|{
DECL|field|BIBTEX_FORMAT
specifier|public
specifier|static
name|String
name|BIBTEX_FORMAT
init|=
literal|"BibTeX"
decl_stmt|;
DECL|field|SPACE_MARKER
specifier|private
specifier|final
specifier|static
name|String
name|SPACE_MARKER
init|=
literal|"__SPC__"
decl_stmt|;
DECL|field|bracketsPattern
specifier|private
specifier|final
specifier|static
name|Pattern
name|bracketsPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\{.*\\}"
argument_list|)
decl_stmt|,
DECL|field|spaceMarkerPattern
name|spaceMarkerPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|SPACE_MARKER
argument_list|)
decl_stmt|;
comment|/* Use a WeakHashMAp for storing cached names, so the cached mapping will not prevent      * an obsoleted name string from being garbage collected.      */
DECL|field|nameCacheLastFirst
specifier|private
specifier|final
specifier|static
name|Map
name|nameCacheLastFirst
init|=
operator|new
name|WeakHashMap
argument_list|()
decl_stmt|;
DECL|field|nameCacheFirstFirst
specifier|private
specifier|final
specifier|static
name|Map
name|nameCacheFirstFirst
init|=
operator|new
name|WeakHashMap
argument_list|()
decl_stmt|;
DECL|field|formats
specifier|private
name|TreeMap
name|formats
init|=
operator|new
name|TreeMap
argument_list|()
decl_stmt|;
DECL|method|ImportFormatReader ()
specifier|public
name|ImportFormatReader
parameter_list|()
block|{
comment|// Add all our importers to the TreeMap. The map is used to build the import
comment|// menus, and to resolve command-line import instructions.
name|formats
operator|.
name|put
argument_list|(
literal|"csa"
argument_list|,
operator|new
name|CsaImporter
argument_list|()
argument_list|)
expr_stmt|;
name|formats
operator|.
name|put
argument_list|(
literal|"isi"
argument_list|,
operator|new
name|IsiImporter
argument_list|()
argument_list|)
expr_stmt|;
name|formats
operator|.
name|put
argument_list|(
literal|"refer"
argument_list|,
operator|new
name|EndnoteImporter
argument_list|()
argument_list|)
expr_stmt|;
name|formats
operator|.
name|put
argument_list|(
literal|"medline"
argument_list|,
operator|new
name|MedlineImporter
argument_list|()
argument_list|)
expr_stmt|;
name|formats
operator|.
name|put
argument_list|(
literal|"bibtexml"
argument_list|,
operator|new
name|BibteXMLImporter
argument_list|()
argument_list|)
expr_stmt|;
name|formats
operator|.
name|put
argument_list|(
literal|"biblioscape"
argument_list|,
operator|new
name|BiblioscapeImporter
argument_list|()
argument_list|)
expr_stmt|;
name|formats
operator|.
name|put
argument_list|(
literal|"sixpack"
argument_list|,
operator|new
name|SixpackImporter
argument_list|()
argument_list|)
expr_stmt|;
name|formats
operator|.
name|put
argument_list|(
literal|"inspec"
argument_list|,
operator|new
name|InspecImporter
argument_list|()
argument_list|)
expr_stmt|;
name|formats
operator|.
name|put
argument_list|(
literal|"scifinder"
argument_list|,
operator|new
name|ScifinderImporter
argument_list|()
argument_list|)
expr_stmt|;
name|formats
operator|.
name|put
argument_list|(
literal|"ovid"
argument_list|,
operator|new
name|OvidImporter
argument_list|()
argument_list|)
expr_stmt|;
name|formats
operator|.
name|put
argument_list|(
literal|"ris"
argument_list|,
operator|new
name|RisImporter
argument_list|()
argument_list|)
expr_stmt|;
name|formats
operator|.
name|put
argument_list|(
literal|"jstor"
argument_list|,
operator|new
name|JstorImporter
argument_list|()
argument_list|)
expr_stmt|;
name|formats
operator|.
name|put
argument_list|(
literal|"silverplatter"
argument_list|,
operator|new
name|SilverPlatterImporter
argument_list|()
argument_list|)
expr_stmt|;
name|formats
operator|.
name|put
argument_list|(
literal|"biomail"
argument_list|,
operator|new
name|BiomailImporter
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|clearNameCache ()
specifier|public
specifier|static
name|void
name|clearNameCache
parameter_list|()
block|{
name|nameCacheLastFirst
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nameCacheFirstFirst
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|importFromStream (String format, InputStream in)
specifier|public
name|List
name|importFromStream
parameter_list|(
name|String
name|format
parameter_list|,
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|Object
name|o
init|=
name|formats
operator|.
name|get
argument_list|(
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown import format: "
operator|+
name|format
argument_list|)
throw|;
name|ImportFormat
name|importer
init|=
operator|(
name|ImportFormat
operator|)
name|o
decl_stmt|;
name|List
name|res
init|=
name|importer
operator|.
name|importEntries
argument_list|(
name|in
argument_list|)
decl_stmt|;
comment|// Remove all empty entries
if|if
condition|(
name|res
operator|!=
literal|null
condition|)
name|purgeEmptyEntries
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
DECL|method|importFromFile (String format, String filename)
specifier|public
name|List
name|importFromFile
parameter_list|(
name|String
name|format
parameter_list|,
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
name|Object
name|o
init|=
name|formats
operator|.
name|get
argument_list|(
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown import format: "
operator|+
name|format
argument_list|)
throw|;
name|ImportFormat
name|importer
init|=
operator|(
name|ImportFormat
operator|)
name|o
decl_stmt|;
comment|//System.out.println(importer.getFormatName());
return|return
name|importFromFile
argument_list|(
name|importer
argument_list|,
name|filename
argument_list|)
return|;
block|}
DECL|method|importFromFile (ImportFormat importer, String filename)
specifier|public
name|List
name|importFromFile
parameter_list|(
name|ImportFormat
name|importer
parameter_list|,
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|InputStream
name|stream
init|=
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|importer
operator|.
name|isRecognizedFormat
argument_list|(
name|stream
argument_list|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Wrong file format"
argument_list|)
argument_list|)
throw|;
name|stream
operator|=
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|importer
operator|.
name|importEntries
argument_list|(
name|stream
argument_list|)
return|;
block|}
DECL|method|createDatabase (List bibentries)
specifier|public
specifier|static
name|BibtexDatabase
name|createDatabase
parameter_list|(
name|List
name|bibentries
parameter_list|)
block|{
name|purgeEmptyEntries
argument_list|(
name|bibentries
argument_list|)
expr_stmt|;
name|BibtexDatabase
name|database
init|=
operator|new
name|BibtexDatabase
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|bibentries
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BibtexEntry
name|entry
init|=
operator|(
name|BibtexEntry
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|entry
operator|.
name|setId
argument_list|(
name|Util
operator|.
name|createNeutralId
argument_list|()
argument_list|)
expr_stmt|;
name|database
operator|.
name|insertEntry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeyCollisionException
name|ex
parameter_list|)
block|{
comment|//ignore
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"KeyCollisionException [ addBibEntries(...) ]"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|database
return|;
block|}
DECL|method|getImportFormats ()
specifier|public
name|Set
name|getImportFormats
parameter_list|()
block|{
return|return
name|formats
operator|.
name|entrySet
argument_list|()
return|;
block|}
DECL|method|getImportFormatList ()
specifier|public
name|String
name|getImportFormatList
parameter_list|()
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|formats
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|format
init|=
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|ImportFormat
name|imFo
init|=
operator|(
name|ImportFormat
operator|)
name|formats
operator|.
name|get
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|int
name|pad
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
literal|14
operator|-
name|imFo
operator|.
name|getFormatName
argument_list|()
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|imFo
operator|.
name|getFormatName
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|pad
condition|;
name|j
operator|++
control|)
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" : "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|String
name|res
init|=
name|sb
operator|.
name|toString
argument_list|()
decl_stmt|;
return|return
name|res
return|;
comment|//.substring(0, res.length()-1);
block|}
comment|//MK:vvv Methods fixAuthor_firstNameFirst(String) and fixAuthor_lastnameFirst(String) are re-written
comment|//  /**
comment|//   * Describe<code>fixAuthor</code> method here.
comment|//   *
comment|//   * @param in
comment|//   *          a<code>String</code> value
comment|//   * @return a<code>String</code> value // input format string: LN FN [and
comment|//   *         LN, FN]* // output format string: FN LN [and FN LN]*
comment|//   */
comment|//    public static String fixAuthor_firstNameFirst(final String inOrig) {
comment|//
comment|//	String in = inOrig;
comment|//
comment|//	// Check if we have cached this particular name string before:
comment|//	Object old = nameCacheFirstFirst.get(in); if (old != null) return (String)old;
comment|//
comment|//	StringBuffer sb = new StringBuffer();
comment|//
comment|//	//System.out.println("FIX AUTHOR: in= " + in);
comment|//	String[] authors = in.split(" and ");
comment|//
comment|//	for (int i = 0; i< authors.length; i++) {
comment|//	    authors[i] = authors[i].trim();
comment|//
comment|//	    String[] t = authors[i].split(",");
comment|//
comment|//	    if (t.length< 2)
comment|//		// there is no comma, assume we have FN LN order
comment|//		sb.append(authors[i].trim());
comment|//	    else
comment|//		sb.append(t[1].trim() + " " + t[0].trim());
comment|//
comment|//	    if (i != (authors.length - 1)) // put back the " and "
comment|//		sb.append(" and ");
comment|//
comment|//	    //	    if (i == (authors.length - 2))
comment|//	    //		sb.append(" and ");
comment|//	    //	    else if (i != (authors.length - 1))
comment|//	    //		sb.append(", ");
comment|//	}
comment|//
comment|//	String fixed = sb.toString();
comment|//
comment|//	// Cache this transformation so we don't have to repeat it unnecessarily:
comment|//	nameCacheFirstFirst.put(inOrig, fixed);
comment|//
comment|//	return fixed;
comment|//    }
comment|//
comment|//  //========================================================
comment|//  // rearranges the author names
comment|//  // input format string: LN, FN [and LN, FN]*
comment|//  // output format string: LN, FN [and LN, FN]*
comment|//  //========================================================
comment|//  public static String fixAuthor_lastnameFirst(final String inOrig) {
comment|//
comment|//      String in = inOrig;
comment|//
comment|//      // Check if we have cached this particular name string before:
comment|//      Object old = nameCacheLastFirst.get(in); if (old != null) return (String)old;
comment|//
comment|//      if (in.indexOf("{")>= 0) {
comment|//	  StringBuffer tmp = new StringBuffer();
comment|//	  int start = -1, end = 0;
comment|//	  while ((start = in.indexOf("{", end))> -1) {
comment|//              tmp.append(in.substring(end, start));
comment|//	      end = in.indexOf("}", start);
comment|//	      if (end> 0) {
comment|//		  tmp.append(in.substring(start, end).replaceAll(" ", SPACE_MARKER));
comment|//	      } else if (end< 0) {
comment|//                  // The braces are mismatched, so give up this.
comment|//                  tmp.append(in.substring(start));
comment|//                  break;
comment|//              }
comment|//	  }
comment|//	  if ((end> 0)&& (end< in.length()))
comment|//	      tmp.append(in.substring(end));
comment|//
comment|//	  in = tmp.toString();
comment|//
comment|//      }
comment|//
comment|//    StringBuffer sb = new StringBuffer();
comment|//
comment|//    String[] authors = in.split(" and ");
comment|//
comment|//    for (int i = 0; i< authors.length; i++) {
comment|//      authors[i] = authors[i].trim();
comment|//
comment|//      int comma = authors[i].indexOf(",");
comment|//test:
comment|//      if (comma>= 0) {
comment|//          // There is a comma, so we assume it's ok. Fix it so there is no white
comment|//          // space in front of the comma, and one space after:
comment|//          String[] parts = authors[i].split(",");
comment|//          sb.append(parts[0].trim());
comment|//          for (int part=1; part<parts.length; part++) {
comment|//              sb.append(", ");
comment|//              sb.append(parts[part].trim());
comment|//          }
comment|//          //sb.append(authors[i]);
comment|//      }
comment|//      else {
comment|//        // The name is without a comma, so it must be rearranged.
comment|//        int pos = authors[i].lastIndexOf(' ');
comment|//
comment|//        if (pos == -1) {
comment|//          // No spaces. Give up and just add the name.
comment|//          sb.append(authors[i]);
comment|//
comment|//          break test;
comment|//        }
comment|//
comment|//        String surname = authors[i].substring(pos + 1).trim();
comment|//
comment|//        if (surname.equalsIgnoreCase("jr.")) {
comment|//          pos = authors[i].lastIndexOf(' ', pos - 1);
comment|//
comment|//          if (pos == -1) {
comment|//            // Only last name and jr?
comment|//            sb.append(authors[i]);
comment|//
comment|//            break test;
comment|//          } else
comment|//            surname = authors[i].substring(pos + 1);
comment|//        }
comment|//
comment|//        // Ok, we've isolated the last name. Put together the rearranged name:
comment|//        sb.append(surname + ", ");
comment|//        sb.append(authors[i].substring(0, pos).trim());
comment|//      }
comment|//
comment|//      if (i != (authors.length - 1))
comment|//        sb.append(" and ");
comment|//    }
comment|//
comment|//    /*
comment|//     * String[] t = authors[i].split(","); if(t.length< 2) { // The name is
comment|//     * without a comma, so it must be rearranged. t = authors[i].split(" "); if
comment|//     * (t.length> 1) { sb.append(t[t.length - 1]+ ","); // Last name for (int
comment|//     * j=0; j<t.length-1; j++) sb.append(" "+t[j]); } else if (t.length> 0)
comment|//     * sb.append(t[0]); } else { // The name is written with last name first, so
comment|//     * it's ok. sb.append(authors[i]); }
comment|//     *
comment|//     * if(i !=authors.length-1) sb.append(" and ");
comment|//     *  }
comment|//     */
comment|//
comment|//    //Util.pr(in+" -> "+sb.toString());
comment|//    String fixed = sb.toString();
comment|//
comment|//    if (spaceMarkerPattern.matcher(fixed).find())
comment|//	fixed = fixed.replaceAll(SPACE_MARKER, " ");
comment|//
comment|//    // Cache this transformation so we don't have to repeat it unnecessarily:
comment|//    nameCacheLastFirst.put(inOrig, fixed);
comment|//
comment|//    return fixed;
comment|//  }
DECL|method|fixAuthor_Natbib (final String inOrig)
specifier|public
specifier|static
name|String
name|fixAuthor_Natbib
parameter_list|(
specifier|final
name|String
name|inOrig
parameter_list|)
block|{
name|AuthorList
name|authors
init|=
operator|new
name|AuthorList
argument_list|(
name|inOrig
argument_list|)
decl_stmt|;
return|return
name|authors
operator|.
name|getAuthorsNatbib
argument_list|()
return|;
block|}
DECL|method|fixAuthor_firstNameFirstCommas (final String inOrig, final boolean abbr)
specifier|public
specifier|static
name|String
name|fixAuthor_firstNameFirstCommas
parameter_list|(
specifier|final
name|String
name|inOrig
parameter_list|,
specifier|final
name|boolean
name|abbr
parameter_list|)
block|{
name|AuthorList
name|authors
init|=
operator|new
name|AuthorList
argument_list|(
name|inOrig
argument_list|)
decl_stmt|;
return|return
name|authors
operator|.
name|getAuthorsFirstLast
argument_list|(
name|abbr
argument_list|)
return|;
block|}
DECL|method|fixAuthor_firstNameFirst (final String inOrig)
specifier|public
specifier|static
name|String
name|fixAuthor_firstNameFirst
parameter_list|(
specifier|final
name|String
name|inOrig
parameter_list|)
block|{
name|AuthorList
name|authors
init|=
operator|new
name|AuthorList
argument_list|(
name|inOrig
argument_list|)
decl_stmt|;
return|return
name|authors
operator|.
name|getAuthorsFirstLastAnds
argument_list|()
return|;
block|}
DECL|method|fixAuthor_lastnameFirstCommas (final String inOrig, final boolean abbr)
specifier|public
specifier|static
name|String
name|fixAuthor_lastnameFirstCommas
parameter_list|(
specifier|final
name|String
name|inOrig
parameter_list|,
specifier|final
name|boolean
name|abbr
parameter_list|)
block|{
name|AuthorList
name|authors
init|=
operator|new
name|AuthorList
argument_list|(
name|inOrig
argument_list|)
decl_stmt|;
return|return
name|authors
operator|.
name|getAuthorsLastFirst
argument_list|(
name|abbr
argument_list|)
return|;
block|}
DECL|method|fixAuthor_lastnameFirst (final String inOrig)
specifier|public
specifier|static
name|String
name|fixAuthor_lastnameFirst
parameter_list|(
specifier|final
name|String
name|inOrig
parameter_list|)
block|{
name|String
name|in
init|=
name|inOrig
decl_stmt|;
comment|// Check if we have cached this particular name string before:
name|Object
name|old
init|=
name|nameCacheLastFirst
operator|.
name|get
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
return|return
operator|(
name|String
operator|)
name|old
return|;
if|if
condition|(
name|in
operator|.
name|indexOf
argument_list|(
literal|"{"
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|StringBuffer
name|tmp
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|int
name|start
init|=
operator|-
literal|1
decl_stmt|,
name|end
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|start
operator|=
name|in
operator|.
name|indexOf
argument_list|(
literal|"{"
argument_list|,
name|end
argument_list|)
operator|)
operator|>
operator|-
literal|1
condition|)
block|{
name|tmp
operator|.
name|append
argument_list|(
name|in
operator|.
name|substring
argument_list|(
name|end
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|end
operator|=
name|in
operator|.
name|indexOf
argument_list|(
literal|"}"
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|>
literal|0
condition|)
block|{
name|tmp
operator|.
name|append
argument_list|(
name|in
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|" "
argument_list|,
name|SPACE_MARKER
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|end
operator|<
literal|0
condition|)
block|{
comment|// The braces are mismatched, so give up this.
name|tmp
operator|.
name|append
argument_list|(
name|in
operator|.
name|substring
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|end
operator|>
literal|0
operator|)
operator|&&
operator|(
name|end
operator|<
name|in
operator|.
name|length
argument_list|()
operator|)
condition|)
name|tmp
operator|.
name|append
argument_list|(
name|in
operator|.
name|substring
argument_list|(
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
name|tmp
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|String
index|[]
name|authors
init|=
name|in
operator|.
name|split
argument_list|(
literal|" and "
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|authors
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|authors
index|[
name|i
index|]
operator|=
name|authors
index|[
name|i
index|]
operator|.
name|trim
argument_list|()
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|fixSingleAuthor_lastNameFirst
argument_list|(
name|authors
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
name|authors
operator|.
name|length
operator|-
literal|1
operator|)
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
block|}
name|String
name|fixed
init|=
name|sb
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|spaceMarkerPattern
operator|.
name|matcher
argument_list|(
name|fixed
argument_list|)
operator|.
name|find
argument_list|()
condition|)
name|fixed
operator|=
name|fixed
operator|.
name|replaceAll
argument_list|(
name|SPACE_MARKER
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|// Cache this transformation so we don't have to repeat it unnecessarily:
name|nameCacheLastFirst
operator|.
name|put
argument_list|(
name|inOrig
argument_list|,
name|fixed
argument_list|)
expr_stmt|;
return|return
name|fixed
return|;
block|}
DECL|method|fixAuthor_lastnameOnly (final String inOrig)
specifier|public
specifier|static
name|String
name|fixAuthor_lastnameOnly
parameter_list|(
specifier|final
name|String
name|inOrig
parameter_list|)
block|{
name|String
name|in
init|=
name|inOrig
decl_stmt|;
comment|// // Check if we have cached this particular name string before:
comment|//Object old = nameCacheLastFirst.get(in); if (old != null) return (String)old;
if|if
condition|(
name|in
operator|.
name|indexOf
argument_list|(
literal|"{"
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|StringBuffer
name|tmp
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|int
name|start
init|=
operator|-
literal|1
decl_stmt|,
name|end
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|start
operator|=
name|in
operator|.
name|indexOf
argument_list|(
literal|"{"
argument_list|,
name|end
argument_list|)
operator|)
operator|>
operator|-
literal|1
condition|)
block|{
name|tmp
operator|.
name|append
argument_list|(
name|in
operator|.
name|substring
argument_list|(
name|end
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|end
operator|=
name|in
operator|.
name|indexOf
argument_list|(
literal|"}"
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|>
literal|0
condition|)
block|{
name|tmp
operator|.
name|append
argument_list|(
name|in
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|" "
argument_list|,
name|SPACE_MARKER
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|end
operator|<
literal|0
condition|)
block|{
comment|// The braces are mismatched, so give up this.
name|tmp
operator|.
name|append
argument_list|(
name|in
operator|.
name|substring
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|end
operator|>
literal|0
operator|)
operator|&&
operator|(
name|end
operator|<
name|in
operator|.
name|length
argument_list|()
operator|)
condition|)
name|tmp
operator|.
name|append
argument_list|(
name|in
operator|.
name|substring
argument_list|(
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
name|tmp
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|String
index|[]
name|authors
init|=
name|in
operator|.
name|split
argument_list|(
literal|" and "
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|authors
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|authors
index|[
name|i
index|]
operator|=
name|authors
index|[
name|i
index|]
operator|.
name|trim
argument_list|()
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|fixSingleAuthor_lastNameOnly
argument_list|(
name|authors
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|authors
operator|.
name|length
operator|-
literal|2
operator|)
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|authors
operator|.
name|length
operator|-
literal|2
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
block|}
name|String
name|fixed
init|=
name|sb
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|spaceMarkerPattern
operator|.
name|matcher
argument_list|(
name|fixed
argument_list|)
operator|.
name|find
argument_list|()
condition|)
name|fixed
operator|=
name|fixed
operator|.
name|replaceAll
argument_list|(
name|SPACE_MARKER
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|// // Cache this transformation so we don't have to repeat it unnecessarily:
comment|// nameCacheLastFirst.put(inOrig, fixed);
return|return
name|fixed
return|;
block|}
DECL|method|fixAuthorForAlphabetization (final String inOrig)
specifier|public
specifier|static
name|String
name|fixAuthorForAlphabetization
parameter_list|(
specifier|final
name|String
name|inOrig
parameter_list|)
block|{
name|String
name|in
init|=
name|inOrig
decl_stmt|;
if|if
condition|(
name|in
operator|.
name|indexOf
argument_list|(
literal|"{"
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|StringBuffer
name|tmp
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|int
name|start
init|=
operator|-
literal|1
decl_stmt|,
name|end
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|start
operator|=
name|in
operator|.
name|indexOf
argument_list|(
literal|"{"
argument_list|,
name|end
argument_list|)
operator|)
operator|>
operator|-
literal|1
condition|)
block|{
name|tmp
operator|.
name|append
argument_list|(
name|in
operator|.
name|substring
argument_list|(
name|end
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|end
operator|=
name|in
operator|.
name|indexOf
argument_list|(
literal|"}"
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|>
literal|0
condition|)
block|{
name|tmp
operator|.
name|append
argument_list|(
name|in
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|" "
argument_list|,
name|SPACE_MARKER
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|end
operator|<
literal|0
condition|)
block|{
comment|// The braces are mismatched, so give up this.
name|tmp
operator|.
name|append
argument_list|(
name|in
operator|.
name|substring
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|end
operator|>
literal|0
operator|)
operator|&&
operator|(
name|end
operator|<
name|in
operator|.
name|length
argument_list|()
operator|)
condition|)
name|tmp
operator|.
name|append
argument_list|(
name|in
operator|.
name|substring
argument_list|(
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
name|tmp
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|String
index|[]
name|authors
init|=
name|in
operator|.
name|split
argument_list|(
literal|" and "
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|authors
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|authors
index|[
name|i
index|]
operator|=
name|authors
index|[
name|i
index|]
operator|.
name|trim
argument_list|()
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getSortableNameForm
argument_list|(
name|authors
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
name|authors
operator|.
name|length
operator|-
literal|1
operator|)
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
block|}
name|String
name|fixed
init|=
name|sb
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|spaceMarkerPattern
operator|.
name|matcher
argument_list|(
name|fixed
argument_list|)
operator|.
name|find
argument_list|()
condition|)
name|fixed
operator|=
name|fixed
operator|.
name|replaceAll
argument_list|(
name|SPACE_MARKER
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
return|return
name|fixed
return|;
block|}
comment|/* int comma = authors[i].indexOf(","); test:  if (comma>= 0) { // There is a comma, so we assume it's ok. Fix it so there is no white // space in front of the comma, and one space after: String[] parts = authors[i].split(","); sb.append(parts[0].trim()); for (int part=1; part<parts.length; part++) { sb.append(", "); sb.append(parts[part].trim()); } //sb.append(authors[i]); } else { // The name is without a comma, so it must be rearranged. int pos = authors[i].lastIndexOf(' ');  if (pos == -1) { // No spaces. Give up and just add the name. sb.append(authors[i]);  break test; }  String surname = authors[i].substring(pos + 1).trim();  if (surname.equalsIgnoreCase("jr.")) { pos = authors[i].lastIndexOf(' ', pos - 1);  if (pos == -1) { // Only last name and jr? sb.append(authors[i]);  break test; } else surname = authors[i].substring(pos + 1); }  // Ok, we've isolated the last name. Put together the rearranged name: sb.append(surname + ", "); sb.append(authors[i].substring(0, pos).trim()); }                    */
DECL|method|isVonParticle (String name)
specifier|public
specifier|static
name|boolean
name|isVonParticle
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|Globals
operator|.
name|NAME_PARTICLES
operator|.
name|contains
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**      * Rearranges a single name to "Lastname, Firstname" format. Particles like "von" and      * "de la" are considered part of the last name, and placed in front.      * @param name The name to rearrange.      * @return The rearranged name.      */
DECL|method|fixSingleAuthor_lastNameFirst (String name)
specifier|private
specifier|static
name|String
name|fixSingleAuthor_lastNameFirst
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|int
name|commaPos
init|=
name|name
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|)
decl_stmt|;
if|if
condition|(
name|commaPos
operator|==
operator|-
literal|1
condition|)
block|{
comment|// No comma: name in "Firstname Lastname" form.
name|String
index|[]
name|parts
init|=
name|name
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
name|int
name|piv
init|=
name|parts
operator|.
name|length
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|piv
operator|<
literal|0
condition|)
return|return
name|name
return|;
comment|// Empty name...
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
comment|// Add "jr" particle(s) if any:
while|while
condition|(
name|Globals
operator|.
name|JUNIOR_PARTICLES
operator|.
name|contains
argument_list|(
name|parts
index|[
name|piv
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|parts
index|[
name|piv
index|]
argument_list|)
expr_stmt|;
name|piv
operator|--
expr_stmt|;
block|}
comment|// Add the last name:
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|parts
index|[
name|piv
index|]
argument_list|)
expr_stmt|;
name|piv
operator|--
expr_stmt|;
comment|// Then add the ones before, as long as they are von particles:
while|while
condition|(
operator|(
name|piv
operator|>
literal|0
operator|)
operator|&&
name|isVonParticle
argument_list|(
name|parts
index|[
name|piv
index|]
argument_list|)
condition|)
block|{
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|parts
index|[
name|piv
index|]
argument_list|)
expr_stmt|;
name|piv
operator|--
expr_stmt|;
block|}
comment|// Add a comma, a space and the first name(s):
if|if
condition|(
name|piv
operator|>=
literal|0
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|piv
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|parts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
else|else
block|{
name|int
name|splitPos
init|=
name|Math
operator|.
name|min
argument_list|(
name|name
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
name|commaPos
operator|+
literal|1
argument_list|)
decl_stmt|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|(
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|splitPos
argument_list|)
argument_list|)
decl_stmt|;
comment|//System.out.println("'"+sb.toString()+"'");
name|String
index|[]
name|restParts
init|=
name|name
operator|.
name|substring
argument_list|(
name|splitPos
argument_list|)
operator|.
name|trim
argument_list|()
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
name|int
name|piv
init|=
name|restParts
operator|.
name|length
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|(
name|piv
operator|>
literal|0
operator|)
operator|&&
name|isVonParticle
argument_list|(
name|restParts
index|[
name|piv
index|]
argument_list|)
condition|)
block|{
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|restParts
index|[
name|piv
index|]
argument_list|)
expr_stmt|;
name|piv
operator|--
expr_stmt|;
block|}
comment|//System.out.println("'"+sb.toString()+"'");
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|piv
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|restParts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**       * Rearranges a single name to "Lastname" format. Particles like "von" and       * "de la" are considered part of the last name, and placed in front.       * @param name The name to rearrange.       * @return The rearranged name.       */
DECL|method|fixSingleAuthor_lastNameOnly (String name)
specifier|private
specifier|static
name|String
name|fixSingleAuthor_lastNameOnly
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|int
name|commaPos
init|=
name|name
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|)
decl_stmt|;
if|if
condition|(
name|commaPos
operator|==
operator|-
literal|1
condition|)
block|{
comment|// No comma: name in "Firstname Lastname" form.
name|String
index|[]
name|parts
init|=
name|name
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
name|int
name|piv
init|=
name|parts
operator|.
name|length
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|piv
operator|<
literal|0
condition|)
return|return
name|name
return|;
comment|// Empty name...
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
comment|// Add "jr" particle(s) if any:
while|while
condition|(
name|Globals
operator|.
name|JUNIOR_PARTICLES
operator|.
name|contains
argument_list|(
name|parts
index|[
name|piv
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|parts
index|[
name|piv
index|]
argument_list|)
expr_stmt|;
name|piv
operator|--
expr_stmt|;
block|}
comment|// Add the last name:
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|parts
index|[
name|piv
index|]
argument_list|)
expr_stmt|;
name|piv
operator|--
expr_stmt|;
comment|// Then add the ones before, as long as they are von particles:
while|while
condition|(
operator|(
name|piv
operator|>
literal|0
operator|)
operator|&&
name|isVonParticle
argument_list|(
name|parts
index|[
name|piv
index|]
argument_list|)
condition|)
block|{
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|parts
index|[
name|piv
index|]
argument_list|)
expr_stmt|;
name|piv
operator|--
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
else|else
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|(
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|commaPos
argument_list|)
argument_list|)
decl_stmt|;
name|String
index|[]
name|restParts
init|=
name|name
operator|.
name|substring
argument_list|(
name|commaPos
argument_list|)
operator|.
name|trim
argument_list|()
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
name|int
name|piv
init|=
name|restParts
operator|.
name|length
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|(
name|piv
operator|>
literal|0
operator|)
operator|&&
name|isVonParticle
argument_list|(
name|restParts
index|[
name|piv
index|]
argument_list|)
condition|)
block|{
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|restParts
index|[
name|piv
index|]
argument_list|)
expr_stmt|;
name|piv
operator|--
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**      * Rearranges a single name to sortable "Lastname, Firstname" format.      * Particles like "von" and "de la" are placed behind the first name, as they are      * not to disturb sorting of names.      * @param name The name to rearrange.      * @return The rearranged name.      */
DECL|method|getSortableNameForm (String name)
specifier|private
specifier|static
name|String
name|getSortableNameForm
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|int
name|commaPos
init|=
name|name
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|)
decl_stmt|;
if|if
condition|(
name|commaPos
operator|==
operator|-
literal|1
condition|)
block|{
comment|// No comma: name in "Firstname Lastname" form.
name|String
index|[]
name|parts
init|=
name|name
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
name|int
name|piv
init|=
name|parts
operator|.
name|length
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|piv
operator|<
literal|0
condition|)
return|return
name|name
return|;
comment|// Count down past "jr" particle(s), if any:
while|while
condition|(
name|Globals
operator|.
name|JUNIOR_PARTICLES
operator|.
name|contains
argument_list|(
name|parts
index|[
name|piv
index|]
argument_list|)
condition|)
block|{
name|piv
operator|--
expr_stmt|;
block|}
comment|// Add the last name, including any "jr" particle(s):
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|(
name|parts
index|[
name|piv
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|piv
operator|+
literal|1
init|;
name|i
operator|<
name|parts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|parts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|piv
operator|--
expr_stmt|;
comment|// Add a comma, a space and the first name(s):
if|if
condition|(
name|piv
operator|>=
literal|0
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|piv
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|parts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
else|else
block|{
name|String
index|[]
name|lnParts
init|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|commaPos
argument_list|)
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
comment|// Count past any von particles in the last name:
name|int
name|piv
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|piv
operator|<
name|lnParts
operator|.
name|length
operator|-
literal|1
operator|)
operator|&&
name|isVonParticle
argument_list|(
name|lnParts
index|[
name|piv
index|]
argument_list|)
condition|)
name|piv
operator|++
expr_stmt|;
comment|// Start building the name, with the last name:
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|(
name|lnParts
index|[
name|piv
index|]
argument_list|)
decl_stmt|;
comment|// Add more lastnames if there are any:
for|for
control|(
name|int
name|i
init|=
name|piv
operator|+
literal|1
init|;
name|i
operator|<
name|lnParts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|lnParts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Add a comma:
name|sb
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
comment|// Add the first name(s):
name|int
name|splitPos
init|=
name|Math
operator|.
name|min
argument_list|(
name|name
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
name|commaPos
operator|+
literal|1
argument_list|)
decl_stmt|;
name|String
index|[]
name|fnParts
init|=
name|name
operator|.
name|substring
argument_list|(
name|splitPos
argument_list|)
operator|.
name|trim
argument_list|()
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fnParts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|fnParts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// If we counted past any von particles earlier, add them now:
if|if
condition|(
name|piv
operator|>
literal|0
condition|)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|piv
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|lnParts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Done.
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**      * Expand initials, e.g. EH Wissler -> E. H. Wissler or Wissler, EH -> Wissler, E. H.      * @param name      * @return      */
DECL|method|expandAuthorInitials (String name)
specifier|public
specifier|static
name|String
name|expandAuthorInitials
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
index|[]
name|authors
init|=
name|name
operator|.
name|split
argument_list|(
literal|" and "
argument_list|)
decl_stmt|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|authors
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|authors
index|[
name|i
index|]
operator|.
name|indexOf
argument_list|(
literal|", "
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|String
index|[]
name|names
init|=
name|authors
index|[
name|i
index|]
operator|.
name|split
argument_list|(
literal|", "
argument_list|)
decl_stmt|;
if|if
condition|(
name|names
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|names
operator|.
name|length
operator|>
literal|1
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|names
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|expandAll
argument_list|(
name|names
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
index|[]
name|names
init|=
name|authors
index|[
name|i
index|]
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
if|if
condition|(
name|names
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|expandAll
argument_list|(
name|names
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|names
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|names
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|authors
operator|.
name|length
operator|-
literal|1
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
return|;
block|}
comment|//------------------------------------------------------------------------------
comment|/**  * This is an immutable class representing information of either  *<CODE>author</CODE> or<CODE>editor</CODE> field in bibtex record.  *<p>  * Constructor performs parsing of raw field text and stores preformatted data.  * Various accessor methods return author/editor field in different formats.  *<p>  * Parsing algorithm is designed to satisfy two requirements:  * (a) when author's name is typed correctly, the result should  *     coincide with the one of BiBTeX;  * (b) for erroneous names, output should be reasonable (but may differ  *     from BiBTeX output).  * The following rules are used:  *<ol>  *<li> 'author field' is a sequence of tokens;  *<ul>  *<li> tokens are separated by sequences of whitespaces   *         (<CODE>Character.isWhitespace(c)==true</CODE>), commas (,),  *         dashes (-), and tildas (~);  *<li> every comma separates tokens, while sequences of other separators  *         are equivalent to a single separator; for example:  *         "a - b" consists of 2 tokens ("a" and "b"), while  *         "a,-,b" consists of 3 tokens ("a", "", and "b")  *<li> anything enclosed in braces belonges to a single token; for example:  *         "abc x{a,b,-~ c}x" consists of 2 tokens, while  *         "abc xa,b,-~ cx" consists of 4 tokens ("abc", "xa","b", and "cx");  *<li> a token followed immediately by a dash is "dash-terminated" token,  *         and all other tokens are "space-terminated" tokens; for example:  *         in "a-b- c - d" tokens "a" and "b" are dash-terminated and  *         "c" and "d" are space-terminated;  *<li> for the purposes of splitting of 'author name' into parts and  *         construction of abbreviation of first name,  *         one needs definitions of first latter of a token, case of a token,   *         and abbreviation of a token:  *<ul>  *<li> 'first letter' of a token is the first letter character  *              (<CODE>Character.isLetter(c)==true</CODE>) that does not  *              belong to a sequence of letters that immediately follows  *              "\" character, with one exception:  *              if "\" is followed by "aa", "AA", "ae", "AE", "l", "L", "o", "O",  *              "oe", "OE", "i", or "j" followed by non-letter, the 'first letter'  *              of a token is a letter that follows "\"; for example:  *              in "a{x}b" 'first letter' is "a",  *              in "{\"{U}}bel" 'first letter' is "U",  *              in "{\noopsort{\"o}}xyz" 'first letter' is "o",  *              in "{\AE}x" 'first letter' is "A",  *              in "\aex\ijk\Oe\j" 'first letter' is "j";  *              if there is no letter satisfying the above rule, 'first letter'  *              is undefined;  *<li> token is "lower-case" token, if its first letter id defined and  *              is lower-case (<CODE>Character.isLowerCase(c)==true</CODE>),  *              and token is "upper-case" token otherwise;  *<li> 'abbreviation' of a token is the shortest prefix of the token  *              that (a) contains 'first letter' and (b) is braces-balanced;  *              if 'first letter' is undefined, 'abbreviation' is the token  *              itself; in the above examples, 'abbreviation's are  *              "a", "{\"{U}}", "{\noopsort{\"o}}", "{\AE}", "\aex\ijk\Oe\j";  *</ul>  *<li> the behavior based on the above definitions will be erroneous only  *         in one case: if the first-name-token is "{\noopsort{A}}john",  *         we abbreviate it as "{\noopsort{A}}.", while BiBTeX produces "j.";  *         fixing this problem, however, requires processing of the preabmle;  *</ul>  *<li> 'author name's in 'author field' are subsequences of tokens separated  *      by token "and" ("and" is case-insensitive); if 'author name' is an  *      empty sequence of tokens, it is ignored; for examle, both  *      "John Smith and Peter Black" and "and and John Smith and and Peter Black"  *      consists of 2 'author name's "Johm Smith" and "Peter Black"  *      (in erroneous situations, this is a bit different from BiBTeX behavior);  *<li> 'author name' consists of 'first-part', 'von-part', 'last-part', and  *      'junior-part', each of which is a sequence of tokens;  *      how a sequence of tokens has to be splitted into these parts, depends  *      the number of commas:  *<ul>  *<li> no commas, all tokens are upper-case:  *          'junior-part' and 'von-part' are empty, 'last-part' consist  *          of the last token, 'first-part' consists of all other tokens  *          ('first-part' is empty, if 'author name' consists of a single token);  *          for example, in "John James Smith", 'last-part'="Smith" and  *          'first-part'="John James";  *<li> no commas, there exists lower-case token:  *          'junior-part' is empty, 'first-part' consists of all upper-case  *          tokens before the first lower-case token, 'von-part' consists of  *          lower-case tokens starting the first lower-case token and ending  *          the lower-case token that is followed by upper-case token,  *          'last-part' consists of the rest of tokens;  *          note that both 'first-part' and 'latst-part' may be empty and  *          'last-part' may contain lower-case tokens; for example:  *          in "von der", 'first-part'='last-part'="", 'von-part'="von der";  *          in "Charles Louis Xavier Joseph de la Vall{\'e}e la Poussin",  *          'first-part'="Charles Louis Xavier Joseph", 'von-part'="de la",  *          'last-part'="Vall{\'e}e la Poussin";  *<li> one comma:  *          'junior-part' is empty, 'first-part' consists of all tokens after comma,  *          'von-part' consists of the longest sequence of lower-case tokens  *          in the very beginning, 'last-part' consists of all tokens after  *          'von-part' and before comma; note that any part can be empty;  *          for example: in "de la Vall{\'e}e la Poussin, Charles Louis Xavier Joseph",  *          'first-part'="Charles Louis Xavier Joseph", 'von-part'="de la",  *          'last-part'="Vall{\'e}e la Poussin";  *          in "Joseph de la Vall{\'e}e la Poussin, Charles Louis Xavier",  *          'first-part'="Charles Louis Xavier", 'von-part'="",  *          'last-part'="Joseph de la Vall{\'e}e la Poussin";  *<li> two or more commas (any comma after the second one is ignored;  *          it merely separates tokens):  *          'junior-part' consists of all tokens between first and second commas,  *          'first-part' consists of all tokens after the second comma,  *          tokens before the first comma are splitted into 'von-part' and  *          'last-part' similarly to the case of one comma; for example:  *          in "de la Vall{\'e}e Poussin, Jr., Charles Louis Xavier Joseph",  *          'first-part'="Charles Louis Xavier Joseph", 'von-part'="de la",  *          'last-part'="Vall{\'e}e la Poussin", and 'junior-part'="Jr.";  *</ul>  *<li> when 'first-part', 'last-part', 'von-part', or 'junior-part' is reconstructed  *      from tokens, tokens in a part are separated either by space or by dash,  *      depending on whether the token before the separator was space-terminated  *      or dash-terminated; for the last token in a part it does not matter  *      whether it was dash- or space-terminated;  *<li> when 'first-part' is abbreviated, each token is replaced by its abbreviation  *      followed by a period; separators are the same as in the case of non-abbreviated  *      name; for example: in "Heinrich-{\"{U}}bel Kurt von Minich",  *      'first-part'="Heinrich-{\"{U}}bel Kurt", and its abbreviation is  *      "H.-{\"{U}}. K."  *</ol>  */
DECL|class|AuthorList
specifier|private
specifier|static
class|class
name|AuthorList
block|{
comment|// This is the only meaningful field after construction of the object
DECL|field|authors
specifier|private
name|Vector
name|authors
decl_stmt|;
comment|// of Author
comment|// The following variables are used only during parsing
DECL|field|orig
specifier|private
name|String
name|orig
decl_stmt|;
comment|// the raw bibtex author/editor field
comment|// the following variables are updated by getToken procedure
DECL|field|token_start
specifier|private
name|int
name|token_start
decl_stmt|;
comment|// index in orig
DECL|field|token_end
specifier|private
name|int
name|token_end
decl_stmt|;
comment|// to point 'abc' in '  abc xyz', start=2 and end=5
comment|// the following variables are valid only if getToken returns TOKEN_WORD
DECL|field|token_abbr
specifier|private
name|int
name|token_abbr
decl_stmt|;
comment|// end of token abbreviation (always: token_start< token_abbr<= token_end)
DECL|field|token_term
specifier|private
name|char
name|token_term
decl_stmt|;
comment|// either space or dash
DECL|field|token_case
specifier|private
name|boolean
name|token_case
decl_stmt|;
comment|// true if upper-case token, false if lower-case token
comment|// Tokens of one author name.
comment|// Each token occupies TGL consecutive entries in this vector (as described below)
DECL|field|tokens
specifier|private
name|Vector
name|tokens
decl_stmt|;
DECL|field|TOKEN_GROUP_LENGTH
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_GROUP_LENGTH
init|=
literal|4
decl_stmt|;
comment|// number of entries for a token
comment|// the following are offsets of an entry in a group of entries for one token
DECL|field|OFFSET_TOKEN
specifier|private
specifier|static
specifier|final
name|int
name|OFFSET_TOKEN
init|=
literal|0
decl_stmt|;
comment|// String -- token itself;
DECL|field|OFFSET_TOKEN_ABBR
specifier|private
specifier|static
specifier|final
name|int
name|OFFSET_TOKEN_ABBR
init|=
literal|1
decl_stmt|;
comment|// String -- token abbreviation;
DECL|field|OFFSET_TOKEN_TERM
specifier|private
specifier|static
specifier|final
name|int
name|OFFSET_TOKEN_TERM
init|=
literal|2
decl_stmt|;
comment|// Character -- token terminator (either " " or "-")
DECL|field|OFFSET_TOKEN_CASE
specifier|private
specifier|static
specifier|final
name|int
name|OFFSET_TOKEN_CASE
init|=
literal|3
decl_stmt|;
comment|// Boolean -- true=uppercase, false=lowercase
comment|// the following are indices in 'tokens' vector created during parsing of author name
comment|// and later used to properly split author name into parts
DECL|field|von_start
name|int
name|von_start
decl_stmt|,
comment|// first lower-case token (-1 if all tokens upper-case)
DECL|field|last_start
name|last_start
decl_stmt|,
comment|// first upper-case token after first lower-case token (-1 if does not exist)
DECL|field|comma_first
name|comma_first
decl_stmt|,
comment|// token after first comma (-1 if no commas)
DECL|field|comma_second
name|comma_second
decl_stmt|;
comment|// token after second comma (-1 if no commas or only one comma)
comment|// Token types (returned by getToken procedure)
DECL|field|TOKEN_EOF
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_EOF
init|=
literal|0
decl_stmt|;
DECL|field|TOKEN_AND
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_AND
init|=
literal|1
decl_stmt|;
DECL|field|TOKEN_COMMA
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_COMMA
init|=
literal|2
decl_stmt|;
DECL|field|TOKEN_WORD
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_WORD
init|=
literal|3
decl_stmt|;
comment|// Constant Hashtable containing names of TeX special characters
DECL|field|tex_names
specifier|private
specifier|static
specifier|final
name|java
operator|.
name|util
operator|.
name|Hashtable
name|tex_names
init|=
operator|new
name|java
operator|.
name|util
operator|.
name|Hashtable
argument_list|()
decl_stmt|;
comment|// and static constructor to initialize it
static|static
block|{
name|tex_names
operator|.
name|put
argument_list|(
literal|"aa"
argument_list|,
literal|"aa"
argument_list|)
expr_stmt|;
comment|// only keys are important in this table
name|tex_names
operator|.
name|put
argument_list|(
literal|"ae"
argument_list|,
literal|"ae"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"l"
argument_list|,
literal|"l"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"o"
argument_list|,
literal|"o"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"oe"
argument_list|,
literal|"oe"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"i"
argument_list|,
literal|"i"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"AA"
argument_list|,
literal|"AA"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"AE"
argument_list|,
literal|"AE"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"L"
argument_list|,
literal|"L"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"O"
argument_list|,
literal|"O"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"OE"
argument_list|,
literal|"OE"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"j"
argument_list|,
literal|"j"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Parses the parameter strings and stores preformatted author information.      * @param bibtex_authors contents of either<CODE>author</CODE> or      *<CODE>editor</CODE> bibtex field.      */
DECL|method|AuthorList (String bibtex_authors)
specifier|public
name|AuthorList
parameter_list|(
name|String
name|bibtex_authors
parameter_list|)
block|{
name|authors
operator|=
operator|new
name|Vector
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|// 5 seems to be reasonable initial size
name|orig
operator|=
name|bibtex_authors
expr_stmt|;
comment|// initialization
name|token_start
operator|=
literal|0
expr_stmt|;
name|token_end
operator|=
literal|0
expr_stmt|;
comment|// of parser
while|while
condition|(
name|token_start
operator|<
name|orig
operator|.
name|length
argument_list|()
condition|)
block|{
name|Author
name|author
init|=
name|getAuthor
argument_list|()
decl_stmt|;
if|if
condition|(
name|author
operator|!=
literal|null
condition|)
name|authors
operator|.
name|add
argument_list|(
name|author
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|// clean-up
name|orig
operator|=
literal|null
expr_stmt|;
name|tokens
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * Parses one author name and returns preformatted information.      * @return Preformatted author name;<CODE>null</CODE> if author name is empty.      */
DECL|method|getAuthor ()
specifier|private
name|Author
name|getAuthor
parameter_list|()
block|{
name|tokens
operator|=
operator|new
name|Vector
argument_list|()
expr_stmt|;
comment|// initialization
name|von_start
operator|=
operator|-
literal|1
expr_stmt|;
name|last_start
operator|=
operator|-
literal|1
expr_stmt|;
name|comma_first
operator|=
operator|-
literal|1
expr_stmt|;
name|comma_second
operator|=
operator|-
literal|1
expr_stmt|;
comment|// First step: collect tokens in 'tokens' Vector and calculate indices
name|token_loop
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|token
init|=
name|getToken
argument_list|()
decl_stmt|;
name|cases
label|:
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|TOKEN_EOF
case|:
case|case
name|TOKEN_AND
case|:
break|break
name|token_loop
break|;
case|case
name|TOKEN_COMMA
case|:
if|if
condition|(
name|comma_first
operator|<
literal|0
condition|)
name|comma_first
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|comma_second
operator|<
literal|0
condition|)
name|comma_second
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
break|break
name|cases
break|;
case|case
name|TOKEN_WORD
case|:
name|tokens
operator|.
name|add
argument_list|(
name|orig
operator|.
name|substring
argument_list|(
name|token_start
argument_list|,
name|token_end
argument_list|)
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|orig
operator|.
name|substring
argument_list|(
name|token_start
argument_list|,
name|token_abbr
argument_list|)
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
operator|new
name|Character
argument_list|(
name|token_term
argument_list|)
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
operator|new
name|Boolean
argument_list|(
name|token_case
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|comma_first
operator|>=
literal|0
condition|)
break|break
name|cases
break|;
if|if
condition|(
name|last_start
operator|>=
literal|0
condition|)
break|break
name|cases
break|;
if|if
condition|(
name|von_start
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|token_case
condition|)
block|{
name|von_start
operator|=
name|tokens
operator|.
name|size
argument_list|()
operator|-
name|TOKEN_GROUP_LENGTH
expr_stmt|;
break|break
name|cases
break|;
block|}
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_start
operator|<
literal|0
operator|&&
name|token_case
condition|)
block|{
name|last_start
operator|=
name|tokens
operator|.
name|size
argument_list|()
operator|-
name|TOKEN_GROUP_LENGTH
expr_stmt|;
break|break
name|cases
break|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|// end token_loop
comment|// Second step: split name into parts (here: calculate indices
comment|// of parts in 'tokens' Vector)
if|if
condition|(
name|tokens
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
comment|// no author information
comment|// the following negatives indicate absence of the corresponding part
name|int
name|first_part_start
init|=
operator|-
literal|1
decl_stmt|,
name|von_part_start
init|=
operator|-
literal|1
decl_stmt|,
name|last_part_start
init|=
operator|-
literal|1
decl_stmt|,
name|jr_part_start
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|first_part_end
init|=
literal|0
decl_stmt|,
name|von_part_end
init|=
literal|0
decl_stmt|,
name|last_part_end
init|=
literal|0
decl_stmt|,
name|jr_part_end
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|comma_first
operator|<
literal|0
condition|)
block|{
comment|// no commas
if|if
condition|(
name|von_start
operator|<
literal|0
condition|)
block|{
comment|// no 'von part'
name|last_part_end
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
name|last_part_start
operator|=
name|tokens
operator|.
name|size
argument_list|()
operator|-
name|TOKEN_GROUP_LENGTH
expr_stmt|;
name|first_part_end
operator|=
name|last_part_start
expr_stmt|;
if|if
condition|(
name|first_part_end
operator|>
literal|0
condition|)
name|first_part_start
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// 'von part' is present
if|if
condition|(
name|last_start
operator|>=
literal|0
condition|)
block|{
name|last_part_end
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
name|last_part_start
operator|=
name|last_start
expr_stmt|;
name|von_part_end
operator|=
name|last_part_start
expr_stmt|;
block|}
else|else
block|{
name|von_part_end
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
name|von_part_start
operator|=
name|von_start
expr_stmt|;
name|first_part_end
operator|=
name|von_part_start
expr_stmt|;
if|if
condition|(
name|first_part_end
operator|>
literal|0
condition|)
name|first_part_start
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
comment|// commas are present: it affects only 'first part' and 'junior part'
name|first_part_end
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|comma_second
operator|<
literal|0
condition|)
block|{
comment|// one comma
if|if
condition|(
name|comma_first
operator|<
name|first_part_end
condition|)
name|first_part_start
operator|=
name|comma_first
expr_stmt|;
block|}
else|else
block|{
comment|// two or more commas
if|if
condition|(
name|comma_second
operator|<
name|first_part_end
condition|)
name|first_part_start
operator|=
name|comma_second
expr_stmt|;
name|jr_part_end
operator|=
name|comma_second
expr_stmt|;
if|if
condition|(
name|comma_first
operator|<
name|jr_part_end
condition|)
name|jr_part_start
operator|=
name|comma_first
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|von_start
operator|!=
literal|0
condition|)
block|{
comment|// no 'von part'
name|last_part_end
operator|=
name|comma_first
expr_stmt|;
if|if
condition|(
name|last_part_end
operator|>
literal|0
condition|)
name|last_part_start
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// 'von part' is present
if|if
condition|(
name|last_start
operator|<
literal|0
condition|)
block|{
name|von_part_end
operator|=
name|comma_first
expr_stmt|;
block|}
else|else
block|{
name|last_part_end
operator|=
name|comma_first
expr_stmt|;
name|last_part_start
operator|=
name|last_start
expr_stmt|;
name|von_part_end
operator|=
name|last_part_start
expr_stmt|;
block|}
empty_stmt|;
name|von_part_start
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|// Third step: do actual splitting, construct Author object
return|return
operator|new
name|Author
argument_list|(
operator|(
name|first_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|first_part_start
argument_list|,
name|first_part_end
argument_list|,
name|OFFSET_TOKEN
argument_list|,
literal|false
argument_list|)
operator|)
argument_list|,
operator|(
name|first_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|first_part_start
argument_list|,
name|first_part_end
argument_list|,
name|OFFSET_TOKEN_ABBR
argument_list|,
literal|true
argument_list|)
operator|)
argument_list|,
operator|(
name|von_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|von_part_start
argument_list|,
name|von_part_end
argument_list|,
name|OFFSET_TOKEN
argument_list|,
literal|false
argument_list|)
operator|)
argument_list|,
operator|(
name|last_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|last_part_start
argument_list|,
name|last_part_end
argument_list|,
name|OFFSET_TOKEN
argument_list|,
literal|false
argument_list|)
operator|)
argument_list|,
operator|(
name|jr_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|jr_part_start
argument_list|,
name|jr_part_end
argument_list|,
name|OFFSET_TOKEN
argument_list|,
literal|false
argument_list|)
operator|)
argument_list|)
return|;
block|}
comment|/**      * Concatenates list of tokens from 'tokens' Vector.      * Tokens are separated by spaces or dashes, dependeing on stored in 'tokens'.      * Callers always ensure that start< end; thus, there exists at least      * one token to be concatenated.      * @param start index of the first token to be concatenated in 'tokens' Vector      * (always divisible by TOKEN_GROUP_LENGTH).      * @param end index of the first token not to be concatenated in 'tokens' Vector      * (always divisible by TOKEN_GROUP_LENGTH).      * @param offset offset within token group (used to request concatenation of      * either full tokens or abbreviation).      * @param dot_after<CODE>true</CODE> -- add period after each token,       *<CODE>false</CODE> -- do not add.      * @return the result of concatenation.      */
DECL|method|concatTokens (int start, int end, int offset, boolean dot_after)
specifier|private
name|String
name|concatTokens
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|offset
parameter_list|,
name|boolean
name|dot_after
parameter_list|)
block|{
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// Here we always have start< end
name|res
operator|.
name|append
argument_list|(
operator|(
name|String
operator|)
name|tokens
operator|.
name|get
argument_list|(
name|start
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot_after
condition|)
name|res
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|start
operator|+=
name|TOKEN_GROUP_LENGTH
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
operator|(
name|Character
operator|)
name|tokens
operator|.
name|get
argument_list|(
name|start
operator|-
name|TOKEN_GROUP_LENGTH
operator|+
name|OFFSET_TOKEN_TERM
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
operator|(
name|String
operator|)
name|tokens
operator|.
name|get
argument_list|(
name|start
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot_after
condition|)
name|res
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|start
operator|+=
name|TOKEN_GROUP_LENGTH
expr_stmt|;
block|}
empty_stmt|;
return|return
name|res
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Parses the next token.      *<p>      * The string being parsed is stored in global variable<CODE>orig</CODE>,      * and position which parsing has to start from is stored in global      * variable<CODE>token_end</CODE>; thus,<CODE>token_end</CODE> has to be      * set to 0 before the first invocation. Procedure updates<CODE>token_end</CODE>;      * thus, subsequent invocations do not require any additional variable settings.      *<p>      * The type of the token is returned; if it is<CODE>TOKEN_WORD</CODE>, additional      * information is given  in global variables<CODE>token_start</CODE>,<CODE>token_end</CODE>,      *<CODE>token_abbr</CODE>,<CODE>token_term</CODE>, and<CODE>token_case</CODE>;      * namely:<CODE>orig.substring(token_start,token_end)</CODE> is the thext of the token,      *<CODE>orig.substring(token_start,token_abbr)</CODE> is the token abbreviation,      *<CODE>token_term</CODE> contains token terminator (space or dash),      * and<CODE>token_case</CODE> is<CODE>true</CODE>, if token is upper-case      * and<CODE>false</CODE> if token is lower-case.      * @return<CODE>TOKEN_EOF</CODE> -- no more tokens,      *<CODE>TOKEN_COMMA</CODE> -- token is comma,      *<CODE>TOKEN_AND</CODE> -- token is the word "and" (or "And", or "aND", etc.),      *<CODE>TOKEN_WORD</CODE> -- token is a word; additional information is given      * in global variables<CODE>token_start</CODE>,<CODE>token_end</CODE>,      *<CODE>token_abbr</CODE>,<CODE>token_term</CODE>, and<CODE>token_case</CODE>.      */
DECL|method|getToken ()
specifier|private
name|int
name|getToken
parameter_list|()
block|{
name|token_start
operator|=
name|token_end
expr_stmt|;
while|while
condition|(
name|token_start
operator|<
name|orig
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|orig
operator|.
name|charAt
argument_list|(
name|token_start
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|==
literal|'~'
operator|||
name|c
operator|==
literal|'-'
operator|||
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|)
condition|)
break|break;
name|token_start
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|token_end
operator|=
name|token_start
expr_stmt|;
if|if
condition|(
name|token_start
operator|>=
name|orig
operator|.
name|length
argument_list|()
condition|)
return|return
name|TOKEN_EOF
return|;
if|if
condition|(
name|orig
operator|.
name|charAt
argument_list|(
name|token_start
argument_list|)
operator|==
literal|','
condition|)
block|{
name|token_end
operator|++
expr_stmt|;
return|return
name|TOKEN_COMMA
return|;
block|}
empty_stmt|;
name|token_abbr
operator|=
operator|-
literal|1
expr_stmt|;
name|token_term
operator|=
literal|' '
expr_stmt|;
name|token_case
operator|=
literal|true
expr_stmt|;
name|int
name|braces_level
init|=
literal|0
decl_stmt|;
name|int
name|current_backslash
init|=
operator|-
literal|1
decl_stmt|;
name|boolean
name|first_letter_is_found
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|token_end
operator|<
name|orig
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|orig
operator|.
name|charAt
argument_list|(
name|token_end
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
name|braces_level
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|braces_level
operator|>
literal|0
condition|)
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|braces_level
operator|--
expr_stmt|;
if|if
condition|(
name|first_letter_is_found
operator|&&
name|token_abbr
operator|<
literal|0
operator|&&
name|braces_level
operator|==
literal|0
condition|)
name|token_abbr
operator|=
name|token_end
expr_stmt|;
if|if
condition|(
operator|!
name|first_letter_is_found
operator|&&
name|current_backslash
operator|<
literal|0
operator|&&
name|Character
operator|.
name|isLetter
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|token_case
operator|=
name|Character
operator|.
name|isUpperCase
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|first_letter_is_found
operator|=
literal|true
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|current_backslash
operator|>=
literal|0
operator|&&
operator|!
name|Character
operator|.
name|isLetter
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first_letter_is_found
condition|)
block|{
name|String
name|tex_cmd_name
init|=
name|orig
operator|.
name|substring
argument_list|(
name|current_backslash
operator|+
literal|1
argument_list|,
name|token_end
argument_list|)
decl_stmt|;
if|if
condition|(
name|tex_names
operator|.
name|get
argument_list|(
name|tex_cmd_name
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|token_case
operator|=
name|Character
operator|.
name|isUpperCase
argument_list|(
name|tex_cmd_name
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|first_letter_is_found
operator|=
literal|true
expr_stmt|;
block|}
block|}
empty_stmt|;
name|current_backslash
operator|=
operator|-
literal|1
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|current_backslash
operator|=
name|token_end
expr_stmt|;
if|if
condition|(
name|braces_level
operator|==
literal|0
condition|)
if|if
condition|(
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|'~'
operator|||
name|c
operator|==
literal|'-'
operator|||
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|token_end
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|token_abbr
operator|<
literal|0
condition|)
name|token_abbr
operator|=
name|token_end
expr_stmt|;
if|if
condition|(
name|token_end
operator|<
name|orig
operator|.
name|length
argument_list|()
operator|&&
name|orig
operator|.
name|charAt
argument_list|(
name|token_end
argument_list|)
operator|==
literal|'-'
condition|)
name|token_term
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|orig
operator|.
name|substring
argument_list|(
name|token_start
argument_list|,
name|token_end
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"and"
argument_list|)
condition|)
return|return
name|TOKEN_AND
return|;
else|else
return|return
name|TOKEN_WORD
return|;
block|}
comment|/**      * Returns the number of author names in this object.      * @return the number of author names in this object.      */
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|authors
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Returns the<CODE>Author</CODE> object for ith author.      * @param i index of the author (from 0 to<CODE>size()-1</CODE>).      * @return the<CODE>Author</CODE> object.      */
DECL|method|getAuthor (int i)
specifier|public
name|Author
name|getAuthor
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
operator|(
name|Author
operator|)
name|authors
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/**      * Returns the list of authors in "natbib" format.      *<p>      * "John Smith" ==> "Smith";      * "John Smith and Black Brown, Peter" ==> "Smith and Black Brown";      * "John von Neumann and John Smith and Black Brown, Peter" ==> "von Neumann et al.".      * @return formatted list of authors.      */
DECL|method|getAuthorsNatbib ()
specifier|public
name|String
name|getAuthorsNatbib
parameter_list|()
block|{
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getLastOnly
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|1
argument_list|)
operator|.
name|getLastOnly
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" et al."
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
return|return
name|res
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Returns the list of authors separated by commas with first names after last name;      * first names are abbreviated or not depending on parameter.      * If the list consists of three or more authors, "and" is inserted before      * the last author's name.      *<p>      * "John Smith" ==> "Smith, John" or "Smith, J.";      * "John Smith and Black Brown, Peter" ==>      * "Smith, John and Black Brown, Peter" or "Smith, J. and Black Brown, P.";      * "John von Neumann and John Smith and Black Brown, Peter" ==>      * "von Neumann, John, Smith, John and Black Brown, Peter" or      * "von Neumann, J., Smith, J. and Black Brown, P.".      * @param abbr<CODE>true</CODE> -- abbreviate first names,      *<CODE>false</CODE> -- do not abbreviate.      * @return formatted list of authors.      */
DECL|method|getAuthorsLastFirst (boolean abbr)
specifier|public
name|String
name|getAuthorsLastFirst
parameter_list|(
name|boolean
name|abbr
parameter_list|)
block|{
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getLastFirst
argument_list|(
name|abbr
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getLastFirst
argument_list|(
name|abbr
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|2
condition|)
name|res
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getLastFirst
argument_list|(
name|abbr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
return|return
name|res
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Returns the list of authors separated by "and"s with first names after last name;      * first names are not abbreviated.      *<p>      * "John Smith" ==> "Smith, John";      * "John Smith and Black Brown, Peter" ==> "Smith, John and Black Brown, Peter";      * "John von Neumann and John Smith and Black Brown, Peter" ==>      * "von Neumann, John and Smith, John and Black Brown, Peter".      * @return formatted list of authors.      */
DECL|method|getAuthorsLastFirstAnds ()
specifier|public
name|String
name|getAuthorsLastFirstAnds
parameter_list|()
block|{
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getLastFirst
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getLastFirst
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
return|return
name|res
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Returns the list of authors separated by commas with first names before last name;      * first names are abbreviated or not depending on parameter.      * If the list consists of three or more authors, "and" is inserted before      * the last author's name.      *<p>      * "John Smith" ==> "John Smith" or "J. Smith";      * "John Smith and Black Brown, Peter" ==>      * "John Smith and Peter Black Brown" or "J. Smith and P. Black Brown";      * "John von Neumann and John Smith and Black Brown, Peter" ==>      * "John von Neumann, John Smith and Peter Black Brown" or      * "J. von Neumann, J. Smith and P. Black Brown".      * @param abbr<CODE>true</CODE> -- abbreviate first names,      *<CODE>false</CODE> -- do not abbreviate.      * @return formatted list of authors.      */
DECL|method|getAuthorsFirstLast (boolean abbr)
specifier|public
name|String
name|getAuthorsFirstLast
parameter_list|(
name|boolean
name|abbr
parameter_list|)
block|{
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getFirstLast
argument_list|(
name|abbr
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getFirstLast
argument_list|(
name|abbr
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|2
condition|)
name|res
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getFirstLast
argument_list|(
name|abbr
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
return|return
name|res
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Returns the list of authors separated by "and"s with first names before last name;      * first names are not abbreviated.      *<p>      * "John Smith" ==> "John Smith";      * "John Smith and Black Brown, Peter" ==> "John Smith and Peter Black Brown";      * "John von Neumann and John Smith and Black Brown, Peter" ==>      * "John von Neumann and John Smith and Peter Black Brown".      * @return formatted list of authors.      */
DECL|method|getAuthorsFirstLastAnds ()
specifier|public
name|String
name|getAuthorsFirstLastAnds
parameter_list|()
block|{
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getFirstLast
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getFirstLast
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
return|return
name|res
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**  *  This is an immutable class that keeps information regarding single author.  *  It is just a container for the information, with very simple methods  *  to access it.  *<p>  *  Current usage: only methods<code>getLastOnly</code>,  *<code>getFirstLast</code>, and<code>getLastFirst</code> are used;  *  all other methods are provided for completeness.  */
DECL|class|Author
specifier|private
specifier|static
class|class
name|Author
block|{
DECL|field|first_part
specifier|private
specifier|final
name|String
name|first_part
decl_stmt|;
DECL|field|first_abbr
specifier|private
specifier|final
name|String
name|first_abbr
decl_stmt|;
DECL|field|von_part
specifier|private
specifier|final
name|String
name|von_part
decl_stmt|;
DECL|field|last_part
specifier|private
specifier|final
name|String
name|last_part
decl_stmt|;
DECL|field|jr_part
specifier|private
specifier|final
name|String
name|jr_part
decl_stmt|;
comment|/**      * Creates the Author object.      * If any part of the name is absent,<CODE>null</CODE> must be passes;      * otherwise other methods may return erroneous results.      * @param first the first name of the author (may consist of several tokens,      * like "Charles Louis Xavier Joseph" in       * "Charles Louis Xavier Joseph de la Vall{\'e}e Poussin")      * @param firstabbr the abbreviated first name of the author (may consist      * of several tokens, like "C. L. X. J." in       * "Charles Louis Xavier Joseph de la Vall{\'e}e Poussin").      * It is a responsibility of the caller to create a reasonable      * abbreviation of the first name.      * @param von the von part of the author's name (may consist of      * several tokens, like "de la" in       * "Charles Louis Xavier Joseph de la Vall{\'e}e Poussin")      * @param last the lats name of the author (may consist of several tokens,      * like "Vall{\'e}e Poussin" in       * "Charles Louis Xavier Joseph de la Vall{\'e}e Poussin")      * @param jr the junior part of the author's name (may consist of      * several tokens, like "Jr. III" in       * "Smith, Jr. III, John")      */
DECL|method|Author (String first, String firstabbr, String von, String last, String jr)
specifier|public
name|Author
parameter_list|(
name|String
name|first
parameter_list|,
name|String
name|firstabbr
parameter_list|,
name|String
name|von
parameter_list|,
name|String
name|last
parameter_list|,
name|String
name|jr
parameter_list|)
block|{
name|first_part
operator|=
name|first
expr_stmt|;
name|first_abbr
operator|=
name|firstabbr
expr_stmt|;
name|von_part
operator|=
name|von
expr_stmt|;
name|last_part
operator|=
name|last
expr_stmt|;
name|jr_part
operator|=
name|jr
expr_stmt|;
block|}
comment|/**      * Retunrns the first name of the author stored in this object.      * @return first name of the author (may consist of several tokens)      */
DECL|method|getFirst ()
specifier|public
name|String
name|getFirst
parameter_list|()
block|{
return|return
name|first_part
return|;
block|}
comment|/**      * Retunrns the abbreviated first name of the author stored in this object.      * @return abbreviated first name of the author (may consist of several tokens)      */
DECL|method|getFirstAbbr ()
specifier|public
name|String
name|getFirstAbbr
parameter_list|()
block|{
return|return
name|first_abbr
return|;
block|}
comment|/**      * Retunrns the von part of the author's name stored in this object.      * @return von part of the author's name (may consist of several tokens)      */
DECL|method|getVon ()
specifier|public
name|String
name|getVon
parameter_list|()
block|{
return|return
name|von_part
return|;
block|}
comment|/**      * Retunrns the last name of the author stored in this object.      * @return last name of the author (may consist of several tokens)      */
DECL|method|getLast ()
specifier|public
name|String
name|getLast
parameter_list|()
block|{
return|return
name|last_part
return|;
block|}
comment|/**      * Retunrns the junior part of the author's name stored in this object.      * @return junior part of the author's name (may consist of several tokens)      */
DECL|method|getJr ()
specifier|public
name|String
name|getJr
parameter_list|()
block|{
return|return
name|jr_part
return|;
block|}
comment|/**      * Returns von part followed by last name.      * If both fields were specified as<CODE>null</CODE>,      * the empty string<CODE>""</CODE> is returned.      * @return 'von Last'      */
DECL|method|getLastOnly ()
specifier|public
name|String
name|getLastOnly
parameter_list|()
block|{
if|if
condition|(
name|von_part
operator|==
literal|null
condition|)
block|{
return|return
operator|(
name|last_part
operator|==
literal|null
condition|?
literal|""
else|:
name|last_part
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|last_part
operator|==
literal|null
condition|?
name|von_part
else|:
name|von_part
operator|+
literal|" "
operator|+
name|last_part
operator|)
return|;
block|}
block|}
comment|/**      * Returns the author's name in form 'von Last, Jr., First' with the first name      * full or abbreviated depending on parameter.      * @param abbr<CODE>true</CODE> - abbreviate first name,      *<CODE>false</CODE> - do not abbreviate      * @return 'von Last, Jr., First' (if<CODE>abbr==false</CODE>) or      * 'von Last, Jr., F.' (if<CODE>abbr==true</CODE>)      */
DECL|method|getLastFirst (boolean abbr)
specifier|public
name|String
name|getLastFirst
parameter_list|(
name|boolean
name|abbr
parameter_list|)
block|{
name|String
name|res
init|=
name|getLastOnly
argument_list|()
decl_stmt|;
if|if
condition|(
name|jr_part
operator|!=
literal|null
condition|)
name|res
operator|+=
literal|", "
operator|+
name|jr_part
expr_stmt|;
if|if
condition|(
name|abbr
condition|)
block|{
if|if
condition|(
name|first_abbr
operator|!=
literal|null
condition|)
name|res
operator|+=
literal|", "
operator|+
name|first_abbr
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|first_part
operator|!=
literal|null
condition|)
name|res
operator|+=
literal|", "
operator|+
name|first_part
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
comment|/**      * Returns the author's name in form 'First von Last, Jr.' with the first name      * full or abbreviated depending on parameter.      * @param abbr<CODE>true</CODE> - abbreviate first name,      *<CODE>false</CODE> - do not abbreviate      * @return 'First von Last, Jr.' (if<CODE>abbr==false</CODE>) or      * 'F. von Last, Jr.' (if<CODE>abbr==true</CODE>)      */
DECL|method|getFirstLast (boolean abbr)
specifier|public
name|String
name|getFirstLast
parameter_list|(
name|boolean
name|abbr
parameter_list|)
block|{
name|String
name|res
init|=
name|getLastOnly
argument_list|()
decl_stmt|;
if|if
condition|(
name|abbr
condition|)
block|{
name|res
operator|=
operator|(
name|first_abbr
operator|==
literal|null
condition|?
literal|""
else|:
name|first_abbr
operator|+
literal|" "
operator|)
operator|+
name|res
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
operator|(
name|first_part
operator|==
literal|null
condition|?
literal|""
else|:
name|first_part
operator|+
literal|" "
operator|)
operator|+
name|res
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|jr_part
operator|!=
literal|null
condition|)
name|res
operator|+=
literal|", "
operator|+
name|jr_part
expr_stmt|;
return|return
name|res
return|;
block|}
block|}
comment|//end Author
block|}
comment|//end AuthorList
DECL|method|expandAll (String s)
specifier|public
specifier|static
name|String
name|expandAll
parameter_list|(
name|String
name|s
parameter_list|)
block|{
comment|//System.out.println("'"+s+"'");
comment|// Avoid arrayindexoutof.... :
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
name|s
return|;
comment|// If only one character (uppercase letter), add a dot and return immediately:
if|if
condition|(
operator|(
name|s
operator|.
name|length
argument_list|()
operator|==
literal|1
operator|)
operator|&&
operator|(
name|Character
operator|.
name|isLetter
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|Character
operator|.
name|isUpperCase
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|s
operator|+
literal|"."
return|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|,
name|d
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|Character
operator|.
name|isLetter
argument_list|(
name|c
argument_list|)
operator|&&
name|Character
operator|.
name|isUpperCase
argument_list|(
name|c
argument_list|)
operator|&&
name|Character
operator|.
name|isLetter
argument_list|(
name|d
argument_list|)
operator|&&
name|Character
operator|.
name|isUpperCase
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|". "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|d
expr_stmt|;
block|}
if|if
condition|(
name|Character
operator|.
name|isLetter
argument_list|(
name|c
argument_list|)
operator|&&
name|Character
operator|.
name|isUpperCase
argument_list|(
name|c
argument_list|)
operator|&&
name|Character
operator|.
name|isLetter
argument_list|(
name|d
argument_list|)
operator|&&
name|Character
operator|.
name|isUpperCase
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|". "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
return|;
block|}
DECL|method|checkAndCreateFile (String filename)
specifier|static
name|File
name|checkAndCreateFile
parameter_list|(
name|String
name|filename
parameter_list|)
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|canRead
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error "
operator|+
name|filename
operator|+
literal|" is not a valid file and|or is not readable."
argument_list|)
expr_stmt|;
name|Globals
operator|.
name|logger
argument_list|(
literal|"Error "
operator|+
name|filename
operator|+
literal|" is not a valid file and|or is not readable."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
return|return
name|f
return|;
block|}
comment|//==================================================
comment|// Set a field, unless the string to set is empty.
comment|//==================================================
DECL|method|setIfNecessary (BibtexEntry be, String field, String content)
specifier|public
specifier|static
name|void
name|setIfNecessary
parameter_list|(
name|BibtexEntry
name|be
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|content
parameter_list|)
block|{
if|if
condition|(
operator|!
name|content
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
name|be
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|content
argument_list|)
expr_stmt|;
block|}
DECL|method|loadDatabase (File fileToOpen, String encoding)
specifier|public
specifier|static
name|ParserResult
name|loadDatabase
parameter_list|(
name|File
name|fileToOpen
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Temporary (old method):
comment|//FileLoader fl = new FileLoader();
comment|//BibtexDatabase db = fl.load(fileToOpen.getPath());
comment|// First we make a quick check to see if this looks like a BibTeX file:
name|Reader
name|reader
init|=
name|getReader
argument_list|(
name|fileToOpen
argument_list|,
name|encoding
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|BibtexParser
operator|.
name|isRecognizedFormat
argument_list|(
name|reader
argument_list|)
condition|)
return|return
literal|null
return|;
comment|// The file looks promising. Reinitialize the reader and go on:
name|reader
operator|=
name|getReader
argument_list|(
name|fileToOpen
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|String
name|suppliedEncoding
init|=
literal|null
decl_stmt|;
name|StringBuffer
name|headerText
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
try|try
block|{
name|boolean
name|keepon
init|=
literal|true
decl_stmt|;
name|int
name|piv
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
name|keepon
condition|)
block|{
name|c
operator|=
name|reader
operator|.
name|read
argument_list|()
expr_stmt|;
name|headerText
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|piv
operator|==
literal|0
operator|)
operator|&&
name|Character
operator|.
name|isWhitespace
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|)
operator|||
operator|(
name|c
operator|==
name|GUIGlobals
operator|.
name|SIGNATURE
operator|.
name|charAt
argument_list|(
name|piv
argument_list|)
operator|)
condition|)
name|piv
operator|++
expr_stmt|;
else|else
comment|//if (((char)c) == '@')
name|keepon
operator|=
literal|false
expr_stmt|;
comment|//System.out.println(headerText.toString());
name|found
label|:
if|if
condition|(
name|piv
operator|==
name|GUIGlobals
operator|.
name|SIGNATURE
operator|.
name|length
argument_list|()
condition|)
block|{
name|keepon
operator|=
literal|false
expr_stmt|;
comment|//if (headerText.length()> GUIGlobals.SIGNATURE.length())
comment|//    System.out.println("'"+headerText.toString().substring(0, headerText.length()-GUIGlobals.SIGNATURE.length())+"'");
comment|// Found the signature. The rest of the line is unknown, so we skip
comment|// it:
while|while
condition|(
name|reader
operator|.
name|read
argument_list|()
operator|!=
literal|'\n'
condition|)
empty_stmt|;
comment|// Then we must skip the "Encoding: "
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|GUIGlobals
operator|.
name|encPrefix
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reader
operator|.
name|read
argument_list|()
operator|!=
name|GUIGlobals
operator|.
name|encPrefix
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
condition|)
break|break
name|found
break|;
comment|// No,
comment|// it
comment|// doesn't
comment|// seem
comment|// to
comment|// match.
block|}
comment|// If ok, then read the rest of the line, which should contain the
comment|// name
comment|// of the encoding:
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|reader
operator|.
name|read
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|suppliedEncoding
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{     }
if|if
condition|(
operator|(
name|suppliedEncoding
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|suppliedEncoding
operator|.
name|equalsIgnoreCase
argument_list|(
name|encoding
argument_list|)
operator|)
condition|)
block|{
name|Reader
name|oldReader
init|=
name|reader
decl_stmt|;
try|try
block|{
comment|// Ok, the supplied encoding is different from our default, so we must
comment|// make a new
comment|// reader. Then close the old one.
name|reader
operator|=
name|getReader
argument_list|(
name|fileToOpen
argument_list|,
name|suppliedEncoding
argument_list|)
expr_stmt|;
name|oldReader
operator|.
name|close
argument_list|()
expr_stmt|;
comment|//System.out.println("Using encoding: "+suppliedEncoding);
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|reader
operator|=
name|oldReader
expr_stmt|;
comment|// The supplied encoding didn't work out, so we keep
comment|// our
comment|// existing reader.
comment|//System.out.println("Error, using default encoding.");
block|}
block|}
else|else
block|{
comment|// We couldn't find a supplied encoding. Since we don't know far into the
comment|// file we read,
comment|// we start a new reader.
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|reader
operator|=
name|getReader
argument_list|(
name|fileToOpen
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
comment|//System.out.println("No encoding supplied, or supplied encoding equals
comment|// default. Using default encoding.");
block|}
comment|//return null;
name|BibtexParser
name|bp
init|=
operator|new
name|BibtexParser
argument_list|(
name|reader
argument_list|)
decl_stmt|;
name|ParserResult
name|pr
init|=
name|bp
operator|.
name|parse
argument_list|()
decl_stmt|;
name|pr
operator|.
name|setEncoding
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
return|return
name|pr
return|;
block|}
DECL|method|getReader (File f, String encoding)
specifier|public
specifier|static
name|Reader
name|getReader
parameter_list|(
name|File
name|f
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStreamReader
name|reader
decl_stmt|;
name|reader
operator|=
operator|new
name|InputStreamReader
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|f
argument_list|)
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
return|return
name|reader
return|;
block|}
DECL|method|getReaderDefaultEncoding (InputStream in)
specifier|public
specifier|static
name|Reader
name|getReaderDefaultEncoding
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStreamReader
name|reader
decl_stmt|;
name|reader
operator|=
operator|new
name|InputStreamReader
argument_list|(
name|in
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"defaultEncoding"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reader
return|;
block|}
DECL|method|import_File (String format, String filename)
specifier|public
specifier|static
name|BibtexDatabase
name|import_File
parameter_list|(
name|String
name|format
parameter_list|,
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
name|BibtexDatabase
name|database
init|=
literal|null
decl_stmt|;
name|List
name|bibentries
init|=
literal|null
decl_stmt|;
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"File not found"
argument_list|)
operator|+
literal|": "
operator|+
name|filename
argument_list|)
throw|;
try|try
block|{
name|bibentries
operator|=
name|Globals
operator|.
name|importFormatReader
operator|.
name|importFromFile
argument_list|(
name|format
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Could not resolve import format"
argument_list|)
operator|+
literal|" '"
operator|+
name|format
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
name|bibentries
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Import failed"
argument_list|)
argument_list|)
throw|;
comment|// Remove all empty entries:
name|purgeEmptyEntries
argument_list|(
name|bibentries
argument_list|)
expr_stmt|;
comment|// Add entries to database.
name|database
operator|=
operator|new
name|BibtexDatabase
argument_list|()
expr_stmt|;
name|Iterator
name|it
init|=
name|bibentries
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BibtexEntry
name|entry
init|=
operator|(
name|BibtexEntry
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|entry
operator|.
name|setId
argument_list|(
name|Util
operator|.
name|createNeutralId
argument_list|()
argument_list|)
expr_stmt|;
name|database
operator|.
name|insertEntry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeyCollisionException
name|ex
parameter_list|)
block|{
comment|//ignore
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"KeyCollisionException [ addBibEntries(...) ]"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|database
return|;
block|}
comment|/**    * Receives an ArrayList of BibtexEntry instances, iterates through them, and    * removes all entries that have no fields set. This is useful for rooting out    * an unsucessful import (wrong format) that returns a number of empty entries.    */
DECL|method|purgeEmptyEntries (List entries)
specifier|public
specifier|static
name|void
name|purgeEmptyEntries
parameter_list|(
name|List
name|entries
parameter_list|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|entries
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BibtexEntry
name|entry
init|=
operator|(
name|BibtexEntry
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// Get all fields of the entry:
name|Object
index|[]
name|o
init|=
name|entry
operator|.
name|getAllFields
argument_list|()
decl_stmt|;
comment|// If there are no fields, remove the entry:
if|if
condition|(
name|o
operator|.
name|length
operator|==
literal|0
condition|)
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Tries to import a file by iterating through the available import filters,    * and keeping the import that seems most promising. Returns an Object array    * with two elements, 0: the name of the format used, 1: a List of entries.    */
DECL|method|importUnknownFormat (String filename)
specifier|public
name|Object
index|[]
name|importUnknownFormat
parameter_list|(
name|String
name|filename
parameter_list|)
block|{
name|Object
name|entryList
init|=
literal|null
decl_stmt|;
name|String
name|usedFormat
init|=
literal|null
decl_stmt|;
name|int
name|bestResult
init|=
literal|0
decl_stmt|;
comment|// Cycle through all importers:
for|for
control|(
name|Iterator
name|i
init|=
name|getImportFormats
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ImportFormat
name|imFo
init|=
call|(
name|ImportFormat
call|)
argument_list|(
operator|(
name|Map
operator|.
name|Entry
operator|)
name|i
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
try|try
block|{
comment|//System.out.println("Trying format: "+imFo.getFormatName());
name|List
name|entries
init|=
name|importFromFile
argument_list|(
name|imFo
argument_list|,
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|entries
operator|!=
literal|null
condition|)
name|purgeEmptyEntries
argument_list|(
name|entries
argument_list|)
expr_stmt|;
name|int
name|entryCount
init|=
operator|(
operator|(
name|entries
operator|!=
literal|null
operator|)
condition|?
name|entries
operator|.
name|size
argument_list|()
else|:
literal|0
operator|)
decl_stmt|;
comment|//System.out.println("Entries: "+entryCount);
comment|//BibtexDatabase base = importFile(formats[i], filename);
if|if
condition|(
name|entryCount
operator|>
name|bestResult
condition|)
block|{
name|bestResult
operator|=
name|entryCount
expr_stmt|;
name|usedFormat
operator|=
name|imFo
operator|.
name|getFormatName
argument_list|()
expr_stmt|;
name|entryList
operator|=
name|entries
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|//ex.printStackTrace();
comment|//System.out.println("Import failed");
block|}
block|}
comment|// Finally, if all else fails, see if it is a BibTeX file:
if|if
condition|(
name|entryList
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|ParserResult
name|pr
init|=
name|loadDatabase
argument_list|(
operator|new
name|File
argument_list|(
name|filename
argument_list|)
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"defaultEncoding"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|pr
operator|.
name|getDatabase
argument_list|()
operator|.
name|getEntryCount
argument_list|()
operator|>
literal|0
operator|)
operator|||
operator|(
name|pr
operator|.
name|getDatabase
argument_list|()
operator|.
name|getStringCount
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|entryList
operator|=
name|pr
expr_stmt|;
name|pr
operator|.
name|setFile
argument_list|(
operator|new
name|File
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|usedFormat
operator|=
name|BIBTEX_FORMAT
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
comment|//ex.printStackTrace();
block|}
block|}
return|return
operator|new
name|Object
index|[]
block|{
name|usedFormat
block|,
name|entryList
block|}
return|;
block|}
block|}
end_class

end_unit

