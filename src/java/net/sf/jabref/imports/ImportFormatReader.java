begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2003  Morten O. Alver and Nizar N. Batada  All programs in this directory and subdirectories are published under the GNU General Public License as described below.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA  Further information about the GNU GPL is available at: http://www.gnu.org/copyleft/gpl.ja.html  */
end_comment

begin_package
DECL|package|net.sf.jabref.imports
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|imports
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|*
import|;
end_import

begin_comment
comment|// for medline
end_comment

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|helpers
operator|.
name|*
import|;
end_import

begin_comment
comment|//for medline
end_comment

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|SAXParserFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|SAXParser
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|*
import|;
end_import

begin_comment
comment|/*   // int jabrefframe BibtexDatabase database=new BibtexDatabase(); String filename=Globals.getNewFile(); ArrayList bibitems=readISI(filename); // is there a getFileName(); Iterator it = bibitems.iterator(); while(it.hasNext()){ BibtexEntry entry = (BibtexEntry)it.next(); entry.setId(Util.createId(entry.getType(), database); try { database.insertEntry(entry); } catch (KeyCollisionException ex) {  } } */
end_comment

begin_class
DECL|class|ImportFormatReader
specifier|public
class|class
name|ImportFormatReader
block|{
comment|/**      * Describe<code>fixAuthor</code> method here.      *      * @param in a<code>String</code> value      * @return a<code>String</code> value      // input format string: LN FN [and LN, FN]*      // output format string: FN LN [and FN LN]*      */
DECL|method|fixAuthor_nocomma (String in)
specifier|public
specifier|static
name|String
name|fixAuthor_nocomma
parameter_list|(
name|String
name|in
parameter_list|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|String
index|[]
name|authors
init|=
name|in
operator|.
name|split
argument_list|(
literal|" and "
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|authors
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|//System.out.println(authors[i]);
name|authors
index|[
name|i
index|]
operator|=
name|authors
index|[
name|i
index|]
operator|.
name|trim
argument_list|()
expr_stmt|;
name|String
index|[]
name|t
init|=
name|authors
index|[
name|i
index|]
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|t
index|[
literal|1
index|]
operator|.
name|trim
argument_list|()
operator|+
literal|" "
operator|+
name|t
index|[
literal|0
index|]
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|authors
operator|.
name|length
operator|-
literal|1
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
else|else
name|sb
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|//========================================================
comment|// rearranges the author names
comment|// input format string: LN, FN [and LN, FN]*
comment|// output format string: FN LN [and FN LN]*
comment|//========================================================
DECL|method|fixAuthor (String in)
specifier|public
specifier|static
name|String
name|fixAuthor
parameter_list|(
name|String
name|in
parameter_list|)
block|{
comment|//Util.pr("firstnamefirst");
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
comment|//System.out.println("FIX AUTHOR: in= " + in);
name|String
index|[]
name|authors
init|=
name|in
operator|.
name|split
argument_list|(
literal|" and "
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|authors
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
index|[]
name|t
init|=
name|authors
index|[
name|i
index|]
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|length
operator|<
literal|2
condition|)
return|return
name|in
return|;
comment|// something went wrong or there is no ","
name|sb
operator|.
name|append
argument_list|(
name|t
index|[
literal|1
index|]
operator|.
name|trim
argument_list|()
operator|+
literal|" "
operator|+
name|t
index|[
literal|0
index|]
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|authors
operator|.
name|length
operator|-
literal|1
condition|)
comment|// put back the " and "
name|sb
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|//========================================================
comment|// rearranges the author names
comment|// input format string: LN, FN [and LN, FN]*
comment|// output format string: LN, FN [and LN, FN]*
comment|//========================================================
DECL|method|fixAuthor_lastnameFirst (String in)
specifier|public
specifier|static
name|String
name|fixAuthor_lastnameFirst
parameter_list|(
name|String
name|in
parameter_list|)
block|{
comment|//Util.pr("lastnamefirst: in");
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|String
index|[]
name|authors
init|=
name|in
operator|.
name|split
argument_list|(
literal|" and "
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|authors
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
index|[]
name|t
init|=
name|authors
index|[
name|i
index|]
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|length
operator|<
literal|2
condition|)
block|{
comment|// The name is without a comma, so it must be rearranged.
name|t
operator|=
name|authors
index|[
name|i
index|]
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|t
index|[
name|t
operator|.
name|length
operator|-
literal|1
index|]
operator|+
literal|","
argument_list|)
expr_stmt|;
comment|// Last name
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|t
operator|.
name|length
operator|-
literal|1
condition|;
name|j
operator|++
control|)
name|sb
operator|.
name|append
argument_list|(
literal|" "
operator|+
name|t
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|sb
operator|.
name|append
argument_list|(
name|t
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The name is written with last name first, so it's ok.
name|sb
operator|.
name|append
argument_list|(
name|authors
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|authors
operator|.
name|length
operator|-
literal|1
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
block|}
comment|//Util.pr(in+" -> "+sb.toString());
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|readSixpack (String filename)
specifier|public
specifier|static
name|ArrayList
name|readSixpack
parameter_list|(
name|String
name|filename
parameter_list|)
block|{
specifier|final
name|String
name|SEPARATOR
init|=
operator|new
name|String
argument_list|(
operator|new
name|char
index|[]
block|{
literal|0
block|,
literal|48
block|}
argument_list|)
decl_stmt|;
name|HashMap
name|fI
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"id"
argument_list|,
literal|"bibtexkey"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"au"
argument_list|,
literal|"author"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"ti"
argument_list|,
literal|"title"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"jo"
argument_list|,
literal|"journal"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"vo"
argument_list|,
literal|"volume"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"nu"
argument_list|,
literal|"number"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"pa"
argument_list|,
literal|"pages"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"mo"
argument_list|,
literal|"month"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"yr"
argument_list|,
literal|"year"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"kw"
argument_list|,
literal|"keywords"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"ab"
argument_list|,
literal|"abstract"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"no"
argument_list|,
literal|"note"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"ed"
argument_list|,
literal|"editor"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"pu"
argument_list|,
literal|"publisher"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"se"
argument_list|,
literal|"series"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"ad"
argument_list|,
literal|"address"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"en"
argument_list|,
literal|"edition"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"ch"
argument_list|,
literal|"chapter"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"hp"
argument_list|,
literal|"howpublished"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"tb"
argument_list|,
literal|"booktitle"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"or"
argument_list|,
literal|"organization"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"sc"
argument_list|,
literal|"school"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"in"
argument_list|,
literal|"institution"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"ty"
argument_list|,
literal|"type"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"url"
argument_list|,
literal|"url"
argument_list|)
expr_stmt|;
name|fI
operator|.
name|put
argument_list|(
literal|"cr"
argument_list|,
literal|"crossref"
argument_list|)
expr_stmt|;
name|ArrayList
name|bibitems
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|canRead
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error "
operator|+
name|filename
operator|+
literal|" is not a valid file and|or is not readable."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
try|try
block|{
name|BufferedReader
name|in
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|FileReader
argument_list|(
name|filename
argument_list|)
argument_list|)
decl_stmt|;
name|in
operator|.
name|readLine
argument_list|()
expr_stmt|;
name|String
index|[]
name|fieldDef
init|=
name|in
operator|.
name|readLine
argument_list|()
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|String
name|s
init|=
literal|null
decl_stmt|;
name|BibtexEntry
name|entry
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|in
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|s
operator|=
name|s
operator|.
name|replaceAll
argument_list|(
literal|"<par>"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|// What is<par> ????
name|String
index|[]
name|fields
init|=
name|s
operator|.
name|split
argument_list|(
name|SEPARATOR
argument_list|)
decl_stmt|;
comment|// Check type and create entry:
name|BibtexEntryType
name|typ
init|=
name|BibtexEntryType
operator|.
name|getType
argument_list|(
name|fields
index|[
literal|1
index|]
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|typ
operator|==
literal|null
condition|)
block|{
name|String
name|type
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|fields
index|[
literal|1
index|]
operator|.
name|equals
argument_list|(
literal|"Masterthesis"
argument_list|)
condition|)
name|type
operator|=
literal|"mastersthesis"
expr_stmt|;
if|if
condition|(
name|fields
index|[
literal|1
index|]
operator|.
name|equals
argument_list|(
literal|"PhD-Thesis"
argument_list|)
condition|)
name|type
operator|=
literal|"phdthesis"
expr_stmt|;
if|if
condition|(
name|fields
index|[
literal|1
index|]
operator|.
name|equals
argument_list|(
literal|"miscellaneous"
argument_list|)
condition|)
name|type
operator|=
literal|"misc"
expr_stmt|;
if|if
condition|(
name|fields
index|[
literal|1
index|]
operator|.
name|equals
argument_list|(
literal|"Conference"
argument_list|)
condition|)
name|type
operator|=
literal|"proceedings"
expr_stmt|;
name|typ
operator|=
name|BibtexEntryType
operator|.
name|getType
argument_list|(
name|type
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|entry
operator|=
operator|new
name|BibtexEntry
argument_list|(
name|Util
operator|.
name|createNeutralId
argument_list|()
argument_list|,
name|typ
argument_list|)
expr_stmt|;
name|String
name|fld
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Math
operator|.
name|min
argument_list|(
name|fieldDef
operator|.
name|length
argument_list|,
name|fields
operator|.
name|length
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fld
operator|=
operator|(
name|String
operator|)
name|fI
operator|.
name|get
argument_list|(
name|fieldDef
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fld
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|fld
operator|.
name|equals
argument_list|(
literal|"author"
argument_list|)
operator|||
name|fld
operator|.
name|equals
argument_list|(
literal|"editor"
argument_list|)
condition|)
name|setField
argument_list|(
name|entry
argument_list|,
name|fld
argument_list|,
name|fields
index|[
name|i
index|]
operator|.
name|replaceAll
argument_list|(
literal|" and "
argument_list|,
literal|", "
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|", "
argument_list|,
literal|" and "
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fld
operator|.
name|equals
argument_list|(
literal|"pages"
argument_list|)
condition|)
name|setField
argument_list|(
name|entry
argument_list|,
name|fld
argument_list|,
name|fields
index|[
name|i
index|]
operator|.
name|replaceAll
argument_list|(
literal|"-"
argument_list|,
literal|"--"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|setField
argument_list|(
name|entry
argument_list|,
name|fld
argument_list|,
name|fields
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|bibitems
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|ex
parameter_list|)
block|{
name|Globals
operator|.
name|logger
argument_list|(
literal|"Problem parsing Sixpack entry, ignoring entry."
argument_list|)
expr_stmt|;
block|}
block|}
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|bibitems
return|;
block|}
comment|/**      * Just a little wrapper for BibtexEntry's setField, to prevent the field      * from getting set when the content is an empty string.      */
DECL|method|setField (BibtexEntry be, String field, String content)
specifier|private
specifier|static
name|void
name|setField
parameter_list|(
name|BibtexEntry
name|be
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|content
parameter_list|)
block|{
if|if
condition|(
operator|!
name|content
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
name|be
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|content
argument_list|)
expr_stmt|;
block|}
comment|//============================================================
comment|// given a filename, parses the file (assuming scifinder)
comment|// returns null if unable to find any entries or if the
comment|// file is not in scifinder format
comment|//============================================================
DECL|method|readScifinder ( String filename)
specifier|public
specifier|static
name|ArrayList
name|readScifinder
parameter_list|(
name|String
name|filename
parameter_list|)
block|{
name|ArrayList
name|bibitems
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|canRead
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error "
operator|+
name|filename
operator|+
literal|" is not a valid file and|or is not readable."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
try|try
block|{
name|BufferedReader
name|in
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|FileReader
argument_list|(
name|filename
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|str
decl_stmt|;
while|while
condition|(
operator|(
name|str
operator|=
name|in
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
name|String
index|[]
name|entries
init|=
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|"START_RECORD"
argument_list|)
decl_stmt|;
name|HashMap
name|hm
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|entries
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
index|[]
name|fields
init|=
name|entries
index|[
name|i
index|]
operator|.
name|split
argument_list|(
literal|"FIELD "
argument_list|)
decl_stmt|;
name|String
name|Type
init|=
literal|""
decl_stmt|;
name|hm
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// reset
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|fields
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|String
name|tmp
index|[]
init|=
name|fields
index|[
name|j
index|]
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|.
name|length
operator|>
literal|1
condition|)
block|{
comment|//==2
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"Author"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"author"
argument_list|,
name|tmp
index|[
literal|1
index|]
operator|.
name|replaceAll
argument_list|(
literal|";"
argument_list|,
literal|" and "
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"Title"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"title"
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"Journal Title"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"journal"
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"Volume"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"volume"
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"Page"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"pages"
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"Publication Year"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"year"
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"Abstract"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"abstract"
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"Supplementary Terms"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"keywords"
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"Document Type"
argument_list|)
condition|)
name|Type
operator|=
name|tmp
index|[
literal|1
index|]
operator|.
name|replaceAll
argument_list|(
literal|"Journal"
argument_list|,
literal|"article"
argument_list|)
expr_stmt|;
block|}
block|}
name|BibtexEntry
name|b
init|=
operator|new
name|BibtexEntry
argument_list|(
name|Globals
operator|.
name|DEFAULT_BIBTEXENTRY_ID
argument_list|,
name|Globals
operator|.
name|getEntryType
argument_list|(
name|Type
argument_list|)
argument_list|)
decl_stmt|;
comment|// id assumes an existing database so don't create one here
name|b
operator|.
name|setField
argument_list|(
name|hm
argument_list|)
expr_stmt|;
name|bibitems
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|bibitems
return|;
block|}
comment|//==================================================
comment|//
comment|//==================================================
DECL|method|readISI ( String filename)
specifier|public
specifier|static
name|ArrayList
name|readISI
parameter_list|(
name|String
name|filename
parameter_list|)
comment|//jbm for new Bibitem
block|{
name|ArrayList
name|bibitems
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|canRead
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error "
operator|+
name|filename
operator|+
literal|" is not a valid file and|or is not readable."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
try|try
block|{
name|BufferedReader
name|in
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|FileReader
argument_list|(
name|filename
argument_list|)
argument_list|)
decl_stmt|;
comment|//Pattern fieldPattern = Pattern.compile("^AU |^TI |^SO |^DT |^C1 |^AB |^ID |^BP |^PY |^SE |^PY |^VL |^IS ");
name|String
name|str
decl_stmt|;
while|while
condition|(
operator|(
name|str
operator|=
name|in
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|str
operator|.
name|length
argument_list|()
operator|<
literal|3
condition|)
continue|continue;
comment|// begining of a new item
if|if
condition|(
name|str
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
operator|.
name|equals
argument_list|(
literal|"PT "
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"::"
operator|+
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|beg
init|=
name|str
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
comment|// I could have used the fieldPattern regular expression instead however this seems to be
comment|// quick and dirty and it works!
if|if
condition|(
name|beg
operator|.
name|length
argument_list|()
operator|==
literal|2
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" ## "
argument_list|)
expr_stmt|;
comment|// mark the begining of each field
name|sb
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"EOLEOL"
argument_list|)
expr_stmt|;
comment|// mark the end of each line
name|sb
operator|.
name|append
argument_list|(
name|str
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//remove the initial " "
block|}
block|}
block|}
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|//JOptionPane.showMessageDialog(null, "Error: reading " + filename );
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error reading file: "
operator|+
name|filename
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|String
index|[]
name|entries
init|=
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
comment|// skip the first entry as it is either empty or has document header
name|HashMap
name|hm
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|entries
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
index|[]
name|fields
init|=
name|entries
index|[
name|i
index|]
operator|.
name|split
argument_list|(
literal|" ## "
argument_list|)
decl_stmt|;
name|String
name|Type
init|=
literal|""
decl_stmt|,
name|PT
init|=
literal|""
decl_stmt|,
name|pages
init|=
literal|""
decl_stmt|;
name|hm
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|fields
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|String
name|beg
init|=
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|beg
operator|.
name|equals
argument_list|(
literal|"PT"
argument_list|)
condition|)
block|{
name|PT
operator|=
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
operator|.
name|replaceAll
argument_list|(
literal|"Journal"
argument_list|,
literal|"article"
argument_list|)
expr_stmt|;
name|Type
operator|=
literal|"article"
expr_stmt|;
comment|//make all of them PT?
block|}
elseif|else
if|if
condition|(
name|beg
operator|.
name|equals
argument_list|(
literal|"AU"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"author"
argument_list|,
name|fixAuthor
argument_list|(
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
operator|.
name|replaceAll
argument_list|(
literal|"EOLEOL"
argument_list|,
literal|" and "
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|beg
operator|.
name|equals
argument_list|(
literal|"TI"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"title"
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
operator|.
name|replaceAll
argument_list|(
literal|"EOLEOL"
argument_list|,
literal|" "
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|beg
operator|.
name|equals
argument_list|(
literal|"SO"
argument_list|)
condition|)
block|{
comment|// journal name
name|hm
operator|.
name|put
argument_list|(
literal|"journal"
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|beg
operator|.
name|equals
argument_list|(
literal|"ID"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"keywords"
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
operator|.
name|replaceAll
argument_list|(
literal|"EOLEOL"
argument_list|,
literal|" "
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|beg
operator|.
name|equals
argument_list|(
literal|"AB"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"abstract"
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
operator|.
name|replaceAll
argument_list|(
literal|"EOLEOL"
argument_list|,
literal|" "
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|beg
operator|.
name|equals
argument_list|(
literal|"BP"
argument_list|)
condition|)
comment|//hm.put("pages", fields[j].substring(2,fields[j].length()).trim());
name|pages
operator|=
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|beg
operator|.
name|equals
argument_list|(
literal|"EP"
argument_list|)
condition|)
block|{
name|pages
operator|=
name|pages
operator|+
literal|"--"
operator|+
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|beg
operator|.
name|equals
argument_list|(
literal|"IS"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"number"
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|beg
operator|.
name|equals
argument_list|(
literal|"PY"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"year"
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|beg
operator|.
name|equals
argument_list|(
literal|"VL"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"volume"
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|beg
operator|.
name|equals
argument_list|(
literal|"DT"
argument_list|)
condition|)
block|{
name|Type
operator|=
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|Type
operator|.
name|equals
argument_list|(
literal|"Article"
argument_list|)
operator|&&
operator|!
name|PT
operator|.
name|equals
argument_list|(
literal|"Journal"
argument_list|)
condition|)
comment|//Article"))
name|Type
operator|=
literal|"misc"
expr_stmt|;
else|else
name|Type
operator|=
literal|"article"
expr_stmt|;
block|}
comment|//ignore
elseif|else
if|if
condition|(
name|beg
operator|.
name|equals
argument_list|(
literal|"CR"
argument_list|)
condition|)
comment|//cited references
name|hm
operator|.
name|put
argument_list|(
literal|"CitedReferences"
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"EOLEOL"
argument_list|,
literal|" ; "
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|hm
operator|.
name|put
argument_list|(
literal|"pages"
argument_list|,
name|pages
argument_list|)
expr_stmt|;
name|BibtexEntry
name|b
init|=
operator|new
name|BibtexEntry
argument_list|(
name|Globals
operator|.
name|DEFAULT_BIBTEXENTRY_ID
argument_list|,
name|Globals
operator|.
name|getEntryType
argument_list|(
name|Type
argument_list|)
argument_list|)
decl_stmt|;
comment|// id assumes an existing database so don't create one here
name|b
operator|.
name|setField
argument_list|(
name|hm
argument_list|)
expr_stmt|;
name|bibitems
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|bibitems
return|;
block|}
comment|//==================================================
comment|//
comment|//==================================================
DECL|field|ovid_src_pat
specifier|public
specifier|static
name|Pattern
name|ovid_src_pat
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"Source ([ \\w&\\-]+)\\.[ ]+([0-9]+)\\(([\\w\\-]+)\\):([0-9]+\\-?[0-9]+?)\\,.*([0-9][0-9][0-9][0-9])"
argument_list|)
decl_stmt|;
DECL|field|ovid_src_pat_no_issue
specifier|public
specifier|static
name|Pattern
name|ovid_src_pat_no_issue
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"Source ([ \\w&\\-]+)\\.[ ]+([0-9]+):([0-9]+\\-?[0-9]+?)\\,.*([0-9][0-9][0-9][0-9])"
argument_list|)
decl_stmt|;
DECL|method|readOvid ( String filename)
specifier|public
specifier|static
name|ArrayList
name|readOvid
parameter_list|(
name|String
name|filename
parameter_list|)
block|{
name|ArrayList
name|bibitems
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|int
name|rowNum
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|canRead
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error: "
operator|+
name|filename
operator|+
literal|" is not a valid file and|or is not readable."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
try|try
block|{
name|BufferedReader
name|in
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|FileReader
argument_list|(
name|filename
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|line
decl_stmt|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|in
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|line
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|line
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|' '
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|"__NEWFIELD__"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|String
name|items
index|[]
init|=
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|"<[0-9]+>"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|items
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|HashMap
name|h
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
name|String
index|[]
name|fields
init|=
name|items
index|[
name|i
index|]
operator|.
name|split
argument_list|(
literal|"__NEWFIELD__"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|fields
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|fields
index|[
name|j
index|]
operator|=
name|fields
index|[
name|j
index|]
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|fields
index|[
name|j
index|]
operator|.
name|indexOf
argument_list|(
literal|"Author"
argument_list|)
operator|==
literal|0
operator|&&
name|fields
index|[
name|j
index|]
operator|.
name|indexOf
argument_list|(
literal|"Author Keywords"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|fields
index|[
name|j
index|]
operator|.
name|indexOf
argument_list|(
literal|"Author e-mail"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|String
name|author
decl_stmt|;
name|boolean
name|isComma
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|fields
index|[
name|j
index|]
operator|.
name|indexOf
argument_list|(
literal|";"
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|//LN FN; [LN FN;]*
name|author
operator|=
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|7
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"[^\\.A-Za-z,;\\- ]"
argument_list|,
literal|""
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|";"
argument_list|,
literal|" and "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// LN FN. [LN FN.]*
name|isComma
operator|=
literal|true
expr_stmt|;
name|author
operator|=
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|7
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\."
argument_list|,
literal|" and"
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|" and$"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|author
operator|.
name|split
argument_list|(
literal|" and "
argument_list|)
operator|.
name|length
operator|>
literal|1
condition|)
block|{
comment|// single author or no ";"
if|if
condition|(
name|isComma
operator|==
literal|false
condition|)
name|h
operator|.
name|put
argument_list|(
literal|"author"
argument_list|,
name|fixAuthor
argument_list|(
name|author
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|h
operator|.
name|put
argument_list|(
literal|"author"
argument_list|,
name|fixAuthor_nocomma
argument_list|(
name|author
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|h
operator|.
name|put
argument_list|(
literal|"author"
argument_list|,
name|author
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fields
index|[
name|j
index|]
operator|.
name|indexOf
argument_list|(
literal|"Title"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|.
name|put
argument_list|(
literal|"title"
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|6
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\[.+\\]"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fields
index|[
name|j
index|]
operator|.
name|indexOf
argument_list|(
literal|"Source"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|String
name|s
init|=
name|fields
index|[
name|j
index|]
decl_stmt|;
name|Matcher
name|matcher
init|=
name|ovid_src_pat
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|boolean
name|matchfound
init|=
name|matcher
operator|.
name|find
argument_list|()
decl_stmt|;
if|if
condition|(
name|matchfound
condition|)
block|{
name|h
operator|.
name|put
argument_list|(
literal|"journal"
argument_list|,
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|.
name|put
argument_list|(
literal|"volume"
argument_list|,
name|matcher
operator|.
name|group
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|.
name|put
argument_list|(
literal|"issue"
argument_list|,
name|matcher
operator|.
name|group
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|.
name|put
argument_list|(
literal|"pages"
argument_list|,
name|matcher
operator|.
name|group
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|.
name|put
argument_list|(
literal|"year"
argument_list|,
name|matcher
operator|.
name|group
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// may be missing the issue
name|matcher
operator|=
name|ovid_src_pat_no_issue
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|matchfound
operator|=
name|matcher
operator|.
name|find
argument_list|()
expr_stmt|;
if|if
condition|(
name|matchfound
condition|)
block|{
name|h
operator|.
name|put
argument_list|(
literal|"journal"
argument_list|,
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|.
name|put
argument_list|(
literal|"volume"
argument_list|,
name|matcher
operator|.
name|group
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|.
name|put
argument_list|(
literal|"pages"
argument_list|,
name|matcher
operator|.
name|group
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|.
name|put
argument_list|(
literal|"year"
argument_list|,
name|matcher
operator|.
name|group
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|fields
index|[
name|j
index|]
operator|.
name|indexOf
argument_list|(
literal|"Abstract"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|.
name|put
argument_list|(
literal|"abstract"
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|9
argument_list|,
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//else if(fields[j].indexOf("References")==0)
comment|//	h.put("references", fields[j].substring( 11,fields[j].length()));
block|}
name|BibtexEntry
name|b
init|=
operator|new
name|BibtexEntry
argument_list|(
name|Globals
operator|.
name|DEFAULT_BIBTEXENTRY_ID
argument_list|,
name|Globals
operator|.
name|getEntryType
argument_list|(
literal|"article"
argument_list|)
argument_list|)
decl_stmt|;
comment|// id assumes an existing database so don't create one here
name|b
operator|.
name|setField
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|bibitems
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|bibitems
return|;
block|}
DECL|method|checkAndCreateFile (String filename)
specifier|static
name|File
name|checkAndCreateFile
parameter_list|(
name|String
name|filename
parameter_list|)
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|canRead
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error "
operator|+
name|filename
operator|+
literal|" is not a valid file and|or is not readable."
argument_list|)
expr_stmt|;
name|Globals
operator|.
name|logger
argument_list|(
literal|"Error "
operator|+
name|filename
operator|+
literal|" is not a valid file and|or is not readable."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
return|return
name|f
return|;
block|}
comment|// check here for details on the format
comment|// http://www.ecst.csuchico.edu/~jacobsd/bib/formats/endnote.html
DECL|method|readEndnote (String filename)
specifier|public
specifier|static
name|ArrayList
name|readEndnote
parameter_list|(
name|String
name|filename
parameter_list|)
block|{
name|String
name|ENDOFRECORD
init|=
literal|"__EOREOR__"
decl_stmt|;
name|ArrayList
name|bibitems
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|File
name|f
init|=
name|checkAndCreateFile
argument_list|(
name|filename
argument_list|)
decl_stmt|;
comment|// will return null if file is not readable
if|if
condition|(
name|f
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
try|try
block|{
name|BufferedReader
name|in
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|FileReader
argument_list|(
name|filename
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|str
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
while|while
condition|(
operator|(
name|str
operator|=
name|in
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|str
operator|=
name|str
operator|.
name|trim
argument_list|()
expr_stmt|;
comment|// if(str.equals("")) continue;
if|if
condition|(
name|str
operator|.
name|indexOf
argument_list|(
literal|"%0"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|ENDOFRECORD
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
name|sb
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
name|String
index|[]
name|entries
init|=
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
name|ENDOFRECORD
argument_list|)
decl_stmt|;
name|HashMap
name|hm
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
name|String
name|Author
init|=
literal|""
decl_stmt|,
name|Type
init|=
literal|""
decl_stmt|,
name|Editor
init|=
literal|""
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|entries
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|hm
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Author
operator|=
literal|""
expr_stmt|;
name|Type
operator|=
literal|""
expr_stmt|;
name|Editor
operator|=
literal|""
expr_stmt|;
name|String
index|[]
name|fields
init|=
name|entries
index|[
name|i
index|]
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
operator|.
name|split
argument_list|(
literal|"\n%"
argument_list|)
decl_stmt|;
comment|//String lastPrefix = "";
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|fields
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
operator|<
literal|3
condition|)
continue|continue;
comment|/* Details of Refer format for Journal Article and Book:  		  Generic            Ref     Journal Article   Book 		  Code 		  Author             %A      Author            Author 		  Year               %D      Year              Year 		  Title              %T      Title             Title 		  Secondary Author   %E                        Series Editor 		  Secondary Title    %B      Journal           Series Title 		  Place Published    %C                        City 		  Publisher          %I                        Publisher 		  Volume             %V      Volume            Volume 		  Number of Volumes  %6                        Number of Volumes 		  Number             %N      Issue 		  Pages              %P      Pages             Number of Pages 		  Edition            %7                        Edition 		  Subsidiary Author  %?                        Translator 		  Alternate Title    %J      Alternate Journal 		  Label              %F      Label             Label 		  Keywords           %K      Keywords          Keywords 		  Abstract           %X      Abstract          Abstract 		  Notes              %O      Notes             Notes 		*/
name|String
name|prefix
init|=
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|String
name|val
init|=
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"A"
argument_list|)
condition|)
block|{
if|if
condition|(
name|Author
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
name|Author
operator|=
name|val
expr_stmt|;
else|else
name|Author
operator|+=
literal|" and "
operator|+
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"Y"
argument_list|)
condition|)
block|{
if|if
condition|(
name|Editor
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
name|Editor
operator|=
name|val
expr_stmt|;
else|else
name|Editor
operator|+=
literal|" and "
operator|+
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"T"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"title"
argument_list|,
name|Globals
operator|.
name|putBracesAroundCapitals
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"0"
argument_list|)
condition|)
block|{
if|if
condition|(
name|val
operator|.
name|indexOf
argument_list|(
literal|"Journal"
argument_list|)
operator|==
literal|0
condition|)
name|Type
operator|=
literal|"article"
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|val
operator|.
name|indexOf
argument_list|(
literal|"Book"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|val
operator|.
name|indexOf
argument_list|(
literal|"Edited Book"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|Type
operator|=
literal|"book"
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|.
name|indexOf
argument_list|(
literal|"Conference"
argument_list|)
operator|==
literal|0
condition|)
comment|// Proceedings
name|Type
operator|=
literal|"inproceedings"
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|.
name|indexOf
argument_list|(
literal|"Report"
argument_list|)
operator|==
literal|0
condition|)
comment|// Techreport
name|Type
operator|=
literal|"techreport"
expr_stmt|;
else|else
name|Type
operator|=
literal|"misc"
expr_stmt|;
comment|//
block|}
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"7"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"edition"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"C"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"address"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"D"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"year"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"8"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"date"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"J"
argument_list|)
condition|)
block|{
comment|// "Alternate journal. Let's set it only if no journal
comment|// has been set with %B.
if|if
condition|(
name|hm
operator|.
name|get
argument_list|(
literal|"journal"
argument_list|)
operator|==
literal|null
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"journal"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"B"
argument_list|)
condition|)
block|{
comment|// This prefix stands for "journal" in a journal entry, and
comment|// "series" in a book entry.
if|if
condition|(
name|Type
operator|.
name|equals
argument_list|(
literal|"article"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"journal"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Type
operator|.
name|equals
argument_list|(
literal|"book"
argument_list|)
operator|||
name|Type
operator|.
name|equals
argument_list|(
literal|"inbook"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"series"
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
comment|/* if (Type.equals("inproceedings"))*/
name|hm
operator|.
name|put
argument_list|(
literal|"booktitle"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"I"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"publisher"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"P"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"pages"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"V"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"volume"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"N"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"number"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"U"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"url"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"O"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"note"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"K"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"keywords"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"X"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"abstract"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"9"
argument_list|)
condition|)
block|{
comment|//Util.pr(val);
if|if
condition|(
name|val
operator|.
name|indexOf
argument_list|(
literal|"Ph.D."
argument_list|)
operator|==
literal|0
condition|)
name|Type
operator|=
literal|"phdthesis"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"F"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
name|Globals
operator|.
name|KEY_FIELD
argument_list|,
name|Util
operator|.
name|checkLegalKey
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//fixauthorscomma
if|if
condition|(
operator|!
name|Author
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"author"
argument_list|,
name|fixAuthor
argument_list|(
name|Author
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Editor
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"editor"
argument_list|,
name|fixAuthor
argument_list|(
name|Editor
argument_list|)
argument_list|)
expr_stmt|;
name|BibtexEntry
name|b
init|=
operator|new
name|BibtexEntry
argument_list|(
name|Globals
operator|.
name|DEFAULT_BIBTEXENTRY_ID
argument_list|,
name|Globals
operator|.
name|getEntryType
argument_list|(
name|Type
argument_list|)
argument_list|)
decl_stmt|;
comment|// id assumes an existing database so don't create one here
name|b
operator|.
name|setField
argument_list|(
name|hm
argument_list|)
expr_stmt|;
comment|//if (hm.isEmpty())
if|if
condition|(
name|b
operator|.
name|getAllFields
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|)
name|bibitems
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|bibitems
return|;
block|}
comment|//========================================================
comment|//
comment|//========================================================
DECL|method|readReferenceManager10 (String filename)
specifier|public
specifier|static
name|ArrayList
name|readReferenceManager10
parameter_list|(
name|String
name|filename
parameter_list|)
block|{
name|ArrayList
name|bibitems
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|canRead
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error "
operator|+
name|filename
operator|+
literal|" is not a valid file and|or is not readable."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
try|try
block|{
name|BufferedReader
name|in
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|FileReader
argument_list|(
name|filename
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|str
decl_stmt|;
while|while
condition|(
operator|(
name|str
operator|=
name|in
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
name|String
index|[]
name|entries
init|=
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|"ER  -"
argument_list|)
decl_stmt|;
name|HashMap
name|hm
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|entries
operator|.
name|length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|String
name|Type
init|=
literal|""
decl_stmt|,
name|Author
init|=
literal|""
decl_stmt|,
name|StartPage
init|=
literal|""
decl_stmt|,
name|EndPage
init|=
literal|""
decl_stmt|;
name|hm
operator|.
name|clear
argument_list|()
expr_stmt|;
name|String
index|[]
name|fields
init|=
name|entries
index|[
name|i
index|]
operator|.
name|split
argument_list|(
literal|"\n"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|fields
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fields
index|[
name|j
index|]
operator|.
name|length
argument_list|()
operator|<
literal|2
condition|)
continue|continue;
else|else
block|{
name|String
name|lab
init|=
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|String
name|val
init|=
name|fields
index|[
name|j
index|]
operator|.
name|substring
argument_list|(
literal|6
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|lab
operator|.
name|equals
argument_list|(
literal|"TY"
argument_list|)
condition|)
block|{
if|if
condition|(
name|val
operator|.
name|equals
argument_list|(
literal|"BOOK"
argument_list|)
condition|)
name|Type
operator|=
literal|"book"
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|.
name|equals
argument_list|(
literal|"JOUR"
argument_list|)
condition|)
name|Type
operator|=
literal|"article"
expr_stmt|;
else|else
name|Type
operator|=
literal|"other"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lab
operator|.
name|equals
argument_list|(
literal|"T1"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"title"
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|//Title = val;
elseif|else
if|if
condition|(
name|lab
operator|.
name|equals
argument_list|(
literal|"A1"
argument_list|)
operator|||
name|lab
operator|.
name|equals
argument_list|(
literal|"AU"
argument_list|)
condition|)
block|{
if|if
condition|(
name|Author
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
comment|// don't add " and " for the first author
name|Author
operator|=
name|val
expr_stmt|;
else|else
name|Author
operator|+=
literal|" and "
operator|+
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lab
operator|.
name|equals
argument_list|(
literal|"JA"
argument_list|)
operator|||
name|lab
operator|.
name|equals
argument_list|(
literal|"JF"
argument_list|)
operator|||
name|lab
operator|.
name|equals
argument_list|(
literal|"JO"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"journal"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lab
operator|.
name|equals
argument_list|(
literal|"SP"
argument_list|)
condition|)
name|StartPage
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|lab
operator|.
name|equals
argument_list|(
literal|"EP"
argument_list|)
condition|)
name|EndPage
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|lab
operator|.
name|equals
argument_list|(
literal|"VL"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"volume"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lab
operator|.
name|equals
argument_list|(
literal|"IS"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"number"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lab
operator|.
name|equals
argument_list|(
literal|"N2"
argument_list|)
operator|||
name|lab
operator|.
name|equals
argument_list|(
literal|"AB"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"abstract"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lab
operator|.
name|equals
argument_list|(
literal|"UR"
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"url"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|lab
operator|.
name|equals
argument_list|(
literal|"Y1"
argument_list|)
operator|||
name|lab
operator|.
name|equals
argument_list|(
literal|"PY"
argument_list|)
operator|)
operator|&&
name|val
operator|.
name|length
argument_list|()
operator|>=
literal|4
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"year"
argument_list|,
name|val
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// fix authors
name|Author
operator|=
name|fixAuthor
argument_list|(
name|Author
argument_list|)
expr_stmt|;
if|if
condition|(
name|Author
operator|.
name|endsWith
argument_list|(
literal|"."
argument_list|)
condition|)
name|hm
operator|.
name|put
argument_list|(
literal|"author"
argument_list|,
name|Author
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|Author
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|hm
operator|.
name|put
argument_list|(
literal|"author"
argument_list|,
name|Author
argument_list|)
expr_stmt|;
name|hm
operator|.
name|put
argument_list|(
literal|"pages"
argument_list|,
name|StartPage
operator|+
literal|"--"
operator|+
name|EndPage
argument_list|)
expr_stmt|;
name|BibtexEntry
name|b
init|=
operator|new
name|BibtexEntry
argument_list|(
name|Globals
operator|.
name|DEFAULT_BIBTEXENTRY_ID
argument_list|,
name|Globals
operator|.
name|getEntryType
argument_list|(
name|Type
argument_list|)
argument_list|)
decl_stmt|;
comment|// id assumes an existing database so don't create one here
name|b
operator|.
name|setField
argument_list|(
name|hm
argument_list|)
expr_stmt|;
name|bibitems
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|bibitems
return|;
block|}
comment|//==================================================
comment|//
comment|//==================================================
DECL|method|readMedline (String filename)
specifier|public
specifier|static
name|ArrayList
name|readMedline
parameter_list|(
name|String
name|filename
parameter_list|)
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|canRead
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error "
operator|+
name|filename
operator|+
literal|" is not a valid file and|or is not readable."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Obtain a factory object for creating SAX parsers
name|SAXParserFactory
name|parserFactory
init|=
name|SAXParserFactory
operator|.
name|newInstance
argument_list|()
decl_stmt|;
comment|// Configure the factory object to specify attributes of the parsers it creates
name|parserFactory
operator|.
name|setValidating
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|parserFactory
operator|.
name|setNamespaceAware
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Now create a SAXParser object
name|ArrayList
name|bibItems
init|=
literal|null
decl_stmt|;
try|try
block|{
name|SAXParser
name|parser
init|=
name|parserFactory
operator|.
name|newSAXParser
argument_list|()
decl_stmt|;
comment|//May throw exceptions
name|MedlineHandler
name|handler
init|=
operator|new
name|MedlineHandler
argument_list|()
decl_stmt|;
comment|// Start the parser. It reads the file and calls methods of the handler.
name|parser
operator|.
name|parse
argument_list|(
operator|new
name|File
argument_list|(
name|filename
argument_list|)
argument_list|,
name|handler
argument_list|)
expr_stmt|;
comment|// When you're done, report the results stored by your handler object
name|bibItems
operator|=
name|handler
operator|.
name|getItems
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|ParserConfigurationException
name|e1
parameter_list|)
block|{}
catch|catch
parameter_list|(
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
name|e2
parameter_list|)
block|{}
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|e3
parameter_list|)
block|{}
return|return
name|bibItems
return|;
block|}
DECL|method|readBibTeXML (String filename)
specifier|public
specifier|static
name|ArrayList
name|readBibTeXML
parameter_list|(
name|String
name|filename
parameter_list|)
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|canRead
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error "
operator|+
name|filename
operator|+
literal|" is not a valid file and|or is not readable."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Obtain a factory object for creating SAX parsers
name|SAXParserFactory
name|parserFactory
init|=
name|SAXParserFactory
operator|.
name|newInstance
argument_list|()
decl_stmt|;
comment|// Configure the factory object to specify attributes of the parsers it creates
name|parserFactory
operator|.
name|setValidating
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|parserFactory
operator|.
name|setNamespaceAware
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Now create a SAXParser object
name|ArrayList
name|bibItems
init|=
literal|null
decl_stmt|;
try|try
block|{
name|SAXParser
name|parser
init|=
name|parserFactory
operator|.
name|newSAXParser
argument_list|()
decl_stmt|;
comment|//May throw exceptions
name|BibTeXMLHandler
name|handler
init|=
operator|new
name|BibTeXMLHandler
argument_list|()
decl_stmt|;
comment|// Start the parser. It reads the file and calls methods of the handler.
name|parser
operator|.
name|parse
argument_list|(
operator|new
name|File
argument_list|(
name|filename
argument_list|)
argument_list|,
name|handler
argument_list|)
expr_stmt|;
comment|// When you're done, report the results stored by your handler object
name|bibItems
operator|=
name|handler
operator|.
name|getItems
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|ParserConfigurationException
name|e1
parameter_list|)
block|{}
catch|catch
parameter_list|(
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
name|e2
parameter_list|)
block|{}
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|e3
parameter_list|)
block|{}
return|return
name|bibItems
return|;
block|}
comment|//==================================================
comment|//
comment|//==================================================
DECL|method|fetchMedline (String id)
specifier|public
specifier|static
name|ArrayList
name|fetchMedline
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|ArrayList
name|bibItems
init|=
literal|null
decl_stmt|;
try|try
block|{
name|String
name|baseUrl
init|=
literal|"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&retmode=xml&rettype=citation&id="
operator|+
name|id
decl_stmt|;
name|URL
name|url
init|=
operator|new
name|URL
argument_list|(
name|baseUrl
argument_list|)
decl_stmt|;
name|HttpURLConnection
name|data
init|=
operator|(
name|HttpURLConnection
operator|)
name|url
operator|.
name|openConnection
argument_list|()
decl_stmt|;
comment|// Obtain a factory object for creating SAX parsers
name|SAXParserFactory
name|parserFactory
init|=
name|SAXParserFactory
operator|.
name|newInstance
argument_list|()
decl_stmt|;
comment|// Configure the factory object to specify attributes of the parsers it creates
name|parserFactory
operator|.
name|setValidating
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|parserFactory
operator|.
name|setNamespaceAware
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Now create a SAXParser object
name|SAXParser
name|parser
init|=
name|parserFactory
operator|.
name|newSAXParser
argument_list|()
decl_stmt|;
comment|//May throw exceptions
name|MedlineHandler
name|handler
init|=
operator|new
name|MedlineHandler
argument_list|()
decl_stmt|;
comment|// Start the parser. It reads the file and calls methods of the handler.
name|parser
operator|.
name|parse
argument_list|(
name|data
operator|.
name|getInputStream
argument_list|()
argument_list|,
name|handler
argument_list|)
expr_stmt|;
comment|// When you're done, report the results stored by your handler object
name|bibItems
operator|=
name|handler
operator|.
name|getItems
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|ParserConfigurationException
name|e1
parameter_list|)
block|{}
catch|catch
parameter_list|(
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
name|e2
parameter_list|)
block|{}
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|e3
parameter_list|)
block|{}
return|return
name|bibItems
return|;
block|}
comment|//========================================================
comment|//
comment|//========================================================
DECL|method|readINSPEC ( String filename)
specifier|public
specifier|static
name|ArrayList
name|readINSPEC
parameter_list|(
name|String
name|filename
parameter_list|)
block|{
name|ArrayList
name|bibitems
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|canRead
argument_list|()
operator|&&
operator|!
name|f
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error "
operator|+
name|filename
operator|+
literal|" is not a valid file and|or is not readable."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
try|try
block|{
name|BufferedReader
name|in
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|FileReader
argument_list|(
name|filename
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|str
decl_stmt|;
while|while
condition|(
operator|(
name|str
operator|=
name|in
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|str
operator|.
name|length
argument_list|()
operator|<
literal|2
condition|)
continue|continue;
if|if
condition|(
name|str
operator|.
name|indexOf
argument_list|(
literal|"Record"
argument_list|)
operator|==
literal|0
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|"__::__"
operator|+
name|str
argument_list|)
expr_stmt|;
else|else
name|sb
operator|.
name|append
argument_list|(
literal|"__NEWFIELD__"
operator|+
name|str
argument_list|)
expr_stmt|;
block|}
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|String
index|[]
name|entries
init|=
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|"__::__"
argument_list|)
decl_stmt|;
name|String
name|Type
init|=
literal|""
decl_stmt|;
name|HashMap
name|h
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|entries
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|entries
index|[
name|i
index|]
operator|.
name|indexOf
argument_list|(
literal|"Record"
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|h
operator|.
name|clear
argument_list|()
expr_stmt|;
name|String
index|[]
name|fields
init|=
name|entries
index|[
name|i
index|]
operator|.
name|split
argument_list|(
literal|"__NEWFIELD__"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|fields
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
comment|//System.out.println(fields[j]);
name|String
name|s
init|=
name|fields
index|[
name|j
index|]
decl_stmt|;
name|String
name|f3
init|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|String
name|frest
init|=
name|s
operator|.
name|substring
argument_list|(
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
name|f3
operator|.
name|equals
argument_list|(
literal|"TI"
argument_list|)
condition|)
name|h
operator|.
name|put
argument_list|(
literal|"title"
argument_list|,
name|frest
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|f3
operator|.
name|equals
argument_list|(
literal|"PY"
argument_list|)
condition|)
name|h
operator|.
name|put
argument_list|(
literal|"year"
argument_list|,
name|frest
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|f3
operator|.
name|equals
argument_list|(
literal|"AU"
argument_list|)
condition|)
name|h
operator|.
name|put
argument_list|(
literal|"author"
argument_list|,
name|fixAuthor
argument_list|(
name|frest
operator|.
name|replaceAll
argument_list|(
literal|",-"
argument_list|,
literal|", "
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|";"
argument_list|,
literal|" and "
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|f3
operator|.
name|equals
argument_list|(
literal|"AB"
argument_list|)
condition|)
name|h
operator|.
name|put
argument_list|(
literal|"abstract"
argument_list|,
name|frest
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|f3
operator|.
name|equals
argument_list|(
literal|"ID"
argument_list|)
condition|)
name|h
operator|.
name|put
argument_list|(
literal|"keywords"
argument_list|,
name|frest
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|f3
operator|.
name|equals
argument_list|(
literal|"SO"
argument_list|)
condition|)
block|{
name|int
name|m
init|=
name|frest
operator|.
name|indexOf
argument_list|(
literal|"."
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|>=
literal|0
condition|)
block|{
name|String
name|jr
init|=
name|frest
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|m
argument_list|)
decl_stmt|;
name|h
operator|.
name|put
argument_list|(
literal|"journal"
argument_list|,
name|jr
operator|.
name|replaceAll
argument_list|(
literal|"-"
argument_list|,
literal|" "
argument_list|)
argument_list|)
expr_stmt|;
name|frest
operator|=
name|frest
operator|.
name|substring
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|frest
operator|.
name|indexOf
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|>=
literal|5
condition|)
block|{
name|String
name|yr
init|=
name|frest
operator|.
name|substring
argument_list|(
name|m
operator|-
literal|5
argument_list|,
name|m
argument_list|)
decl_stmt|;
name|h
operator|.
name|put
argument_list|(
literal|"year"
argument_list|,
name|yr
argument_list|)
expr_stmt|;
name|frest
operator|=
name|frest
operator|.
name|substring
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|frest
operator|.
name|indexOf
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|>=
literal|0
condition|)
block|{
name|String
name|pg
init|=
name|frest
operator|.
name|substring
argument_list|(
name|m
operator|+
literal|1
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|h
operator|.
name|put
argument_list|(
literal|"pages"
argument_list|,
name|pg
argument_list|)
expr_stmt|;
name|h
operator|.
name|put
argument_list|(
literal|"volume"
argument_list|,
name|frest
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|f3
operator|.
name|equals
argument_list|(
literal|"RT"
argument_list|)
condition|)
block|{
name|frest
operator|=
name|frest
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|frest
operator|.
name|equals
argument_list|(
literal|"Journal-Paper"
argument_list|)
condition|)
name|Type
operator|=
literal|"article"
expr_stmt|;
elseif|else
if|if
condition|(
name|frest
operator|.
name|equals
argument_list|(
literal|"Conference-Paper"
argument_list|)
operator|||
name|frest
operator|.
name|equals
argument_list|(
literal|"Conference-Paper; Journal-Paper"
argument_list|)
condition|)
name|Type
operator|=
literal|"inproceedings"
expr_stmt|;
else|else
name|Type
operator|=
name|frest
operator|.
name|replaceAll
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|BibtexEntry
name|b
init|=
operator|new
name|BibtexEntry
argument_list|(
name|Globals
operator|.
name|DEFAULT_BIBTEXENTRY_ID
argument_list|,
name|Globals
operator|.
name|getEntryType
argument_list|(
name|Type
argument_list|)
argument_list|)
decl_stmt|;
comment|// id assumes an existing database so don't create one here
name|b
operator|.
name|setField
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|bibitems
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|bibitems
return|;
block|}
comment|//==================================================
comment|//
comment|//==================================================
block|}
end_class

end_unit

