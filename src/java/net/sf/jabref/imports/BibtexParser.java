begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003-06 David Weitzman, Nizar N. Batada, Morten O. Alver, Christopher Oezbek   All programs in this directory and  subdirectories are published under the GNU General Public License as  described below.   This program is free software; you can redistribute it and/or modify  it under the terms of the GNU General Public License as published by  the Free Software Foundation; either version 2 of the License, or (at  your option) any later version.   This program is distributed in the hope that it will be useful, but  WITHOUT ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  General Public License for more details.   You should have received a copy of the GNU General Public License  along with this program; if not, write to the Free Software  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA   Further information about the GNU GPL is available at:  http://www.gnu.org/copyleft/gpl.ja.html   */
end_comment

begin_package
DECL|package|net.sf.jabref.imports
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|imports
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PushbackReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexDatabase
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexEntryType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexFields
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexString
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|CustomEntryType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|GUIGlobals
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|Globals
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|JabRefPreferences
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|KeyCollisionException
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|UnknownEntryType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|Util
import|;
end_import

begin_comment
comment|/**  * Class for importing BibTeX-files.  *   * Use:  *   * BibtexParser parser = new BibtexParser(reader);  *   * ParserResult result = parser.parse();  *   * or  *   * ParserResult result = BibtexParser.parse(reader);  *   * Can be used stand-alone.  *   * @author David Weitzman  * @author Nizar N. Batada  * @author Morten O. Alver  * @author Christopher Oezbek   */
end_comment

begin_class
DECL|class|BibtexParser
specifier|public
class|class
name|BibtexParser
block|{
DECL|field|_in
specifier|private
name|PushbackReader
name|_in
decl_stmt|;
DECL|field|_db
specifier|private
name|BibtexDatabase
name|_db
decl_stmt|;
DECL|field|_meta
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|_meta
decl_stmt|;
DECL|field|entryTypes
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|BibtexEntryType
argument_list|>
name|entryTypes
decl_stmt|;
DECL|field|_eof
specifier|private
name|boolean
name|_eof
init|=
literal|false
decl_stmt|;
DECL|field|line
specifier|private
name|int
name|line
init|=
literal|1
decl_stmt|;
DECL|field|fieldContentParser
specifier|private
name|FieldContentParser
name|fieldContentParser
init|=
operator|new
name|FieldContentParser
argument_list|()
decl_stmt|;
DECL|field|_pr
specifier|private
name|ParserResult
name|_pr
decl_stmt|;
DECL|field|LOOKAHEAD
specifier|private
specifier|static
specifier|final
name|Integer
name|LOOKAHEAD
init|=
literal|64
decl_stmt|;
DECL|method|BibtexParser (Reader in)
specifier|public
name|BibtexParser
parameter_list|(
name|Reader
name|in
parameter_list|)
block|{
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|==
literal|null
condition|)
block|{
name|Globals
operator|.
name|prefs
operator|=
name|JabRefPreferences
operator|.
name|getInstance
argument_list|()
expr_stmt|;
block|}
name|_in
operator|=
operator|new
name|PushbackReader
argument_list|(
name|in
argument_list|,
name|LOOKAHEAD
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Shortcut usage to create a Parser and read the input. 	 *  	 * @param in - 	 *            Reader to read from 	 * @throws IOException 	 */
DECL|method|parse (Reader in)
specifier|public
specifier|static
name|ParserResult
name|parse
parameter_list|(
name|Reader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|BibtexParser
name|parser
init|=
operator|new
name|BibtexParser
argument_list|(
name|in
argument_list|)
decl_stmt|;
return|return
name|parser
operator|.
name|parse
argument_list|()
return|;
block|}
comment|/** 	 * Parses BibtexEntries from the given string and returns the collection of all entries found. 	 *  	 * @param bibtexString 	 *  	 * @return Returns null if an error occurred, returns an empty collection if no entries where found.  	 */
DECL|method|fromString (String bibtexString)
specifier|public
specifier|static
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|fromString
parameter_list|(
name|String
name|bibtexString
parameter_list|)
block|{
name|StringReader
name|reader
init|=
operator|new
name|StringReader
argument_list|(
name|bibtexString
argument_list|)
decl_stmt|;
name|BibtexParser
name|parser
init|=
operator|new
name|BibtexParser
argument_list|(
name|reader
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|parser
operator|.
name|parse
argument_list|()
operator|.
name|getDatabase
argument_list|()
operator|.
name|getEntries
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/** 	 * Parses BibtexEntries from the given string and returns one entry found (or null if none found) 	 *  	 * It is undetermined which entry is returned, so use this in case you know there is only one entry in the string. 	 *  	 * @param bibtexString 	 *  	 * @return The bibtexentry or null if non was found or an error occurred. 	 */
DECL|method|singleFromString (String bibtexString)
specifier|public
specifier|static
name|BibtexEntry
name|singleFromString
parameter_list|(
name|String
name|bibtexString
parameter_list|)
block|{
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|c
init|=
name|fromString
argument_list|(
name|bibtexString
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|c
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
comment|/** 	 * Check whether the source is in the correct format for this importer. 	 */
DECL|method|isRecognizedFormat (Reader inOrig)
specifier|public
specifier|static
name|boolean
name|isRecognizedFormat
parameter_list|(
name|Reader
name|inOrig
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Our strategy is to look for the "@<type>    {" line.
name|BufferedReader
name|in
init|=
operator|new
name|BufferedReader
argument_list|(
name|inOrig
argument_list|)
decl_stmt|;
name|Pattern
name|pat1
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"@[a-zA-Z]*\\s*\\{"
argument_list|)
decl_stmt|;
name|String
name|str
decl_stmt|;
while|while
condition|(
operator|(
name|str
operator|=
name|in
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|pat1
operator|.
name|matcher
argument_list|(
name|str
argument_list|)
operator|.
name|find
argument_list|()
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|str
operator|.
name|startsWith
argument_list|(
name|GUIGlobals
operator|.
name|SIGNATURE
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|skipWhitespace ()
specifier|private
name|void
name|skipWhitespace
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|c
operator|=
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|c
operator|==
literal|65535
operator|)
condition|)
block|{
name|_eof
operator|=
literal|true
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
condition|)
block|{
continue|continue;
block|}
else|else
comment|// found non-whitespace char
comment|// Util.pr("SkipWhitespace, stops: "+c);
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 			 * try { Thread.currentThread().sleep(500); } catch 			 * (InterruptedException ex) {} 			 */
break|break;
block|}
block|}
DECL|method|skipAndRecordWhitespace (int j)
specifier|private
name|String
name|skipAndRecordWhitespace
parameter_list|(
name|int
name|j
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|c
decl_stmt|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|j
operator|!=
literal|' '
condition|)
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|j
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|c
operator|=
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|c
operator|==
literal|65535
operator|)
condition|)
block|{
name|_eof
operator|=
literal|true
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
comment|// found non-whitespace char
comment|// Util.pr("SkipWhitespace, stops: "+c);
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 			 * try { Thread.currentThread().sleep(500); } catch 			 * (InterruptedException ex) {} 			 */
break|break;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** 	 * Will parse the BibTex-Data found when reading from reader. 	 *  	 * The reader will be consumed. 	 *  	 * Multiple calls to parse() return the same results 	 *  	 * @return ParserResult 	 * @throws IOException 	 */
DECL|method|parse ()
specifier|public
name|ParserResult
name|parse
parameter_list|()
throws|throws
name|IOException
block|{
comment|// If we already parsed this, just return it.
if|if
condition|(
name|_pr
operator|!=
literal|null
condition|)
return|return
name|_pr
return|;
name|_db
operator|=
operator|new
name|BibtexDatabase
argument_list|()
expr_stmt|;
comment|// Bibtex related contents.
name|_meta
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
comment|// Metadata in comments for Bibkeeper.
name|entryTypes
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BibtexEntryType
argument_list|>
argument_list|()
expr_stmt|;
comment|// To store custem entry types parsed.
name|_pr
operator|=
operator|new
name|ParserResult
argument_list|(
name|_db
argument_list|,
name|_meta
argument_list|,
name|entryTypes
argument_list|)
expr_stmt|;
comment|// First see if we can find the version number of the JabRef version that
comment|// wrote the file:
name|String
name|versionNum
init|=
name|readJabRefVersionNumber
argument_list|()
decl_stmt|;
if|if
condition|(
name|versionNum
operator|!=
literal|null
condition|)
block|{
name|_pr
operator|.
name|setJabrefVersion
argument_list|(
name|versionNum
argument_list|)
expr_stmt|;
name|setMajorMinorVersions
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// No version number found. However, we have only
block|}
name|skipWhitespace
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
operator|!
name|_eof
condition|)
block|{
name|boolean
name|found
init|=
name|consumeUncritically
argument_list|(
literal|'@'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
break|break;
name|skipWhitespace
argument_list|()
expr_stmt|;
name|String
name|entryType
init|=
name|parseTextToken
argument_list|()
decl_stmt|;
name|BibtexEntryType
name|tp
init|=
name|BibtexEntryType
operator|.
name|getType
argument_list|(
name|entryType
argument_list|)
decl_stmt|;
name|boolean
name|isEntry
init|=
operator|(
name|tp
operator|!=
literal|null
operator|)
decl_stmt|;
comment|// Util.pr(tp.getName());
if|if
condition|(
operator|!
name|isEntry
condition|)
block|{
comment|// The entry type name was not recognized. This can mean
comment|// that it is a string, preamble, or comment. If so,
comment|// parse and set accordingly. If not, assume it is an entry
comment|// with an unknown type.
if|if
condition|(
name|entryType
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
literal|"preamble"
argument_list|)
condition|)
block|{
name|_db
operator|.
name|setPreamble
argument_list|(
name|parsePreamble
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entryType
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
literal|"string"
argument_list|)
condition|)
block|{
name|BibtexString
name|bs
init|=
name|parseString
argument_list|()
decl_stmt|;
try|try
block|{
name|_db
operator|.
name|addString
argument_list|(
name|bs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeyCollisionException
name|ex
parameter_list|)
block|{
name|_pr
operator|.
name|addWarning
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Duplicate string name"
argument_list|)
operator|+
literal|": "
operator|+
name|bs
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// ex.printStackTrace();
block|}
block|}
elseif|else
if|if
condition|(
name|entryType
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
literal|"comment"
argument_list|)
condition|)
block|{
name|StringBuffer
name|commentBuf
init|=
name|parseBracketedTextExactly
argument_list|()
decl_stmt|;
comment|/** 						 *  						 * Metadata are used to store Bibkeeper-specific 						 * information in .bib files. 						 *  						 * Metadata are stored in bibtex files in the format 						 *  						 * @comment{jabref-meta: type:data0;data1;data2;...} 						 *  						 * Each comment that starts with the META_FLAG is stored 						 * in the meta HashMap, with type as key. Unluckily, the 						 * old META_FLAG bibkeeper-meta: was used in JabRef 1.0 						 * and 1.1, so we need to support it as well. At least 						 * for a while. We'll always save with the new one. 						 */
name|String
name|comment
init|=
name|commentBuf
operator|.
name|toString
argument_list|()
operator|.
name|replaceAll
argument_list|(
literal|"[\\x0d\\x0a]"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|comment
operator|.
name|length
argument_list|()
argument_list|,
name|GUIGlobals
operator|.
name|META_FLAG
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
operator|.
name|equals
argument_list|(
name|GUIGlobals
operator|.
name|META_FLAG
argument_list|)
operator|||
name|comment
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|comment
operator|.
name|length
argument_list|()
argument_list|,
name|GUIGlobals
operator|.
name|META_FLAG_OLD
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
operator|.
name|equals
argument_list|(
name|GUIGlobals
operator|.
name|META_FLAG_OLD
argument_list|)
condition|)
block|{
name|String
name|rest
decl_stmt|;
if|if
condition|(
name|comment
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|GUIGlobals
operator|.
name|META_FLAG
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|GUIGlobals
operator|.
name|META_FLAG
argument_list|)
condition|)
name|rest
operator|=
name|comment
operator|.
name|substring
argument_list|(
name|GUIGlobals
operator|.
name|META_FLAG
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|rest
operator|=
name|comment
operator|.
name|substring
argument_list|(
name|GUIGlobals
operator|.
name|META_FLAG_OLD
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|pos
init|=
name|rest
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
name|_meta
operator|.
name|put
argument_list|(
name|rest
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|pos
argument_list|)
argument_list|,
name|rest
operator|.
name|substring
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// We remove all line breaks in the metadata - these
comment|// will have been inserted
comment|// to prevent too long lines when the file was
comment|// saved, and are not part of the data.
block|}
comment|/** 						 * A custom entry type can also be stored in a 						 *  						 * @comment: 						 */
if|if
condition|(
name|comment
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|comment
operator|.
name|length
argument_list|()
argument_list|,
name|GUIGlobals
operator|.
name|ENTRYTYPE_FLAG
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
operator|.
name|equals
argument_list|(
name|GUIGlobals
operator|.
name|ENTRYTYPE_FLAG
argument_list|)
condition|)
block|{
name|CustomEntryType
name|typ
init|=
name|CustomEntryType
operator|.
name|parseEntryType
argument_list|(
name|comment
argument_list|)
decl_stmt|;
name|entryTypes
operator|.
name|put
argument_list|(
name|typ
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|typ
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// The entry type was not recognized. This may mean that
comment|// it is a custom entry type whose definition will
comment|// appear
comment|// at the bottom of the file. So we use an
comment|// UnknownEntryType
comment|// to remember the type name by.
name|tp
operator|=
operator|new
name|UnknownEntryType
argument_list|(
name|entryType
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
comment|// System.out.println("unknown type: "+entryType);
name|isEntry
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isEntry
condition|)
comment|// True if not comment, preamble or string.
block|{
comment|/** 					 * Morten Alver 13 Aug 2006: Trying to make the parser more 					 * robust. If an exception is thrown when parsing an entry, 					 * drop the entry and try to resume parsing. Add a warning 					 * for the user. 					 *  					 * An alternative solution is to try rescuing the entry for 					 * which parsing failed, by returning the entry with the 					 * exception and adding it before parsing is continued. 					 */
try|try
block|{
name|BibtexEntry
name|be
init|=
name|parseEntry
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|boolean
name|duplicateKey
init|=
name|_db
operator|.
name|insertEntry
argument_list|(
name|be
argument_list|)
decl_stmt|;
if|if
condition|(
name|duplicateKey
condition|)
comment|// JZTODO lyrics
name|_pr
operator|.
name|addDuplicateKey
argument_list|(
name|be
operator|.
name|getCiteKey
argument_list|()
argument_list|)
expr_stmt|;
comment|/*_pr.addWarning(Globals.lang("duplicate BibTeX key") + ": " 								+ be.getCiteKey() + " (" 								+ Globals.lang("grouping may not work for this entry") + ")");                        */
elseif|else
if|if
condition|(
name|be
operator|.
name|getCiteKey
argument_list|()
operator|==
literal|null
operator|||
name|be
operator|.
name|getCiteKey
argument_list|()
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|_pr
operator|.
name|addWarning
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"empty BibTeX key"
argument_list|)
operator|+
literal|": "
operator|+
name|be
operator|.
name|getAuthorTitleYear
argument_list|(
literal|40
argument_list|)
operator|+
literal|" ("
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"grouping may not work for this entry"
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|_pr
operator|.
name|addWarning
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Error occured when parsing entry"
argument_list|)
operator|+
literal|": '"
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
operator|+
literal|"'. "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"Skipped entry."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|skipWhitespace
argument_list|()
expr_stmt|;
block|}
comment|// Before returning the database, update entries with unknown type
comment|// based on parsed type definitions, if possible.
name|checkEntryTypes
argument_list|(
name|_pr
argument_list|)
expr_stmt|;
return|return
name|_pr
return|;
block|}
catch|catch
parameter_list|(
name|KeyCollisionException
name|kce
parameter_list|)
block|{
comment|// kce.printStackTrace();
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Duplicate ID in bibtex file: "
operator|+
name|kce
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
DECL|method|peek ()
specifier|private
name|int
name|peek
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|c
init|=
name|read
argument_list|()
decl_stmt|;
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
DECL|method|read ()
specifier|private
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|c
init|=
name|_in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|line
operator|++
expr_stmt|;
return|return
name|c
return|;
block|}
DECL|method|unread (int c)
specifier|private
name|void
name|unread
parameter_list|(
name|int
name|c
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|line
operator|--
expr_stmt|;
name|_in
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
DECL|method|parseString ()
specifier|public
name|BibtexString
name|parseString
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Util.pr("Parsing string");
name|skipWhitespace
argument_list|()
expr_stmt|;
name|consume
argument_list|(
literal|'{'
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
comment|// while (read() != '}');
name|skipWhitespace
argument_list|()
expr_stmt|;
comment|// Util.pr("Parsing string name");
name|String
name|name
init|=
name|parseTextToken
argument_list|()
decl_stmt|;
comment|// Util.pr("Parsed string name");
name|skipWhitespace
argument_list|()
expr_stmt|;
comment|// Util.pr("Now the contents");
name|consume
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|String
name|content
init|=
name|parseFieldContent
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|// Util.pr("Now I'm going to consume a }");
name|consume
argument_list|(
literal|'}'
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
comment|// Util.pr("Finished string parsing.");
name|String
name|id
init|=
name|Util
operator|.
name|createNeutralId
argument_list|()
decl_stmt|;
return|return
operator|new
name|BibtexString
argument_list|(
name|id
argument_list|,
name|name
argument_list|,
name|content
argument_list|)
return|;
block|}
DECL|method|parsePreamble ()
specifier|public
name|String
name|parsePreamble
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|parseBracketedText
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|parseEntry (BibtexEntryType tp)
specifier|public
name|BibtexEntry
name|parseEntry
parameter_list|(
name|BibtexEntryType
name|tp
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|id
init|=
name|Util
operator|.
name|createNeutralId
argument_list|()
decl_stmt|;
comment|// createId(tp, _db);
name|BibtexEntry
name|result
init|=
operator|new
name|BibtexEntry
argument_list|(
name|id
argument_list|,
name|tp
argument_list|)
decl_stmt|;
name|skipWhitespace
argument_list|()
expr_stmt|;
name|consume
argument_list|(
literal|'{'
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|int
name|c
init|=
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\r'
operator|)
condition|)
name|skipWhitespace
argument_list|()
expr_stmt|;
name|String
name|key
init|=
literal|null
decl_stmt|;
name|boolean
name|doAgain
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|doAgain
condition|)
block|{
name|doAgain
operator|=
literal|false
expr_stmt|;
try|try
block|{
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
name|key
operator|=
name|key
operator|+
name|parseKey
argument_list|()
expr_stmt|;
comment|// parseTextToken(),
else|else
name|key
operator|=
name|parseKey
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoLabelException
name|ex
parameter_list|)
block|{
comment|// This exception will be thrown if the entry lacks a key
comment|// altogether, like in "@article{ author = { ...".
comment|// It will also be thrown if a key contains =.
name|c
operator|=
operator|(
name|char
operator|)
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|c
operator|==
literal|'{'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\"'
operator|)
condition|)
block|{
name|String
name|fieldName
init|=
name|ex
operator|.
name|getMessage
argument_list|()
operator|.
name|trim
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|cont
init|=
name|parseFieldContent
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|result
operator|.
name|setField
argument_list|(
name|fieldName
argument_list|,
name|cont
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
name|key
operator|=
name|key
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
operator|+
literal|"="
expr_stmt|;
else|else
name|key
operator|=
name|ex
operator|.
name|getMessage
argument_list|()
operator|+
literal|"="
expr_stmt|;
name|doAgain
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|key
operator|!=
literal|null
operator|)
operator|&&
name|key
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
name|key
operator|=
literal|null
expr_stmt|;
name|result
operator|.
name|setField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|skipWhitespace
argument_list|()
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|c
operator|=
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'}'
operator|)
operator|||
operator|(
name|c
operator|==
literal|')'
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|','
condition|)
name|consume
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|skipWhitespace
argument_list|()
expr_stmt|;
name|c
operator|=
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'}'
operator|)
operator|||
operator|(
name|c
operator|==
literal|')'
operator|)
condition|)
block|{
break|break;
block|}
name|parseField
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|consume
argument_list|(
literal|'}'
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|method|parseField (BibtexEntry entry)
specifier|private
name|void
name|parseField
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|key
init|=
name|parseTextToken
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
comment|// Util.pr("Field: _"+key+"_");
name|skipWhitespace
argument_list|()
expr_stmt|;
name|consume
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|String
name|content
init|=
name|parseFieldContent
argument_list|(
name|key
argument_list|)
decl_stmt|;
comment|// Now, if the field in question is set up to be fitted automatically
comment|// with braces around
comment|// capitals, we should remove those now when reading the field:
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|putBracesAroundCapitals
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|content
operator|=
name|Util
operator|.
name|removeBracesAroundCapitals
argument_list|(
name|content
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|content
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|entry
operator|.
name|getField
argument_list|(
name|key
argument_list|)
operator|==
literal|null
condition|)
name|entry
operator|.
name|setField
argument_list|(
name|key
argument_list|,
name|content
argument_list|)
expr_stmt|;
else|else
block|{
comment|// The following hack enables the parser to deal with multiple
comment|// author or
comment|// editor lines, stringing them together instead of getting just
comment|// one of them.
comment|// Multiple author or editor lines are not allowed by the bibtex
comment|// format, but
comment|// at least one online database exports bibtex like that, making
comment|// it inconvenient
comment|// for users if JabRef didn't accept it.
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"author"
argument_list|)
operator|||
name|key
operator|.
name|equals
argument_list|(
literal|"editor"
argument_list|)
condition|)
name|entry
operator|.
name|setField
argument_list|(
name|key
argument_list|,
name|entry
operator|.
name|getField
argument_list|(
name|key
argument_list|)
operator|+
literal|" and "
operator|+
name|content
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|parseFieldContent (String key)
specifier|private
name|String
name|parseFieldContent
parameter_list|(
name|String
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|skipWhitespace
argument_list|()
expr_stmt|;
name|StringBuffer
name|value
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|int
name|c
init|=
literal|'.'
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|peek
argument_list|()
operator|)
operator|!=
literal|','
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'}'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|')'
operator|)
condition|)
block|{
if|if
condition|(
name|_eof
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|": EOF in mid-string"
argument_list|)
throw|;
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|StringBuffer
name|text
init|=
name|parseQuotedFieldExactly
argument_list|()
decl_stmt|;
name|value
operator|.
name|append
argument_list|(
name|fieldContentParser
operator|.
name|format
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 				 *  				 * The following code doesn't handle {"} correctly: // value is 				 * a string consume('"'); 				 *  				 * while (!((peek() == '"')&& (j != '\\'))) { j = read(); if 				 * (_eof || (j == -1) || (j == 65535)) { throw new 				 * RuntimeException("Error in line "+line+ ": EOF in 				 * mid-string"); } 				 *  				 * value.append((char) j); } 				 *  				 * consume('"'); 				 */
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
comment|// Value is a string enclosed in brackets. There can be pairs
comment|// of brackets inside of a field, so we need to count the
comment|// brackets to know when the string is finished.
name|StringBuffer
name|text
init|=
name|parseBracketedTextExactly
argument_list|()
decl_stmt|;
name|value
operator|.
name|append
argument_list|(
name|fieldContentParser
operator|.
name|format
argument_list|(
name|text
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Character
operator|.
name|isDigit
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
condition|)
block|{
comment|// value is a number
name|String
name|numString
init|=
name|parseTextToken
argument_list|()
decl_stmt|;
comment|// Morten Alver 2007-07-04: I don't see the point of parsing the integer
comment|// and converting it back to a string, so I'm removing the construct below
comment|// the following line:
name|value
operator|.
name|append
argument_list|(
name|numString
argument_list|)
expr_stmt|;
comment|/*                 try { 					// Fixme: What is this for? 					value.append(String.valueOf(Integer.parseInt(numString))); 				} catch (NumberFormatException e) { 					// If Integer could not be parsed then just add the text 					// Used to fix [ 1594123 ] Failure to import big numbers 					value.append(numString); 				} 				*/
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
name|consume
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|textToken
init|=
name|parseTextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|textToken
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|" or above: "
operator|+
literal|"Empty text token.\nThis could be caused "
operator|+
literal|"by a missing comma between two fields."
argument_list|)
throw|;
name|value
operator|.
name|append
argument_list|(
literal|"#"
argument_list|)
operator|.
name|append
argument_list|(
name|textToken
argument_list|)
operator|.
name|append
argument_list|(
literal|"#"
argument_list|)
expr_stmt|;
comment|// Util.pr(parseTextToken());
comment|// throw new RuntimeException("Unknown field type");
block|}
name|skipWhitespace
argument_list|()
expr_stmt|;
block|}
comment|// Util.pr("Returning field content: "+value.toString());
comment|// Check if we are to strip extra pairs of braces before returning:
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"autoDoubleBraces"
argument_list|)
condition|)
block|{
comment|// Do it:
while|while
condition|(
operator|(
name|value
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|)
operator|&&
operator|(
name|value
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'{'
operator|)
operator|&&
operator|(
name|value
operator|.
name|charAt
argument_list|(
name|value
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'}'
operator|)
condition|)
block|{
name|value
operator|.
name|deleteCharAt
argument_list|(
name|value
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|value
operator|.
name|deleteCharAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// Problem: if the field content is "{DNA} blahblah {EPA}", one pair
comment|// too much will be removed.
comment|// Check if this is the case, and re-add as many pairs as needed.
while|while
condition|(
name|hasNegativeBraceCount
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|value
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|value
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|value
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** 	 * Originalinhalt nach parseFieldContent(String) verschoben. 	 * @return 	 * @throws IOException 	 */
comment|//	private String parseFieldContent() throws IOException {
comment|//		return parseFieldContent(null);
comment|//	}
comment|/** 	 * Check if a string at any point has had more ending braces (}) than 	 * opening ones ({). Will e.g. return true for the string "DNA} blahblal 	 * {EPA" 	 *  	 * @param s 	 *            The string to check. 	 * @return true if at any index the brace count is negative. 	 */
DECL|method|hasNegativeBraceCount (String s)
specifier|private
name|boolean
name|hasNegativeBraceCount
parameter_list|(
name|String
name|s
parameter_list|)
block|{
comment|// System.out.println(s);
name|int
name|i
init|=
literal|0
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'{'
condition|)
name|count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'}'
condition|)
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
literal|true
return|;
name|i
operator|++
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/** 	 * This method is used to parse string labels, field names, entry type and 	 * numbers outside brackets. 	 */
DECL|method|parseTextToken ()
specifier|private
name|String
name|parseTextToken
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuffer
name|token
init|=
operator|new
name|StringBuffer
argument_list|(
literal|20
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|c
init|=
name|read
argument_list|()
decl_stmt|;
comment|// Util.pr(".. "+c);
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
name|_eof
operator|=
literal|true
expr_stmt|;
return|return
name|token
operator|.
name|toString
argument_list|()
return|;
block|}
if|if
condition|(
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|||
operator|(
name|c
operator|==
literal|':'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'-'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'_'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'*'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'+'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'/'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\''
operator|)
condition|)
block|{
name|token
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|// Util.pr("Pasted text token: "+token.toString());
return|return
name|token
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
comment|/** 	 * Tries to restore the key 	 *  	 * @return rest of key on success, otherwise empty string 	 * @throws IOException 	 *             on Reader-Error 	 */
DECL|method|fixKey ()
specifier|private
name|String
name|fixKey
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuilder
name|key
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|lookahead_used
init|=
literal|0
decl_stmt|;
name|char
name|currentChar
decl_stmt|;
comment|// Find a char which ends key (','&&'\n') or entryfield ('='):
do|do
block|{
name|currentChar
operator|=
operator|(
name|char
operator|)
name|read
argument_list|()
expr_stmt|;
name|key
operator|.
name|append
argument_list|(
name|currentChar
argument_list|)
expr_stmt|;
name|lookahead_used
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|currentChar
operator|!=
literal|','
operator|&&
name|currentChar
operator|!=
literal|'\n'
operator|&&
name|currentChar
operator|!=
literal|'='
operator|)
operator|&&
operator|(
name|lookahead_used
operator|<
name|LOOKAHEAD
operator|)
condition|)
do|;
comment|// Consumed a char too much, back into reader and remove from key:
name|unread
argument_list|(
name|currentChar
argument_list|)
expr_stmt|;
name|key
operator|.
name|deleteCharAt
argument_list|(
name|key
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Restore if possible:
switch|switch
condition|(
name|currentChar
condition|)
block|{
case|case
literal|'='
case|:
comment|// Get entryfieldname, push it back and take rest as key
name|key
operator|=
name|key
operator|.
name|reverse
argument_list|()
expr_stmt|;
name|boolean
name|matchedAlpha
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|key
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|currentChar
operator|=
name|key
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/// Skip spaces:
if|if
condition|(
operator|!
name|matchedAlpha
operator|&&
name|currentChar
operator|==
literal|' '
condition|)
block|{
continue|continue;
block|}
name|matchedAlpha
operator|=
literal|true
expr_stmt|;
comment|// Begin of entryfieldname (e.g. author) -> push back:
name|unread
argument_list|(
name|currentChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentChar
operator|==
literal|' '
operator|||
name|currentChar
operator|==
literal|'\n'
condition|)
block|{
comment|/*                          * found whitespaces, entryfieldname completed -> key in                          * keybuffer, skip whitespaces                          */
name|StringBuilder
name|newKey
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|<
name|key
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|currentChar
operator|=
name|key
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|currentChar
argument_list|)
condition|)
block|{
name|newKey
operator|.
name|append
argument_list|(
name|currentChar
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Finished, now reverse newKey and remove whitespaces:
name|_pr
operator|.
name|addWarning
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Line %0: Found corrupted BibTeX-key."
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|line
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|=
name|newKey
operator|.
name|reverse
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|','
case|:
name|_pr
operator|.
name|addWarning
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Line %0: Found corrupted BibTeX-key (contains whitespaces)."
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|line
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
literal|'\n'
case|:
name|_pr
operator|.
name|addWarning
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Line %0: Found corrupted BibTeX-key (comma missing)."
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|line
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// No more lookahead, give up:
name|unreadBuffer
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
return|return
name|removeWhitespaces
argument_list|(
name|key
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** 	 * removes whitespaces from<code>sb</code> 	 *  	 * @param sb 	 * @return 	 */
DECL|method|removeWhitespaces (StringBuilder sb)
specifier|private
name|StringBuilder
name|removeWhitespaces
parameter_list|(
name|StringBuilder
name|sb
parameter_list|)
block|{
name|StringBuilder
name|newSb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|char
name|current
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sb
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|current
operator|=
name|sb
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|current
argument_list|)
condition|)
name|newSb
operator|.
name|append
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
return|return
name|newSb
return|;
block|}
comment|/** 	 * pushes buffer back into input 	 *  	 * @param sb 	 * @throws IOException 	 *             can be thrown if buffer is bigger than LOOKAHEAD 	 */
DECL|method|unreadBuffer (StringBuilder sb)
specifier|private
name|void
name|unreadBuffer
parameter_list|(
name|StringBuilder
name|sb
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|unread
argument_list|(
name|sb
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * This method is used to parse the bibtex key for an entry. 	 */
DECL|method|parseKey ()
specifier|private
name|String
name|parseKey
parameter_list|()
throws|throws
name|IOException
throws|,
name|NoLabelException
block|{
name|StringBuffer
name|token
init|=
operator|new
name|StringBuffer
argument_list|(
literal|20
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|c
init|=
name|read
argument_list|()
decl_stmt|;
comment|// Util.pr(".. '"+(char)c+"'\t"+c);
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
name|_eof
operator|=
literal|true
expr_stmt|;
return|return
name|token
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// Ikke: #{}\uFFFD~\uFFFD
comment|//
comment|// G\uFFFDr: $_*+.-\/?"^
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|&&
operator|(
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|||
operator|(
operator|(
name|c
operator|!=
literal|'#'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'{'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'}'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\uFFFD'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'~'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\uFFFD'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|','
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'='
operator|)
operator|)
operator|)
condition|)
block|{
name|token
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
condition|)
block|{
comment|// We have encountered white space instead of the comma at
comment|// the end of
comment|// the key. Possibly the comma is missing, so we try to
comment|// return what we
comment|// have found, as the key and try to restore the rest in fixKey().
return|return
name|token
operator|.
name|toString
argument_list|()
operator|+
name|fixKey
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|token
operator|.
name|toString
argument_list|()
return|;
comment|// } else if (Character.isWhitespace((char)c)) {
comment|// throw new NoLabelException(token.toString());
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
comment|// If we find a '=' sign, it is either an error, or
comment|// the entry lacked a comma signifying the end of the key.
return|return
name|token
operator|.
name|toString
argument_list|()
return|;
comment|// throw new NoLabelException(token.toString());
block|}
else|else
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|":"
operator|+
literal|"Character '"
operator|+
operator|(
name|char
operator|)
name|c
operator|+
literal|"' is not "
operator|+
literal|"allowed in bibtex keys."
argument_list|)
throw|;
block|}
block|}
block|}
DECL|class|NoLabelException
specifier|private
class|class
name|NoLabelException
extends|extends
name|Exception
block|{
DECL|method|NoLabelException (String hasRead)
specifier|public
name|NoLabelException
parameter_list|(
name|String
name|hasRead
parameter_list|)
block|{
name|super
argument_list|(
name|hasRead
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|parseBracketedText ()
specifier|private
name|StringBuffer
name|parseBracketedText
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Util.pr("Parse bracketed text");
name|StringBuffer
name|value
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|consume
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|int
name|brackets
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|peek
argument_list|()
operator|==
literal|'}'
operator|)
operator|&&
operator|(
name|brackets
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|int
name|j
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|j
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|j
operator|==
literal|65535
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|": EOF in mid-string"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|j
operator|==
literal|'{'
condition|)
name|brackets
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|==
literal|'}'
condition|)
name|brackets
operator|--
expr_stmt|;
comment|// If we encounter whitespace of any kind, read it as a
comment|// simple space, and ignore any others that follow immediately.
comment|/* 			 * if (j == '\n') { if (peek() == '\n') value.append('\n'); } else 			 */
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
operator|(
name|char
operator|)
name|j
argument_list|)
condition|)
block|{
name|String
name|whs
init|=
name|skipAndRecordWhitespace
argument_list|(
name|j
argument_list|)
decl_stmt|;
comment|// System.out.println(":"+whs+":");
if|if
condition|(
operator|!
name|whs
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|&&
operator|!
name|whs
operator|.
name|equals
argument_list|(
literal|"\n\t"
argument_list|)
condition|)
block|{
comment|//&&
comment|// !whs.equals("\n"))
name|whs
operator|=
name|whs
operator|.
name|replaceAll
argument_list|(
literal|"\t"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|// Remove tabulators.
comment|// while (whs.endsWith("\t"))
comment|// whs = whs.substring(0, whs.length()-1);
name|value
operator|.
name|append
argument_list|(
name|whs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|value
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|j
argument_list|)
expr_stmt|;
block|}
name|consume
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
DECL|method|parseBracketedTextExactly ()
specifier|private
name|StringBuffer
name|parseBracketedTextExactly
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuffer
name|value
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|consume
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|int
name|brackets
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|peek
argument_list|()
operator|==
literal|'}'
operator|)
operator|&&
operator|(
name|brackets
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|int
name|j
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|j
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|j
operator|==
literal|65535
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|": EOF in mid-string"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|j
operator|==
literal|'{'
condition|)
name|brackets
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|==
literal|'}'
condition|)
name|brackets
operator|--
expr_stmt|;
name|value
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|j
argument_list|)
expr_stmt|;
block|}
name|consume
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
DECL|method|parseQuotedFieldExactly ()
specifier|private
name|StringBuffer
name|parseQuotedFieldExactly
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuffer
name|value
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|consume
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|int
name|brackets
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|peek
argument_list|()
operator|==
literal|'"'
operator|)
operator|&&
operator|(
name|brackets
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|int
name|j
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|j
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|j
operator|==
literal|65535
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|": EOF in mid-string"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|j
operator|==
literal|'{'
condition|)
name|brackets
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|==
literal|'}'
condition|)
name|brackets
operator|--
expr_stmt|;
name|value
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|j
argument_list|)
expr_stmt|;
block|}
name|consume
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
DECL|method|consume (char expected)
specifier|private
name|void
name|consume
parameter_list|(
name|char
name|expected
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|c
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|expected
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|": Expected "
operator|+
name|expected
operator|+
literal|" but received "
operator|+
operator|(
name|char
operator|)
name|c
argument_list|)
throw|;
block|}
block|}
DECL|method|consumeUncritically (char expected)
specifier|private
name|boolean
name|consumeUncritically
parameter_list|(
name|char
name|expected
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|read
argument_list|()
operator|)
operator|!=
name|expected
operator|)
operator|&&
operator|(
name|c
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|65535
operator|)
condition|)
block|{
comment|// do nothing
block|}
if|if
condition|(
operator|(
name|c
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|c
operator|==
literal|65535
operator|)
condition|)
name|_eof
operator|=
literal|true
expr_stmt|;
comment|// Return true if we actually found the character we were looking for:
return|return
name|c
operator|==
name|expected
return|;
block|}
DECL|method|consume (char expected1, char expected2)
specifier|private
name|void
name|consume
parameter_list|(
name|char
name|expected1
parameter_list|,
name|char
name|expected2
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Consumes one of the two, doesn't care which appears.
name|int
name|c
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|!=
name|expected1
operator|)
operator|&&
operator|(
name|c
operator|!=
name|expected2
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|": Expected "
operator|+
name|expected1
operator|+
literal|" or "
operator|+
name|expected2
operator|+
literal|" but received "
operator|+
name|c
argument_list|)
throw|;
block|}
block|}
DECL|method|checkEntryTypes (ParserResult _pr)
specifier|public
name|void
name|checkEntryTypes
parameter_list|(
name|ParserResult
name|_pr
parameter_list|)
block|{
for|for
control|(
name|BibtexEntry
name|be
range|:
name|_db
operator|.
name|getEntries
argument_list|()
control|)
block|{
if|if
condition|(
name|be
operator|.
name|getType
argument_list|()
operator|instanceof
name|UnknownEntryType
condition|)
block|{
comment|// Look up the unknown type name in our map of parsed types:
name|Object
name|o
init|=
name|entryTypes
operator|.
name|get
argument_list|(
name|be
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|BibtexEntryType
name|type
init|=
operator|(
name|BibtexEntryType
operator|)
name|o
decl_stmt|;
name|be
operator|.
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// System.out.println("Unknown entry type:
comment|// "+be.getType().getName());
name|_pr
operator|.
name|addWarning
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"unknown entry type"
argument_list|)
operator|+
literal|": "
operator|+
name|be
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|". "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"Type set to 'other'"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|be
operator|.
name|setType
argument_list|(
name|BibtexEntryType
operator|.
name|OTHER
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Read the JabRef signature, if any, and find what version number is given.      * This method advances the file reader only as far as the end of the first line of      * the JabRef signature, or up until the point where the read characters don't match      * the signature. This should ensure that the parser can continue from that spot without      * resetting the reader, without the risk of losing important contents.      *      * @return The version number, or null if not found.      * @throws IOException      */
DECL|method|readJabRefVersionNumber ()
specifier|private
name|String
name|readJabRefVersionNumber
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuffer
name|headerText
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|boolean
name|keepon
init|=
literal|true
decl_stmt|;
name|int
name|piv
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|// We start by reading the standard part of the signature, which precedes
comment|// the version number:
comment|//                     This file was created with JabRef X.y.
while|while
condition|(
name|keepon
condition|)
block|{
name|c
operator|=
name|peek
argument_list|()
expr_stmt|;
name|headerText
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|piv
operator|==
literal|0
operator|)
operator|&&
operator|(
name|Character
operator|.
name|isWhitespace
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|||
operator|(
name|c
operator|==
literal|'%'
operator|)
operator|)
condition|)
name|read
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|GUIGlobals
operator|.
name|SIGNATURE
operator|.
name|charAt
argument_list|(
name|piv
argument_list|)
condition|)
block|{
name|piv
operator|++
expr_stmt|;
name|read
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|keepon
operator|=
literal|false
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Check if we've reached the end of the signature's standard part:
if|if
condition|(
name|piv
operator|==
name|GUIGlobals
operator|.
name|SIGNATURE
operator|.
name|length
argument_list|()
condition|)
block|{
name|keepon
operator|=
literal|false
expr_stmt|;
comment|// Found the standard part. Now read the version number:
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|read
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|c
operator|!=
operator|-
literal|1
operator|)
condition|)
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|String
name|versionNum
init|=
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
comment|// See if it fits the X.y. pattern:
if|if
condition|(
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[1-9]+\\.[1-9A-Za-z ]+\\."
argument_list|)
operator|.
name|matcher
argument_list|(
name|versionNum
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
comment|// It matched. Remove the last period and return:
return|return
name|versionNum
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|versionNum
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[1-9]+\\.[1-9]\\.[1-9A-Za-z ]+\\."
argument_list|)
operator|.
name|matcher
argument_list|(
name|versionNum
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
comment|// It matched. Remove the last period and return:
return|return
name|versionNum
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|versionNum
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * After a JabRef version number has been parsed and put into _pr,      * parse the version number to determine the JabRef major and minor version      * number      */
DECL|method|setMajorMinorVersions ()
specifier|private
name|void
name|setMajorMinorVersions
parameter_list|()
block|{
name|String
name|v
init|=
name|_pr
operator|.
name|getJabrefVersion
argument_list|()
decl_stmt|;
name|Pattern
name|p
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"([0-9]+)\\.([0-9]+).*"
argument_list|)
decl_stmt|;
name|Pattern
name|p2
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"([0-9]+)\\.([0-9]+)\\.([0-9]+).*"
argument_list|)
decl_stmt|;
name|Matcher
name|m
init|=
name|p
operator|.
name|matcher
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|Matcher
name|m2
init|=
name|p2
operator|.
name|matcher
argument_list|(
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|matches
argument_list|()
condition|)
if|if
condition|(
name|m
operator|.
name|groupCount
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|_pr
operator|.
name|setJabrefMajorVersion
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|m
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|_pr
operator|.
name|setJabrefMinorVersion
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|m
operator|.
name|group
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m2
operator|.
name|matches
argument_list|()
condition|)
if|if
condition|(
name|m2
operator|.
name|groupCount
argument_list|()
operator|>=
literal|3
condition|)
block|{
name|_pr
operator|.
name|setJabrefMinor2Version
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|m2
operator|.
name|group
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

