begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2004 R. Nagel  All programs in this directory and subdirectories are published under the GNU General Public License as described below.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA  Further information about the GNU GPL is available at: http://www.gnu.org/copyleft/gpl.ja.html  */
end_comment

begin_comment
comment|// created by : r.nagel 23.08.2004
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// modified :
end_comment

begin_package
DECL|package|net.sf.jabref.wizard.aux
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|wizard
operator|.
name|aux
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|imports
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  *<p>Title: Latex Aux to Bibtex</p>  *  *<p>Description: generates a sub-database which contains only bibtex entries  * from input aux file</p>  *  *<p>Copyright: Copyright (c) 2004</p>  *  *<p>Company:</p>  *  * @version 1.0  * @author r.nagel  *  * @todo Redesign of dialog structure for an assitent like feeling....  *   Now the unknown bibtex entries cannot inserted into the reference database  *   without closing the dialog.  */
end_comment

begin_class
DECL|class|AuxSubGenerator
specifier|public
class|class
name|AuxSubGenerator
block|{
DECL|field|mySet
specifier|private
name|HashSet
name|mySet
decl_stmt|;
comment|// all unique bibtex keys in aux file
DECL|field|notFoundList
specifier|private
name|Vector
name|notFoundList
decl_stmt|;
comment|// all not solved bibtex keys
DECL|field|db
specifier|private
name|BibtexDatabase
name|db
decl_stmt|;
comment|// reference database
DECL|field|auxDB
specifier|private
name|BibtexDatabase
name|auxDB
decl_stmt|;
comment|// contains only the bibtex keys who found in aux file
DECL|method|AuxSubGenerator (BibtexDatabase refDBase)
specifier|public
name|AuxSubGenerator
parameter_list|(
name|BibtexDatabase
name|refDBase
parameter_list|)
block|{
name|mySet
operator|=
operator|new
name|HashSet
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|notFoundList
operator|=
operator|new
name|Vector
argument_list|()
expr_stmt|;
name|db
operator|=
name|refDBase
expr_stmt|;
block|}
DECL|method|setReferenceDatabase (BibtexDatabase newRefDB)
specifier|public
specifier|final
name|void
name|setReferenceDatabase
parameter_list|(
name|BibtexDatabase
name|newRefDB
parameter_list|)
block|{
name|db
operator|=
name|newRefDB
expr_stmt|;
block|}
comment|/**    * parseAuxFile    * read the Aux file and fill up some intern data structures    *    * @param filename String : Path to LatexAuxFile    * @return boolean, true = no error occurs    */
DECL|method|parseAuxFile (String filename)
specifier|public
specifier|final
name|boolean
name|parseAuxFile
parameter_list|(
name|String
name|filename
parameter_list|)
block|{
comment|// regular expressions
name|Pattern
name|pattern
decl_stmt|;
name|Matcher
name|matcher
decl_stmt|;
comment|// while condition
name|boolean
name|weiter
init|=
literal|false
decl_stmt|;
comment|// return value -> default: no error
name|boolean
name|back
init|=
literal|true
decl_stmt|;
comment|// the important tag
name|pattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\\\citation\\{.+\\}"
argument_list|)
expr_stmt|;
comment|// input-file-buffer
name|BufferedReader
name|br
init|=
literal|null
decl_stmt|;
try|try
block|{
name|br
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|FileReader
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|weiter
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Cannot locate input file! "
operator|+
name|fnfe
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
comment|// System.exit( 0 ) ;
name|back
operator|=
literal|false
expr_stmt|;
block|}
while|while
condition|(
name|weiter
condition|)
block|{
name|String
name|line
decl_stmt|;
try|try
block|{
name|line
operator|=
name|br
operator|.
name|readLine
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|line
operator|=
literal|null
expr_stmt|;
name|weiter
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|!=
literal|null
condition|)
block|{
name|matcher
operator|=
name|pattern
operator|.
name|matcher
argument_list|(
name|line
argument_list|)
expr_stmt|;
while|while
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
comment|// extract the bibtex-key XXX from \citation{XXX} string
name|int
name|len
init|=
name|matcher
operator|.
name|end
argument_list|()
operator|-
name|matcher
operator|.
name|start
argument_list|()
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|11
condition|)
block|{
name|String
name|str
init|=
name|matcher
operator|.
name|group
argument_list|()
operator|.
name|substring
argument_list|(
name|matcher
operator|.
name|start
argument_list|()
operator|+
literal|10
argument_list|,
name|matcher
operator|.
name|end
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|// save key into an set
name|mySet
operator|.
name|add
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|//            System.out.println("found " +str +" in AUX") ;
block|}
block|}
block|}
else|else
name|weiter
operator|=
literal|false
expr_stmt|;
block|}
comment|// end of while
if|if
condition|(
name|back
condition|)
comment|// only close, if open sucessful
block|{
try|try
block|{
name|br
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{}
block|}
return|return
name|back
return|;
block|}
comment|/**    * resolveTags    * Try to find an equivalent bibtex entry into reference database for all keys    * (found in aux file). This methode will fill up some intern data structures.....    */
DECL|method|resolveTags ()
specifier|public
specifier|final
name|void
name|resolveTags
parameter_list|()
block|{
name|auxDB
operator|=
operator|new
name|BibtexDatabase
argument_list|()
expr_stmt|;
name|notFoundList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Iterator
name|it
init|=
name|mySet
operator|.
name|iterator
argument_list|()
decl_stmt|;
comment|// forall bibtex keys (found in aux-file) try to find an equivalent
comment|// entry into reference database
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|str
init|=
operator|(
name|String
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|BibtexEntry
name|entry
init|=
name|db
operator|.
name|getEntryByKey
argument_list|(
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
name|notFoundList
operator|.
name|add
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|auxDB
operator|.
name|insertEntry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
block|}
block|}
block|}
comment|/**    * generate    * Shortcut methode for easy generation.    *    * @param auxFileName String    * @param bibDB BibtexDatabase - reference database    * @return Vector - contains all not resolved bibtex entries    */
DECL|method|generate (String auxFileName, BibtexDatabase bibDB)
specifier|public
specifier|final
name|Vector
name|generate
parameter_list|(
name|String
name|auxFileName
parameter_list|,
name|BibtexDatabase
name|bibDB
parameter_list|)
block|{
name|setReferenceDatabase
argument_list|(
name|bibDB
argument_list|)
expr_stmt|;
name|parseAuxFile
argument_list|(
name|auxFileName
argument_list|)
expr_stmt|;
name|resolveTags
argument_list|()
expr_stmt|;
return|return
name|notFoundList
return|;
block|}
DECL|method|getGeneratedDatabase ()
specifier|public
name|BibtexDatabase
name|getGeneratedDatabase
parameter_list|()
block|{
if|if
condition|(
name|auxDB
operator|==
literal|null
condition|)
name|auxDB
operator|=
operator|new
name|BibtexDatabase
argument_list|()
expr_stmt|;
return|return
name|auxDB
return|;
block|}
DECL|method|getFoundKeysInAux ()
specifier|public
specifier|final
name|int
name|getFoundKeysInAux
parameter_list|()
block|{
return|return
name|mySet
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getResolvedKeysCount ()
specifier|public
specifier|final
name|int
name|getResolvedKeysCount
parameter_list|()
block|{
return|return
name|auxDB
operator|.
name|getEntryCount
argument_list|()
return|;
block|}
DECL|method|getNotResolvedKeysCount ()
specifier|public
specifier|final
name|int
name|getNotResolvedKeysCount
parameter_list|()
block|{
return|return
name|notFoundList
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** reset used all datastructures */
DECL|method|clear ()
specifier|public
specifier|final
name|void
name|clear
parameter_list|()
block|{
name|mySet
operator|.
name|clear
argument_list|()
expr_stmt|;
name|notFoundList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/** returns a vector off all not resolved bibtex entries found in auxfile */
DECL|method|getNotFoundList ()
specifier|public
name|Vector
name|getNotFoundList
parameter_list|()
block|{
return|return
name|notFoundList
return|;
block|}
block|}
end_class

end_unit

