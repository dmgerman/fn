begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2003 Morten O. Alver and Nizar N. Batada  All programs in this directory and subdirectories are published under the GNU General Public License as described below.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA  Further information about the GNU GPL is available at: http://www.gnu.org/copyleft/gpl.ja.html  */
end_comment

begin_package
DECL|package|net.sf.jabref
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|HttpURLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|datatransfer
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|*
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|*
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|undo
operator|.
name|*
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|ParserConfigurationException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|SAXParser
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|SAXParserFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|imports
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|labelPattern
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|*
import|;
end_import

begin_class
DECL|class|BasePanel
specifier|public
class|class
name|BasePanel
extends|extends
name|JSplitPane
implements|implements
name|ClipboardOwner
block|{
DECL|field|ths
name|BasePanel
name|ths
init|=
name|this
decl_stmt|;
DECL|field|splitPane
name|JSplitPane
name|splitPane
decl_stmt|;
DECL|field|previewPanel
name|PreviewPanel
name|previewPanel
init|=
literal|null
decl_stmt|;
DECL|field|frame
name|JabRefFrame
name|frame
decl_stmt|;
DECL|field|database
name|BibtexDatabase
name|database
decl_stmt|;
DECL|field|prefs
name|JabRefPreferences
name|prefs
decl_stmt|;
comment|// The database shown in this panel.
DECL|field|file
name|File
name|file
init|=
literal|null
decl_stmt|,
DECL|field|fileToOpen
name|fileToOpen
init|=
literal|null
decl_stmt|;
comment|// The filename of the database.
DECL|field|encoding
name|String
name|encoding
init|=
literal|null
decl_stmt|;
comment|//Hashtable autoCompleters = new Hashtable();
comment|// Hashtable that holds as keys the names of the fields where
comment|// autocomplete is active, and references to the autocompleter objects.
comment|// The undo manager.
DECL|field|undoManager
specifier|public
name|CountingUndoManager
name|undoManager
init|=
operator|new
name|CountingUndoManager
argument_list|(
name|ths
argument_list|)
decl_stmt|;
DECL|field|undoAction
name|UndoAction
name|undoAction
init|=
operator|new
name|UndoAction
argument_list|()
decl_stmt|;
DECL|field|redoAction
name|RedoAction
name|redoAction
init|=
operator|new
name|RedoAction
argument_list|()
decl_stmt|;
comment|//ExampleFileFilter fileFilter;
comment|// File filter for .bib files.
DECL|field|baseChanged
DECL|field|nonUndoableChange
name|boolean
name|baseChanged
init|=
literal|false
decl_stmt|,
name|nonUndoableChange
init|=
literal|false
decl_stmt|;
comment|// Used to track whether the base has changed since last save.
DECL|field|tableModel
name|EntryTableModel
name|tableModel
init|=
literal|null
decl_stmt|;
DECL|field|entryTable
name|EntryTable
name|entryTable
init|=
literal|null
decl_stmt|;
comment|// The sidepane manager takes care of populating the sidepane.
DECL|field|sidePaneManager
specifier|public
name|SidePaneManager
name|sidePaneManager
decl_stmt|;
DECL|field|searchManager
name|SearchManager2
name|searchManager
decl_stmt|;
DECL|field|medlineFetcher
name|MedlineFetcher
name|medlineFetcher
decl_stmt|;
DECL|field|citeSeerFetcher
name|CiteSeerFetcher
name|citeSeerFetcher
decl_stmt|;
DECL|field|rcm
name|RightClickMenu
name|rcm
decl_stmt|;
DECL|field|showing
name|BibtexEntry
name|showing
init|=
literal|null
decl_stmt|;
comment|// To indicate which entry is currently shown.
DECL|field|entryEditors
name|HashMap
name|entryEditors
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
comment|// To contain instantiated entry editors. This is to save time
comment|// in switching between entries.
comment|//HashMap entryTypeForms = new HashMap();
comment|// Hashmap to keep track of which entries currently have open
comment|// EntryTypeForm dialogs.
DECL|field|preambleEditor
name|PreambleEditor
name|preambleEditor
init|=
literal|null
decl_stmt|;
comment|// Keeps track of the preamble dialog if it is open.
DECL|field|stringDialog
name|StringDialog
name|stringDialog
init|=
literal|null
decl_stmt|;
comment|// Keeps track of the string dialog if it is open.
DECL|field|groupSelector
name|GroupSelector
name|groupSelector
decl_stmt|;
comment|// The group selector component for this database. Instantiated by the SidePaneManager if necessary,
comment|// or from this class if merging groups from a different database.
DECL|field|sortingBySearchResults
name|boolean
name|sortingBySearchResults
init|=
literal|false
decl_stmt|,
DECL|field|coloringBySearchResults
name|coloringBySearchResults
init|=
literal|false
decl_stmt|,
DECL|field|sortingByGroup
name|sortingByGroup
init|=
literal|false
decl_stmt|,
DECL|field|coloringByGroup
name|coloringByGroup
init|=
literal|false
decl_stmt|,
DECL|field|previewEnabled
name|previewEnabled
init|=
literal|true
decl_stmt|;
comment|// MetaData parses, keeps and writes meta data.
DECL|field|metaData
name|MetaData
name|metaData
decl_stmt|;
DECL|field|fieldExtras
name|HashMap
name|fieldExtras
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
comment|//## keep track of all keys for duplicate key warning and unique key generation
comment|//private HashMap allKeys  = new HashMap();	// use a map instead of a set since i need to know how many of each key is inthere
DECL|field|suppressOutput
specifier|private
name|boolean
name|suppressOutput
init|=
literal|false
decl_stmt|;
DECL|field|actions
specifier|private
name|HashMap
name|actions
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
DECL|method|BasePanel (JabRefFrame frame, JabRefPreferences prefs)
specifier|public
name|BasePanel
parameter_list|(
name|JabRefFrame
name|frame
parameter_list|,
name|JabRefPreferences
name|prefs
parameter_list|)
block|{
name|database
operator|=
operator|new
name|BibtexDatabase
argument_list|()
expr_stmt|;
name|metaData
operator|=
operator|new
name|MetaData
argument_list|()
expr_stmt|;
name|this
operator|.
name|frame
operator|=
name|frame
expr_stmt|;
name|this
operator|.
name|prefs
operator|=
name|prefs
expr_stmt|;
name|setupActions
argument_list|()
expr_stmt|;
name|setupMainPanel
argument_list|()
expr_stmt|;
block|}
DECL|method|BasePanel (JabRefFrame frame, BibtexDatabase db, File file, HashMap meta, JabRefPreferences prefs)
specifier|public
name|BasePanel
parameter_list|(
name|JabRefFrame
name|frame
parameter_list|,
name|BibtexDatabase
name|db
parameter_list|,
name|File
name|file
parameter_list|,
name|HashMap
name|meta
parameter_list|,
name|JabRefPreferences
name|prefs
parameter_list|)
block|{
name|super
argument_list|(
name|JSplitPane
operator|.
name|HORIZONTAL_SPLIT
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|frame
operator|=
name|frame
expr_stmt|;
name|database
operator|=
name|db
expr_stmt|;
name|this
operator|.
name|prefs
operator|=
name|prefs
expr_stmt|;
name|parseMetaData
argument_list|(
name|meta
argument_list|)
expr_stmt|;
name|setupActions
argument_list|()
expr_stmt|;
name|setupMainPanel
argument_list|()
expr_stmt|;
comment|/*if (prefs.getBoolean("autoComplete")) { 	    db.setCompleters(autoCompleters); 	    }*/
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
block|}
DECL|method|database ()
specifier|public
name|BibtexDatabase
name|database
parameter_list|()
block|{
return|return
name|database
return|;
block|}
DECL|method|frame ()
specifier|public
name|JabRefFrame
name|frame
parameter_list|()
block|{
return|return
name|frame
return|;
block|}
DECL|method|prefs ()
specifier|public
name|JabRefPreferences
name|prefs
parameter_list|()
block|{
return|return
name|prefs
return|;
block|}
DECL|method|output (String s)
specifier|public
name|void
name|output
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
operator|!
name|suppressOutput
condition|)
name|frame
operator|.
name|output
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/**      * BaseAction is used to define actions that are called from the      * base frame through runCommand(). runCommand() finds the      * appropriate BaseAction object, and runs its action() method.      */
DECL|class|BaseAction
specifier|abstract
class|class
name|BaseAction
block|{
comment|//implements Runnable {
DECL|method|action ()
specifier|abstract
name|void
name|action
parameter_list|()
throws|throws
name|Throwable
function_decl|;
block|}
DECL|method|setupActions ()
specifier|private
name|void
name|setupActions
parameter_list|()
block|{
name|actions
operator|.
name|put
argument_list|(
literal|"undo"
argument_list|,
name|undoAction
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"redo"
argument_list|,
name|redoAction
argument_list|)
expr_stmt|;
comment|// The action for opening an entry editor.
name|actions
operator|.
name|put
argument_list|(
literal|"edit"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
comment|//(new Thread() {
comment|//public void run() {
name|int
name|clickedOn
init|=
operator|-
literal|1
decl_stmt|;
comment|// We demand that one and only one row is selected.
if|if
condition|(
name|entryTable
operator|.
name|getSelectedRowCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|clickedOn
operator|=
name|entryTable
operator|.
name|getSelectedRow
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|clickedOn
operator|>=
literal|0
condition|)
block|{
name|String
name|id
init|=
name|tableModel
operator|.
name|getNameFromNumber
argument_list|(
name|clickedOn
argument_list|)
decl_stmt|;
name|BibtexEntry
name|be
init|=
name|database
operator|.
name|getEntryById
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|showEntry
argument_list|(
name|be
argument_list|)
expr_stmt|;
if|if
condition|(
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|!=
literal|null
condition|)
operator|new
name|FocusRequester
argument_list|(
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for saving a database.
name|actions
operator|.
name|put
argument_list|(
literal|"save"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
throws|throws
name|Throwable
block|{
if|if
condition|(
name|file
operator|==
literal|null
condition|)
name|runCommand
argument_list|(
literal|"saveAs"
argument_list|)
expr_stmt|;
else|else
block|{
name|saveDatabase
argument_list|(
name|file
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|undoManager
operator|.
name|markUnchanged
argument_list|()
expr_stmt|;
comment|// (Only) after a successful save the following
comment|// statement marks that the base is unchanged
comment|// since last save:
name|nonUndoableChange
operator|=
literal|false
expr_stmt|;
name|baseChanged
operator|=
literal|false
expr_stmt|;
name|frame
operator|.
name|setTabTitle
argument_list|(
name|ths
argument_list|,
name|file
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Saved database"
argument_list|)
operator|+
literal|" '"
operator|+
name|file
operator|.
name|getPath
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"saveAs"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|chosenFile
init|=
name|Globals
operator|.
name|getNewFile
argument_list|(
name|frame
argument_list|,
name|prefs
argument_list|,
operator|new
name|File
argument_list|(
name|prefs
operator|.
name|get
argument_list|(
literal|"workingDirectory"
argument_list|)
argument_list|)
argument_list|,
literal|".bib"
argument_list|,
name|JFileChooser
operator|.
name|SAVE_DIALOG
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|chosenFile
operator|!=
literal|null
condition|)
block|{
name|file
operator|=
operator|new
name|File
argument_list|(
name|chosenFile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
operator|||
operator|(
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|frame
argument_list|,
literal|"'"
operator|+
name|file
operator|.
name|getName
argument_list|()
operator|+
literal|"' "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"exists. Overwrite file?"
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Save database"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|OK_CANCEL_OPTION
argument_list|)
operator|==
name|JOptionPane
operator|.
name|OK_OPTION
operator|)
condition|)
block|{
name|runCommand
argument_list|(
literal|"save"
argument_list|)
expr_stmt|;
name|prefs
operator|.
name|put
argument_list|(
literal|"workingDirectory"
argument_list|,
name|file
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
name|frame
operator|.
name|fileHistory
operator|.
name|newFile
argument_list|(
name|file
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|file
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"saveSelectedAs"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|chosenFile
init|=
name|Globals
operator|.
name|getNewFile
argument_list|(
name|frame
argument_list|,
name|prefs
argument_list|,
operator|new
name|File
argument_list|(
name|prefs
operator|.
name|get
argument_list|(
literal|"workingDirectory"
argument_list|)
argument_list|)
argument_list|,
literal|".bib"
argument_list|,
name|JFileChooser
operator|.
name|SAVE_DIALOG
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|chosenFile
operator|!=
literal|null
condition|)
block|{
name|File
name|expFile
init|=
operator|new
name|File
argument_list|(
name|chosenFile
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|expFile
operator|.
name|exists
argument_list|()
operator|||
operator|(
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|frame
argument_list|,
literal|"'"
operator|+
name|expFile
operator|.
name|getName
argument_list|()
operator|+
literal|"' "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"exists. Overwrite file?"
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Save database"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|OK_CANCEL_OPTION
argument_list|)
operator|==
name|JOptionPane
operator|.
name|OK_OPTION
operator|)
condition|)
block|{
name|saveDatabase
argument_list|(
name|expFile
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//runCommand("save");
name|frame
operator|.
name|fileHistory
operator|.
name|newFile
argument_list|(
name|expFile
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Saved selected to"
argument_list|)
operator|+
literal|" '"
operator|+
name|expFile
operator|.
name|getPath
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for copying selected entries.
name|actions
operator|.
name|put
argument_list|(
literal|"copy"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|entryTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|TransferableBibtexEntry
name|trbe
init|=
operator|new
name|TransferableBibtexEntry
argument_list|(
name|bes
argument_list|)
decl_stmt|;
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
operator|.
name|getSystemClipboard
argument_list|()
operator|.
name|setContents
argument_list|(
name|trbe
argument_list|,
name|ths
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Copied"
argument_list|)
operator|+
literal|" "
operator|+
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
else|:
literal|"1 "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|+
literal|"."
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The user maybe selected a single cell.
name|int
index|[]
name|rows
init|=
name|entryTable
operator|.
name|getSelectedRows
argument_list|()
decl_stmt|,
name|cols
init|=
name|entryTable
operator|.
name|getSelectedColumns
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|cols
operator|.
name|length
operator|==
literal|1
operator|)
operator|&&
operator|(
name|rows
operator|.
name|length
operator|==
literal|1
operator|)
condition|)
block|{
comment|// Copy single value.
name|Object
name|o
init|=
name|tableModel
operator|.
name|getValueAt
argument_list|(
name|rows
index|[
literal|0
index|]
argument_list|,
name|cols
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|StringSelection
name|ss
init|=
operator|new
name|StringSelection
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
operator|.
name|getSystemClipboard
argument_list|()
operator|.
name|setContents
argument_list|(
name|ss
argument_list|,
name|ths
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Copied cell contents"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"cut"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
throws|throws
name|Throwable
block|{
name|runCommand
argument_list|(
literal|"copy"
argument_list|)
expr_stmt|;
name|BibtexEntry
index|[]
name|bes
init|=
name|entryTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
comment|// Create a CompoundEdit to make the action undoable.
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
literal|"cut entries"
else|:
literal|"cut entry"
argument_list|)
decl_stmt|;
comment|// Loop through the array of entries, and delete them.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|database
operator|.
name|removeEntry
argument_list|(
name|bes
index|[
name|i
index|]
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|ensureNotShowing
argument_list|(
name|bes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableRemoveEntry
argument_list|(
name|database
argument_list|,
name|bes
index|[
name|i
index|]
argument_list|,
name|ths
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|entryTable
operator|.
name|clearSelection
argument_list|()
expr_stmt|;
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Cut_pr"
argument_list|)
operator|+
literal|" "
operator|+
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
else|:
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"delete"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|boolean
name|cancelled
init|=
literal|false
decl_stmt|;
name|BibtexEntry
index|[]
name|bes
init|=
name|entryTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
name|int
name|row0
init|=
name|entryTable
operator|.
name|getSelectedRow
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
comment|//&& (database.getEntryCount()> 0)&& (entryTable.getSelectedRow()< database.getEntryCount())) {
if|if
condition|(
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"confirmDelete"
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Really delete the selected"
argument_list|)
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|+
literal|"?"
decl_stmt|,
name|title
init|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Delete entry"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|msg
operator|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Really delete the selected"
argument_list|)
operator|+
literal|" "
operator|+
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
operator|+
literal|"?"
expr_stmt|;
name|title
operator|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Delete multiple entries"
argument_list|)
expr_stmt|;
block|}
name|CheckBoxMessage
name|cb
init|=
operator|new
name|CheckBoxMessage
argument_list|(
name|msg
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Disable this confirmation dialog"
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|answer
init|=
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|frame
argument_list|,
name|cb
argument_list|,
name|title
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_OPTION
argument_list|,
name|JOptionPane
operator|.
name|QUESTION_MESSAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|==
name|JOptionPane
operator|.
name|NO_OPTION
condition|)
block|{
name|entryTable
operator|.
name|clearSelection
argument_list|()
expr_stmt|;
name|cancelled
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|.
name|isSelected
argument_list|()
condition|)
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"confirmDelete"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cancelled
condition|)
block|{
comment|// Create a CompoundEdit to make the action undoable.
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
name|Globals
operator|.
name|lang
argument_list|(
literal|"delete entries"
argument_list|)
else|:
name|Globals
operator|.
name|lang
argument_list|(
literal|"delete entry"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Loop through the array of entries, and delete them.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|database
operator|.
name|removeEntry
argument_list|(
name|bes
index|[
name|i
index|]
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableRemoveEntry
argument_list|(
name|database
argument_list|,
name|bes
index|[
name|i
index|]
argument_list|,
name|ths
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Deleted"
argument_list|)
operator|+
literal|" "
operator|+
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
else|:
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|entryTable
operator|.
name|clearSelection
argument_list|()
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for pasting entries or cell contents.
comment|// Edited by Seb Wills<saw27@mrao.cam.ac.uk> on 14-Apr-04:
comment|//  - more robust detection of available content flavors (doesn't only look at first one offered)
comment|//  - support for parsing string-flavor clipboard contents which are bibtex entries.
comment|//    This allows you to (a) paste entire bibtex entries from a text editor, web browser, etc
comment|//                       (b) copy and paste entries between multiple instances of JabRef (since
comment|//         only the text representation seems to get as far as the X clipboard, at least on my system)
name|actions
operator|.
name|put
argument_list|(
literal|"paste"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
comment|// Get clipboard contents, and see if TransferableBibtexEntry is among the content flavors offered
name|Transferable
name|content
init|=
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
operator|.
name|getSystemClipboard
argument_list|()
operator|.
name|getContents
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|content
operator|!=
literal|null
condition|)
block|{
name|BibtexEntry
index|[]
name|bes
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|content
operator|.
name|isDataFlavorSupported
argument_list|(
name|TransferableBibtexEntry
operator|.
name|entryFlavor
argument_list|)
condition|)
block|{
comment|// We have determined that the clipboard data is a set of entries.
try|try
block|{
name|bes
operator|=
operator|(
name|BibtexEntry
index|[]
operator|)
operator|(
name|content
operator|.
name|getTransferData
argument_list|(
name|TransferableBibtexEntry
operator|.
name|entryFlavor
argument_list|)
operator|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedFlavorException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|content
operator|.
name|isDataFlavorSupported
argument_list|(
name|DataFlavor
operator|.
name|stringFlavor
argument_list|)
condition|)
block|{
comment|// We have determined that no TransferableBibtexEntry is available, but
comment|// there is a string, which we will handle according to context:
name|int
index|[]
name|rows
init|=
name|entryTable
operator|.
name|getSelectedRows
argument_list|()
decl_stmt|,
name|cols
init|=
name|entryTable
operator|.
name|getSelectedColumns
argument_list|()
decl_stmt|;
name|Util
operator|.
name|pr
argument_list|(
name|rows
operator|.
name|length
operator|+
literal|" x "
operator|+
name|cols
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cols
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|cols
operator|.
name|length
operator|==
literal|1
operator|)
operator|&&
operator|(
name|cols
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rows
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|rows
operator|.
name|length
operator|==
literal|1
operator|)
condition|)
block|{
comment|// A single cell is highlighted, so paste the string straight into it without parsing
try|try
block|{
name|tableModel
operator|.
name|setValueAt
argument_list|(
call|(
name|String
call|)
argument_list|(
name|content
operator|.
name|getTransferData
argument_list|(
name|DataFlavor
operator|.
name|stringFlavor
argument_list|)
argument_list|)
argument_list|,
name|rows
index|[
literal|0
index|]
argument_list|,
name|cols
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|output
argument_list|(
literal|"Pasted cell contents"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedFlavorException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
name|output
argument_list|(
literal|"Can't paste."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// no single cell is selected, so try parsing the clipboard contents as bibtex entries instead
try|try
block|{
name|BibtexParser
name|bp
init|=
operator|new
name|BibtexParser
argument_list|(
operator|new
name|java
operator|.
name|io
operator|.
name|StringReader
argument_list|(
call|(
name|String
call|)
argument_list|(
name|content
operator|.
name|getTransferData
argument_list|(
name|DataFlavor
operator|.
name|stringFlavor
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|BibtexDatabase
name|db
init|=
name|bp
operator|.
name|parse
argument_list|()
operator|.
name|getDatabase
argument_list|()
decl_stmt|;
name|Util
operator|.
name|pr
argument_list|(
literal|"Parsed "
operator|+
name|db
operator|.
name|getEntryCount
argument_list|()
operator|+
literal|" entries from clipboard text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|.
name|getEntryCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Set
name|keySet
init|=
name|db
operator|.
name|getKeySet
argument_list|()
decl_stmt|;
if|if
condition|(
name|keySet
operator|!=
literal|null
condition|)
block|{
comment|// Copy references to the entries into a BibtexEntry array.
comment|// Could import directly from db, but going via bes allows re-use
comment|// of the same pasting code as used for TransferableBibtexEntries
name|bes
operator|=
operator|new
name|BibtexEntry
index|[
name|db
operator|.
name|getEntryCount
argument_list|()
index|]
expr_stmt|;
name|Iterator
name|it
init|=
name|keySet
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|bes
index|[
name|i
index|]
operator|=
name|db
operator|.
name|getEntryById
argument_list|(
call|(
name|String
call|)
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|String
name|cont
init|=
call|(
name|String
call|)
argument_list|(
name|content
operator|.
name|getTransferData
argument_list|(
name|DataFlavor
operator|.
name|stringFlavor
argument_list|)
argument_list|)
decl_stmt|;
name|Util
operator|.
name|pr
argument_list|(
literal|"----------------\n"
operator|+
name|cont
operator|+
literal|"\n---------------------"
argument_list|)
expr_stmt|;
name|Util
operator|.
name|guessBibtexFields
argument_list|(
name|cont
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Unable to parse clipboard text as Bibtex entries."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|UnsupportedFlavorException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// finally we paste in the entries (if any), which either came from TransferableBibtexEntries
comment|// or were parsed from a string
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
literal|"paste entries"
else|:
literal|"paste entry"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|BibtexEntry
name|be
init|=
call|(
name|BibtexEntry
call|)
argument_list|(
name|bes
index|[
name|i
index|]
operator|.
name|clone
argument_list|()
argument_list|)
decl_stmt|;
comment|// We have to clone the
comment|// entries, since the pasted
comment|// entries must exist
comment|// independently of the copied
comment|// ones.
name|be
operator|.
name|setId
argument_list|(
name|Util
operator|.
name|createId
argument_list|(
name|be
operator|.
name|getType
argument_list|()
argument_list|,
name|database
argument_list|)
argument_list|)
expr_stmt|;
name|database
operator|.
name|insertEntry
argument_list|(
name|be
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableInsertEntry
argument_list|(
name|database
argument_list|,
name|be
argument_list|,
name|ths
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeyCollisionException
name|ex
parameter_list|)
block|{
name|Util
operator|.
name|pr
argument_list|(
literal|"KeyCollisionException... this shouldn't happen."
argument_list|)
expr_stmt|;
block|}
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|tableModel
operator|.
name|remap
argument_list|()
expr_stmt|;
name|entryTable
operator|.
name|clearSelection
argument_list|()
expr_stmt|;
name|entryTable
operator|.
name|revalidate
argument_list|()
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Pasted"
argument_list|)
operator|+
literal|" "
operator|+
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
else|:
literal|"1 "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*Util.pr(flavor.length+"");                           Util.pr(flavor[0].toString());                           Util.pr(flavor[1].toString());                           Util.pr(flavor[2].toString());                           Util.pr(flavor[3].toString());                           Util.pr(flavor[4].toString());                        */
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"selectAll"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|entryTable
operator|.
name|selectAll
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for opening the preamble editor
name|actions
operator|.
name|put
argument_list|(
literal|"editPreamble"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
if|if
condition|(
name|preambleEditor
operator|==
literal|null
condition|)
block|{
name|PreambleEditor
name|form
init|=
operator|new
name|PreambleEditor
argument_list|(
name|frame
argument_list|,
name|ths
argument_list|,
name|database
argument_list|,
name|prefs
argument_list|)
decl_stmt|;
name|Util
operator|.
name|placeDialog
argument_list|(
name|form
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|form
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|preambleEditor
operator|=
name|form
expr_stmt|;
block|}
else|else
block|{
name|preambleEditor
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for opening the string editor
name|actions
operator|.
name|put
argument_list|(
literal|"editStrings"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
if|if
condition|(
name|stringDialog
operator|==
literal|null
condition|)
block|{
name|StringDialog
name|form
init|=
operator|new
name|StringDialog
argument_list|(
name|frame
argument_list|,
name|ths
argument_list|,
name|database
argument_list|,
name|prefs
argument_list|)
decl_stmt|;
name|Util
operator|.
name|placeDialog
argument_list|(
name|form
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|form
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|stringDialog
operator|=
name|form
expr_stmt|;
block|}
else|else
block|{
name|stringDialog
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for toggling the groups interface
name|actions
operator|.
name|put
argument_list|(
literal|"toggleGroups"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|sidePaneManager
operator|.
name|togglePanel
argument_list|(
literal|"groups"
argument_list|)
expr_stmt|;
name|frame
operator|.
name|groupToggle
operator|.
name|setSelected
argument_list|(
name|sidePaneManager
operator|.
name|isPanelVisible
argument_list|(
literal|"groups"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"pushToLyX"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
specifier|final
name|int
index|[]
name|rows
init|=
name|entryTable
operator|.
name|getSelectedRows
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numSelected
init|=
name|rows
operator|.
name|length
decl_stmt|;
comment|// Globals.logger("Pushing " +numSelected+(numSelected>1? " entries" : "entry") + " to LyX");
comment|// check if lyxpipe is defined
specifier|final
name|File
name|lyxpipe
init|=
operator|new
name|File
argument_list|(
name|prefs
operator|.
name|get
argument_list|(
literal|"lyxpipe"
argument_list|)
operator|+
literal|".in"
argument_list|)
decl_stmt|;
comment|// this needs to fixed because it gives "asdf" when going prefs.get("lyxpipe")
if|if
condition|(
operator|!
name|lyxpipe
operator|.
name|exists
argument_list|()
operator|||
operator|!
name|lyxpipe
operator|.
name|canWrite
argument_list|()
condition|)
block|{
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Error"
argument_list|)
operator|+
literal|": "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"verify that LyX is running and that the lyxpipe is valid"
argument_list|)
operator|+
literal|". ["
operator|+
name|prefs
operator|.
name|get
argument_list|(
literal|"lyxpipe"
argument_list|)
operator|+
literal|"]"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|//Util.pr("tre");
if|if
condition|(
name|numSelected
operator|>
literal|0
condition|)
block|{
name|Thread
name|pushThread
init|=
operator|new
name|Thread
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|Util
operator|.
name|pr
argument_list|(
literal|"test"
argument_list|)
expr_stmt|;
name|FileWriter
name|fw
init|=
operator|new
name|FileWriter
argument_list|(
name|lyxpipe
argument_list|)
decl_stmt|;
name|Util
operator|.
name|pr
argument_list|(
literal|"test2"
argument_list|)
expr_stmt|;
name|BufferedWriter
name|lyx_out
init|=
operator|new
name|BufferedWriter
argument_list|(
name|fw
argument_list|)
decl_stmt|;
name|String
name|citeStr
init|=
literal|""
decl_stmt|,
name|citeKey
init|=
literal|""
decl_stmt|,
name|message
init|=
literal|""
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSelected
condition|;
name|i
operator|++
control|)
block|{
name|Util
operator|.
name|pr
argument_list|(
literal|":"
operator|+
name|i
argument_list|)
expr_stmt|;
name|BibtexEntry
name|bes
init|=
name|database
operator|.
name|getEntryById
argument_list|(
name|tableModel
operator|.
name|getNameFromNumber
argument_list|(
name|rows
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|citeKey
operator|=
operator|(
name|String
operator|)
name|bes
operator|.
name|getField
argument_list|(
name|GUIGlobals
operator|.
name|KEY_FIELD
argument_list|)
expr_stmt|;
comment|// if the key is empty we give a warning and ignore this entry
if|if
condition|(
name|citeKey
operator|==
literal|null
operator|||
name|citeKey
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|citeStr
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
name|citeStr
operator|=
name|citeKey
expr_stmt|;
else|else
name|citeStr
operator|+=
literal|","
operator|+
name|citeKey
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|message
operator|+=
literal|", "
expr_stmt|;
name|message
operator|+=
operator|(
literal|1
operator|+
name|rows
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|citeStr
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
name|output
argument_list|(
literal|"Please define citekey first"
argument_list|)
expr_stmt|;
else|else
block|{
name|citeStr
operator|=
literal|"LYXCMD:sampleclient:citation-insert:"
operator|+
name|citeStr
expr_stmt|;
name|lyx_out
operator|.
name|write
argument_list|(
name|citeStr
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|output
argument_list|(
literal|"Pushed the citations for the following rows to Lyx: "
operator|+
name|message
argument_list|)
expr_stmt|;
block|}
name|lyx_out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|excep
parameter_list|)
block|{
name|output
argument_list|(
literal|"ERROR: unable to write to "
operator|+
name|prefs
operator|.
name|get
argument_list|(
literal|"lyxpipe"
argument_list|)
operator|+
literal|".in"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|pushThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|Timeout
name|t
init|=
operator|new
name|Timeout
argument_list|(
literal|2000
argument_list|,
name|pushThread
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Error: unable to access LyX-pipe"
argument_list|)
argument_list|)
decl_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for auto-generating keys.
name|actions
operator|.
name|put
argument_list|(
literal|"makeKey"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|int
index|[]
name|rows
init|=
name|entryTable
operator|.
name|getSelectedRows
argument_list|()
decl_stmt|;
name|int
name|numSelected
init|=
name|rows
operator|.
name|length
decl_stmt|;
name|BibtexEntry
name|bes
init|=
literal|null
decl_stmt|;
comment|/*if (numSelected> 0) { 			int answer = JOptionPane.showConfirmDialog 			    (frame, "Generate bibtex key"+ 			     (numSelected>1 ? "s for the selected " 			      +numSelected+" entries?" : 			      " for the selected entry?"), 			     "Autogenerate Bibtexkey", 			     JOptionPane.YES_NO_CANCEL_OPTION); 			if (answer != JOptionPane.YES_OPTION) { 			    return ;  			    } 			*/
if|if
condition|(
name|numSelected
operator|==
literal|0
condition|)
block|{
comment|// None selected. Inform the user to select entries first.
name|JOptionPane
operator|.
name|showMessageDialog
argument_list|(
name|frame
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"First select the entries you want keys to be generated for."
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Autogenerate BibTeX key"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|INFORMATION_MESSAGE
argument_list|)
expr_stmt|;
return|return ;
block|}
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Generating BibTeX key for"
argument_list|)
operator|+
literal|" "
operator|+
name|numSelected
operator|+
literal|" "
operator|+
operator|(
name|numSelected
operator|>
literal|1
condition|?
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
else|:
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
literal|"autogenerate keys"
argument_list|)
decl_stmt|;
comment|//BibtexEntry be;
name|Object
name|oldValue
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSelected
condition|;
name|i
operator|++
control|)
block|{
name|bes
operator|=
name|database
operator|.
name|getEntryById
argument_list|(
name|tableModel
operator|.
name|getNameFromNumber
argument_list|(
name|rows
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|oldValue
operator|=
name|bes
operator|.
name|getField
argument_list|(
name|GUIGlobals
operator|.
name|KEY_FIELD
argument_list|)
expr_stmt|;
comment|//bes = frame.labelMaker.applyRule(bes, database) ;
name|bes
operator|=
name|LabelPatternUtil
operator|.
name|makeLabel
argument_list|(
name|prefs
operator|.
name|getKeyPattern
argument_list|()
argument_list|,
name|database
argument_list|,
name|bes
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableKeyChange
argument_list|(
name|database
argument_list|,
name|bes
operator|.
name|getId
argument_list|()
argument_list|,
operator|(
name|String
operator|)
name|oldValue
argument_list|,
operator|(
name|String
operator|)
name|bes
operator|.
name|getField
argument_list|(
name|GUIGlobals
operator|.
name|KEY_FIELD
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Generated BibTeX key for"
argument_list|)
operator|+
literal|" "
operator|+
name|numSelected
operator|+
literal|" "
operator|+
operator|(
name|numSelected
operator|>
literal|1
condition|?
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
else|:
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"search"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|sidePaneManager
operator|.
name|togglePanel
argument_list|(
literal|"search"
argument_list|)
expr_stmt|;
name|boolean
name|on
init|=
name|sidePaneManager
operator|.
name|isPanelVisible
argument_list|(
literal|"search"
argument_list|)
decl_stmt|;
name|frame
operator|.
name|searchToggle
operator|.
name|setSelected
argument_list|(
name|on
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
name|searchManager
operator|.
name|startSearch
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"incSearch"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|sidePaneManager
operator|.
name|ensureVisible
argument_list|(
literal|"search"
argument_list|)
expr_stmt|;
name|frame
operator|.
name|searchToggle
operator|.
name|setSelected
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|searchManager
operator|.
name|startIncrementalSearch
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for copying the selected entry's key.
name|actions
operator|.
name|put
argument_list|(
literal|"copyKey"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|entryTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
comment|//String[] keys = new String[bes.length];
name|Vector
name|keys
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
comment|// Collect all non-null keys.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bes
index|[
name|i
index|]
operator|.
name|getField
argument_list|(
name|Globals
operator|.
name|KEY_FIELD
argument_list|)
operator|!=
literal|null
condition|)
name|keys
operator|.
name|add
argument_list|(
name|bes
index|[
name|i
index|]
operator|.
name|getField
argument_list|(
name|Globals
operator|.
name|KEY_FIELD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|output
argument_list|(
literal|"None of the selected entries have BibTeX keys."
argument_list|)
expr_stmt|;
return|return;
block|}
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|(
operator|(
name|String
operator|)
name|keys
operator|.
name|elementAt
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|keys
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
operator|(
name|String
operator|)
name|keys
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|StringSelection
name|ss
init|=
operator|new
name|StringSelection
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
operator|.
name|getSystemClipboard
argument_list|()
operator|.
name|setContents
argument_list|(
name|ss
argument_list|,
name|ths
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys
operator|.
name|size
argument_list|()
operator|==
name|bes
operator|.
name|length
condition|)
comment|// All entries had keys.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
operator|)
condition|?
literal|"Copied keys"
else|:
literal|"Copied key"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Warning"
argument_list|)
operator|+
literal|": "
operator|+
operator|(
name|bes
operator|.
name|length
operator|-
name|keys
operator|.
name|size
argument_list|()
operator|)
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"out of"
argument_list|)
operator|+
literal|" "
operator|+
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries have undefined BibTeX key"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for copying a cite for the selected entry.
name|actions
operator|.
name|put
argument_list|(
literal|"copyCiteKey"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|entryTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
comment|//String[] keys = new String[bes.length];
name|Vector
name|keys
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
comment|// Collect all non-null keys.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bes
index|[
name|i
index|]
operator|.
name|getField
argument_list|(
name|Globals
operator|.
name|KEY_FIELD
argument_list|)
operator|!=
literal|null
condition|)
name|keys
operator|.
name|add
argument_list|(
name|bes
index|[
name|i
index|]
operator|.
name|getField
argument_list|(
name|Globals
operator|.
name|KEY_FIELD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|output
argument_list|(
literal|"None of the selected entries have BibTeX keys."
argument_list|)
expr_stmt|;
return|return;
block|}
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|(
operator|(
name|String
operator|)
name|keys
operator|.
name|elementAt
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|keys
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
operator|(
name|String
operator|)
name|keys
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|StringSelection
name|ss
init|=
operator|new
name|StringSelection
argument_list|(
literal|"\\cite{"
operator|+
name|sb
operator|.
name|toString
argument_list|()
operator|+
literal|"}"
argument_list|)
decl_stmt|;
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
operator|.
name|getSystemClipboard
argument_list|()
operator|.
name|setContents
argument_list|(
name|ss
argument_list|,
name|ths
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys
operator|.
name|size
argument_list|()
operator|==
name|bes
operator|.
name|length
condition|)
comment|// All entries had keys.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
operator|)
condition|?
literal|"Copied keys"
else|:
literal|"Copied key"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Warning"
argument_list|)
operator|+
literal|": "
operator|+
operator|(
name|bes
operator|.
name|length
operator|-
name|keys
operator|.
name|size
argument_list|()
operator|)
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"out of"
argument_list|)
operator|+
literal|" "
operator|+
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries have undefined BibTeX key"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"mergeDatabase"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
specifier|final
name|MergeDialog
name|md
init|=
operator|new
name|MergeDialog
argument_list|(
name|frame
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Append database"
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Util
operator|.
name|placeDialog
argument_list|(
name|md
argument_list|,
name|ths
argument_list|)
expr_stmt|;
name|md
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|okPressed
condition|)
block|{
name|String
name|chosenFile
init|=
name|Globals
operator|.
name|getNewFile
argument_list|(
name|frame
argument_list|,
name|prefs
argument_list|,
operator|new
name|File
argument_list|(
name|prefs
operator|.
name|get
argument_list|(
literal|"workingDirectory"
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
name|JFileChooser
operator|.
name|OPEN_DIALOG
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/*JFileChooser chooser = (prefs.get("workingDirectory") == null) ?                       new JabRefFileChooser((File)null) :                       new JabRefFileChooser(new File(prefs.get("workingDirectory")));                   chooser.addChoosableFileFilter( new OpenFileFilter() );//nb nov2                   int returnVal = chooser.showOpenDialog(ths);*/
if|if
condition|(
name|chosenFile
operator|==
literal|null
condition|)
return|return;
name|fileToOpen
operator|=
operator|new
name|File
argument_list|(
name|chosenFile
argument_list|)
expr_stmt|;
comment|// Run the actual open in a thread to prevent the program
comment|// locking until the file is loaded.
if|if
condition|(
name|fileToOpen
operator|!=
literal|null
condition|)
block|{
operator|(
operator|new
name|Thread
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
name|openIt
argument_list|(
name|md
operator|.
name|importEntries
argument_list|()
argument_list|,
name|md
operator|.
name|importStrings
argument_list|()
argument_list|,
name|md
operator|.
name|importGroups
argument_list|()
argument_list|,
name|md
operator|.
name|importSelectorWords
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
operator|)
operator|.
name|start
argument_list|()
expr_stmt|;
name|frame
operator|.
name|fileHistory
operator|.
name|newFile
argument_list|(
name|fileToOpen
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|void
name|openIt
parameter_list|(
name|boolean
name|importEntries
parameter_list|,
name|boolean
name|importStrings
parameter_list|,
name|boolean
name|importGroups
parameter_list|,
name|boolean
name|importSelectorWords
parameter_list|)
block|{
if|if
condition|(
operator|(
name|fileToOpen
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|fileToOpen
operator|.
name|exists
argument_list|()
operator|)
condition|)
block|{
try|try
block|{
name|prefs
operator|.
name|put
argument_list|(
literal|"workingDirectory"
argument_list|,
name|fileToOpen
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
comment|// Should this be done _after_ we know it was successfully opened?
name|String
name|encoding
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"defaultEncoding"
argument_list|)
decl_stmt|;
name|ParserResult
name|pr
init|=
name|ImportFormatReader
operator|.
name|loadDatabase
argument_list|(
name|fileToOpen
argument_list|,
name|encoding
argument_list|)
decl_stmt|;
name|BibtexDatabase
name|db
init|=
name|pr
operator|.
name|getDatabase
argument_list|()
decl_stmt|;
name|MetaData
name|meta
init|=
operator|new
name|MetaData
argument_list|(
name|pr
operator|.
name|getMetaData
argument_list|()
argument_list|)
decl_stmt|;
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
literal|"Append database"
argument_list|)
decl_stmt|;
if|if
condition|(
name|importEntries
condition|)
block|{
comment|// Add entries
name|Iterator
name|i
init|=
name|db
operator|.
name|getKeySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BibtexEntry
name|be
init|=
call|(
name|BibtexEntry
call|)
argument_list|(
name|db
operator|.
name|getEntryById
argument_list|(
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|clone
argument_list|()
argument_list|)
decl_stmt|;
name|be
operator|.
name|setId
argument_list|(
name|Util
operator|.
name|createNeutralId
argument_list|()
argument_list|)
expr_stmt|;
name|database
operator|.
name|insertEntry
argument_list|(
name|be
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableInsertEntry
argument_list|(
name|database
argument_list|,
name|be
argument_list|,
name|ths
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|importStrings
condition|)
block|{
name|BibtexString
name|bs
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|db
operator|.
name|getStringCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|bs
operator|=
call|(
name|BibtexString
call|)
argument_list|(
name|db
operator|.
name|getString
argument_list|(
name|i
argument_list|)
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|database
operator|.
name|hasStringLabel
argument_list|(
name|bs
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|pos
operator|=
name|database
operator|.
name|getStringCount
argument_list|()
expr_stmt|;
name|database
operator|.
name|addString
argument_list|(
name|bs
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableInsertString
argument_list|(
name|ths
argument_list|,
name|database
argument_list|,
name|bs
argument_list|,
name|pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|importGroups
condition|)
block|{
name|Vector
name|newGroups
init|=
name|meta
operator|.
name|getData
argument_list|(
literal|"groups"
argument_list|)
decl_stmt|;
if|if
condition|(
name|newGroups
operator|!=
literal|null
condition|)
block|{
comment|/*if (groupSelector == null) {                           // The current database has no group selector defined, so we must instantiate one.                           groupSelector = new GroupSelector                               (frame, ths, new Vector(), sidePaneManager, prefs);                           sidePaneManager.register("groups", groupSelector);                         }*/
name|groupSelector
operator|.
name|addGroups
argument_list|(
name|newGroups
argument_list|,
name|ce
argument_list|)
expr_stmt|;
name|groupSelector
operator|.
name|revalidateList
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|importSelectorWords
condition|)
block|{
name|Iterator
name|i
init|=
name|meta
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|s
init|=
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
name|Globals
operator|.
name|SELECTOR_META_PREFIX
argument_list|)
condition|)
block|{
name|metaData
operator|.
name|putData
argument_list|(
name|s
argument_list|,
name|meta
operator|.
name|getData
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
name|output
argument_list|(
literal|"Imported from database '"
operator|+
name|fileToOpen
operator|.
name|getPath
argument_list|()
operator|+
literal|"':"
argument_list|)
expr_stmt|;
name|fileToOpen
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|JOptionPane
operator|.
name|showMessageDialog
argument_list|(
name|ths
argument_list|,
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
literal|"Open database"
argument_list|,
name|JOptionPane
operator|.
name|ERROR_MESSAGE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"openFile"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
operator|(
operator|new
name|Thread
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|entryTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
name|String
name|field
init|=
literal|"ps"
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|==
literal|1
operator|)
condition|)
block|{
name|Object
name|link
init|=
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"ps"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"pdf"
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|link
operator|=
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"pdf"
argument_list|)
expr_stmt|;
name|field
operator|=
literal|"pdf"
expr_stmt|;
block|}
name|String
name|filepath
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|link
operator|!=
literal|null
condition|)
block|{
name|filepath
operator|=
name|link
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// see if we can fall back to a filename based on the bibtex key
name|String
name|basefile
decl_stmt|;
name|Object
name|key
init|=
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
name|Globals
operator|.
name|KEY_FIELD
argument_list|)
decl_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
name|basefile
operator|=
name|key
operator|.
name|toString
argument_list|()
expr_stmt|;
name|String
name|dir
init|=
name|prefs
operator|.
name|get
argument_list|(
literal|"pdfDirectory"
argument_list|)
decl_stmt|;
if|if
condition|(
name|dir
operator|.
name|endsWith
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
argument_list|)
condition|)
block|{
name|basefile
operator|=
name|dir
operator|+
name|basefile
expr_stmt|;
block|}
else|else
block|{
name|basefile
operator|=
name|dir
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
operator|+
name|basefile
expr_stmt|;
block|}
specifier|final
name|String
index|[]
name|typesToTry
init|=
operator|new
name|String
index|[]
block|{
literal|"html"
block|,
literal|"ps"
block|,
literal|"pdf"
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|typesToTry
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|basefile
operator|+
literal|"."
operator|+
name|typesToTry
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|Util
operator|.
name|pr
argument_list|(
literal|"Checking for "
operator|+
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|exists
argument_list|()
condition|)
block|{
name|field
operator|=
name|typesToTry
index|[
name|i
index|]
expr_stmt|;
name|filepath
operator|=
name|f
operator|.
name|getPath
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|filepath
operator|!=
literal|null
condition|)
block|{
comment|//output(Globals.lang("Calling external viewer..."));
try|try
block|{
name|Util
operator|.
name|openExternalViewer
argument_list|(
name|filepath
argument_list|,
name|field
argument_list|,
name|prefs
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"External viewer called"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Error"
argument_list|)
operator|+
literal|": "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"No pdf or ps defined, and no file matching Bibtex key found"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"No entries or multiple entries selected."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|)
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"openUrl"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|entryTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
name|String
name|field
init|=
literal|"doi"
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|==
literal|1
operator|)
condition|)
block|{
name|Object
name|link
init|=
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"doi"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"url"
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|link
operator|=
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"url"
argument_list|)
expr_stmt|;
name|field
operator|=
literal|"url"
expr_stmt|;
block|}
if|if
condition|(
name|link
operator|!=
literal|null
condition|)
block|{
comment|//output(Globals.lang("Calling external viewer..."));
try|try
block|{
name|Util
operator|.
name|openExternalViewer
argument_list|(
name|link
operator|.
name|toString
argument_list|()
argument_list|,
name|field
argument_list|,
name|prefs
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"External viewer called"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Error: check your External viewer settings in Preferences"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"No url defined"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"No entries or multiple entries selected."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"replaceAll"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|ReplaceStringDialog
name|rsd
init|=
operator|new
name|ReplaceStringDialog
argument_list|(
name|frame
argument_list|)
decl_stmt|;
name|rsd
operator|.
name|show
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|rsd
operator|.
name|okPressed
argument_list|()
condition|)
return|return;
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
literal|"Replace string"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rsd
operator|.
name|selOnly
argument_list|()
condition|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|database
operator|.
name|getKeySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
name|counter
operator|+=
name|rsd
operator|.
name|replace
argument_list|(
name|database
operator|.
name|getEntryById
argument_list|(
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
argument_list|)
argument_list|,
name|ce
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|entryTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|counter
operator|+=
name|rsd
operator|.
name|replace
argument_list|(
name|bes
index|[
name|i
index|]
argument_list|,
name|ce
argument_list|)
expr_stmt|;
block|}
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Replaced"
argument_list|)
operator|+
literal|" "
operator|+
name|counter
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
name|counter
operator|==
literal|1
condition|?
literal|"occurence"
else|:
literal|"occurences"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|counter
operator|>
literal|0
condition|)
block|{
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"dupliCheck"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|DuplicateSearch
name|ds
init|=
operator|new
name|DuplicateSearch
argument_list|(
name|ths
argument_list|)
decl_stmt|;
name|ds
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"markEntries"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
literal|"Mark entries"
argument_list|)
decl_stmt|;
name|BibtexEntry
index|[]
name|bes
init|=
name|entryTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|bes
index|[
name|i
index|]
argument_list|,
name|Globals
operator|.
name|MARKED
argument_list|,
name|bes
index|[
name|i
index|]
operator|.
name|getField
argument_list|(
name|Globals
operator|.
name|MARKED
argument_list|)
argument_list|,
literal|"0"
argument_list|)
argument_list|)
expr_stmt|;
name|bes
index|[
name|i
index|]
operator|.
name|setField
argument_list|(
name|Globals
operator|.
name|MARKED
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"unmarkEntries"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
literal|"Unmark entries"
argument_list|)
decl_stmt|;
name|BibtexEntry
index|[]
name|bes
init|=
name|entryTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|bes
index|[
name|i
index|]
argument_list|,
name|Globals
operator|.
name|MARKED
argument_list|,
name|bes
index|[
name|i
index|]
operator|.
name|getField
argument_list|(
name|Globals
operator|.
name|MARKED
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|bes
index|[
name|i
index|]
operator|.
name|setField
argument_list|(
name|Globals
operator|.
name|MARKED
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"unmarkAll"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
literal|"Unmark all"
argument_list|)
decl_stmt|;
name|Set
name|keySet
init|=
name|database
operator|.
name|getKeySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|keySet
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BibtexEntry
name|be
init|=
name|database
operator|.
name|getEntryById
argument_list|(
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|be
argument_list|,
name|Globals
operator|.
name|MARKED
argument_list|,
name|be
operator|.
name|getField
argument_list|(
name|Globals
operator|.
name|MARKED
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|be
operator|.
name|setField
argument_list|(
name|Globals
operator|.
name|MARKED
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"togglePreview"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|previewEnabled
operator|=
operator|!
name|previewEnabled
expr_stmt|;
if|if
condition|(
operator|!
name|previewEnabled
condition|)
name|hidePreview
argument_list|()
expr_stmt|;
else|else
block|{
comment|//BibtexEntry[] bes = entryTable.getSelectedEntries();
comment|//if ((bes != null)&& (bes.length> 0))
name|updateViewToSelected
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method is called from JabRefFrame is a database specific      * action is requested by the user. Runs the command if it is      * defined, or prints an error message to the standard error      * stream.      *      * @param command The name of the command to run.     */
DECL|method|runCommand (String _command)
specifier|public
name|void
name|runCommand
parameter_list|(
name|String
name|_command
parameter_list|)
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|command
init|=
name|_command
decl_stmt|;
comment|//(new Thread() {
comment|//  public void run() {
if|if
condition|(
name|actions
operator|.
name|get
argument_list|(
name|command
argument_list|)
operator|==
literal|null
condition|)
name|Util
operator|.
name|pr
argument_list|(
literal|"No action defined for'"
operator|+
name|command
operator|+
literal|"'"
argument_list|)
expr_stmt|;
else|else
try|try
block|{
operator|(
operator|(
name|BaseAction
operator|)
name|actions
operator|.
name|get
argument_list|(
name|command
argument_list|)
operator|)
operator|.
name|action
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{              }
comment|//  }
comment|//}).start();
block|}
DECL|method|saveDatabase (File file, boolean selectedOnly)
specifier|private
name|void
name|saveDatabase
parameter_list|(
name|File
name|file
parameter_list|,
name|boolean
name|selectedOnly
parameter_list|)
throws|throws
name|SaveException
block|{
try|try
block|{
if|if
condition|(
operator|!
name|selectedOnly
condition|)
name|FileActions
operator|.
name|saveDatabase
argument_list|(
name|database
argument_list|,
name|metaData
argument_list|,
name|file
argument_list|,
name|prefs
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|prefs
operator|.
name|get
argument_list|(
literal|"defaultEncoding"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FileActions
operator|.
name|savePartOfDatabase
argument_list|(
name|database
argument_list|,
name|metaData
argument_list|,
name|file
argument_list|,
name|prefs
argument_list|,
name|entryTable
operator|.
name|getSelectedEntries
argument_list|()
argument_list|,
name|prefs
operator|.
name|get
argument_list|(
literal|"defaultEncoding"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SaveException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|.
name|specificEntry
argument_list|()
condition|)
block|{
comment|// Error occured during processing of
comment|// be. Highlight it:
name|int
name|row
init|=
name|tableModel
operator|.
name|getNumberFromName
argument_list|(
name|ex
operator|.
name|getEntry
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|,
name|topShow
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|row
operator|-
literal|3
argument_list|)
decl_stmt|;
comment|//Util.pr(""+row);
name|entryTable
operator|.
name|setRowSelectionInterval
argument_list|(
name|row
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|entryTable
operator|.
name|setColumnSelectionInterval
argument_list|(
literal|0
argument_list|,
name|entryTable
operator|.
name|getColumnCount
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|entryTable
operator|.
name|scrollTo
argument_list|(
name|topShow
argument_list|)
expr_stmt|;
name|showEntry
argument_list|(
name|ex
operator|.
name|getEntry
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|JOptionPane
operator|.
name|showMessageDialog
argument_list|(
name|frame
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Could not save file"
argument_list|)
operator|+
literal|".\n"
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Save database"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|ERROR_MESSAGE
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SaveException
argument_list|(
literal|"rt"
argument_list|)
throw|;
block|}
block|}
comment|/**      * This method is called from JabRefFrame when the user wants to      * create a new entry. If the argument is null, the user is      * prompted for an entry type.      *      * @param type The type of the entry to create.      */
DECL|method|newEntry (BibtexEntryType type)
specifier|public
name|void
name|newEntry
parameter_list|(
name|BibtexEntryType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
comment|// Find out what type is wanted.
name|EntryTypeDialog
name|etd
init|=
operator|new
name|EntryTypeDialog
argument_list|(
name|frame
argument_list|)
decl_stmt|;
comment|// We want to center the dialog, to make it look nicer.
name|Util
operator|.
name|placeDialog
argument_list|(
name|etd
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|etd
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|type
operator|=
name|etd
operator|.
name|getChoice
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
comment|// Only if the dialog was not cancelled.
name|String
name|id
init|=
name|Util
operator|.
name|createId
argument_list|(
name|type
argument_list|,
name|database
argument_list|)
decl_stmt|;
name|BibtexEntry
name|be
init|=
operator|new
name|BibtexEntry
argument_list|(
name|id
argument_list|,
name|type
argument_list|)
decl_stmt|;
try|try
block|{
name|database
operator|.
name|insertEntry
argument_list|(
name|be
argument_list|)
expr_stmt|;
comment|// Create new Bibtex entry
comment|// Set owner field to default value
if|if
condition|(
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"useOwner"
argument_list|)
condition|)
name|be
operator|.
name|setField
argument_list|(
name|Globals
operator|.
name|OWNER
argument_list|,
name|prefs
operator|.
name|get
argument_list|(
literal|"defaultOwner"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create an UndoableInsertEntry object.
name|undoManager
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableInsertEntry
argument_list|(
name|database
argument_list|,
name|be
argument_list|,
name|ths
argument_list|)
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Added new"
argument_list|)
operator|+
literal|" '"
operator|+
name|type
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"' "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
name|int
name|row
init|=
name|tableModel
operator|.
name|getNumberFromName
argument_list|(
name|id
argument_list|)
decl_stmt|;
comment|//Util.pr(""+row);
name|entryTable
operator|.
name|clearSelection
argument_list|()
expr_stmt|;
name|entryTable
operator|.
name|scrollTo
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
comment|// The database just changed.
if|if
condition|(
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"autoOpenForm"
argument_list|)
condition|)
block|{
name|showEntry
argument_list|(
name|be
argument_list|)
expr_stmt|;
comment|//EntryTypeForm etf = new EntryTypeForm(frame, ths, be, prefs);
comment|//Util.placeDialog(etf, frame);
comment|//etf.setVisible(true);
comment|//entryTypeForms.put(id, etf);
block|}
block|}
catch|catch
parameter_list|(
name|KeyCollisionException
name|ex
parameter_list|)
block|{
name|Util
operator|.
name|pr
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|validateMainPanel ()
specifier|public
name|void
name|validateMainPanel
parameter_list|()
block|{     }
DECL|method|setupTable ()
specifier|public
name|void
name|setupTable
parameter_list|()
block|{
name|tableModel
operator|=
operator|new
name|EntryTableModel
argument_list|(
name|frame
argument_list|,
name|this
argument_list|,
name|database
argument_list|)
expr_stmt|;
name|entryTable
operator|=
operator|new
name|EntryTable
argument_list|(
name|tableModel
argument_list|,
name|ths
argument_list|,
name|frame
operator|.
name|prefs
argument_list|)
expr_stmt|;
name|entryTable
operator|.
name|getActionMap
argument_list|()
operator|.
name|put
argument_list|(
literal|"cut"
argument_list|,
operator|new
name|AbstractAction
argument_list|()
block|{
specifier|public
name|void
name|actionPerformed
parameter_list|(
name|ActionEvent
name|e
parameter_list|)
block|{
try|try
block|{
name|runCommand
argument_list|(
literal|"cut"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|entryTable
operator|.
name|getActionMap
argument_list|()
operator|.
name|put
argument_list|(
literal|"copy"
argument_list|,
operator|new
name|AbstractAction
argument_list|()
block|{
specifier|public
name|void
name|actionPerformed
parameter_list|(
name|ActionEvent
name|e
parameter_list|)
block|{
try|try
block|{
name|runCommand
argument_list|(
literal|"copy"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|entryTable
operator|.
name|getActionMap
argument_list|()
operator|.
name|put
argument_list|(
literal|"paste"
argument_list|,
operator|new
name|AbstractAction
argument_list|()
block|{
specifier|public
name|void
name|actionPerformed
parameter_list|(
name|ActionEvent
name|e
parameter_list|)
block|{
try|try
block|{
name|runCommand
argument_list|(
literal|"paste"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|/* 	entryTable.getInputMap().put(prefs.getKey("Edit entry"), "Edit"); 	entryTable.getActionMap().put("Edit", new AbstractAction() { 		public void actionPerformed(ActionEvent e) { 		    Util.pr("eueo"); 		    try { runCommand("edit"); 		    } catch (Throwable ex) { 			ex.printStackTrace(); 		    } 		} 	    }); 	*/
name|entryTable
operator|.
name|addKeyListener
argument_list|(
operator|new
name|KeyAdapter
argument_list|()
block|{
specifier|public
name|void
name|keyPressed
parameter_list|(
name|KeyEvent
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getKeyCode
argument_list|()
operator|==
name|KeyEvent
operator|.
name|VK_ENTER
condition|)
block|{
try|try
block|{
name|runCommand
argument_list|(
literal|"edit"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|getKeyCode
argument_list|()
operator|==
name|KeyEvent
operator|.
name|VK_DELETE
condition|)
block|{
try|try
block|{
name|runCommand
argument_list|(
literal|"delete"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*                     if (((e.getKeyCode() == KeyEvent.VK_DOWN) || (e.getKeyCode() == KeyEvent.VK_UP))&& (e.getModifiers() == 0)) {                        Util.pr(entryTable.getSelectedRow()+"");                     }*/
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Set the right-click menu for the entry table.
comment|//rcm = new RightClickMenu(this, metaData);
name|entryTable
operator|.
name|setRightClickMenu
argument_list|(
name|rcm
argument_list|)
expr_stmt|;
name|int
name|pos
init|=
name|splitPane
operator|.
name|getDividerLocation
argument_list|()
decl_stmt|;
name|splitPane
operator|.
name|setTopComponent
argument_list|(
name|entryTable
operator|.
name|getPane
argument_list|()
argument_list|)
expr_stmt|;
name|splitPane
operator|.
name|setDividerLocation
argument_list|(
name|pos
argument_list|)
expr_stmt|;
comment|//splitPane.revalidate();
block|}
DECL|method|setupMainPanel ()
specifier|public
name|void
name|setupMainPanel
parameter_list|()
block|{
name|splitPane
operator|=
operator|new
name|JSplitPane
argument_list|(
name|JSplitPane
operator|.
name|VERTICAL_SPLIT
argument_list|)
expr_stmt|;
name|splitPane
operator|.
name|setDividerSize
argument_list|(
name|GUIGlobals
operator|.
name|SPLIT_PANE_DIVIDER_SIZE
argument_list|)
expr_stmt|;
comment|// We replace the default FocusTraversalPolicy with a subclass
comment|// that only allows FieldEditor components to gain keyboard focus,
comment|// if there is an entry editor open.
comment|/*splitPane.setFocusTraversalPolicy(new LayoutFocusTraversalPolicy() { 		protected boolean accept(Component c) { 		    Util.pr("jaa"); 		    if (showing == null) 			return super.accept(c); 		    else 			return (super.accept(c)&& 				(c instanceof FieldEditor)); 		} 		});*/
name|setupTable
argument_list|()
expr_stmt|;
comment|// If an entry is currently being shown, make sure it stays shown,
comment|// otherwise set the bottom component to null.
if|if
condition|(
name|showing
operator|==
literal|null
condition|)
block|{
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
name|previewPanel
argument_list|)
expr_stmt|;
if|if
condition|(
name|previewPanel
operator|!=
literal|null
condition|)
name|splitPane
operator|.
name|setDividerLocation
argument_list|(
name|splitPane
operator|.
name|getHeight
argument_list|()
operator|-
name|GUIGlobals
operator|.
name|PREVIEW_HEIGHT
argument_list|)
expr_stmt|;
block|}
else|else
name|showEntry
argument_list|(
name|showing
argument_list|)
expr_stmt|;
name|setRightComponent
argument_list|(
name|splitPane
argument_list|)
expr_stmt|;
name|sidePaneManager
operator|=
operator|new
name|SidePaneManager
argument_list|(
name|frame
argument_list|,
name|this
argument_list|,
name|prefs
argument_list|,
name|metaData
argument_list|)
expr_stmt|;
name|medlineFetcher
operator|=
operator|new
name|MedlineFetcher
argument_list|(
name|this
argument_list|,
name|sidePaneManager
argument_list|)
expr_stmt|;
name|citeSeerFetcher
operator|=
operator|new
name|CiteSeerFetcher
argument_list|(
name|this
argument_list|,
name|sidePaneManager
argument_list|)
expr_stmt|;
name|sidePaneManager
operator|.
name|register
argument_list|(
literal|"fetchMedline"
argument_list|,
name|medlineFetcher
argument_list|)
expr_stmt|;
comment|//medlineAuthorFetcher = new MedlineAuthorFetcher(this, sidePaneManager);
comment|//sidePaneManager.register("fetchAuthorMedline", medlineAuthorFetcher);
name|searchManager
operator|=
operator|new
name|SearchManager2
argument_list|(
name|frame
argument_list|,
name|prefs
argument_list|,
name|sidePaneManager
argument_list|)
expr_stmt|;
name|sidePaneManager
operator|.
name|add
argument_list|(
literal|"search"
argument_list|,
name|searchManager
argument_list|)
expr_stmt|;
name|sidePaneManager
operator|.
name|register
argument_list|(
literal|"CiteSeerProgress"
argument_list|,
name|citeSeerFetcher
argument_list|)
expr_stmt|;
name|sidePaneManager
operator|.
name|populatePanel
argument_list|()
expr_stmt|;
comment|//mainPanel.setDividerLocation(GUIGlobals.SPLIT_PANE_DIVIDER_LOCATION);
name|setDividerSize
argument_list|(
name|GUIGlobals
operator|.
name|SPLIT_PANE_DIVIDER_SIZE
argument_list|)
expr_stmt|;
name|setResizeWeight
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|revalidate
argument_list|()
expr_stmt|;
block|}
comment|/**      * This method is called after a database has been parsed. The      * hashmap contains the contents of all comments in the .bib file      * that started with the meta flag (GUIGlobals.META_FLAG).      * In this method, the meta data are input to their respective      * handlers.      *      * @param meta Metadata to input.      */
DECL|method|parseMetaData (HashMap meta)
specifier|public
name|void
name|parseMetaData
parameter_list|(
name|HashMap
name|meta
parameter_list|)
block|{
name|metaData
operator|=
operator|new
name|MetaData
argument_list|(
name|meta
argument_list|)
expr_stmt|;
block|}
DECL|method|refreshTable ()
specifier|public
name|void
name|refreshTable
parameter_list|()
block|{
comment|// This method is called by EntryTypeForm when a field value is
comment|// stored. The table is scheduled for repaint.
name|entryTable
operator|.
name|assureNotEditing
argument_list|()
expr_stmt|;
name|entryTable
operator|.
name|invalidate
argument_list|()
expr_stmt|;
name|tableModel
operator|.
name|remap
argument_list|()
expr_stmt|;
name|entryTable
operator|.
name|revalidate
argument_list|()
expr_stmt|;
name|entryTable
operator|.
name|repaint
argument_list|()
expr_stmt|;
block|}
DECL|method|updatePreamble ()
specifier|public
name|void
name|updatePreamble
parameter_list|()
block|{
if|if
condition|(
name|preambleEditor
operator|!=
literal|null
condition|)
name|preambleEditor
operator|.
name|updatePreamble
argument_list|()
expr_stmt|;
block|}
DECL|method|assureStringDialogNotEditing ()
specifier|public
name|void
name|assureStringDialogNotEditing
parameter_list|()
block|{
if|if
condition|(
name|stringDialog
operator|!=
literal|null
condition|)
name|stringDialog
operator|.
name|assureNotEditing
argument_list|()
expr_stmt|;
block|}
DECL|method|updateStringDialog ()
specifier|public
name|void
name|updateStringDialog
parameter_list|()
block|{
if|if
condition|(
name|stringDialog
operator|!=
literal|null
condition|)
name|stringDialog
operator|.
name|refreshTable
argument_list|()
expr_stmt|;
block|}
DECL|method|updateViewToSelected ()
specifier|public
name|void
name|updateViewToSelected
parameter_list|()
block|{
comment|// First, if the entry editor is visible, we should update it to the selected entry.
name|BibtexEntry
name|be
init|=
literal|null
decl_stmt|;
name|BibtexEntry
index|[]
name|bes
init|=
name|entryTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
name|be
operator|=
name|bes
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|showing
operator|!=
literal|null
condition|)
return|return;
if|if
condition|(
name|showing
operator|!=
literal|null
condition|)
block|{
name|showEntry
argument_list|(
name|be
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// If no entry editor is visible we must either instantiate a new preview panel or update the one we have.
if|if
condition|(
operator|!
name|previewEnabled
condition|)
block|{
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
literal|null
argument_list|)
expr_stmt|;
return|return;
comment|// Do nothing if previews are disabled.
block|}
if|if
condition|(
name|previewPanel
operator|==
literal|null
condition|)
block|{
name|previewPanel
operator|=
operator|new
name|PreviewPanel
argument_list|(
name|be
argument_list|)
expr_stmt|;
block|}
else|else
name|previewPanel
operator|.
name|setEntry
argument_list|(
name|be
argument_list|)
expr_stmt|;
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
name|previewPanel
argument_list|)
expr_stmt|;
name|splitPane
operator|.
name|setDividerLocation
argument_list|(
name|splitPane
operator|.
name|getHeight
argument_list|()
operator|-
name|GUIGlobals
operator|.
name|PREVIEW_HEIGHT
argument_list|)
expr_stmt|;
name|previewPanel
operator|.
name|repaint
argument_list|()
expr_stmt|;
comment|//throw new NullPointerException("..");
block|}
comment|/**      * Ensure that no preview is shown. Called when preview is turned off. Must chech if      * a preview is in fact visible before doing anything rash.      */
DECL|method|hidePreview ()
specifier|public
name|void
name|hidePreview
parameter_list|()
block|{
name|previewPanel
operator|=
literal|null
expr_stmt|;
name|Component
name|c
init|=
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|c
operator|instanceof
name|PreviewPanel
operator|)
condition|)
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|isShowingEditor ()
specifier|public
name|boolean
name|isShowingEditor
parameter_list|()
block|{
return|return
operator|(
operator|(
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|instanceof
name|EntryEditor
operator|)
operator|)
return|;
block|}
DECL|method|showEntry (BibtexEntry be)
specifier|public
name|void
name|showEntry
parameter_list|(
name|BibtexEntry
name|be
parameter_list|)
block|{
if|if
condition|(
name|showing
operator|==
name|be
condition|)
block|{
if|if
condition|(
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// This is the special occasion when showing is set to an
comment|// entry, but no entry editor is in fact shown. This happens
comment|// after Preferences dialog is closed, and it means that we
comment|// must make sure the same entry is shown again. We do this by
comment|// setting showing to null, and recursively calling this method.
name|showing
operator|=
literal|null
expr_stmt|;
name|showEntry
argument_list|(
name|be
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The correct entry is already being shown. Make sure the editor
comment|// is updated.
operator|(
operator|(
name|EntryEditor
operator|)
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|)
operator|.
name|updateAllFields
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
name|EntryEditor
name|form
decl_stmt|;
name|int
name|divLoc
init|=
operator|-
literal|1
decl_stmt|,
name|visPan
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|showing
operator|!=
literal|null
condition|)
name|visPan
operator|=
operator|(
operator|(
name|EntryEditor
operator|)
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|)
operator|.
name|getVisiblePanel
argument_list|()
expr_stmt|;
if|if
condition|(
name|showing
operator|!=
literal|null
condition|)
name|divLoc
operator|=
name|splitPane
operator|.
name|getDividerLocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|entryEditors
operator|.
name|containsKey
argument_list|(
name|be
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
comment|// We already have an editor for this entry type.
name|form
operator|=
operator|(
name|EntryEditor
operator|)
name|entryEditors
operator|.
name|get
argument_list|(
operator|(
name|be
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|form
operator|.
name|switchTo
argument_list|(
name|be
argument_list|)
expr_stmt|;
if|if
condition|(
name|visPan
operator|>=
literal|0
condition|)
name|form
operator|.
name|setVisiblePanel
argument_list|(
name|visPan
argument_list|)
expr_stmt|;
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
name|form
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We must instantiate a new editor for this type.
name|form
operator|=
operator|new
name|EntryEditor
argument_list|(
name|frame
argument_list|,
name|ths
argument_list|,
name|be
argument_list|,
name|prefs
argument_list|)
expr_stmt|;
if|if
condition|(
name|visPan
operator|>=
literal|0
condition|)
name|form
operator|.
name|setVisiblePanel
argument_list|(
name|visPan
argument_list|)
expr_stmt|;
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|entryEditors
operator|.
name|put
argument_list|(
name|be
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|form
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|divLoc
operator|>
literal|0
condition|)
block|{
name|splitPane
operator|.
name|setDividerLocation
argument_list|(
name|divLoc
argument_list|)
expr_stmt|;
block|}
else|else
name|splitPane
operator|.
name|setDividerLocation
argument_list|(
name|GUIGlobals
operator|.
name|VERTICAL_DIVIDER_LOCATION
argument_list|)
expr_stmt|;
comment|//new FocusRequester(form);
comment|//form.requestFocus();
name|showing
operator|=
name|be
expr_stmt|;
name|setEntryEditorEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Make sure it is enabled.
block|}
comment|/**      * Closes the entry editor.      * Set showing to null, and call updateViewToSelected.      */
DECL|method|hideEntryEditor ()
specifier|public
name|void
name|hideEntryEditor
parameter_list|()
block|{
name|BibtexEntry
name|be
init|=
name|showing
decl_stmt|;
name|showing
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|be
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|entryTable
operator|.
name|getSelectedRows
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|int
name|row
init|=
name|tableModel
operator|.
name|getNumberFromName
argument_list|(
name|be
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|entryTable
operator|.
name|addRowSelectionInterval
argument_list|(
name|row
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
name|updateViewToSelected
argument_list|()
expr_stmt|;
block|}
operator|new
name|FocusRequester
argument_list|(
name|entryTable
argument_list|)
expr_stmt|;
comment|/*splitPane.setBottomComponent(previewPanel);         if (previewPanel != null)           splitPane.setDividerLocation(splitPane.getHeight()-GUIGlobals.PREVIEW_HEIGHT);  */
block|}
comment|/**      * Closes the entry editor if it is showing the given entry.      *      * @param be a<code>BibtexEntry</code> value      */
DECL|method|ensureNotShowing (BibtexEntry be)
specifier|public
name|void
name|ensureNotShowing
parameter_list|(
name|BibtexEntry
name|be
parameter_list|)
block|{
if|if
condition|(
name|showing
operator|==
name|be
condition|)
block|{
name|hideEntryEditor
argument_list|()
expr_stmt|;
name|showing
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|updateEntryEditorIfShowing ()
specifier|public
name|void
name|updateEntryEditorIfShowing
parameter_list|()
block|{
if|if
condition|(
name|isShowingEditor
argument_list|()
condition|)
operator|(
operator|(
name|EntryEditor
operator|)
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|)
operator|.
name|updateAllFields
argument_list|()
expr_stmt|;
block|}
DECL|method|markBaseChanged ()
specifier|public
name|void
name|markBaseChanged
parameter_list|()
block|{
name|baseChanged
operator|=
literal|true
expr_stmt|;
comment|// Put an asterix behind the file name to indicate the
comment|// database has changed.
name|String
name|oldTitle
init|=
name|frame
operator|.
name|getTabTitle
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|oldTitle
operator|.
name|endsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
name|frame
operator|.
name|setTabTitle
argument_list|(
name|this
argument_list|,
name|oldTitle
operator|+
literal|"*"
argument_list|)
expr_stmt|;
comment|// If the status line states that the base has been saved, we
comment|// remove this message, since it is no longer relevant. If a
comment|// different message is shown, we leave it.
if|if
condition|(
name|frame
operator|.
name|statusLine
operator|.
name|getText
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"Saved database"
argument_list|)
condition|)
name|frame
operator|.
name|output
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
DECL|method|markNonUndoableBaseChanged ()
specifier|public
name|void
name|markNonUndoableBaseChanged
parameter_list|()
block|{
name|nonUndoableChange
operator|=
literal|true
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
block|}
DECL|method|markChangedOrUnChanged ()
specifier|public
specifier|synchronized
name|void
name|markChangedOrUnChanged
parameter_list|()
block|{
if|if
condition|(
name|undoManager
operator|.
name|hasChanged
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|baseChanged
condition|)
name|markBaseChanged
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseChanged
operator|&&
operator|!
name|nonUndoableChange
condition|)
block|{
name|baseChanged
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
name|frame
operator|.
name|setTabTitle
argument_list|(
name|ths
argument_list|,
name|file
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|frame
operator|.
name|setTabTitle
argument_list|(
name|ths
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"untitled"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Shows either normal search results or group search, depending      * on the searchValueField. This is done by reordering entries and      * graying out non-hits.      *      * @param searchValueField Which field to show search for: Globals.SEARCH or      * Globals.GROUPSEARCH.      *      */
DECL|method|showSearchResults (String searchValueField, boolean reorder, boolean grayOut, boolean select)
specifier|public
name|void
name|showSearchResults
parameter_list|(
name|String
name|searchValueField
parameter_list|,
name|boolean
name|reorder
parameter_list|,
name|boolean
name|grayOut
parameter_list|,
name|boolean
name|select
parameter_list|)
block|{
comment|//entryTable.scrollTo(0);
name|entryTable
operator|.
name|invalidate
argument_list|()
expr_stmt|;
if|if
condition|(
name|searchValueField
operator|==
name|Globals
operator|.
name|SEARCH
condition|)
block|{
name|sortingBySearchResults
operator|=
name|reorder
expr_stmt|;
name|coloringBySearchResults
operator|=
name|grayOut
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|searchValueField
operator|==
name|Globals
operator|.
name|GROUPSEARCH
condition|)
block|{
name|sortingByGroup
operator|=
name|reorder
expr_stmt|;
name|coloringByGroup
operator|=
name|grayOut
expr_stmt|;
block|}
comment|//tableModel.remap();
name|entryTable
operator|.
name|clearSelection
argument_list|()
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
if|if
condition|(
name|select
condition|)
block|{
name|selectResults
argument_list|(
name|searchValueField
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|entryTable
operator|.
name|clearSelection
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reorder
condition|)
name|entryTable
operator|.
name|scrollTo
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|//entryTable.revalidate();
comment|//entryTable.repaint();
block|}
comment|/**      * Selects all entries with a non-zero value in the field      * @param<code>String</code> field name.      */
DECL|method|selectResults (String field)
specifier|public
name|void
name|selectResults
parameter_list|(
name|String
name|field
parameter_list|)
block|{
name|LinkedList
name|intervals
init|=
operator|new
name|LinkedList
argument_list|()
decl_stmt|;
name|int
name|prevStart
init|=
operator|-
literal|1
decl_stmt|,
name|prevToSel
init|=
literal|0
decl_stmt|;
comment|// First we build a list of intervals to select, without touching the table.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|entryTable
operator|.
name|getRowCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|value
init|=
call|(
name|String
call|)
argument_list|(
name|database
operator|.
name|getEntryById
argument_list|(
name|tableModel
operator|.
name|getNameFromNumber
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|value
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|value
operator|.
name|equals
argument_list|(
literal|"0"
argument_list|)
condition|)
block|{
if|if
condition|(
name|prevStart
operator|<
literal|0
condition|)
name|prevStart
operator|=
name|i
expr_stmt|;
name|prevToSel
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prevStart
operator|>=
literal|0
condition|)
block|{
name|intervals
operator|.
name|add
argument_list|(
operator|new
name|int
index|[]
block|{
name|prevStart
block|,
name|prevToSel
block|}
argument_list|)
expr_stmt|;
name|prevStart
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|// Then select those intervals, if any.
if|if
condition|(
name|intervals
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|entryTable
operator|.
name|setSelectionListenerEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|entryTable
operator|.
name|clearSelection
argument_list|()
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|intervals
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|int
index|[]
name|interval
init|=
operator|(
name|int
index|[]
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|entryTable
operator|.
name|addRowSelectionInterval
argument_list|(
name|interval
index|[
literal|0
index|]
argument_list|,
name|interval
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|entryTable
operator|.
name|setSelectionListenerEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Selects a single entry, and scrolls the table to center it.      *      * @param pos Current position of entry to select.      *      */
DECL|method|selectSingleEntry (int pos)
specifier|public
name|void
name|selectSingleEntry
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|entryTable
operator|.
name|clearSelection
argument_list|()
expr_stmt|;
name|entryTable
operator|.
name|addRowSelectionInterval
argument_list|(
name|pos
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|entryTable
operator|.
name|scrollToCenter
argument_list|(
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|stopShowingSearchResults ()
specifier|public
name|void
name|stopShowingSearchResults
parameter_list|()
block|{
name|sortingBySearchResults
operator|=
literal|false
expr_stmt|;
name|coloringBySearchResults
operator|=
literal|false
expr_stmt|;
comment|/* entryTable.setShowingSearchResults(showingSearchResults,         showingGroup);        */
name|entryTable
operator|.
name|clearSelection
argument_list|()
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
name|entryTable
operator|.
name|requestFocus
argument_list|()
expr_stmt|;
block|}
DECL|method|stopShowingGroup ()
specifier|public
name|void
name|stopShowingGroup
parameter_list|()
block|{
name|sortingByGroup
operator|=
literal|false
expr_stmt|;
name|coloringByGroup
operator|=
literal|false
expr_stmt|;
comment|/*       entryTable.setShowingSearchResults(showingSearchResults,                                          showingGroup);*/
name|entryTable
operator|.
name|clearSelection
argument_list|()
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
block|}
DECL|method|getTableModel ()
specifier|public
name|EntryTableModel
name|getTableModel
parameter_list|()
block|{
return|return
name|tableModel
return|;
block|}
DECL|method|getDatabase ()
specifier|public
name|BibtexDatabase
name|getDatabase
parameter_list|()
block|{
return|return
name|database
return|;
block|}
DECL|method|entryTypeFormClosing (String id)
specifier|public
name|void
name|entryTypeFormClosing
parameter_list|(
name|String
name|id
parameter_list|)
block|{
comment|// Called by EntryTypeForm when closing.
comment|// Deprecated, since EntryEditor has replaced EntryTypeForm.
block|}
DECL|method|preambleEditorClosing ()
specifier|public
name|void
name|preambleEditorClosing
parameter_list|()
block|{
name|preambleEditor
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|stringsClosing ()
specifier|public
name|void
name|stringsClosing
parameter_list|()
block|{
name|stringDialog
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|addToGroup (String groupName, String regexp, String field)
specifier|public
name|void
name|addToGroup
parameter_list|(
name|String
name|groupName
parameter_list|,
name|String
name|regexp
parameter_list|,
name|String
name|field
parameter_list|)
block|{
name|boolean
name|giveWarning
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|GUIGlobals
operator|.
name|ALL_FIELDS
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
name|GUIGlobals
operator|.
name|ALL_FIELDS
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|field
operator|.
name|equals
argument_list|(
literal|"keywords"
argument_list|)
condition|)
block|{
name|giveWarning
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|giveWarning
condition|)
block|{
name|String
name|message
init|=
literal|"This action will modify the '"
operator|+
name|field
operator|+
literal|"' field "
operator|+
literal|"of your entries.\nThis could cause undesired changes to "
operator|+
literal|"your entries, so it\nis recommended that you change the field "
operator|+
literal|"in your group\ndefinition to 'keywords' or a non-standard name."
operator|+
literal|"\n\nDo you still want to continue?"
decl_stmt|;
name|int
name|choice
init|=
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|this
argument_list|,
name|message
argument_list|,
literal|"Warning"
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_OPTION
argument_list|,
name|JOptionPane
operator|.
name|WARNING_MESSAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|choice
operator|==
name|JOptionPane
operator|.
name|NO_OPTION
condition|)
return|return;
block|}
name|BibtexEntry
index|[]
name|bes
init|=
name|entryTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|QuickSearchRule
name|qsr
init|=
operator|new
name|QuickSearchRule
argument_list|(
name|field
argument_list|,
name|regexp
argument_list|)
decl_stmt|;
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
literal|"add to group"
argument_list|)
decl_stmt|;
name|boolean
name|hasEdits
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qsr
operator|.
name|applyRule
argument_list|(
literal|null
argument_list|,
name|bes
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|String
name|oldContent
init|=
operator|(
name|String
operator|)
name|bes
index|[
name|i
index|]
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|,
name|pre
init|=
literal|" "
decl_stmt|,
name|post
init|=
literal|""
decl_stmt|;
name|String
name|newContent
init|=
operator|(
name|oldContent
operator|==
literal|null
condition|?
literal|""
else|:
name|oldContent
operator|+
name|pre
operator|)
operator|+
name|regexp
operator|+
name|post
decl_stmt|;
name|bes
index|[
name|i
index|]
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|newContent
argument_list|)
expr_stmt|;
comment|// Store undo information.
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|bes
index|[
name|i
index|]
argument_list|,
name|field
argument_list|,
name|oldContent
argument_list|,
name|newContent
argument_list|)
argument_list|)
expr_stmt|;
name|hasEdits
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hasEdits
condition|)
block|{
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|updateViewToSelected
argument_list|()
expr_stmt|;
block|}
name|output
argument_list|(
literal|"Appended '"
operator|+
name|regexp
operator|+
literal|"' to the '"
operator|+
name|field
operator|+
literal|"' field of "
operator|+
name|bes
operator|.
name|length
operator|+
literal|" entr"
operator|+
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
literal|"ies."
else|:
literal|"y."
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeFromGroup (String groupName, String regexp, String field)
specifier|public
name|void
name|removeFromGroup
parameter_list|(
name|String
name|groupName
parameter_list|,
name|String
name|regexp
parameter_list|,
name|String
name|field
parameter_list|)
block|{
name|boolean
name|giveWarning
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|GUIGlobals
operator|.
name|ALL_FIELDS
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
name|GUIGlobals
operator|.
name|ALL_FIELDS
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|field
operator|.
name|equals
argument_list|(
literal|"keywords"
argument_list|)
condition|)
block|{
name|giveWarning
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|giveWarning
condition|)
block|{
name|String
name|message
init|=
literal|"This action will modify the '"
operator|+
name|field
operator|+
literal|"' field "
operator|+
literal|"of your entries.\nThis could cause undesired changes to "
operator|+
literal|"your entries, so it\nis recommended that you change the field "
operator|+
literal|"in your group\ndefinition to 'keywords' or a non-standard name."
operator|+
literal|"\n\nDo you still want to continue?"
decl_stmt|;
name|int
name|choice
init|=
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|this
argument_list|,
name|message
argument_list|,
literal|"Warning"
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_OPTION
argument_list|,
name|JOptionPane
operator|.
name|WARNING_MESSAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|choice
operator|==
name|JOptionPane
operator|.
name|NO_OPTION
condition|)
return|return;
block|}
name|BibtexEntry
index|[]
name|bes
init|=
name|entryTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|QuickSearchRule
name|qsr
init|=
operator|new
name|QuickSearchRule
argument_list|(
name|field
argument_list|,
name|regexp
argument_list|)
decl_stmt|;
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
literal|"remove from group"
argument_list|)
decl_stmt|;
name|boolean
name|hasEdits
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qsr
operator|.
name|applyRule
argument_list|(
literal|null
argument_list|,
name|bes
index|[
name|i
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|String
name|oldContent
init|=
operator|(
name|String
operator|)
name|bes
index|[
name|i
index|]
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|qsr
operator|.
name|removeMatches
argument_list|(
name|bes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|// Store undo information.
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|bes
index|[
name|i
index|]
argument_list|,
name|field
argument_list|,
name|oldContent
argument_list|,
name|bes
index|[
name|i
index|]
operator|.
name|getField
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|hasEdits
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hasEdits
condition|)
block|{
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|updateViewToSelected
argument_list|()
expr_stmt|;
block|}
name|output
argument_list|(
literal|"Removed '"
operator|+
name|regexp
operator|+
literal|"' from the '"
operator|+
name|field
operator|+
literal|"' field of "
operator|+
name|bes
operator|.
name|length
operator|+
literal|" entr"
operator|+
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
literal|"ies."
else|:
literal|"y."
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|changeType (BibtexEntryType type)
specifier|public
name|void
name|changeType
parameter_list|(
name|BibtexEntryType
name|type
parameter_list|)
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|entryTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|==
literal|null
operator|)
operator|||
operator|(
name|bes
operator|.
name|length
operator|==
literal|0
operator|)
condition|)
block|{
name|output
argument_list|(
literal|"First select the entries you wish to change type "
operator|+
literal|"for."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|int
name|choice
init|=
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|this
argument_list|,
literal|"Multiple entries selected. Do you want to change"
operator|+
literal|"\nthe type of all these to '"
operator|+
name|type
operator|.
name|getName
argument_list|()
operator|+
literal|"'?"
argument_list|,
literal|"Change type"
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_OPTION
argument_list|,
name|JOptionPane
operator|.
name|WARNING_MESSAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|choice
operator|==
name|JOptionPane
operator|.
name|NO_OPTION
condition|)
return|return;
block|}
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
literal|"change type"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableChangeType
argument_list|(
name|bes
index|[
name|i
index|]
argument_list|,
name|bes
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|bes
index|[
name|i
index|]
operator|.
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Changed type to"
argument_list|)
operator|+
literal|" '"
operator|+
name|type
operator|.
name|getName
argument_list|()
operator|+
literal|"' "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"for"
argument_list|)
operator|+
literal|" "
operator|+
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
block|}
DECL|class|UndoAction
class|class
name|UndoAction
extends|extends
name|BaseAction
block|{
DECL|method|action ()
specifier|public
name|void
name|action
parameter_list|()
block|{
try|try
block|{
name|String
name|name
init|=
name|undoManager
operator|.
name|getUndoPresentationName
argument_list|()
decl_stmt|;
name|undoManager
operator|.
name|undo
argument_list|()
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
name|frame
operator|.
name|output
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CannotUndoException
name|ex
parameter_list|)
block|{
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Nothing to undo"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
comment|// After everything, enable/disable the undo/redo actions
comment|// appropriately.
comment|//updateUndoState();
comment|//redoAction.updateRedoState();
name|markChangedOrUnChanged
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|RedoAction
class|class
name|RedoAction
extends|extends
name|BaseAction
block|{
DECL|method|action ()
specifier|public
name|void
name|action
parameter_list|()
block|{
try|try
block|{
name|String
name|name
init|=
name|undoManager
operator|.
name|getRedoPresentationName
argument_list|()
decl_stmt|;
name|undoManager
operator|.
name|redo
argument_list|()
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|refreshTable
argument_list|()
expr_stmt|;
name|frame
operator|.
name|output
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CannotRedoException
name|ex
parameter_list|)
block|{
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Nothing to redo"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
comment|// After everything, enable/disable the undo/redo actions
comment|// appropriately.
comment|//updateRedoState();
comment|//undoAction.updateUndoState();
name|markChangedOrUnChanged
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Method pertaining to the ClipboardOwner interface.
DECL|method|lostOwnership (Clipboard clipboard, Transferable contents)
specifier|public
name|void
name|lostOwnership
parameter_list|(
name|Clipboard
name|clipboard
parameter_list|,
name|Transferable
name|contents
parameter_list|)
block|{}
DECL|method|previewEnabled ()
specifier|public
name|boolean
name|previewEnabled
parameter_list|()
block|{
return|return
name|previewEnabled
return|;
block|}
DECL|method|setEntryEditorEnabled (boolean enabled)
specifier|public
name|void
name|setEntryEditorEnabled
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
if|if
condition|(
operator|(
name|showing
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|instanceof
name|EntryEditor
operator|)
condition|)
block|{
name|EntryEditor
name|ed
init|=
operator|(
name|EntryEditor
operator|)
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
decl_stmt|;
if|if
condition|(
name|ed
operator|.
name|isEnabled
argument_list|()
operator|!=
name|enabled
condition|)
name|ed
operator|.
name|setEnabled
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|Timeout
class|class
name|Timeout
extends|extends
name|javax
operator|.
name|swing
operator|.
name|Timer
block|{
DECL|method|Timeout (int timeout, final Thread toStop, final String message)
specifier|public
name|Timeout
parameter_list|(
name|int
name|timeout
parameter_list|,
specifier|final
name|Thread
name|toStop
parameter_list|,
specifier|final
name|String
name|message
parameter_list|)
block|{
name|super
argument_list|(
name|timeout
argument_list|,
operator|new
name|ActionListener
argument_list|()
block|{
specifier|public
name|void
name|actionPerformed
parameter_list|(
name|ActionEvent
name|e
parameter_list|)
block|{
name|toStop
operator|.
name|stop
argument_list|()
expr_stmt|;
name|stop
argument_list|()
expr_stmt|;
comment|//output(message);
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

