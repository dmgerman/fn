begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2003 Morten O. Alver and Nizar N. Batada  All programs in this directory and subdirectories are published under the GNU General Public License as described below.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA  Further information about the GNU GPL is available at: http://www.gnu.org/copyleft/gpl.ja.html   */
end_comment

begin_package
DECL|package|net.sf.jabref
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|BorderLayout
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|GridBagConstraints
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|GridBagLayout
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Toolkit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|datatransfer
operator|.
name|Clipboard
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|datatransfer
operator|.
name|ClipboardOwner
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|datatransfer
operator|.
name|DataFlavor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|datatransfer
operator|.
name|StringSelection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|datatransfer
operator|.
name|Transferable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|datatransfer
operator|.
name|UnsupportedFlavorException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|ActionEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|KeyAdapter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|KeyEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|UnsupportedCharsetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|AbstractAction
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JFileChooser
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JOptionPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JPanel
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JRadioButton
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JSplitPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JTextArea
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|SwingUtilities
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|filechooser
operator|.
name|FileFilter
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|tree
operator|.
name|TreePath
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|undo
operator|.
name|CannotRedoException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|undo
operator|.
name|CannotUndoException
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|collab
operator|.
name|ChangeScanner
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|collab
operator|.
name|FileUpdateListener
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|collab
operator|.
name|FileUpdatePanel
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|AutoSetExternalFileForEntries
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|WriteXMPAction
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|GroupSelector
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|GroupTreeNode
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|imports
operator|.
name|AppendDatabaseAction
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|imports
operator|.
name|BibtexParser
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|journals
operator|.
name|AbbreviateAction
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|journals
operator|.
name|UnabbreviateAction
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|labelPattern
operator|.
name|LabelPatternUtil
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|search
operator|.
name|NoSearchMatcher
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|search
operator|.
name|SearchMatcher
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|CountingUndoManager
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|NamedCompound
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|UndoableChangeType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|UndoableInsertEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|UndoableKeyChange
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|UndoableRemoveEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|wizard
operator|.
name|text
operator|.
name|gui
operator|.
name|TextInputDialog
import|;
end_import

begin_import
import|import
name|ca
operator|.
name|odell
operator|.
name|glazedlists
operator|.
name|FilterList
import|;
end_import

begin_import
import|import
name|ca
operator|.
name|odell
operator|.
name|glazedlists
operator|.
name|event
operator|.
name|ListEvent
import|;
end_import

begin_import
import|import
name|ca
operator|.
name|odell
operator|.
name|glazedlists
operator|.
name|event
operator|.
name|ListEventListener
import|;
end_import

begin_import
import|import
name|ca
operator|.
name|odell
operator|.
name|glazedlists
operator|.
name|matchers
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jgoodies
operator|.
name|forms
operator|.
name|builder
operator|.
name|DefaultFormBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jgoodies
operator|.
name|forms
operator|.
name|layout
operator|.
name|FormLayout
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jgoodies
operator|.
name|uif_lite
operator|.
name|component
operator|.
name|UIFSplitPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|BorderFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|ButtonGroup
import|;
end_import

begin_class
DECL|class|BasePanel
specifier|public
class|class
name|BasePanel
extends|extends
name|JPanel
implements|implements
name|ClipboardOwner
implements|,
name|FileUpdateListener
block|{
DECL|field|SHOWING_NOTHING
DECL|field|SHOWING_PREVIEW
DECL|field|SHOWING_EDITOR
DECL|field|WILL_SHOW_EDITOR
specifier|public
specifier|final
specifier|static
name|int
name|SHOWING_NOTHING
init|=
literal|0
decl_stmt|,
name|SHOWING_PREVIEW
init|=
literal|1
decl_stmt|,
name|SHOWING_EDITOR
init|=
literal|2
decl_stmt|,
name|WILL_SHOW_EDITOR
init|=
literal|3
decl_stmt|;
DECL|field|mode
specifier|private
name|int
name|mode
init|=
literal|0
decl_stmt|;
DECL|field|currentEditor
specifier|private
name|EntryEditor
name|currentEditor
init|=
literal|null
decl_stmt|;
DECL|field|currentPreview
specifier|private
name|PreviewPanel
name|currentPreview
init|=
literal|null
decl_stmt|;
DECL|field|tmp
name|boolean
name|tmp
init|=
literal|true
decl_stmt|;
DECL|field|selectionListener
specifier|private
name|MainTableSelectionListener
name|selectionListener
init|=
literal|null
decl_stmt|;
DECL|field|groupsHighlightListener
specifier|private
name|ListEventListener
name|groupsHighlightListener
decl_stmt|;
DECL|field|contentPane
name|UIFSplitPane
name|contentPane
init|=
operator|new
name|UIFSplitPane
argument_list|()
decl_stmt|;
DECL|field|splitPane
name|JSplitPane
name|splitPane
decl_stmt|;
comment|//BibtexEntry testE = new BibtexEntry("tt");
comment|//boolean previewActive = true;
DECL|field|frame
name|JabRefFrame
name|frame
decl_stmt|;
DECL|field|database
name|BibtexDatabase
name|database
decl_stmt|;
comment|// The database shown in this panel.
comment|//  	Moving file to MetaData (Morten, 2006.08.29)
comment|// private File fileToOpen = null;
DECL|field|fileMonitorHandle
name|String
name|fileMonitorHandle
init|=
literal|null
decl_stmt|;
DECL|field|saving
DECL|field|updatedExternally
name|boolean
name|saving
init|=
literal|false
decl_stmt|,
name|updatedExternally
init|=
literal|false
decl_stmt|;
DECL|field|encoding
specifier|private
name|String
name|encoding
decl_stmt|;
DECL|field|gbl
name|GridBagLayout
name|gbl
init|=
operator|new
name|GridBagLayout
argument_list|()
decl_stmt|;
DECL|field|con
name|GridBagConstraints
name|con
init|=
operator|new
name|GridBagConstraints
argument_list|()
decl_stmt|;
DECL|field|autoCompleters
name|HashMap
name|autoCompleters
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
comment|// Hashtable that holds as keys the names of the fields where
comment|// autocomplete is active, and references to the autocompleter objects.
comment|// The undo manager.
DECL|field|undoManager
specifier|public
name|CountingUndoManager
name|undoManager
init|=
operator|new
name|CountingUndoManager
argument_list|(
name|this
argument_list|)
decl_stmt|;
DECL|field|undoAction
name|UndoAction
name|undoAction
init|=
operator|new
name|UndoAction
argument_list|()
decl_stmt|;
DECL|field|redoAction
name|RedoAction
name|redoAction
init|=
operator|new
name|RedoAction
argument_list|()
decl_stmt|;
comment|//ExampleFileFilter fileFilter;
comment|// File filter for .bib files.
DECL|field|baseChanged
DECL|field|nonUndoableChange
name|boolean
name|baseChanged
init|=
literal|false
decl_stmt|,
name|nonUndoableChange
init|=
literal|false
decl_stmt|;
comment|// Used to track whether the base has changed since last save.
comment|//EntryTableModel tableModel = null;
comment|//public EntryTable entryTable = null;
DECL|field|mainTable
specifier|public
name|MainTable
name|mainTable
init|=
literal|null
decl_stmt|;
DECL|field|searchFilterList
DECL|field|groupFilterList
specifier|public
name|FilterList
name|searchFilterList
init|=
literal|null
decl_stmt|,
name|groupFilterList
init|=
literal|null
decl_stmt|;
DECL|field|rcm
specifier|public
name|RightClickMenu
name|rcm
decl_stmt|;
DECL|field|showing
name|BibtexEntry
name|showing
init|=
literal|null
decl_stmt|;
comment|// To indicate which entry is currently shown.
DECL|field|entryEditors
specifier|public
name|HashMap
name|entryEditors
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
comment|// To contain instantiated entry editors. This is to save time
comment|// in switching between entries.
comment|//HashMap entryTypeForms = new HashMap();
comment|// Hashmap to keep track of which entries currently have open
comment|// EntryTypeForm dialogs.
DECL|field|preambleEditor
name|PreambleEditor
name|preambleEditor
init|=
literal|null
decl_stmt|;
comment|// Keeps track of the preamble dialog if it is open.
DECL|field|stringDialog
name|StringDialog
name|stringDialog
init|=
literal|null
decl_stmt|;
comment|// Keeps track of the string dialog if it is open.
comment|/**      * The group selector component for this database. Instantiated by the      * SidePaneManager if necessary, or from this class if merging groups from a      * different database.      */
comment|//GroupSelector groupSelector;
DECL|field|sortingBySearchResults
specifier|public
name|boolean
name|sortingBySearchResults
init|=
literal|false
decl_stmt|,
DECL|field|coloringBySearchResults
name|coloringBySearchResults
init|=
literal|false
decl_stmt|,
DECL|field|hidingNonHits
name|hidingNonHits
init|=
literal|false
decl_stmt|,
DECL|field|sortingByGroup
name|sortingByGroup
init|=
literal|false
decl_stmt|,
DECL|field|sortingByCiteSeerResults
name|sortingByCiteSeerResults
init|=
literal|false
decl_stmt|,
DECL|field|coloringByGroup
name|coloringByGroup
init|=
literal|false
decl_stmt|;
comment|//previewEnabled = Globals.prefs.getBoolean("previewEnabled");
DECL|field|lastSearchHits
name|int
name|lastSearchHits
init|=
operator|-
literal|1
decl_stmt|;
comment|// The number of hits in the latest search.
comment|// Potential use in hiding non-hits completely.
comment|// MetaData parses, keeps and writes meta data.
DECL|field|metaData
name|MetaData
name|metaData
decl_stmt|;
DECL|field|fieldExtras
name|HashMap
name|fieldExtras
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
comment|//## keep track of all keys for duplicate key warning and unique key generation
comment|//private HashMap allKeys  = new HashMap();	// use a map instead of a set since i need to know how many of each key is inthere
DECL|field|suppressOutput
specifier|private
name|boolean
name|suppressOutput
init|=
literal|false
decl_stmt|;
DECL|field|actions
specifier|private
name|HashMap
name|actions
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
DECL|field|sidePaneManager
specifier|private
name|SidePaneManager
name|sidePaneManager
decl_stmt|;
comment|/**      * Create a new BasePanel with an empty database.      * @param frame The application window.      */
DECL|method|BasePanel (JabRefFrame frame)
specifier|public
name|BasePanel
parameter_list|(
name|JabRefFrame
name|frame
parameter_list|)
block|{
name|this
operator|.
name|sidePaneManager
operator|=
name|Globals
operator|.
name|sidePaneManager
expr_stmt|;
name|database
operator|=
operator|new
name|BibtexDatabase
argument_list|()
expr_stmt|;
name|metaData
operator|=
operator|new
name|MetaData
argument_list|()
expr_stmt|;
name|metaData
operator|.
name|initializeNewDatabase
argument_list|()
expr_stmt|;
name|this
operator|.
name|frame
operator|=
name|frame
expr_stmt|;
name|setupActions
argument_list|()
expr_stmt|;
name|setupMainPanel
argument_list|()
expr_stmt|;
name|encoding
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"defaultEncoding"
argument_list|)
expr_stmt|;
comment|//System.out.println("Default: "+encoding);
block|}
DECL|method|BasePanel (JabRefFrame frame, BibtexDatabase db, File file, HashMap meta, String encoding)
specifier|public
name|BasePanel
parameter_list|(
name|JabRefFrame
name|frame
parameter_list|,
name|BibtexDatabase
name|db
parameter_list|,
name|File
name|file
parameter_list|,
name|HashMap
name|meta
parameter_list|,
name|String
name|encoding
parameter_list|)
block|{
name|this
operator|.
name|encoding
operator|=
name|encoding
expr_stmt|;
comment|// System.out.println(encoding);
comment|//super(JSplitPane.HORIZONTAL_SPLIT, true);
name|this
operator|.
name|sidePaneManager
operator|=
name|Globals
operator|.
name|sidePaneManager
expr_stmt|;
name|this
operator|.
name|frame
operator|=
name|frame
expr_stmt|;
name|database
operator|=
name|db
expr_stmt|;
if|if
condition|(
name|meta
operator|!=
literal|null
condition|)
name|parseMetaData
argument_list|(
name|meta
argument_list|)
expr_stmt|;
else|else
block|{
name|metaData
operator|=
operator|new
name|MetaData
argument_list|()
expr_stmt|;
name|metaData
operator|.
name|initializeNewDatabase
argument_list|()
expr_stmt|;
block|}
name|setupActions
argument_list|()
expr_stmt|;
name|setupMainPanel
argument_list|()
expr_stmt|;
name|metaData
operator|.
name|setFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|// Register so we get notifications about outside changes to the file.
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
try|try
block|{
name|fileMonitorHandle
operator|=
name|Globals
operator|.
name|fileUpdateMonitor
operator|.
name|addUpdateListener
argument_list|(
name|this
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{         }
block|}
DECL|method|isBaseChanged ()
specifier|public
name|boolean
name|isBaseChanged
parameter_list|()
block|{
return|return
name|baseChanged
return|;
block|}
DECL|method|getMode ()
specifier|public
name|int
name|getMode
parameter_list|()
block|{
return|return
name|mode
return|;
block|}
DECL|method|database ()
specifier|public
name|BibtexDatabase
name|database
parameter_list|()
block|{
return|return
name|database
return|;
block|}
DECL|method|metaData ()
specifier|public
name|MetaData
name|metaData
parameter_list|()
block|{
return|return
name|metaData
return|;
block|}
DECL|method|frame ()
specifier|public
name|JabRefFrame
name|frame
parameter_list|()
block|{
return|return
name|frame
return|;
block|}
DECL|method|prefs ()
specifier|public
name|JabRefPreferences
name|prefs
parameter_list|()
block|{
return|return
name|Globals
operator|.
name|prefs
return|;
block|}
DECL|method|getEncoding ()
specifier|public
name|String
name|getEncoding
parameter_list|()
block|{
return|return
name|encoding
return|;
block|}
DECL|method|setEncoding (String encoding)
specifier|public
name|void
name|setEncoding
parameter_list|(
name|String
name|encoding
parameter_list|)
block|{
name|this
operator|.
name|encoding
operator|=
name|encoding
expr_stmt|;
block|}
DECL|method|output (String s)
specifier|public
name|void
name|output
parameter_list|(
name|String
name|s
parameter_list|)
block|{
comment|//Util.pr("\""+s+"\""+(SwingUtilities.isEventDispatchThread()));
if|if
condition|(
operator|!
name|suppressOutput
condition|)
name|frame
operator|.
name|output
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
DECL|method|setupActions ()
specifier|private
name|void
name|setupActions
parameter_list|()
block|{
name|actions
operator|.
name|put
argument_list|(
literal|"undo"
argument_list|,
name|undoAction
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"redo"
argument_list|,
name|redoAction
argument_list|)
expr_stmt|;
comment|// The action for opening an entry editor.
name|actions
operator|.
name|put
argument_list|(
literal|"edit"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|selectionListener
operator|.
name|editSignalled
argument_list|()
expr_stmt|;
block|}
comment|/*                   if (isShowingEditor()) {                       new FocusRequester(splitPane.getBottomComponent());                       return;                   }                    frame.block();                 //(new Thread() {                 //public void run() {                 int clickedOn = -1;                 // We demand that one and only one row is selected.                 if (entryTable.getSelectedRowCount() == 1) {                   clickedOn = entryTable.getSelectedRow();                 }                 if (clickedOn>= 0) {                   String id = tableModel.getIdForRow(clickedOn);                   BibtexEntry be = database.getEntryById(id);                   showEntry(be);                    if (splitPane.getBottomComponent() != null) {                       new FocusRequester(splitPane.getBottomComponent());                   }                  }         frame.unblock();               }                 */
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"test"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
throws|throws
name|Throwable
block|{
name|ExportFormats
operator|.
name|initAllExports
argument_list|()
expr_stmt|;
name|JFileChooser
name|fc
init|=
name|ExportFormats
operator|.
name|createExportFileChooser
argument_list|(
literal|"/home/alver/Documents"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|showSaveDialog
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|File
name|file
init|=
name|fc
operator|.
name|getSelectedFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|file
operator|==
literal|null
condition|)
return|return;
name|FileFilter
name|ff
init|=
name|fc
operator|.
name|getFileFilter
argument_list|()
decl_stmt|;
if|if
condition|(
name|ff
operator|instanceof
name|ExportFileFilter
condition|)
block|{
name|ExportFormat
name|format
init|=
operator|(
operator|(
name|ExportFileFilter
operator|)
name|ff
operator|)
operator|.
name|getExportFormat
argument_list|()
decl_stmt|;
name|format
operator|.
name|performExport
argument_list|(
name|database
argument_list|,
name|file
operator|.
name|getPath
argument_list|()
argument_list|,
literal|"UTF8"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// Make sure we remember which filter was used, to set the default
comment|// for next time:
name|Globals
operator|.
name|prefs
operator|.
name|put
argument_list|(
literal|"lastUsedExport"
argument_list|,
name|format
operator|.
name|getConsoleName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for saving a database.
name|actions
operator|.
name|put
argument_list|(
literal|"save"
argument_list|,
operator|new
name|AbstractWorker
argument_list|()
block|{
specifier|private
name|boolean
name|success
init|=
literal|false
decl_stmt|,
name|cancelled
init|=
literal|false
decl_stmt|;
specifier|public
name|void
name|init
parameter_list|()
throws|throws
name|Throwable
block|{
name|success
operator|=
literal|false
expr_stmt|;
name|cancelled
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|getFile
argument_list|()
operator|==
literal|null
condition|)
name|runCommand
argument_list|(
literal|"saveAs"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|updatedExternally
operator|||
name|Globals
operator|.
name|fileUpdateMonitor
operator|.
name|hasBeenModified
argument_list|(
name|fileMonitorHandle
argument_list|)
condition|)
block|{
name|String
index|[]
name|opts
init|=
operator|new
name|String
index|[]
block|{
name|Globals
operator|.
name|lang
argument_list|(
literal|"Review changes"
argument_list|)
block|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Save"
argument_list|)
block|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Cancel"
argument_list|)
block|}
decl_stmt|;
name|int
name|answer
init|=
name|JOptionPane
operator|.
name|showOptionDialog
argument_list|(
name|frame
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"File has been updated externally. "
operator|+
literal|"What do you want to do?"
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"File updated externally"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_CANCEL_OPTION
argument_list|,
name|JOptionPane
operator|.
name|QUESTION_MESSAGE
argument_list|,
literal|null
argument_list|,
name|opts
argument_list|,
name|opts
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/*  int choice = JOptionPane.showConfirmDialog(frame, Globals.lang("File has been updated externally. " +"Are you sure you want to save?"), Globals.lang("File updated externally"),                        JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);*/
if|if
condition|(
name|answer
operator|==
name|JOptionPane
operator|.
name|CANCEL_OPTION
condition|)
return|return;
elseif|else
if|if
condition|(
name|answer
operator|==
name|JOptionPane
operator|.
name|YES_OPTION
condition|)
block|{
name|ChangeScanner
name|scanner
init|=
operator|new
name|ChangeScanner
argument_list|(
name|frame
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
decl_stmt|;
comment|//, panel.database(), panel.metaData());
comment|//try {
name|scanner
operator|.
name|changeScan
argument_list|(
name|getFile
argument_list|()
argument_list|)
expr_stmt|;
name|setUpdatedExternally
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|SwingUtilities
operator|.
name|invokeLater
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
name|sidePaneManager
operator|.
name|hide
argument_list|(
literal|"fileUpdate"
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|//} catch (IOException ex) {
comment|//    ex.printStackTrace();
comment|//}
return|return;
block|}
block|}
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Saving database"
argument_list|)
operator|+
literal|"..."
argument_list|)
expr_stmt|;
name|saving
operator|=
literal|true
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|update
parameter_list|()
block|{
if|if
condition|(
name|success
condition|)
block|{
comment|// Reset title of tab
name|frame
operator|.
name|setTabTitle
argument_list|(
name|BasePanel
operator|.
name|this
argument_list|,
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|getFile
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Saved database"
argument_list|)
operator|+
literal|" '"
operator|+
name|getFile
argument_list|()
operator|.
name|getPath
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|cancelled
condition|)
block|{
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Save failed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|getFile
argument_list|()
operator|==
literal|null
condition|)
block|{
name|cancelled
operator|=
literal|true
expr_stmt|;
return|return;
block|}
try|try
block|{
comment|// If the option is set, autogenerate keys for all entries that are
comment|// lacking keys, before saving:
name|autoGenerateKeysBeforeSaving
argument_list|()
expr_stmt|;
comment|// Now save the database:
name|success
operator|=
name|saveDatabase
argument_list|(
name|getFile
argument_list|()
argument_list|,
literal|false
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
comment|//Util.pr("Testing resolve string... BasePanel line 237");
comment|//Util.pr("Resolve aq: "+database.resolveString("aq"));
comment|//Util.pr("Resolve text: "+database.resolveForStrings("A text which refers to the string #aq# and #billball#, hurra."));
try|try
block|{
name|Globals
operator|.
name|fileUpdateMonitor
operator|.
name|updateTimeStamp
argument_list|(
name|fileMonitorHandle
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
comment|// This means the file has not yet been registered, which is the case
comment|// when doing a "Save as". Maybe we should change the monitor so no
comment|// exception is cast.
block|}
name|saving
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|undoManager
operator|.
name|markUnchanged
argument_list|()
expr_stmt|;
comment|// (Only) after a successful save the following
comment|// statement marks that the base is unchanged
comment|// since last save:
name|nonUndoableChange
operator|=
literal|false
expr_stmt|;
name|baseChanged
operator|=
literal|false
expr_stmt|;
name|updatedExternally
operator|=
literal|false
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SaveException
name|ex2
parameter_list|)
block|{
name|ex2
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"saveAs"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
throws|throws
name|Throwable
block|{
name|JPanel
name|options
init|=
operator|new
name|JPanel
argument_list|()
decl_stmt|;
name|DefaultFormBuilder
name|builder
init|=
operator|new
name|DefaultFormBuilder
argument_list|(
name|options
argument_list|,
operator|new
name|FormLayout
argument_list|(
literal|"left:pref"
argument_list|,
literal|"pref, pref, pref"
argument_list|)
argument_list|)
decl_stmt|;
comment|//options.setLayout(new GridLayout(2,1));
name|ButtonGroup
name|bg
init|=
operator|new
name|ButtonGroup
argument_list|()
decl_stmt|;
name|JRadioButton
name|sAll
init|=
operator|new
name|JRadioButton
argument_list|(
literal|"<html>All entries</html>"
argument_list|)
decl_stmt|;
name|JRadioButton
name|sSel
init|=
operator|new
name|JRadioButton
argument_list|(
literal|"<html>Selected<br>entries</html>"
argument_list|)
decl_stmt|;
name|sAll
operator|.
name|setSelected
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|bg
operator|.
name|add
argument_list|(
name|sAll
argument_list|)
expr_stmt|;
name|bg
operator|.
name|add
argument_list|(
name|sSel
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Include"
argument_list|)
operator|+
literal|":"
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|sAll
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|sSel
argument_list|)
expr_stmt|;
name|builder
operator|.
name|appendGlueRow
argument_list|()
expr_stmt|;
name|options
operator|.
name|setBorder
argument_list|(
name|BorderFactory
operator|.
name|createEmptyBorder
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|chosenFile
init|=
name|Globals
operator|.
name|getNewFile
argument_list|(
name|frame
argument_list|,
operator|new
name|File
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"workingDirectory"
argument_list|)
argument_list|)
argument_list|,
literal|".bib"
argument_list|,
name|JFileChooser
operator|.
name|SAVE_DIALOG
argument_list|,
literal|false
argument_list|,
name|options
argument_list|)
decl_stmt|;
if|if
condition|(
name|chosenFile
operator|==
literal|null
condition|)
return|return;
comment|// cancelled
name|Globals
operator|.
name|prefs
operator|.
name|put
argument_list|(
literal|"workingDirectory"
argument_list|,
name|metaData
operator|.
name|getFile
argument_list|()
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check if the file already exists:
if|if
condition|(
operator|(
operator|new
name|File
argument_list|(
name|chosenFile
argument_list|)
operator|)
operator|.
name|exists
argument_list|()
operator|&&
operator|(
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|frame
argument_list|,
literal|"'"
operator|+
name|metaData
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"exists. Overwrite file?"
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Save database"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|OK_CANCEL_OPTION
argument_list|)
operator|!=
name|JOptionPane
operator|.
name|OK_OPTION
operator|)
condition|)
block|{
return|return;
comment|// cancelled
block|}
comment|// Save:
if|if
condition|(
name|sAll
operator|.
name|isSelected
argument_list|()
condition|)
block|{
comment|//
comment|// Normal save
comment|//
if|if
condition|(
name|chosenFile
operator|!=
literal|null
condition|)
block|{
name|metaData
operator|.
name|setFile
argument_list|(
operator|new
name|File
argument_list|(
name|chosenFile
argument_list|)
argument_list|)
expr_stmt|;
name|runCommand
argument_list|(
literal|"save"
argument_list|)
expr_stmt|;
comment|// Register so we get notifications about outside changes to the file.
try|try
block|{
name|fileMonitorHandle
operator|=
name|Globals
operator|.
name|fileUpdateMonitor
operator|.
name|addUpdateListener
argument_list|(
name|BasePanel
operator|.
name|this
argument_list|,
name|getFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
name|frame
operator|.
name|getFileHistory
argument_list|()
operator|.
name|newFile
argument_list|(
name|metaData
operator|.
name|getFile
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//
comment|// Save selected entries
comment|//
name|File
name|expFile
init|=
operator|new
name|File
argument_list|(
name|chosenFile
argument_list|)
decl_stmt|;
name|saveDatabase
argument_list|(
name|expFile
argument_list|,
literal|true
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|frame
operator|.
name|getFileHistory
argument_list|()
operator|.
name|newFile
argument_list|(
name|expFile
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Saved selected to"
argument_list|)
operator|+
literal|" '"
operator|+
name|expFile
operator|.
name|getPath
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"saveSelectedAs"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|chosenFile
init|=
name|Globals
operator|.
name|getNewFile
argument_list|(
name|frame
argument_list|,
operator|new
name|File
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"workingDirectory"
argument_list|)
argument_list|)
argument_list|,
literal|".bib"
argument_list|,
name|JFileChooser
operator|.
name|SAVE_DIALOG
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|chosenFile
operator|!=
literal|null
condition|)
block|{
name|File
name|expFile
init|=
operator|new
name|File
argument_list|(
name|chosenFile
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|expFile
operator|.
name|exists
argument_list|()
operator|||
operator|(
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|frame
argument_list|,
literal|"'"
operator|+
name|expFile
operator|.
name|getName
argument_list|()
operator|+
literal|"' "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"exists. Overwrite file?"
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Save database"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|OK_CANCEL_OPTION
argument_list|)
operator|==
name|JOptionPane
operator|.
name|OK_OPTION
operator|)
condition|)
block|{
name|saveDatabase
argument_list|(
name|expFile
argument_list|,
literal|true
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"defaultEncoding"
argument_list|)
argument_list|)
expr_stmt|;
comment|//runCommand("save");
name|frame
operator|.
name|getFileHistory
argument_list|()
operator|.
name|newFile
argument_list|(
name|expFile
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Saved selected to"
argument_list|)
operator|+
literal|" '"
operator|+
name|expFile
operator|.
name|getPath
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for copying selected entries.
name|actions
operator|.
name|put
argument_list|(
literal|"copy"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|TransferableBibtexEntry
name|trbe
init|=
operator|new
name|TransferableBibtexEntry
argument_list|(
name|bes
argument_list|)
decl_stmt|;
comment|// ! look at ClipBoardManager
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
operator|.
name|getSystemClipboard
argument_list|()
operator|.
name|setContents
argument_list|(
name|trbe
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Copied"
argument_list|)
operator|+
literal|" "
operator|+
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
else|:
literal|"1 "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|+
literal|"."
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The user maybe selected a single cell.
name|int
index|[]
name|rows
init|=
name|mainTable
operator|.
name|getSelectedRows
argument_list|()
decl_stmt|,
name|cols
init|=
name|mainTable
operator|.
name|getSelectedColumns
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|cols
operator|.
name|length
operator|==
literal|1
operator|)
operator|&&
operator|(
name|rows
operator|.
name|length
operator|==
literal|1
operator|)
condition|)
block|{
comment|// Copy single value.
name|Object
name|o
init|=
name|mainTable
operator|.
name|getValueAt
argument_list|(
name|rows
index|[
literal|0
index|]
argument_list|,
name|cols
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|StringSelection
name|ss
init|=
operator|new
name|StringSelection
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
operator|.
name|getSystemClipboard
argument_list|()
operator|.
name|setContents
argument_list|(
name|ss
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Copied cell contents"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"cut"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
throws|throws
name|Throwable
block|{
name|runCommand
argument_list|(
literal|"copy"
argument_list|)
expr_stmt|;
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
comment|//int row0 = mainTable.getSelectedRow();
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
comment|// Create a CompoundEdit to make the action undoable.
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
literal|"cut entries"
else|:
literal|"cut entry"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Loop through the array of entries, and delete them.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|database
operator|.
name|removeEntry
argument_list|(
name|bes
index|[
name|i
index|]
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|ensureNotShowing
argument_list|(
name|bes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableRemoveEntry
argument_list|(
name|database
argument_list|,
name|bes
index|[
name|i
index|]
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//entryTable.clearSelection();
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Cut_pr"
argument_list|)
operator|+
literal|" "
operator|+
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
else|:
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
comment|// Reselect the entry in the first prev. selected position:
comment|/*if (row0>= entryTable.getRowCount())                             row0 = entryTable.getRowCount()-1;                         if (row0>= 0)                             entryTable.addRowSelectionInterval(row0, row0);*/
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"delete"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|boolean
name|cancelled
init|=
literal|false
decl_stmt|;
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
name|int
name|row0
init|=
name|mainTable
operator|.
name|getSelectedRow
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|boolean
name|goOn
init|=
name|showDeleteConfirmationDialog
argument_list|(
name|bes
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|goOn
condition|)
block|{
return|return;
block|}
else|else
block|{
comment|// Create a CompoundEdit to make the action undoable.
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
literal|"delete entries"
else|:
literal|"delete entry"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Loop through the array of entries, and delete them.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|database
operator|.
name|removeEntry
argument_list|(
name|bes
index|[
name|i
index|]
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|ensureNotShowing
argument_list|(
name|bes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableRemoveEntry
argument_list|(
name|database
argument_list|,
name|bes
index|[
name|i
index|]
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|markBaseChanged
argument_list|()
expr_stmt|;
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Deleted"
argument_list|)
operator|+
literal|" "
operator|+
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
else|:
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
comment|//entryTable.clearSelection();
block|}
comment|// Reselect the entry in the first prev. selected position:
comment|/*if (row0>= entryTable.getRowCount())                               row0 = entryTable.getRowCount()-1;                           if (row0>= 0) {                              final int toSel = row0;                             //                               SwingUtilities.invokeLater(new Runnable() {                                 public void run() {                                     entryTable.addRowSelectionInterval(toSel, toSel);                                     //entryTable.ensureVisible(toSel);                                 }                               });                             */
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for pasting entries or cell contents.
comment|// Edited by Seb Wills<saw27@mrao.cam.ac.uk> on 14-Apr-04:
comment|//  - more robust detection of available content flavors (doesn't only look at first one offered)
comment|//  - support for parsing string-flavor clipboard contents which are bibtex entries.
comment|//    This allows you to (a) paste entire bibtex entries from a text editor, web browser, etc
comment|//                       (b) copy and paste entries between multiple instances of JabRef (since
comment|//         only the text representation seems to get as far as the X clipboard, at least on my system)
name|actions
operator|.
name|put
argument_list|(
literal|"paste"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
comment|// Get clipboard contents, and see if TransferableBibtexEntry is among the content flavors offered
name|Transferable
name|content
init|=
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
operator|.
name|getSystemClipboard
argument_list|()
operator|.
name|getContents
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|content
operator|!=
literal|null
condition|)
block|{
name|BibtexEntry
index|[]
name|bes
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|content
operator|.
name|isDataFlavorSupported
argument_list|(
name|TransferableBibtexEntry
operator|.
name|entryFlavor
argument_list|)
condition|)
block|{
comment|// We have determined that the clipboard data is a set of entries.
try|try
block|{
name|bes
operator|=
operator|(
name|BibtexEntry
index|[]
operator|)
operator|(
name|content
operator|.
name|getTransferData
argument_list|(
name|TransferableBibtexEntry
operator|.
name|entryFlavor
argument_list|)
operator|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedFlavorException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|content
operator|.
name|isDataFlavorSupported
argument_list|(
name|DataFlavor
operator|.
name|stringFlavor
argument_list|)
condition|)
block|{
comment|// We have determined that no TransferableBibtexEntry is available, but
comment|// there is a string, which we will handle according to context:
name|int
index|[]
name|rows
init|=
name|mainTable
operator|.
name|getSelectedRows
argument_list|()
decl_stmt|;
comment|//cols = entryTable.getSelectedColumns();
comment|//Util.pr(rows.length+" x "+cols.length);
comment|/*if ((cols != null)&& (cols.length == 1)&& (cols[0] != 0)&& (rows != null)&& (rows.length == 1)) {                                 // A single cell is highlighted, so paste the string straight into it without parsing                                 try {                                     tableModel.setValueAt((String)(content.getTransferData(DataFlavor.stringFlavor)), rows[0], cols[0]);                                     refreshTable();                                     markBaseChanged();                                     output("Pasted cell contents");                                 } catch (UnsupportedFlavorException ex) {                                     ex.printStackTrace();                                 } catch (IOException ex) {                                     ex.printStackTrace();                                 } catch (IllegalArgumentException ex) {                                     output("Can't paste.");                                 }                             } else {*/
comment|// no single cell is selected, so try parsing the clipboard contents as bibtex entries instead
try|try
block|{
name|BibtexParser
name|bp
init|=
operator|new
name|BibtexParser
argument_list|(
operator|new
name|java
operator|.
name|io
operator|.
name|StringReader
argument_list|(
call|(
name|String
call|)
argument_list|(
name|content
operator|.
name|getTransferData
argument_list|(
name|DataFlavor
operator|.
name|stringFlavor
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|BibtexDatabase
name|db
init|=
name|bp
operator|.
name|parse
argument_list|()
operator|.
name|getDatabase
argument_list|()
decl_stmt|;
name|Util
operator|.
name|pr
argument_list|(
literal|"Parsed "
operator|+
name|db
operator|.
name|getEntryCount
argument_list|()
operator|+
literal|" entries from clipboard text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|.
name|getEntryCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Set
name|keySet
init|=
name|db
operator|.
name|getKeySet
argument_list|()
decl_stmt|;
if|if
condition|(
name|keySet
operator|!=
literal|null
condition|)
block|{
comment|// Copy references to the entries into a BibtexEntry array.
comment|// Could import directly from db, but going via bes allows re-use
comment|// of the same pasting code as used for TransferableBibtexEntries
name|bes
operator|=
operator|new
name|BibtexEntry
index|[
name|db
operator|.
name|getEntryCount
argument_list|()
index|]
expr_stmt|;
name|Iterator
name|it
init|=
name|keySet
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|bes
index|[
name|i
index|]
operator|=
name|db
operator|.
name|getEntryById
argument_list|(
call|(
name|String
call|)
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*else {                                     String cont = (String)(content.getTransferData(DataFlavor.stringFlavor));                                     Util.pr("----------------\n"+cont+"\n---------------------");                                     TextAnalyzer ta = new TextAnalyzer(cont);                                       output(Globals.lang("Unable to parse clipboard text as Bibtex entries."));                                       }*/
block|}
catch|catch
parameter_list|(
name|UnsupportedFlavorException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|// finally we paste in the entries (if any), which either came from TransferableBibtexEntries
comment|// or were parsed from a string
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
literal|"paste entries"
else|:
literal|"paste entry"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|BibtexEntry
name|be
init|=
call|(
name|BibtexEntry
call|)
argument_list|(
name|bes
index|[
name|i
index|]
operator|.
name|clone
argument_list|()
argument_list|)
decl_stmt|;
name|Util
operator|.
name|setAutomaticFields
argument_list|(
name|be
argument_list|)
expr_stmt|;
comment|// We have to clone the
comment|// entries, since the pasted
comment|// entries must exist
comment|// independently of the copied
comment|// ones.
name|be
operator|.
name|setId
argument_list|(
name|Util
operator|.
name|createNeutralId
argument_list|()
argument_list|)
expr_stmt|;
name|database
operator|.
name|insertEntry
argument_list|(
name|be
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableInsertEntry
argument_list|(
name|database
argument_list|,
name|be
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeyCollisionException
name|ex
parameter_list|)
block|{
name|Util
operator|.
name|pr
argument_list|(
literal|"KeyCollisionException... this shouldn't happen."
argument_list|)
expr_stmt|;
block|}
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
comment|//entryTable.clearSelection();
comment|//entryTable.revalidate();
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Pasted"
argument_list|)
operator|+
literal|" "
operator|+
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
else|:
literal|"1 "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"selectAll"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|mainTable
operator|.
name|selectAll
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for opening the preamble editor
name|actions
operator|.
name|put
argument_list|(
literal|"editPreamble"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
if|if
condition|(
name|preambleEditor
operator|==
literal|null
condition|)
block|{
name|PreambleEditor
name|form
init|=
operator|new
name|PreambleEditor
argument_list|(
name|frame
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|,
name|database
argument_list|,
name|Globals
operator|.
name|prefs
argument_list|)
decl_stmt|;
name|Util
operator|.
name|placeDialog
argument_list|(
name|form
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|form
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|preambleEditor
operator|=
name|form
expr_stmt|;
block|}
else|else
block|{
name|preambleEditor
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for opening the string editor
name|actions
operator|.
name|put
argument_list|(
literal|"editStrings"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
if|if
condition|(
name|stringDialog
operator|==
literal|null
condition|)
block|{
name|StringDialog
name|form
init|=
operator|new
name|StringDialog
argument_list|(
name|frame
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|,
name|database
argument_list|,
name|Globals
operator|.
name|prefs
argument_list|)
decl_stmt|;
name|Util
operator|.
name|placeDialog
argument_list|(
name|form
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|form
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|stringDialog
operator|=
name|form
expr_stmt|;
block|}
else|else
block|{
name|stringDialog
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for toggling the groups interface
name|actions
operator|.
name|put
argument_list|(
literal|"toggleGroups"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|sidePaneManager
operator|.
name|toggle
argument_list|(
literal|"groups"
argument_list|)
expr_stmt|;
name|frame
operator|.
name|groupToggle
operator|.
name|setSelected
argument_list|(
name|sidePaneManager
operator|.
name|isComponentVisible
argument_list|(
literal|"groups"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for auto-generating keys.
name|actions
operator|.
name|put
argument_list|(
literal|"makeKey"
argument_list|,
operator|new
name|AbstractWorker
argument_list|()
block|{
comment|//int[] rows;
name|List
name|entries
decl_stmt|;
name|int
name|numSelected
decl_stmt|;
name|boolean
name|cancelled
init|=
literal|false
decl_stmt|;
comment|// Run first, in EDT:
specifier|public
name|void
name|init
parameter_list|()
block|{
name|entries
operator|=
operator|new
name|ArrayList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|getSelectedEntries
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//rows = entryTable.getSelectedRows() ;
name|numSelected
operator|=
name|entries
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|entries
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// None selected. Inform the user to select entries first.
name|JOptionPane
operator|.
name|showMessageDialog
argument_list|(
name|frame
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"First select the entries you want keys to be generated for."
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Autogenerate BibTeX key"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|INFORMATION_MESSAGE
argument_list|)
expr_stmt|;
return|return ;
block|}
name|frame
operator|.
name|block
argument_list|()
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Generating BibTeX key for"
argument_list|)
operator|+
literal|" "
operator|+
name|numSelected
operator|+
literal|" "
operator|+
operator|(
name|numSelected
operator|>
literal|1
condition|?
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
else|:
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|)
operator|+
literal|"..."
argument_list|)
expr_stmt|;
block|}
comment|// Run second, on a different thread:
specifier|public
name|void
name|run
parameter_list|()
block|{
name|BibtexEntry
name|bes
init|=
literal|null
decl_stmt|;
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"autogenerate keys"
argument_list|)
argument_list|)
decl_stmt|;
comment|//BibtexEntry be;
name|Object
name|oldValue
decl_stmt|;
name|boolean
name|hasShownWarning
init|=
literal|false
decl_stmt|;
comment|// First check if any entries have keys set already. If so, possibly remove
comment|// them from consideration, or warn about overwriting keys.
name|loop
label|:
for|for
control|(
name|Iterator
name|i
init|=
name|entries
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|bes
operator|=
operator|(
name|BibtexEntry
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|bes
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"avoidOverwritingKey"
argument_list|)
condition|)
comment|// Rmove the entry, because its key is already set:
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"warnBeforeOverwritingKey"
argument_list|)
condition|)
block|{
comment|// Ask if the user wants to cancel the operation:
name|CheckBoxMessage
name|cbm
init|=
operator|new
name|CheckBoxMessage
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"One or more keys will be overwritten. Continue?"
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Disable this confirmation dialog"
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|answer
init|=
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|frame
argument_list|,
name|cbm
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Overwrite keys"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_OPTION
argument_list|)
decl_stmt|;
if|if
condition|(
name|cbm
operator|.
name|isSelected
argument_list|()
condition|)
name|Globals
operator|.
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"warnBeforeOverwritingKey"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|==
name|JOptionPane
operator|.
name|NO_OPTION
condition|)
block|{
comment|// Ok, break off the operation.
name|cancelled
operator|=
literal|true
expr_stmt|;
return|return;
block|}
comment|// No need to check more entries, because the user has already confirmed
comment|// that it's ok to overwrite keys:
break|break
name|loop
break|;
block|}
block|}
block|}
name|HashMap
name|oldvals
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
comment|// Iterate again, removing already set keys. This is skipped if overwriting
comment|// is disabled, since all entries with keys set will have been removed.
if|if
condition|(
operator|!
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"avoidOverwritingKey"
argument_list|)
condition|)
for|for
control|(
name|Iterator
name|i
init|=
name|entries
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|bes
operator|=
operator|(
name|BibtexEntry
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
comment|// Store the old value:
name|oldvals
operator|.
name|put
argument_list|(
name|bes
argument_list|,
name|bes
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
argument_list|)
expr_stmt|;
name|database
operator|.
name|setCiteKeyForEntry
argument_list|(
name|bes
operator|.
name|getId
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// Finally, set the new keys:
for|for
control|(
name|Iterator
name|i
init|=
name|entries
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|bes
operator|=
operator|(
name|BibtexEntry
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|bes
operator|=
name|LabelPatternUtil
operator|.
name|makeLabel
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|getKeyPattern
argument_list|()
argument_list|,
name|database
argument_list|,
name|bes
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableKeyChange
argument_list|(
name|database
argument_list|,
name|bes
operator|.
name|getId
argument_list|()
argument_list|,
operator|(
name|String
operator|)
name|oldvals
operator|.
name|get
argument_list|(
name|bes
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|bes
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
block|}
comment|// Run third, on EDT:
specifier|public
name|void
name|update
parameter_list|()
block|{
if|if
condition|(
name|cancelled
condition|)
block|{
name|frame
operator|.
name|unblock
argument_list|()
expr_stmt|;
return|return;
block|}
name|markBaseChanged
argument_list|()
expr_stmt|;
name|numSelected
operator|=
name|entries
operator|.
name|size
argument_list|()
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Generated BibTeX key for"
argument_list|)
operator|+
literal|" "
operator|+
name|numSelected
operator|+
literal|" "
operator|+
operator|(
name|numSelected
operator|!=
literal|1
condition|?
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
else|:
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|frame
operator|.
name|unblock
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"search"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
comment|//sidePaneManager.togglePanel("search");
name|sidePaneManager
operator|.
name|show
argument_list|(
literal|"search"
argument_list|)
expr_stmt|;
comment|//boolean on = sidePaneManager.isPanelVisible("search");
name|frame
operator|.
name|searchToggle
operator|.
name|setSelected
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
literal|true
condition|)
name|frame
operator|.
name|searchManager
operator|.
name|startSearch
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"toggleSearch"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
comment|//sidePaneManager.togglePanel("search");
name|sidePaneManager
operator|.
name|toggle
argument_list|(
literal|"search"
argument_list|)
expr_stmt|;
name|boolean
name|on
init|=
name|sidePaneManager
operator|.
name|isComponentVisible
argument_list|(
literal|"search"
argument_list|)
decl_stmt|;
name|frame
operator|.
name|searchToggle
operator|.
name|setSelected
argument_list|(
name|on
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
name|frame
operator|.
name|searchManager
operator|.
name|startSearch
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"incSearch"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|sidePaneManager
operator|.
name|show
argument_list|(
literal|"search"
argument_list|)
expr_stmt|;
name|frame
operator|.
name|searchToggle
operator|.
name|setSelected
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|frame
operator|.
name|searchManager
operator|.
name|startIncrementalSearch
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for copying the selected entry's key.
name|actions
operator|.
name|put
argument_list|(
literal|"copyKey"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|storeCurrentEdit
argument_list|()
expr_stmt|;
comment|//String[] keys = new String[bes.length];
name|Vector
name|keys
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
comment|// Collect all non-null keys.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bes
index|[
name|i
index|]
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
operator|!=
literal|null
condition|)
name|keys
operator|.
name|add
argument_list|(
name|bes
index|[
name|i
index|]
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|output
argument_list|(
literal|"None of the selected entries have BibTeX keys."
argument_list|)
expr_stmt|;
return|return;
block|}
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|(
operator|(
name|String
operator|)
name|keys
operator|.
name|elementAt
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|keys
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
operator|(
name|String
operator|)
name|keys
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|StringSelection
name|ss
init|=
operator|new
name|StringSelection
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
operator|.
name|getSystemClipboard
argument_list|()
operator|.
name|setContents
argument_list|(
name|ss
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys
operator|.
name|size
argument_list|()
operator|==
name|bes
operator|.
name|length
condition|)
comment|// All entries had keys.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
operator|)
condition|?
literal|"Copied keys"
else|:
literal|"Copied key"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Warning"
argument_list|)
operator|+
literal|": "
operator|+
operator|(
name|bes
operator|.
name|length
operator|-
name|keys
operator|.
name|size
argument_list|()
operator|)
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"out of"
argument_list|)
operator|+
literal|" "
operator|+
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries have undefined BibTeX key"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for copying a cite for the selected entry.
name|actions
operator|.
name|put
argument_list|(
literal|"copyCiteKey"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|storeCurrentEdit
argument_list|()
expr_stmt|;
comment|//String[] keys = new String[bes.length];
name|Vector
name|keys
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
comment|// Collect all non-null keys.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bes
index|[
name|i
index|]
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
operator|!=
literal|null
condition|)
name|keys
operator|.
name|add
argument_list|(
name|bes
index|[
name|i
index|]
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|output
argument_list|(
literal|"None of the selected entries have BibTeX keys."
argument_list|)
expr_stmt|;
return|return;
block|}
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|(
operator|(
name|String
operator|)
name|keys
operator|.
name|elementAt
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|keys
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
operator|(
name|String
operator|)
name|keys
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|StringSelection
name|ss
init|=
operator|new
name|StringSelection
argument_list|(
literal|"\\cite{"
operator|+
name|sb
operator|.
name|toString
argument_list|()
operator|+
literal|"}"
argument_list|)
decl_stmt|;
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
operator|.
name|getSystemClipboard
argument_list|()
operator|.
name|setContents
argument_list|(
name|ss
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys
operator|.
name|size
argument_list|()
operator|==
name|bes
operator|.
name|length
condition|)
comment|// All entries had keys.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
operator|)
condition|?
literal|"Copied keys"
else|:
literal|"Copied key"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Warning"
argument_list|)
operator|+
literal|": "
operator|+
operator|(
name|bes
operator|.
name|length
operator|-
name|keys
operator|.
name|size
argument_list|()
operator|)
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"out of"
argument_list|)
operator|+
literal|" "
operator|+
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries have undefined BibTeX key"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"mergeDatabase"
argument_list|,
operator|new
name|AppendDatabaseAction
argument_list|(
name|frame
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"openFile"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
operator|(
operator|new
name|Thread
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
name|String
name|field
init|=
literal|"ps"
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|==
literal|1
operator|)
condition|)
block|{
name|Object
name|link
init|=
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"ps"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"pdf"
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|link
operator|=
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"pdf"
argument_list|)
expr_stmt|;
name|field
operator|=
literal|"pdf"
expr_stmt|;
block|}
name|String
name|filepath
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|link
operator|!=
literal|null
condition|)
block|{
name|filepath
operator|=
name|link
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// see if we can fall back to a filename based on the bibtex key
name|String
name|basefile
decl_stmt|;
name|Object
name|key
init|=
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
decl_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
name|basefile
operator|=
name|key
operator|.
name|toString
argument_list|()
expr_stmt|;
specifier|final
name|String
index|[]
name|types
init|=
operator|new
name|String
index|[]
block|{
literal|"pdf"
block|,
literal|"ps"
block|}
decl_stmt|;
specifier|final
name|String
name|sep
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|types
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|dir
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|types
index|[
name|i
index|]
operator|+
literal|"Directory"
argument_list|)
decl_stmt|;
if|if
condition|(
name|dir
operator|.
name|endsWith
argument_list|(
name|sep
argument_list|)
condition|)
block|{
name|dir
operator|=
name|dir
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|dir
operator|.
name|length
argument_list|()
operator|-
name|sep
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|found
init|=
name|Util
operator|.
name|findPdf
argument_list|(
name|basefile
argument_list|,
name|types
index|[
name|i
index|]
argument_list|,
name|dir
argument_list|,
operator|new
name|OpenFileFilter
argument_list|(
literal|"."
operator|+
name|types
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
operator|!=
literal|null
condition|)
block|{
name|filepath
operator|=
name|dir
operator|+
name|sep
operator|+
name|found
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|filepath
operator|!=
literal|null
condition|)
block|{
comment|//output(Globals.lang("Calling external viewer..."));
try|try
block|{
name|Util
operator|.
name|openExternalViewer
argument_list|(
name|metaData
argument_list|()
argument_list|,
name|filepath
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"External viewer called"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Error"
argument_list|)
operator|+
literal|": "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"No pdf or ps defined, and no file matching Bibtex key found"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"No entries or multiple entries selected."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|)
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"openUrl"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
name|String
name|field
init|=
literal|"doi"
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|==
literal|1
operator|)
condition|)
block|{
name|Object
name|link
init|=
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"doi"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"url"
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|link
operator|=
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"url"
argument_list|)
expr_stmt|;
name|field
operator|=
literal|"url"
expr_stmt|;
block|}
if|if
condition|(
name|link
operator|!=
literal|null
condition|)
block|{
comment|//output(Globals.lang("Calling external viewer..."));
try|try
block|{
name|Util
operator|.
name|openExternalViewer
argument_list|(
name|metaData
argument_list|()
argument_list|,
name|link
operator|.
name|toString
argument_list|()
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"External viewer called"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Error"
argument_list|)
operator|+
literal|": "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"No url defined"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"No entries or multiple entries selected."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"replaceAll"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|ReplaceStringDialog
name|rsd
init|=
operator|new
name|ReplaceStringDialog
argument_list|(
name|frame
argument_list|)
decl_stmt|;
name|rsd
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rsd
operator|.
name|okPressed
argument_list|()
condition|)
return|return;
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Replace string"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rsd
operator|.
name|selOnly
argument_list|()
condition|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|database
operator|.
name|getKeySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
name|counter
operator|+=
name|rsd
operator|.
name|replace
argument_list|(
name|database
operator|.
name|getEntryById
argument_list|(
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
argument_list|)
argument_list|,
name|ce
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|counter
operator|+=
name|rsd
operator|.
name|replace
argument_list|(
name|bes
index|[
name|i
index|]
argument_list|,
name|ce
argument_list|)
expr_stmt|;
block|}
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Replaced"
argument_list|)
operator|+
literal|" "
operator|+
name|counter
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
name|counter
operator|==
literal|1
condition|?
literal|"occurence"
else|:
literal|"occurences"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|counter
operator|>
literal|0
condition|)
block|{
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"dupliCheck"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|DuplicateSearch
name|ds
init|=
operator|new
name|DuplicateSearch
argument_list|(
name|BasePanel
operator|.
name|this
argument_list|)
decl_stmt|;
name|ds
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|/*actions.put("strictDupliCheck", new BaseAction() {                 public void action() {                   StrictDuplicateSearch ds = new StrictDuplicateSearch(BasePanel.this);                   ds.start();                 }               });*/
name|actions
operator|.
name|put
argument_list|(
literal|"plainTextImport"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
comment|// get Type of new entry
name|EntryTypeDialog
name|etd
init|=
operator|new
name|EntryTypeDialog
argument_list|(
name|frame
argument_list|)
decl_stmt|;
name|Util
operator|.
name|placeDialog
argument_list|(
name|etd
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
expr_stmt|;
name|etd
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|BibtexEntryType
name|tp
init|=
name|etd
operator|.
name|getChoice
argument_list|()
decl_stmt|;
if|if
condition|(
name|tp
operator|==
literal|null
condition|)
return|return;
name|String
name|id
init|=
name|Util
operator|.
name|createNeutralId
argument_list|()
decl_stmt|;
name|BibtexEntry
name|bibEntry
init|=
operator|new
name|BibtexEntry
argument_list|(
name|id
argument_list|,
name|tp
argument_list|)
decl_stmt|;
name|TextInputDialog
name|tidialog
init|=
operator|new
name|TextInputDialog
argument_list|(
name|frame
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|,
literal|"import"
argument_list|,
literal|true
argument_list|,
name|bibEntry
argument_list|)
decl_stmt|;
name|Util
operator|.
name|placeDialog
argument_list|(
name|tidialog
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
expr_stmt|;
name|tidialog
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|tidialog
operator|.
name|okPressed
argument_list|()
condition|)
block|{
name|Util
operator|.
name|setAutomaticFields
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|BibtexEntry
index|[]
block|{
name|bibEntry
block|}
argument_list|)
argument_list|)
expr_stmt|;
name|insertEntry
argument_list|(
name|bibEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action starts the "import from plain text" dialog
comment|/*actions.put("importPlainText", new BaseAction() {                       public void action()                       {                         BibtexEntry bibEntry = null ;                         // try to get the first marked entry                         BibtexEntry[] bes = entryTable.getSelectedEntries();                         if ((bes != null)&& (bes.length> 0))                           bibEntry = bes[0] ;                          if (bibEntry != null)                         {                           // Create an UndoableInsertEntry object.                           undoManager.addEdit(new UndoableInsertEntry(database, bibEntry, BasePanel.this));                            TextInputDialog tidialog = new TextInputDialog(frame, BasePanel.this,                                                                          "import", true,                                                                          bibEntry) ;                           Util.placeDialog(tidialog, BasePanel.this);                           tidialog.setVisible(true);                            if (tidialog.okPressed())                           {                             output(Globals.lang("changed ")+" '"                                    +bibEntry.getType().getName().toLowerCase()+"' "                                    +Globals.lang("entry")+".");                             refreshTable();                             int row = tableModel.getNumberFromName(bibEntry.getId());                              entryTable.clearSelection();                             entryTable.scrollTo(row);                             markBaseChanged(); // The database just changed.                             if (Globals.prefs.getBoolean("autoOpenForm"))                             {                                   showEntry(bibEntry);                             }                           }                         }                       }                   });                 */
name|actions
operator|.
name|put
argument_list|(
literal|"markEntries"
argument_list|,
operator|new
name|AbstractWorker
argument_list|()
block|{
specifier|private
name|int
name|besLength
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|void
name|run
parameter_list|()
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Mark entries"
argument_list|)
argument_list|)
decl_stmt|;
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
name|besLength
operator|=
name|bes
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|bes
operator|==
literal|null
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Util
operator|.
name|markEntry
argument_list|(
name|bes
index|[
name|i
index|]
argument_list|,
name|ce
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|update
parameter_list|()
block|{
name|markBaseChanged
argument_list|()
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Marked selected"
argument_list|)
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
name|besLength
operator|>
literal|0
condition|?
literal|"entry"
else|:
literal|"entries"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"unmarkEntries"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
try|try
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Unmark entries"
argument_list|)
argument_list|)
decl_stmt|;
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
name|bes
operator|==
literal|null
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Util
operator|.
name|unmarkEntry
argument_list|(
name|bes
index|[
name|i
index|]
argument_list|,
name|database
argument_list|,
name|ce
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Unmarked selected"
argument_list|)
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
name|bes
operator|.
name|length
operator|>
literal|0
condition|?
literal|"entry"
else|:
literal|"entries"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"unmarkAll"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Unmark all"
argument_list|)
argument_list|)
decl_stmt|;
name|Set
name|keySet
init|=
name|database
operator|.
name|getKeySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|keySet
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BibtexEntry
name|be
init|=
name|database
operator|.
name|getEntryById
argument_list|(
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|Util
operator|.
name|unmarkEntry
argument_list|(
name|be
argument_list|,
name|database
argument_list|,
name|ce
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"togglePreview"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|boolean
name|enabled
init|=
operator|!
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"previewEnabled"
argument_list|)
decl_stmt|;
name|Globals
operator|.
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"previewEnabled"
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
name|frame
operator|.
name|setPreviewActive
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
name|frame
operator|.
name|previewToggle
operator|.
name|setSelected
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"toggleHighlightGroupsMatchingAny"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|boolean
name|enabled
init|=
operator|!
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"highlightGroupsMatchingAny"
argument_list|)
decl_stmt|;
name|Globals
operator|.
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"highlightGroupsMatchingAny"
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
name|frame
operator|.
name|highlightAny
operator|.
name|setSelected
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|enabled
condition|)
block|{
name|frame
operator|.
name|highlightAll
operator|.
name|setSelected
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|Globals
operator|.
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"highlightGroupsMatchingAll"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// ping the listener so it updates:
name|groupsHighlightListener
operator|.
name|listChanged
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"toggleHighlightGroupsMatchingAll"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|boolean
name|enabled
init|=
operator|!
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"highlightGroupsMatchingAll"
argument_list|)
decl_stmt|;
name|Globals
operator|.
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"highlightGroupsMatchingAll"
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
name|frame
operator|.
name|highlightAll
operator|.
name|setSelected
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|enabled
condition|)
block|{
name|frame
operator|.
name|highlightAny
operator|.
name|setSelected
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|Globals
operator|.
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"highlightGroupsMatchingAny"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// ping the listener so it updates:
name|groupsHighlightListener
operator|.
name|listChanged
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"switchPreview"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|selectionListener
operator|.
name|switchPreview
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"manageSelectors"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|ContentSelectorDialog2
name|csd
init|=
operator|new
name|ContentSelectorDialog2
argument_list|(
name|frame
argument_list|,
name|frame
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|,
literal|false
argument_list|,
name|metaData
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Util
operator|.
name|placeDialog
argument_list|(
name|csd
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|csd
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"exportToClipboard"
argument_list|,
operator|new
name|ExportToClipboardAction
argument_list|(
name|frame
argument_list|,
name|database
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"writeXMP"
argument_list|,
operator|new
name|WriteXMPAction
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"abbreviateIso"
argument_list|,
operator|new
name|AbbreviateAction
argument_list|(
name|this
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"abbreviateMedline"
argument_list|,
operator|new
name|AbbreviateAction
argument_list|(
name|this
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"unabbreviate"
argument_list|,
operator|new
name|UnabbreviateAction
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"autoSetPdf"
argument_list|,
operator|new
name|AutoSetExternalFileForEntries
argument_list|(
name|this
argument_list|,
literal|"pdf"
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"autoSetPs"
argument_list|,
operator|new
name|AutoSetExternalFileForEntries
argument_list|(
name|this
argument_list|,
literal|"ps"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method is called from JabRefFrame is a database specific      * action is requested by the user. Runs the command if it is      * defined, or prints an error message to the standard error      * stream.      *      * @param _command The name of the command to run.     */
DECL|method|runCommand (String _command)
specifier|public
name|void
name|runCommand
parameter_list|(
name|String
name|_command
parameter_list|)
block|{
specifier|final
name|String
name|command
init|=
name|_command
decl_stmt|;
comment|//(new Thread() {
comment|//  public void run() {
if|if
condition|(
name|actions
operator|.
name|get
argument_list|(
name|command
argument_list|)
operator|==
literal|null
condition|)
name|Util
operator|.
name|pr
argument_list|(
literal|"No action defined for'"
operator|+
name|command
operator|+
literal|"'"
argument_list|)
expr_stmt|;
else|else
block|{
name|Object
name|o
init|=
name|actions
operator|.
name|get
argument_list|(
name|command
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|o
operator|instanceof
name|BaseAction
condition|)
operator|(
operator|(
name|BaseAction
operator|)
name|o
operator|)
operator|.
name|action
argument_list|()
expr_stmt|;
else|else
block|{
comment|// This part uses Spin's features:
name|Worker
name|wrk
init|=
operator|(
operator|(
name|AbstractWorker
operator|)
name|o
operator|)
operator|.
name|getWorker
argument_list|()
decl_stmt|;
comment|// The Worker returned by getWorker() has been wrapped
comment|// by Spin.off(), which makes its methods be run in
comment|// a different thread from the EDT.
name|CallBack
name|clb
init|=
operator|(
operator|(
name|AbstractWorker
operator|)
name|o
operator|)
operator|.
name|getCallBack
argument_list|()
decl_stmt|;
operator|(
operator|(
name|AbstractWorker
operator|)
name|o
operator|)
operator|.
name|init
argument_list|()
expr_stmt|;
comment|// This method runs in this same thread, the EDT.
comment|// Useful for initial GUI actions, like printing a message.
comment|// The CallBack returned by getCallBack() has been wrapped
comment|// by Spin.over(), which makes its methods be run on
comment|// the EDT.
name|wrk
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// Runs the potentially time-consuming action
comment|// without freezing the GUI. The magic is that THIS line
comment|// of execution will not continue until run() is finished.
name|clb
operator|.
name|update
argument_list|()
expr_stmt|;
comment|// Runs the update() method on the EDT.
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
comment|// If the action has blocked the JabRefFrame before crashing, we need to unblock it.
comment|// The call to unblock will simply hide the glasspane, so there is no harm in calling
comment|// it even if the frame hasn't been blocked.
name|frame
operator|.
name|unblock
argument_list|()
expr_stmt|;
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|//  }
comment|//}).start();
block|}
DECL|method|saveDatabase (File file, boolean selectedOnly, String encoding)
specifier|private
name|boolean
name|saveDatabase
parameter_list|(
name|File
name|file
parameter_list|,
name|boolean
name|selectedOnly
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|SaveException
block|{
name|SaveSession
name|session
decl_stmt|;
name|frame
operator|.
name|block
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|selectedOnly
condition|)
name|session
operator|=
name|FileActions
operator|.
name|saveDatabase
argument_list|(
name|database
argument_list|,
name|metaData
argument_list|,
name|file
argument_list|,
name|Globals
operator|.
name|prefs
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
else|else
name|session
operator|=
name|FileActions
operator|.
name|savePartOfDatabase
argument_list|(
name|database
argument_list|,
name|metaData
argument_list|,
name|file
argument_list|,
name|Globals
operator|.
name|prefs
argument_list|,
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedCharsetException
name|ex2
parameter_list|)
block|{
name|JOptionPane
operator|.
name|showMessageDialog
argument_list|(
name|frame
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Could not save file. "
operator|+
literal|"Character encoding '%0' is not supported."
argument_list|,
name|encoding
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Save database"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|ERROR_MESSAGE
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SaveException
argument_list|(
literal|"rt"
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|SaveException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|.
name|specificEntry
argument_list|()
condition|)
block|{
comment|// Error occured during processing of
comment|// be. Highlight it:
name|int
name|row
init|=
name|mainTable
operator|.
name|findEntry
argument_list|(
name|ex
operator|.
name|getEntry
argument_list|()
argument_list|)
decl_stmt|,
name|topShow
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|row
operator|-
literal|3
argument_list|)
decl_stmt|;
name|mainTable
operator|.
name|setRowSelectionInterval
argument_list|(
name|row
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|scrollTo
argument_list|(
name|topShow
argument_list|)
expr_stmt|;
name|showEntry
argument_list|(
name|ex
operator|.
name|getEntry
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|JOptionPane
operator|.
name|showMessageDialog
argument_list|(
name|frame
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Could not save file"
argument_list|)
operator|+
literal|".\n"
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Save database"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|ERROR_MESSAGE
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SaveException
argument_list|(
literal|"rt"
argument_list|)
throw|;
block|}
finally|finally
block|{
name|frame
operator|.
name|unblock
argument_list|()
expr_stmt|;
block|}
name|boolean
name|commit
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|session
operator|.
name|getWriter
argument_list|()
operator|.
name|couldEncodeAll
argument_list|()
condition|)
block|{
name|DefaultFormBuilder
name|builder
init|=
operator|new
name|DefaultFormBuilder
argument_list|(
operator|new
name|FormLayout
argument_list|(
literal|"left:pref, 4dlu, fill:pref"
argument_list|,
literal|""
argument_list|)
argument_list|)
decl_stmt|;
name|JTextArea
name|ta
init|=
operator|new
name|JTextArea
argument_list|(
name|session
operator|.
name|getWriter
argument_list|()
operator|.
name|getProblemCharacters
argument_list|()
argument_list|)
decl_stmt|;
name|ta
operator|.
name|setEditable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"The chosen encoding '%0' could not encode the following characters: "
argument_list|,
name|session
operator|.
name|getEncoding
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|ta
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"What do you want to do?"
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|tryDiff
init|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Try different encoding"
argument_list|)
decl_stmt|;
name|int
name|answer
init|=
name|JOptionPane
operator|.
name|showOptionDialog
argument_list|(
name|frame
argument_list|,
name|builder
operator|.
name|getPanel
argument_list|()
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Save database"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_CANCEL_OPTION
argument_list|,
name|JOptionPane
operator|.
name|WARNING_MESSAGE
argument_list|,
literal|null
argument_list|,
operator|new
name|String
index|[]
block|{
name|Globals
operator|.
name|lang
argument_list|(
literal|"Save"
argument_list|)
block|,
name|tryDiff
block|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Cancel"
argument_list|)
block|}
argument_list|,
name|tryDiff
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|==
name|JOptionPane
operator|.
name|NO_OPTION
condition|)
block|{
comment|// The user wants to use another encoding.
name|Object
name|choice
init|=
name|JOptionPane
operator|.
name|showInputDialog
argument_list|(
name|frame
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Select encoding"
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Save database"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|QUESTION_MESSAGE
argument_list|,
literal|null
argument_list|,
name|Globals
operator|.
name|ENCODINGS
argument_list|,
name|encoding
argument_list|)
decl_stmt|;
if|if
condition|(
name|choice
operator|!=
literal|null
condition|)
block|{
name|String
name|newEncoding
init|=
operator|(
name|String
operator|)
name|choice
decl_stmt|;
return|return
name|saveDatabase
argument_list|(
name|file
argument_list|,
name|selectedOnly
argument_list|,
name|newEncoding
argument_list|)
return|;
block|}
else|else
name|commit
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|answer
operator|==
name|JOptionPane
operator|.
name|CANCEL_OPTION
condition|)
name|commit
operator|=
literal|false
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|commit
condition|)
block|{
name|session
operator|.
name|commit
argument_list|()
expr_stmt|;
name|this
operator|.
name|encoding
operator|=
name|encoding
expr_stmt|;
comment|// Make sure to remember which encoding we used.
block|}
else|else
name|session
operator|.
name|cancel
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
return|return
name|commit
return|;
block|}
comment|/**      * This method is called from JabRefFrame when the user wants to      * create a new entry. If the argument is null, the user is      * prompted for an entry type.      *      * @param type The type of the entry to create.      * @return The newly created BibtexEntry or null the operation was canceled by the user.      */
DECL|method|newEntry (BibtexEntryType type)
specifier|public
name|BibtexEntry
name|newEntry
parameter_list|(
name|BibtexEntryType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
comment|// Find out what type is wanted.
name|EntryTypeDialog
name|etd
init|=
operator|new
name|EntryTypeDialog
argument_list|(
name|frame
argument_list|)
decl_stmt|;
comment|// We want to center the dialog, to make it look nicer.
name|Util
operator|.
name|placeDialog
argument_list|(
name|etd
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|etd
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|type
operator|=
name|etd
operator|.
name|getChoice
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
comment|// Only if the dialog was not cancelled.
name|String
name|id
init|=
name|Util
operator|.
name|createNeutralId
argument_list|()
decl_stmt|;
specifier|final
name|BibtexEntry
name|be
init|=
operator|new
name|BibtexEntry
argument_list|(
name|id
argument_list|,
name|type
argument_list|)
decl_stmt|;
try|try
block|{
name|database
operator|.
name|insertEntry
argument_list|(
name|be
argument_list|)
expr_stmt|;
comment|// Set owner/timestamp if options are enabled:
name|ArrayList
name|list
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|be
argument_list|)
expr_stmt|;
name|Util
operator|.
name|setAutomaticFields
argument_list|(
name|list
argument_list|)
expr_stmt|;
comment|// Create an UndoableInsertEntry object.
name|undoManager
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableInsertEntry
argument_list|(
name|database
argument_list|,
name|be
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Added new"
argument_list|)
operator|+
literal|" '"
operator|+
name|type
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"' "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
specifier|final
name|int
name|row
init|=
name|mainTable
operator|.
name|findEntry
argument_list|(
name|be
argument_list|)
decl_stmt|;
comment|// We are going to select the new entry. Before that, make sure that we are in
comment|// show-entry mode. If we aren't already in that mode, enter the WILL_SHOW_EDITOR
comment|// mode which makes sure the selection will trigger display of the entry editor
comment|// and adjustment of the splitter.
if|if
condition|(
name|mode
operator|!=
name|SHOWING_EDITOR
condition|)
block|{
name|mode
operator|=
name|WILL_SHOW_EDITOR
expr_stmt|;
block|}
name|highlightEntry
argument_list|(
name|be
argument_list|)
expr_stmt|;
comment|// Selects the entry. The selection listener will open the editor.
name|markBaseChanged
argument_list|()
expr_stmt|;
comment|// The database just changed.
operator|new
name|FocusRequester
argument_list|(
name|getEntryEditor
argument_list|(
name|be
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|be
return|;
block|}
catch|catch
parameter_list|(
name|KeyCollisionException
name|ex
parameter_list|)
block|{
name|Util
operator|.
name|pr
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * This method is called from JabRefFrame when the user wants to      * create a new entry.      * @param bibEntry The new entry.      */
DECL|method|insertEntry (BibtexEntry bibEntry)
specifier|public
name|void
name|insertEntry
parameter_list|(
name|BibtexEntry
name|bibEntry
parameter_list|)
block|{
if|if
condition|(
name|bibEntry
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|database
operator|.
name|insertEntry
argument_list|(
name|bibEntry
argument_list|)
expr_stmt|;
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"useOwner"
argument_list|)
condition|)
comment|// Set owner field to default value
name|bibEntry
operator|.
name|setField
argument_list|(
name|BibtexFields
operator|.
name|OWNER
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"defaultOwner"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create an UndoableInsertEntry object.
name|undoManager
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableInsertEntry
argument_list|(
name|database
argument_list|,
name|bibEntry
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Added new"
argument_list|)
operator|+
literal|" '"
operator|+
name|bibEntry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"' "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|int
name|row
init|=
name|mainTable
operator|.
name|findEntry
argument_list|(
name|bibEntry
argument_list|)
decl_stmt|;
name|mainTable
operator|.
name|clearSelection
argument_list|()
expr_stmt|;
name|mainTable
operator|.
name|scrollTo
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
comment|// The database just changed.
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"autoOpenForm"
argument_list|)
condition|)
block|{
name|showEntry
argument_list|(
name|bibEntry
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeyCollisionException
name|ex
parameter_list|)
block|{
name|Util
operator|.
name|pr
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|createMainTable ()
specifier|public
name|void
name|createMainTable
parameter_list|()
block|{
comment|//Comparator comp = new FieldComparator("author");
name|GlazedEntrySorter
name|eventList
init|=
operator|new
name|GlazedEntrySorter
argument_list|(
name|database
operator|.
name|getEntryMap
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// Must initialize sort columns somehow:
name|database
operator|.
name|addDatabaseChangeListener
argument_list|(
name|eventList
argument_list|)
expr_stmt|;
name|groupFilterList
operator|=
operator|new
name|FilterList
argument_list|(
name|eventList
operator|.
name|getTheList
argument_list|()
argument_list|,
name|NoSearchMatcher
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|searchFilterList
operator|=
operator|new
name|FilterList
argument_list|(
name|groupFilterList
argument_list|,
name|NoSearchMatcher
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
comment|//final SortedList sortedList = new SortedList(searchFilterList, null);
name|MainTableFormat
name|tableFormat
init|=
operator|new
name|MainTableFormat
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|tableFormat
operator|.
name|updateTableFormat
argument_list|()
expr_stmt|;
comment|//EventTableModel tableModel = new EventTableModel(sortedList, tableFormat);
name|mainTable
operator|=
operator|new
name|MainTable
argument_list|(
comment|/*tableModel, */
name|tableFormat
argument_list|,
name|searchFilterList
argument_list|,
name|frame
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|selectionListener
operator|=
operator|new
name|MainTableSelectionListener
argument_list|(
name|this
argument_list|,
name|mainTable
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|updateFont
argument_list|()
expr_stmt|;
name|mainTable
operator|.
name|addSelectionListener
argument_list|(
name|selectionListener
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|addMouseListener
argument_list|(
name|selectionListener
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|addKeyListener
argument_list|(
name|selectionListener
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|addFocusListener
argument_list|(
name|selectionListener
argument_list|)
expr_stmt|;
comment|// Add the listener that will take care of highlighting groups as the selection changes:
name|groupsHighlightListener
operator|=
operator|new
name|ListEventListener
argument_list|()
block|{
specifier|public
name|void
name|listChanged
parameter_list|(
name|ListEvent
name|listEvent
parameter_list|)
block|{
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"highlightGroupsMatchingAny"
argument_list|)
condition|)
name|getGroupSelector
argument_list|()
operator|.
name|showMatchingGroups
argument_list|(
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"highlightGroupsMatchingAll"
argument_list|)
condition|)
name|getGroupSelector
argument_list|()
operator|.
name|showMatchingGroups
argument_list|(
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
else|else
comment|// no highlight
name|getGroupSelector
argument_list|()
operator|.
name|showMatchingGroups
argument_list|(
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
expr_stmt|;
name|mainTable
operator|.
name|addSelectionListener
argument_list|(
name|groupsHighlightListener
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|getActionMap
argument_list|()
operator|.
name|put
argument_list|(
literal|"cut"
argument_list|,
operator|new
name|AbstractAction
argument_list|()
block|{
specifier|public
name|void
name|actionPerformed
parameter_list|(
name|ActionEvent
name|e
parameter_list|)
block|{
try|try
block|{
name|runCommand
argument_list|(
literal|"cut"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|getActionMap
argument_list|()
operator|.
name|put
argument_list|(
literal|"copy"
argument_list|,
operator|new
name|AbstractAction
argument_list|()
block|{
specifier|public
name|void
name|actionPerformed
parameter_list|(
name|ActionEvent
name|e
parameter_list|)
block|{
try|try
block|{
name|runCommand
argument_list|(
literal|"copy"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|getActionMap
argument_list|()
operator|.
name|put
argument_list|(
literal|"paste"
argument_list|,
operator|new
name|AbstractAction
argument_list|()
block|{
specifier|public
name|void
name|actionPerformed
parameter_list|(
name|ActionEvent
name|e
parameter_list|)
block|{
try|try
block|{
name|runCommand
argument_list|(
literal|"paste"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|addKeyListener
argument_list|(
operator|new
name|KeyAdapter
argument_list|()
block|{
specifier|public
name|void
name|keyPressed
parameter_list|(
name|KeyEvent
name|e
parameter_list|)
block|{
specifier|final
name|int
name|keyCode
init|=
name|e
operator|.
name|getKeyCode
argument_list|()
decl_stmt|;
specifier|final
name|TreePath
name|path
init|=
name|frame
operator|.
name|groupSelector
operator|.
name|getSelectionPath
argument_list|()
decl_stmt|;
specifier|final
name|GroupTreeNode
name|node
init|=
name|path
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|GroupTreeNode
operator|)
name|path
operator|.
name|getLastPathComponent
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|isControlDown
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|keyCode
condition|)
block|{
comment|// The up/down/left/rightkeystrokes are displayed in the
comment|// GroupSelector's popup menu, so if they are to be changed,
comment|// edit GroupSelector.java accordingly!
case|case
name|KeyEvent
operator|.
name|VK_UP
case|:
name|e
operator|.
name|consume
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
name|frame
operator|.
name|groupSelector
operator|.
name|moveNodeUp
argument_list|(
name|node
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|KeyEvent
operator|.
name|VK_DOWN
case|:
name|e
operator|.
name|consume
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
name|frame
operator|.
name|groupSelector
operator|.
name|moveNodeDown
argument_list|(
name|node
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|KeyEvent
operator|.
name|VK_LEFT
case|:
name|e
operator|.
name|consume
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
name|frame
operator|.
name|groupSelector
operator|.
name|moveNodeLeft
argument_list|(
name|node
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|KeyEvent
operator|.
name|VK_RIGHT
case|:
name|e
operator|.
name|consume
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
name|frame
operator|.
name|groupSelector
operator|.
name|moveNodeRight
argument_list|(
name|node
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|KeyEvent
operator|.
name|VK_PAGE_DOWN
case|:
name|frame
operator|.
name|nextTab
operator|.
name|actionPerformed
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|e
operator|.
name|consume
argument_list|()
expr_stmt|;
break|break;
case|case
name|KeyEvent
operator|.
name|VK_PAGE_UP
case|:
name|frame
operator|.
name|prevTab
operator|.
name|actionPerformed
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|e
operator|.
name|consume
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|keyCode
operator|==
name|KeyEvent
operator|.
name|VK_ENTER
condition|)
block|{
name|e
operator|.
name|consume
argument_list|()
expr_stmt|;
try|try
block|{
name|runCommand
argument_list|(
literal|"edit"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|setupMainPanel ()
specifier|public
name|void
name|setupMainPanel
parameter_list|()
block|{
comment|//System.out.println("setupMainPanel");
comment|//splitPane = new com.jgoodies.uif_lite.component.UIFSplitPane(JSplitPane.VERTICAL_SPLIT);
name|splitPane
operator|=
operator|new
name|JSplitPane
argument_list|(
name|JSplitPane
operator|.
name|VERTICAL_SPLIT
argument_list|)
expr_stmt|;
name|splitPane
operator|.
name|setDividerSize
argument_list|(
name|GUIGlobals
operator|.
name|SPLIT_PANE_DIVIDER_SIZE
argument_list|)
expr_stmt|;
comment|// We replace the default FocusTraversalPolicy with a subclass
comment|// that only allows FieldEditor components to gain keyboard focus,
comment|// if there is an entry editor open.
comment|/*splitPane.setFocusTraversalPolicy(new LayoutFocusTraversalPolicy() {                 protected boolean accept(Component c) {                     Util.pr("jaa");                     if (showing == null)                         return super.accept(c);                     else                         return (super.accept(c)&&                                 (c instanceof FieldEditor));                 }                 });*/
name|createMainTable
argument_list|()
expr_stmt|;
name|splitPane
operator|.
name|setTopComponent
argument_list|(
name|mainTable
operator|.
name|getPane
argument_list|()
argument_list|)
expr_stmt|;
comment|//setupTable();
comment|// If an entry is currently being shown, make sure it stays shown,
comment|// otherwise set the bottom component to null.
if|if
condition|(
name|mode
operator|==
name|SHOWING_PREVIEW
condition|)
block|{
name|mode
operator|=
name|SHOWING_NOTHING
expr_stmt|;
name|int
name|row
init|=
name|mainTable
operator|.
name|findEntry
argument_list|(
name|currentPreview
operator|.
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|row
operator|>=
literal|0
condition|)
name|mainTable
operator|.
name|setRowSelectionInterval
argument_list|(
name|row
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|SHOWING_EDITOR
condition|)
block|{
name|mode
operator|=
name|SHOWING_NOTHING
expr_stmt|;
comment|/*int row = mainTable.findEntry(currentEditor.entry);             if (row>= 0)                 mainTable.setRowSelectionInterval(row, row);             */
comment|//showEntryEditor(currentEditor);
block|}
else|else
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|setLayout
argument_list|(
operator|new
name|BorderLayout
argument_list|()
argument_list|)
expr_stmt|;
name|removeAll
argument_list|()
expr_stmt|;
name|add
argument_list|(
name|splitPane
argument_list|,
name|BorderLayout
operator|.
name|CENTER
argument_list|)
expr_stmt|;
comment|// Set up AutoCompleters for this panel:
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"autoComplete"
argument_list|)
condition|)
block|{
name|instantiateAutoCompleters
argument_list|()
expr_stmt|;
block|}
name|splitPane
operator|.
name|revalidate
argument_list|()
expr_stmt|;
name|revalidate
argument_list|()
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
block|}
DECL|method|getAutoCompleters ()
specifier|public
name|HashMap
name|getAutoCompleters
parameter_list|()
block|{
return|return
name|autoCompleters
return|;
block|}
DECL|method|getAutoCompleter (String fieldName)
specifier|public
name|AutoCompleter
name|getAutoCompleter
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
operator|(
name|AutoCompleter
operator|)
name|autoCompleters
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
DECL|method|instantiateAutoCompleters ()
specifier|private
name|void
name|instantiateAutoCompleters
parameter_list|()
block|{
name|autoCompleters
operator|.
name|clear
argument_list|()
expr_stmt|;
name|String
index|[]
name|completeFields
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getStringArray
argument_list|(
literal|"autoCompleteFields"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|completeFields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|field
init|=
name|completeFields
index|[
name|i
index|]
decl_stmt|;
name|autoCompleters
operator|.
name|put
argument_list|(
name|field
argument_list|,
operator|new
name|AutoCompleter
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|database
operator|.
name|getKeySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BibtexEntry
name|entry
init|=
name|database
operator|.
name|getEntryById
argument_list|(
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|Util
operator|.
name|updateCompletersForEntry
argument_list|(
name|autoCompleters
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This method is called after a database has been parsed. The      * hashmap contains the contents of all comments in the .bib file      * that started with the meta flag (GUIGlobals.META_FLAG).      * In this method, the meta data are input to their respective      * handlers.      *      * @param meta Metadata to input.      */
DECL|method|parseMetaData (HashMap meta)
specifier|public
name|void
name|parseMetaData
parameter_list|(
name|HashMap
name|meta
parameter_list|)
block|{
name|metaData
operator|=
operator|new
name|MetaData
argument_list|(
name|meta
argument_list|,
name|database
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/*     public void refreshTable() {         //System.out.println("hiding="+hidingNonHits+"\tlastHits="+lastSearchHits);         // This method is called by EntryTypeForm when a field value is         // stored. The table is scheduled for repaint.         entryTable.assureNotEditing();         //entryTable.invalidate();         BibtexEntry[] bes = entryTable.getSelectedEntries();     if (hidingNonHits)         tableModel.update(lastSearchHits);     else         tableModel.update();     //tableModel.remap();         if ((bes != null)&& (bes.length> 0))             selectEntries(bes, 0);      //long toc = System.currentTimeMillis();     //	Util.pr("Refresh took: "+(toc-tic)+" ms");     } */
DECL|method|updatePreamble ()
specifier|public
name|void
name|updatePreamble
parameter_list|()
block|{
if|if
condition|(
name|preambleEditor
operator|!=
literal|null
condition|)
name|preambleEditor
operator|.
name|updatePreamble
argument_list|()
expr_stmt|;
block|}
DECL|method|assureStringDialogNotEditing ()
specifier|public
name|void
name|assureStringDialogNotEditing
parameter_list|()
block|{
if|if
condition|(
name|stringDialog
operator|!=
literal|null
condition|)
name|stringDialog
operator|.
name|assureNotEditing
argument_list|()
expr_stmt|;
block|}
DECL|method|updateStringDialog ()
specifier|public
name|void
name|updateStringDialog
parameter_list|()
block|{
if|if
condition|(
name|stringDialog
operator|!=
literal|null
condition|)
name|stringDialog
operator|.
name|refreshTable
argument_list|()
expr_stmt|;
block|}
DECL|method|updateEntryPreviewToRow (BibtexEntry e)
specifier|public
name|void
name|updateEntryPreviewToRow
parameter_list|(
name|BibtexEntry
name|e
parameter_list|)
block|{      }
DECL|method|adjustSplitter ()
specifier|public
name|void
name|adjustSplitter
parameter_list|()
block|{
name|int
name|mode
init|=
name|getMode
argument_list|()
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|SHOWING_PREVIEW
condition|)
block|{
name|splitPane
operator|.
name|setDividerLocation
argument_list|(
name|splitPane
operator|.
name|getHeight
argument_list|()
operator|-
name|GUIGlobals
operator|.
name|PREVIEW_PANEL_HEIGHT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|splitPane
operator|.
name|setDividerLocation
argument_list|(
name|GUIGlobals
operator|.
name|VERTICAL_DIVIDER_LOCATION
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Stores the source view in the entry editor, if one is open, has the source view      * selected and the source has been edited.      * @return boolean false if there is a validation error in the source panel, true otherwise.      */
DECL|method|entryEditorAllowsChange ()
specifier|public
name|boolean
name|entryEditorAllowsChange
parameter_list|()
block|{
name|Component
name|c
init|=
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|c
operator|instanceof
name|EntryEditor
operator|)
condition|)
block|{
return|return
operator|(
operator|(
name|EntryEditor
operator|)
name|c
operator|)
operator|.
name|lastSourceAccepted
argument_list|()
return|;
block|}
else|else
return|return
literal|true
return|;
block|}
DECL|method|moveFocusToEntryEditor ()
specifier|public
name|void
name|moveFocusToEntryEditor
parameter_list|()
block|{
name|Component
name|c
init|=
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|c
operator|instanceof
name|EntryEditor
operator|)
condition|)
block|{
operator|new
name|FocusRequester
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Ensure that no preview is shown. Called when preview is turned off. Must chech if      * a preview is in fact visible before doing anything rash.      */
DECL|method|hidePreview ()
specifier|public
name|void
name|hidePreview
parameter_list|()
block|{
name|Globals
operator|.
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"previewEnabled"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Component
name|c
init|=
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|!=
literal|null
operator|)
operator|&&
operator|!
operator|(
name|c
operator|instanceof
name|EntryEditor
operator|)
condition|)
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|isShowingEditor ()
specifier|public
name|boolean
name|isShowingEditor
parameter_list|()
block|{
return|return
operator|(
operator|(
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|instanceof
name|EntryEditor
operator|)
operator|)
return|;
block|}
DECL|method|showEntry (final BibtexEntry be)
specifier|public
name|void
name|showEntry
parameter_list|(
specifier|final
name|BibtexEntry
name|be
parameter_list|)
block|{
if|if
condition|(
name|showing
operator|==
name|be
condition|)
block|{
if|if
condition|(
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// This is the special occasion when showing is set to an
comment|// entry, but no entry editor is in fact shown. This happens
comment|// after Preferences dialog is closed, and it means that we
comment|// must make sure the same entry is shown again. We do this by
comment|// setting showing to null, and recursively calling this method.
name|showing
operator|=
literal|null
expr_stmt|;
name|showEntry
argument_list|(
name|be
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The correct entry is already being shown. Make sure the editor
comment|// is updated.
operator|(
operator|(
name|EntryEditor
operator|)
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|)
operator|.
name|updateAllFields
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
name|EntryEditor
name|form
decl_stmt|;
name|int
name|divLoc
init|=
operator|-
literal|1
decl_stmt|;
name|String
name|visName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|showing
operator|!=
literal|null
condition|)
block|{
name|visName
operator|=
operator|(
operator|(
name|EntryEditor
operator|)
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|)
operator|.
name|getVisiblePanelName
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|showing
operator|!=
literal|null
condition|)
name|divLoc
operator|=
name|splitPane
operator|.
name|getDividerLocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|entryEditors
operator|.
name|containsKey
argument_list|(
name|be
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
comment|// We already have an editor for this entry type.
name|form
operator|=
operator|(
name|EntryEditor
operator|)
name|entryEditors
operator|.
name|get
argument_list|(
operator|(
name|be
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|form
operator|.
name|switchTo
argument_list|(
name|be
argument_list|)
expr_stmt|;
if|if
condition|(
name|visName
operator|!=
literal|null
condition|)
name|form
operator|.
name|setVisiblePanel
argument_list|(
name|visName
argument_list|)
expr_stmt|;
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
name|form
argument_list|)
expr_stmt|;
comment|//highlightEntry(be);
block|}
else|else
block|{
comment|// We must instantiate a new editor for this type.
name|form
operator|=
operator|new
name|EntryEditor
argument_list|(
name|frame
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|,
name|be
argument_list|)
expr_stmt|;
if|if
condition|(
name|visName
operator|!=
literal|null
condition|)
name|form
operator|.
name|setVisiblePanel
argument_list|(
name|visName
argument_list|)
expr_stmt|;
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
name|form
argument_list|)
expr_stmt|;
comment|//highlightEntry(be);
name|entryEditors
operator|.
name|put
argument_list|(
name|be
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|form
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|divLoc
operator|>
literal|0
condition|)
block|{
name|splitPane
operator|.
name|setDividerLocation
argument_list|(
name|divLoc
argument_list|)
expr_stmt|;
block|}
else|else
name|splitPane
operator|.
name|setDividerLocation
argument_list|(
name|GUIGlobals
operator|.
name|VERTICAL_DIVIDER_LOCATION
argument_list|)
expr_stmt|;
comment|//new FocusRequester(form);
comment|//form.requestFocus();
name|showing
operator|=
name|be
expr_stmt|;
name|setEntryEditorEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Make sure it is enabled.
block|}
comment|/**      * Get an entry editor ready to edit the given entry. If an appropriate editor is already      * cached, it will be updated and returned.      * @param entry The entry to be edited.      * @return A suitable entry editor.      */
DECL|method|getEntryEditor (BibtexEntry entry)
specifier|public
name|EntryEditor
name|getEntryEditor
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|)
block|{
name|EntryEditor
name|form
decl_stmt|;
if|if
condition|(
name|entryEditors
operator|.
name|containsKey
argument_list|(
name|entry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|EntryEditor
name|visibleNow
init|=
name|currentEditor
decl_stmt|;
comment|// We already have an editor for this entry type.
name|form
operator|=
operator|(
name|EntryEditor
operator|)
name|entryEditors
operator|.
name|get
argument_list|(
operator|(
name|entry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|form
operator|.
name|switchTo
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|//if (visName != null)
comment|//    form.setVisiblePanel(visName);
block|}
else|else
block|{
comment|// We must instantiate a new editor for this type.
name|form
operator|=
operator|new
name|EntryEditor
argument_list|(
name|frame
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|//if (visName != null)
comment|//    form.setVisiblePanel(visName);
name|entryEditors
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|form
argument_list|)
expr_stmt|;
block|}
return|return
name|form
return|;
block|}
DECL|method|getCurrentEditor ()
specifier|public
name|EntryEditor
name|getCurrentEditor
parameter_list|()
block|{
return|return
name|currentEditor
return|;
block|}
comment|/**      * Sets the given entry editor as the bottom component in the split pane. If an entry editor already      * was shown, makes sure that the divider doesn't move.      * Updates the mode to SHOWING_EDITOR.      * @param editor The entry editor to add.      */
DECL|method|showEntryEditor (EntryEditor editor)
specifier|public
name|void
name|showEntryEditor
parameter_list|(
name|EntryEditor
name|editor
parameter_list|)
block|{
name|int
name|oldSplitterLocation
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|SHOWING_EDITOR
condition|)
name|oldSplitterLocation
operator|=
name|splitPane
operator|.
name|getDividerLocation
argument_list|()
expr_stmt|;
name|boolean
name|adjustSplitter
init|=
operator|(
name|mode
operator|==
name|WILL_SHOW_EDITOR
operator|)
decl_stmt|;
name|mode
operator|=
name|SHOWING_EDITOR
expr_stmt|;
name|currentEditor
operator|=
name|editor
expr_stmt|;
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
name|editor
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldSplitterLocation
operator|>
literal|0
condition|)
name|splitPane
operator|.
name|setDividerLocation
argument_list|(
name|oldSplitterLocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjustSplitter
condition|)
block|{
name|adjustSplitter
argument_list|()
expr_stmt|;
comment|//new FocusRequester(editor);
block|}
block|}
comment|/**      * Sets the given preview panel as the bottom component in the split panel.      * Updates the mode to SHOWING_PREVIEW.      * @param preview The preview to show.      */
DECL|method|showPreview (PreviewPanel preview)
specifier|public
name|void
name|showPreview
parameter_list|(
name|PreviewPanel
name|preview
parameter_list|)
block|{
name|mode
operator|=
name|SHOWING_PREVIEW
expr_stmt|;
name|currentPreview
operator|=
name|preview
expr_stmt|;
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
name|preview
operator|.
name|getPane
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes the bottom component.      */
DECL|method|hideBottomComponent ()
specifier|public
name|void
name|hideBottomComponent
parameter_list|()
block|{
name|mode
operator|=
name|SHOWING_NOTHING
expr_stmt|;
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method selects the given entry, and scrolls it into view in the table.      * If an entryEditor is shown, it is given focus afterwards.      */
DECL|method|highlightEntry (final BibtexEntry be)
specifier|public
name|void
name|highlightEntry
parameter_list|(
specifier|final
name|BibtexEntry
name|be
parameter_list|)
block|{
comment|//SwingUtilities.invokeLater(new Thread() {
comment|//     public void run() {
specifier|final
name|int
name|row
init|=
name|mainTable
operator|.
name|findEntry
argument_list|(
name|be
argument_list|)
decl_stmt|;
if|if
condition|(
name|row
operator|>=
literal|0
condition|)
block|{
name|mainTable
operator|.
name|setRowSelectionInterval
argument_list|(
name|row
argument_list|,
name|row
argument_list|)
expr_stmt|;
comment|//entryTable.setActiveRow(row);
name|mainTable
operator|.
name|ensureVisible
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
comment|//     }
comment|//});
block|}
comment|/**      * This method is called from an EntryEditor when it should be closed. We relay      * to the selection listener, which takes care of the rest.      * @param editor The entry editor to close.      */
DECL|method|entryEditorClosing (EntryEditor editor)
specifier|public
name|void
name|entryEditorClosing
parameter_list|(
name|EntryEditor
name|editor
parameter_list|)
block|{
name|selectionListener
operator|.
name|entryEditorClosing
argument_list|(
name|editor
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method selects the given enties.      * If an entryEditor is shown, it is given focus afterwards.      */
comment|/*public void selectEntries(final BibtexEntry[] bes, final int toScrollTo) {          SwingUtilities.invokeLater(new Thread() {              public void run() {                  int rowToScrollTo = 0;                  entryTable.revalidate();                  entryTable.clearSelection();                  loop: for (int i=0; i<bes.length; i++) {                     if (bes[i] == null)                         continue loop;                     int row = tableModel.getNumberFromName(bes[i].getId());                     if (i==toScrollTo)                     rowToScrollTo = row;                     if (row>= 0)                         entryTable.addRowSelectionIntervalQuietly(row, row);                  }                  entryTable.ensureVisible(rowToScrollTo);                  Component comp = splitPane.getBottomComponent();                  //if (comp instanceof EntryEditor)                  //    comp.requestFocus();              }         });     } */
comment|/**      * Closes the entry editor if it is showing the given entry.      *      * @param be a<code>BibtexEntry</code> value      */
DECL|method|ensureNotShowing (BibtexEntry be)
specifier|public
name|void
name|ensureNotShowing
parameter_list|(
name|BibtexEntry
name|be
parameter_list|)
block|{
if|if
condition|(
operator|(
name|mode
operator|==
name|SHOWING_EDITOR
operator|)
operator|&&
operator|(
name|currentEditor
operator|.
name|getEntry
argument_list|()
operator|==
name|be
operator|)
condition|)
block|{
name|selectionListener
operator|.
name|entryEditorClosing
argument_list|(
name|currentEditor
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateEntryEditorIfShowing ()
specifier|public
name|void
name|updateEntryEditorIfShowing
parameter_list|()
block|{
if|if
condition|(
name|mode
operator|==
name|SHOWING_EDITOR
condition|)
block|{
if|if
condition|(
name|currentEditor
operator|.
name|getType
argument_list|()
operator|!=
name|currentEditor
operator|.
name|getEntry
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
comment|// The entry has changed type, so we must get a new editor.
name|showing
operator|=
literal|null
expr_stmt|;
name|EntryEditor
name|newEditor
init|=
name|getEntryEditor
argument_list|(
name|currentEditor
operator|.
name|getEntry
argument_list|()
argument_list|)
decl_stmt|;
name|showEntryEditor
argument_list|(
name|newEditor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|currentEditor
operator|.
name|updateAllFields
argument_list|()
expr_stmt|;
name|currentEditor
operator|.
name|updateSource
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * If an entry editor is showing, make sure its currently focused field      * stores its changes, if any.      */
DECL|method|storeCurrentEdit ()
specifier|public
name|void
name|storeCurrentEdit
parameter_list|()
block|{
if|if
condition|(
name|isShowingEditor
argument_list|()
condition|)
block|{
name|EntryEditor
name|editor
init|=
operator|(
name|EntryEditor
operator|)
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
decl_stmt|;
name|editor
operator|.
name|storeCurrentEdit
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * This method iterates through all existing entry editors in this      * BasePanel, telling each to update all its instances of      * FieldContentSelector. This is done to ensure that the list of words      * in each selector is up-to-date after the user has made changes in      * the Manage dialog.      */
DECL|method|updateAllContentSelectors ()
specifier|public
name|void
name|updateAllContentSelectors
parameter_list|()
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|entryEditors
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|EntryEditor
name|ed
init|=
operator|(
name|EntryEditor
operator|)
name|entryEditors
operator|.
name|get
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|ed
operator|.
name|updateAllContentSelectors
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|rebuildAllEntryEditors ()
specifier|public
name|void
name|rebuildAllEntryEditors
parameter_list|()
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|entryEditors
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|EntryEditor
name|ed
init|=
operator|(
name|EntryEditor
operator|)
name|entryEditors
operator|.
name|get
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|ed
operator|.
name|rebuildPanels
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|markBaseChanged ()
specifier|public
name|void
name|markBaseChanged
parameter_list|()
block|{
name|baseChanged
operator|=
literal|true
expr_stmt|;
comment|// Put an asterix behind the file name to indicate the
comment|// database has changed.
name|String
name|oldTitle
init|=
name|frame
operator|.
name|getTabTitle
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|oldTitle
operator|.
name|endsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
name|frame
operator|.
name|setTabTitle
argument_list|(
name|this
argument_list|,
name|oldTitle
operator|+
literal|"*"
argument_list|,
name|frame
operator|.
name|getTabTooltip
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
comment|// If the status line states that the base has been saved, we
comment|// remove this message, since it is no longer relevant. If a
comment|// different message is shown, we leave it.
if|if
condition|(
name|frame
operator|.
name|statusLine
operator|.
name|getText
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"Saved database"
argument_list|)
condition|)
name|frame
operator|.
name|output
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
DECL|method|markNonUndoableBaseChanged ()
specifier|public
name|void
name|markNonUndoableBaseChanged
parameter_list|()
block|{
name|nonUndoableChange
operator|=
literal|true
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
block|}
DECL|method|markChangedOrUnChanged ()
specifier|public
specifier|synchronized
name|void
name|markChangedOrUnChanged
parameter_list|()
block|{
if|if
condition|(
name|undoManager
operator|.
name|hasChanged
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|baseChanged
condition|)
name|markBaseChanged
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseChanged
operator|&&
operator|!
name|nonUndoableChange
condition|)
block|{
name|baseChanged
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|getFile
argument_list|()
operator|!=
literal|null
condition|)
name|frame
operator|.
name|setTabTitle
argument_list|(
name|BasePanel
operator|.
name|this
argument_list|,
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|getFile
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|frame
operator|.
name|setTabTitle
argument_list|(
name|BasePanel
operator|.
name|this
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"untitled"
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Selects a single entry, and scrolls the table to center it.      *      * @param pos Current position of entry to select.      *      */
DECL|method|selectSingleEntry (int pos)
specifier|public
name|void
name|selectSingleEntry
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|mainTable
operator|.
name|clearSelection
argument_list|()
expr_stmt|;
name|mainTable
operator|.
name|addRowSelectionInterval
argument_list|(
name|pos
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|scrollToCenter
argument_list|(
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* *      * Selects all entries with a non-zero value in the field      * @param field<code>String</code> field name.      */
comment|/*    public void selectResults(String field) {       LinkedList intervals = new LinkedList();       int prevStart = -1, prevToSel = 0;       // First we build a list of intervals to select, without touching the table.       for (int i = 0; i< entryTable.getRowCount(); i++) {         String value = (String) (database.getEntryById                                  (tableModel.getIdForRow(i)))             .getField(field);         if ( (value != null)&& !value.equals("0")) {           if (prevStart< 0)             prevStart = i;           prevToSel = i;         }         else if (prevStart>= 0) {           intervals.add(new int[] {prevStart, prevToSel});           prevStart = -1;         }       }       // Then select those intervals, if any.       if (intervals.size()> 0) {         entryTable.setSelectionListenerEnabled(false);         entryTable.clearSelection();         for (Iterator i=intervals.iterator(); i.hasNext();) {           int[] interval = (int[])i.next();           entryTable.addRowSelectionInterval(interval[0], interval[1]);         }         entryTable.setSelectionListenerEnabled(true);       }   */
DECL|method|setSearchMatcher (SearchMatcher matcher)
specifier|public
name|void
name|setSearchMatcher
parameter_list|(
name|SearchMatcher
name|matcher
parameter_list|)
block|{
name|searchFilterList
operator|.
name|setMatcher
argument_list|(
name|matcher
argument_list|)
expr_stmt|;
block|}
DECL|method|setGroupMatcher (Matcher matcher)
specifier|public
name|void
name|setGroupMatcher
parameter_list|(
name|Matcher
name|matcher
parameter_list|)
block|{
name|groupFilterList
operator|.
name|setMatcher
argument_list|(
name|matcher
argument_list|)
expr_stmt|;
block|}
DECL|method|stopShowingSearchResults ()
specifier|public
name|void
name|stopShowingSearchResults
parameter_list|()
block|{
name|searchFilterList
operator|.
name|setMatcher
argument_list|(
name|NoSearchMatcher
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
DECL|method|stopShowingGroup ()
specifier|public
name|void
name|stopShowingGroup
parameter_list|()
block|{
name|groupFilterList
operator|.
name|setMatcher
argument_list|(
name|NoSearchMatcher
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
DECL|method|getDatabase ()
specifier|public
name|BibtexDatabase
name|getDatabase
parameter_list|()
block|{
return|return
name|database
return|;
block|}
DECL|method|preambleEditorClosing ()
specifier|public
name|void
name|preambleEditorClosing
parameter_list|()
block|{
name|preambleEditor
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|stringsClosing ()
specifier|public
name|void
name|stringsClosing
parameter_list|()
block|{
name|stringDialog
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|changeType (BibtexEntry entry, BibtexEntryType type)
specifier|public
name|void
name|changeType
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexEntryType
name|type
parameter_list|)
block|{
name|changeType
argument_list|(
operator|new
name|BibtexEntry
index|[]
block|{
name|entry
block|}
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
DECL|method|changeType (BibtexEntryType type)
specifier|public
name|void
name|changeType
parameter_list|(
name|BibtexEntryType
name|type
parameter_list|)
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
name|changeType
argument_list|(
name|bes
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
DECL|method|changeType (BibtexEntry[] bes, BibtexEntryType type)
specifier|public
name|void
name|changeType
parameter_list|(
name|BibtexEntry
index|[]
name|bes
parameter_list|,
name|BibtexEntryType
name|type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|bes
operator|==
literal|null
operator|)
operator|||
operator|(
name|bes
operator|.
name|length
operator|==
literal|0
operator|)
condition|)
block|{
name|output
argument_list|(
literal|"First select the entries you wish to change type "
operator|+
literal|"for."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|int
name|choice
init|=
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|this
argument_list|,
literal|"Multiple entries selected. Do you want to change"
operator|+
literal|"\nthe type of all these to '"
operator|+
name|type
operator|.
name|getName
argument_list|()
operator|+
literal|"'?"
argument_list|,
literal|"Change type"
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_OPTION
argument_list|,
name|JOptionPane
operator|.
name|WARNING_MESSAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|choice
operator|==
name|JOptionPane
operator|.
name|NO_OPTION
condition|)
return|return;
block|}
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"change type"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableChangeType
argument_list|(
name|bes
index|[
name|i
index|]
argument_list|,
name|bes
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|bes
index|[
name|i
index|]
operator|.
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Changed type to"
argument_list|)
operator|+
literal|" '"
operator|+
name|type
operator|.
name|getName
argument_list|()
operator|+
literal|"' "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"for"
argument_list|)
operator|+
literal|" "
operator|+
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|updateEntryEditorIfShowing
argument_list|()
expr_stmt|;
block|}
DECL|method|showDeleteConfirmationDialog (int numberOfEntries)
specifier|public
name|boolean
name|showDeleteConfirmationDialog
parameter_list|(
name|int
name|numberOfEntries
parameter_list|)
block|{
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"confirmDelete"
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Really delete the selected"
argument_list|)
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|+
literal|"?"
decl_stmt|,
name|title
init|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Delete entry"
argument_list|)
decl_stmt|;
if|if
condition|(
name|numberOfEntries
operator|>
literal|1
condition|)
block|{
name|msg
operator|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Really delete the selected"
argument_list|)
operator|+
literal|" "
operator|+
name|numberOfEntries
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
operator|+
literal|"?"
expr_stmt|;
name|title
operator|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Delete multiple entries"
argument_list|)
expr_stmt|;
block|}
name|CheckBoxMessage
name|cb
init|=
operator|new
name|CheckBoxMessage
argument_list|(
name|msg
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Disable this confirmation dialog"
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|answer
init|=
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|frame
argument_list|,
name|cb
argument_list|,
name|title
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_OPTION
argument_list|,
name|JOptionPane
operator|.
name|QUESTION_MESSAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|cb
operator|.
name|isSelected
argument_list|()
condition|)
name|Globals
operator|.
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"confirmDelete"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|answer
operator|==
name|JOptionPane
operator|.
name|YES_OPTION
operator|)
return|;
block|}
else|else
return|return
literal|true
return|;
block|}
comment|/**      * If the relevant option is set, autogenerate keys for all entries that are      * lacking keys.      */
DECL|method|autoGenerateKeysBeforeSaving ()
specifier|public
name|void
name|autoGenerateKeysBeforeSaving
parameter_list|()
block|{
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"generateKeysBeforeSaving"
argument_list|)
condition|)
block|{
name|BibtexEntry
name|bes
decl_stmt|;
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"autogenerate keys"
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|any
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|database
operator|.
name|getKeySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|bes
operator|=
name|database
operator|.
name|getEntryById
argument_list|(
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|oldKey
init|=
name|bes
operator|.
name|getCiteKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|oldKey
operator|==
literal|null
operator|)
operator|||
operator|(
name|oldKey
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|)
condition|)
block|{
name|LabelPatternUtil
operator|.
name|makeLabel
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|getKeyPattern
argument_list|()
argument_list|,
name|database
argument_list|,
name|bes
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableKeyChange
argument_list|(
name|database
argument_list|,
name|bes
operator|.
name|getId
argument_list|()
argument_list|,
literal|null
argument_list|,
operator|(
name|String
operator|)
name|bes
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|any
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Store undo information, if any:
if|if
condition|(
name|any
condition|)
block|{
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Activates or deactivates the entry preview, depending on the argument.      * When deactivating, makes sure that any visible preview is hidden.      * @param enabled      */
DECL|method|setPreviewActive (boolean enabled)
specifier|public
name|void
name|setPreviewActive
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
name|selectionListener
operator|.
name|setPreviewActive
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
block|}
DECL|class|UndoAction
class|class
name|UndoAction
extends|extends
name|BaseAction
block|{
DECL|method|action ()
specifier|public
name|void
name|action
parameter_list|()
block|{
try|try
block|{
name|String
name|name
init|=
name|undoManager
operator|.
name|getUndoPresentationName
argument_list|()
decl_stmt|;
name|undoManager
operator|.
name|undo
argument_list|()
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|frame
operator|.
name|output
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CannotUndoException
name|ex
parameter_list|)
block|{
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Nothing to undo"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
comment|// After everything, enable/disable the undo/redo actions
comment|// appropriately.
comment|//updateUndoState();
comment|//redoAction.updateRedoState();
name|markChangedOrUnChanged
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|RedoAction
class|class
name|RedoAction
extends|extends
name|BaseAction
block|{
DECL|method|action ()
specifier|public
name|void
name|action
parameter_list|()
block|{
try|try
block|{
name|String
name|name
init|=
name|undoManager
operator|.
name|getRedoPresentationName
argument_list|()
decl_stmt|;
name|undoManager
operator|.
name|redo
argument_list|()
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|frame
operator|.
name|output
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CannotRedoException
name|ex
parameter_list|)
block|{
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Nothing to redo"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
comment|// After everything, enable/disable the undo/redo actions
comment|// appropriately.
comment|//updateRedoState();
comment|//undoAction.updateUndoState();
name|markChangedOrUnChanged
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Method pertaining to the ClipboardOwner interface.
DECL|method|lostOwnership (Clipboard clipboard, Transferable contents)
specifier|public
name|void
name|lostOwnership
parameter_list|(
name|Clipboard
name|clipboard
parameter_list|,
name|Transferable
name|contents
parameter_list|)
block|{}
DECL|method|setEntryEditorEnabled (boolean enabled)
specifier|public
name|void
name|setEntryEditorEnabled
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
if|if
condition|(
operator|(
name|showing
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|instanceof
name|EntryEditor
operator|)
condition|)
block|{
name|EntryEditor
name|ed
init|=
operator|(
name|EntryEditor
operator|)
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
decl_stmt|;
if|if
condition|(
name|ed
operator|.
name|isEnabled
argument_list|()
operator|!=
name|enabled
condition|)
name|ed
operator|.
name|setEnabled
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|fileMonitorHandle ()
specifier|public
name|String
name|fileMonitorHandle
parameter_list|()
block|{
return|return
name|fileMonitorHandle
return|;
block|}
DECL|method|fileUpdated ()
specifier|public
name|void
name|fileUpdated
parameter_list|()
block|{
if|if
condition|(
name|saving
condition|)
return|return;
comment|// We are just saving the file, so this message is most likely due
comment|// to bad timing. If not, we'll handle it on the next polling.
comment|//Util.pr("File '"+file.getPath()+"' has been modified.");
name|updatedExternally
operator|=
literal|true
expr_stmt|;
specifier|final
name|ChangeScanner
name|scanner
init|=
operator|new
name|ChangeScanner
argument_list|(
name|frame
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
decl_stmt|;
comment|// Adding the sidepane component is Swing work, so we must do this in the Swing
comment|// thread:
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// Check if there is already a notification about external
comment|// changes:
name|boolean
name|hasAlready
init|=
name|sidePaneManager
operator|.
name|hasComponent
argument_list|(
name|FileUpdatePanel
operator|.
name|NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|hasAlready
condition|)
block|{
name|sidePaneManager
operator|.
name|hideComponent
argument_list|(
name|FileUpdatePanel
operator|.
name|NAME
argument_list|)
expr_stmt|;
name|sidePaneManager
operator|.
name|unregisterComponent
argument_list|(
name|FileUpdatePanel
operator|.
name|NAME
argument_list|)
expr_stmt|;
block|}
name|FileUpdatePanel
name|pan
init|=
operator|new
name|FileUpdatePanel
argument_list|(
name|frame
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|,
name|sidePaneManager
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|scanner
argument_list|)
decl_stmt|;
name|sidePaneManager
operator|.
name|register
argument_list|(
name|FileUpdatePanel
operator|.
name|NAME
argument_list|,
name|pan
argument_list|)
expr_stmt|;
name|sidePaneManager
operator|.
name|show
argument_list|(
name|FileUpdatePanel
operator|.
name|NAME
argument_list|)
expr_stmt|;
name|setUpdatedExternally
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|//scanner.displayResult();
block|}
block|}
decl_stmt|;
comment|// Test: running scan automatically in background
name|scanner
operator|.
name|changeScan
argument_list|(
name|BasePanel
operator|.
name|this
operator|.
name|getFile
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|scanner
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|scanner
operator|.
name|changesFound
argument_list|()
condition|)
block|{
name|SwingUtilities
operator|.
name|invokeLater
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setUpdatedExternally
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|//System.out.println("No changes found.");
block|}
block|}
DECL|method|fileRemoved ()
specifier|public
name|void
name|fileRemoved
parameter_list|()
block|{
name|Util
operator|.
name|pr
argument_list|(
literal|"File '"
operator|+
name|getFile
argument_list|()
operator|.
name|getPath
argument_list|()
operator|+
literal|"' has been deleted."
argument_list|)
expr_stmt|;
block|}
DECL|method|cleanUp ()
specifier|public
name|void
name|cleanUp
parameter_list|()
block|{
if|if
condition|(
name|fileMonitorHandle
operator|!=
literal|null
condition|)
name|Globals
operator|.
name|fileUpdateMonitor
operator|.
name|removeUpdateListener
argument_list|(
name|fileMonitorHandle
argument_list|)
expr_stmt|;
block|}
DECL|method|setUpdatedExternally (boolean b)
specifier|public
name|void
name|setUpdatedExternally
parameter_list|(
name|boolean
name|b
parameter_list|)
block|{
name|updatedExternally
operator|=
name|b
expr_stmt|;
block|}
comment|/**      * Get an array containing the currently selected entries.      *      * @return An array containing the selected entries.      */
DECL|method|getSelectedEntries ()
specifier|public
name|BibtexEntry
index|[]
name|getSelectedEntries
parameter_list|()
block|{
return|return
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
return|;
block|}
comment|/**      * Get the file where this database was last saved to or loaded from, if any.      *      * @return The relevant File, or null if none is defined.      */
DECL|method|getFile ()
specifier|public
name|File
name|getFile
parameter_list|()
block|{
return|return
name|metaData
operator|.
name|getFile
argument_list|()
return|;
block|}
comment|/**      * Get a String containing a comma-separated list of the bibtex keys      * of the selected entries.      *      * @return A comma-separated list of the keys of the selected entries.      */
DECL|method|getKeysForSelection ()
specifier|public
name|String
name|getKeysForSelection
parameter_list|()
block|{
name|List
name|entries
init|=
name|mainTable
operator|.
name|getSelected
argument_list|()
decl_stmt|;
name|StringBuffer
name|result
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|String
name|citeKey
init|=
literal|""
decl_stmt|;
comment|//, message = "";
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|entries
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BibtexEntry
name|bes
init|=
operator|(
name|BibtexEntry
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|citeKey
operator|=
operator|(
name|String
operator|)
name|bes
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
expr_stmt|;
comment|// if the key is empty we give a warning and ignore this entry
if|if
condition|(
name|citeKey
operator|==
literal|null
operator|||
name|citeKey
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|first
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|citeKey
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|append
argument_list|(
literal|","
argument_list|)
operator|.
name|append
argument_list|(
name|citeKey
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|getGroupSelector ()
specifier|public
name|GroupSelector
name|getGroupSelector
parameter_list|()
block|{
return|return
name|frame
operator|.
name|groupSelector
return|;
block|}
block|}
end_class

end_unit

