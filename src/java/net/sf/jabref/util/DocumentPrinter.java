begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|net.sf.jabref.util
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Graphics
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Graphics2D
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Rectangle
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Shape
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|print
operator|.
name|PageFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|print
operator|.
name|Printable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|print
operator|.
name|PrinterException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|print
operator|.
name|PrinterJob
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JEditorPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|text
operator|.
name|View
import|;
end_import

begin_comment
comment|/**  * DocumentPrinter prints objects of type Document. Text attributes, including  * fonts, color, and small icons, will be rendered to a printed page.  * DocumentPrinter computes line breaks, paginates, and performs other  * formatting.  *   * An HTMLDocument is printed by sending it as an argument to the  * print(HTMLDocument) method. A PlainDocument is printed the same way. Other  * types of documents must be sent in a JEditorPane as an argument to the  * print(JEditorPane) method. Printing Documents in this way will automatically  * display a print dialog.  *   * As objects which implement the Printable Interface, instances of the  * DocumentPrinter class can also be used as the argument in the setPrintable  * method of the PrinterJob class. Instead of using the print() methods detailed  * above, a programmer may gain access to the formatting capabilities of this  * class without using its print dialog by creating an instance of  * DocumentPrinter and setting the document to be printed with the setDocument()  * or setJEditorPane(). The Document may then be printed by setting the instance  * of DocumentPrinter in any PrinterJob.  *   * This class is based on "How to print HTML from a jEditorPane - faq269-5935"  *   * http://www.tek-tips.com/faqs.cfm?fid=5935  *   * and was originally called DocumentPrinter.  *   * Copyright 2002 Kei G. Gauthier Suite 301 77 Winsor Street Ludlow, MA 01056  *   * Originally attributed by Kei to  *   * http://www.fawcette.com/javapro/2002_12/online/print_kgauthier_12_10_02/default_pf.aspx  *   * @author Christopher Oezbek  *   * I stripped the class of all the boilerplate I could find (protected and  * such).  *   */
end_comment

begin_class
DECL|class|DocumentPrinter
specifier|public
class|class
name|DocumentPrinter
block|{
comment|/** 	 * Note that pFormat is not the variable name used by the print method of 	 * the DocumentPrintable. Although it would always be expected to reference 	 * the pFormat object, the print method gets its PageFormat as an argument. 	 */
DECL|field|pFormat
name|PageFormat
name|pFormat
decl_stmt|;
comment|/** 	 * Global job used by this DocumentPrinter. Initialized upon calling the 	 * constructor. 	 */
DECL|field|pJob
name|PrinterJob
name|pJob
decl_stmt|;
comment|/** 	 * The constructor initializes the pFormat and PJob variables. 	 *  	 * Caution calling PrinterJob.getPrinterJob() is done here which is 	 * resource-intensive. 	 */
DECL|method|DocumentPrinter ()
specifier|public
name|DocumentPrinter
parameter_list|()
block|{
name|pFormat
operator|=
operator|new
name|PageFormat
argument_list|()
expr_stmt|;
name|pJob
operator|=
name|PrinterJob
operator|.
name|getPrinterJob
argument_list|()
expr_stmt|;
block|}
comment|/** 	 * pageDialog() displays a page setup dialog. Typically this is called by 	 * "File -> Print Setup" 	 */
DECL|method|pageDialog ()
specifier|public
name|void
name|pageDialog
parameter_list|()
block|{
name|pFormat
operator|=
name|pJob
operator|.
name|pageDialog
argument_list|(
name|pFormat
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * print(JEditorPane) prints a Document contained within a JEditorPane if 	 * the user confirms it using the printer dialog shown upon this call. 	 *  	 * This method is useful when Java does not provide direct access to a 	 * particular Document type, such as a Rich Text Format document. With this 	 * method such a document can be sent to the DocumentPrinter class enclosed 	 * in a JEditorPane. 	 *  	 * To pass a HTMLDocument call this method with an editorPane that contains 	 * the document 	 *  	 *<pre> 	 * JEditorPane pane = new JEditorPane(); 	 * pane.setContentType(&quot;text/html&quot;); 	 * pane.setDocument(htmlDocument); 	 *</pre> 	 *  	 * This method is not thread-safe, if that matters to anybody, since it only 	 * uses a single PrinterJob. 	 *  	 * @param jobName 	 *            (may be null) The print-job will get this attribute set, which 	 *            for instance is used by the Adobe PDF writer to determine an 	 *            initial guess for a filename or which is displayed in the 	 *            printer spooler. 	 * @param jedPane 	 *            The pane which to print. This is done by copying document and 	 *            content type. The original jedPane is not modified. 	 * @return The method will return false if the user canceled the operation, 	 *         true if the pages where send to the printing system successfully 	 *         and will throw an PrinterException to show to the user if an 	 *         error occurred. 	 *  	 * @throws PrinterException 	 *             Show this exception to the user. 	 */
DECL|method|print (String jobName, JEditorPane jedPane)
specifier|public
name|boolean
name|print
parameter_list|(
name|String
name|jobName
parameter_list|,
name|JEditorPane
name|jedPane
parameter_list|)
throws|throws
name|PrinterException
block|{
if|if
condition|(
operator|!
name|pJob
operator|.
name|printDialog
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|jobName
operator|!=
literal|null
condition|)
name|pJob
operator|.
name|setJobName
argument_list|(
name|jobName
argument_list|)
expr_stmt|;
name|JEditorPane
name|pane
init|=
operator|new
name|JEditorPane
argument_list|()
decl_stmt|;
name|pane
operator|.
name|setContentType
argument_list|(
name|jedPane
operator|.
name|getContentType
argument_list|()
argument_list|)
expr_stmt|;
name|pane
operator|.
name|setDocument
argument_list|(
name|jedPane
operator|.
name|getDocument
argument_list|()
argument_list|)
expr_stmt|;
name|pJob
operator|.
name|setPrintable
argument_list|(
operator|new
name|DocumentPrintable
argument_list|(
name|pane
argument_list|)
argument_list|,
name|pFormat
argument_list|)
expr_stmt|;
name|pJob
operator|.
name|print
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/** 	 * Class that actually does the printing. 	 *  	 */
DECL|class|DocumentPrintable
class|class
name|DocumentPrintable
implements|implements
name|Printable
block|{
comment|/** 		 * boolean to allow control over whether pages too wide to fit on a page 		 * will be scaled. 		 */
DECL|field|scaleWidthToFit
name|boolean
name|scaleWidthToFit
init|=
literal|true
decl_stmt|;
comment|/** 		 * Used to keep track of when the page to print changes. 		 */
DECL|field|currentPage
name|int
name|currentPage
init|=
operator|-
literal|1
decl_stmt|;
comment|/** 		 * Location of the current page end. 		 */
DECL|field|pageEndY
name|double
name|pageEndY
init|=
literal|0
decl_stmt|;
comment|/** 		 * Location of the current page start. 		 */
DECL|field|pageStartY
name|double
name|pageStartY
init|=
literal|0
decl_stmt|;
comment|/** 		 * Stores the JEditorPane that is being printed. 		 */
DECL|field|pane
name|JEditorPane
name|pane
decl_stmt|;
DECL|method|DocumentPrintable (JEditorPane pane)
specifier|public
name|DocumentPrintable
parameter_list|(
name|JEditorPane
name|pane
parameter_list|)
block|{
name|this
operator|.
name|pane
operator|=
name|pane
expr_stmt|;
block|}
comment|/** 		 * The print method implements the Printable interface. Although 		 * Printables may be called to render a page more than once, each page 		 * is painted in order. We may, therefore, keep track of changes in the 		 * page being rendered by setting the currentPage variable to equal the 		 * pageIndex, and then comparing these variables on subsequent calls to 		 * this method. When the two variables match, it means that the page is 		 * being rendered for the second or third time. When the currentPage 		 * differs from the pageIndex, a new page is being requested. 		 *  		 * The highlights of the process used print a page are as follows: 		 *  		 * I. The Graphics object is cast to a Graphics2D object to allow for 		 * scaling. II. The JEditorPane is laid out using the width of a 		 * printable page. This will handle line breaks. If the JEditorPane 		 * cannot be sized at the width of the graphics clip, scaling will be 		 * allowed. III. The root view of the JEditorPane is obtained. By 		 * examining this root view and all of its children, printView will be 		 * able to determine the location of each printable element of the 		 * document. IV. If the scaleWidthToFit option is chosen, a scaling 		 * ratio is determined, and the graphics2D object is scaled. V. The 		 * Graphics2D object is clipped to the size of the printable page. VI. 		 * currentPage is checked to see if this is a new page to render. If so, 		 * pageStartY and pageEndY are reset. VII. To match the coordinates of 		 * the printable clip of graphics2D and the allocation rectangle which 		 * will be used to lay out the views, graphics2D is translated to begin 		 * at the printable X and Y coordinates of the graphics clip. VIII. An 		 * allocation Rectangle is created to represent the layout of the Views. 		 *  		 * The Printable Interface always prints the area indexed by reference 		 * to the Graphics object. For instance, with a standard 8.5 x 11 inch 		 * page with 1 inch margins the rectangle X = 72, Y = 72, Width = 468, 		 * and Height = 648, the area 72, 72, 468, 648 will be painted 		 * regardless of which page is actually being printed. 		 *  		 * To align the allocation Rectangle with the graphics2D object two 		 * things are done. The first step is to translate the X and Y 		 * coordinates of the graphics2D object to begin at the X and Y 		 * coordinates of the printable clip, see step VII. Next, when printing 		 * other than the first page, the allocation rectangle must start laying 		 * out in coordinates represented by negative numbers. After page one, 		 * the beginning of the allocation is started at minus the page end of 		 * the prior page. This moves the part which has already been rendered 		 * to before the printable clip of the graphics2D object. 		 *  		 * X. The printView method is called to paint the page. Its return value 		 * will indicate if a page has been rendered. 		 *  		 * Although public, print should not ordinarily be called by programs 		 * other than PrinterJob. 		 */
DECL|method|print (Graphics graphics, PageFormat pageFormat, int pageIndex)
specifier|public
name|int
name|print
parameter_list|(
name|Graphics
name|graphics
parameter_list|,
name|PageFormat
name|pageFormat
parameter_list|,
name|int
name|pageIndex
parameter_list|)
block|{
name|double
name|scale
init|=
literal|1.0
decl_stmt|;
name|Graphics2D
name|graphics2D
decl_stmt|;
name|View
name|rootView
decl_stmt|;
comment|// I
name|graphics2D
operator|=
operator|(
name|Graphics2D
operator|)
name|graphics
expr_stmt|;
comment|// II
name|pane
operator|.
name|setSize
argument_list|(
operator|(
name|int
operator|)
name|pageFormat
operator|.
name|getImageableWidth
argument_list|()
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|pane
operator|.
name|validate
argument_list|()
expr_stmt|;
comment|// III
name|rootView
operator|=
name|pane
operator|.
name|getUI
argument_list|()
operator|.
name|getRootView
argument_list|(
name|pane
argument_list|)
expr_stmt|;
comment|// IV
if|if
condition|(
operator|(
name|scaleWidthToFit
operator|)
operator|&&
operator|(
name|pane
operator|.
name|getMinimumSize
argument_list|()
operator|.
name|getWidth
argument_list|()
operator|>
name|pageFormat
operator|.
name|getImageableWidth
argument_list|()
operator|)
condition|)
block|{
name|scale
operator|=
name|pageFormat
operator|.
name|getImageableWidth
argument_list|()
operator|/
name|pane
operator|.
name|getMinimumSize
argument_list|()
operator|.
name|getWidth
argument_list|()
expr_stmt|;
name|graphics2D
operator|.
name|scale
argument_list|(
name|scale
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
comment|// V
name|graphics2D
operator|.
name|setClip
argument_list|(
call|(
name|int
call|)
argument_list|(
name|pageFormat
operator|.
name|getImageableX
argument_list|()
operator|/
name|scale
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|pageFormat
operator|.
name|getImageableY
argument_list|()
operator|/
name|scale
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|pageFormat
operator|.
name|getImageableWidth
argument_list|()
operator|/
name|scale
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|pageFormat
operator|.
name|getImageableHeight
argument_list|()
operator|/
name|scale
argument_list|)
argument_list|)
expr_stmt|;
comment|// VI
if|if
condition|(
name|pageIndex
operator|>
name|currentPage
condition|)
block|{
name|currentPage
operator|=
name|pageIndex
expr_stmt|;
name|pageStartY
operator|+=
name|pageEndY
expr_stmt|;
name|pageEndY
operator|=
name|graphics2D
operator|.
name|getClipBounds
argument_list|()
operator|.
name|getHeight
argument_list|()
expr_stmt|;
block|}
comment|// VII
name|graphics2D
operator|.
name|translate
argument_list|(
name|graphics2D
operator|.
name|getClipBounds
argument_list|()
operator|.
name|getX
argument_list|()
argument_list|,
name|graphics2D
operator|.
name|getClipBounds
argument_list|()
operator|.
name|getY
argument_list|()
argument_list|)
expr_stmt|;
comment|// VIII
name|Rectangle
name|allocation
init|=
operator|new
name|Rectangle
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|)
operator|-
name|pageStartY
argument_list|,
call|(
name|int
call|)
argument_list|(
name|pane
operator|.
name|getMinimumSize
argument_list|()
operator|.
name|getWidth
argument_list|()
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|pane
operator|.
name|getPreferredSize
argument_list|()
operator|.
name|getHeight
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// X
if|if
condition|(
name|printView
argument_list|(
name|graphics2D
argument_list|,
name|allocation
argument_list|,
name|rootView
argument_list|)
condition|)
block|{
return|return
name|Printable
operator|.
name|PAGE_EXISTS
return|;
block|}
else|else
block|{
name|pageStartY
operator|=
literal|0
expr_stmt|;
name|pageEndY
operator|=
literal|0
expr_stmt|;
name|currentPage
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|Printable
operator|.
name|NO_SUCH_PAGE
return|;
block|}
block|}
comment|/** 		 * printView is a recursive method which iterates through the tree 		 * structure of the view sent to it. If the view sent to printView is a 		 * branch view, that is one with children, the method calls itself on 		 * each of these children. If the view is a leaf view, that is a view 		 * without children which represents an actual piece of text to be 		 * painted, printView attempts to render the view to the Graphics2D 		 * object. 		 *  		 * I. When any view starts after the beginning of the current printable 		 * page, this means that there are pages to print and the method sets 		 * pageExists to true. II. When a leaf view is taller than the printable 		 * area of a page, it cannot, of course, be broken down to fit a single 		 * page. Such a View will be printed whenever it intersects with the 		 * Graphics2D clip. III. If a leaf view intersects the printable area of 		 * the graphics clip and fits vertically within the printable area, it 		 * will be rendered. IV. If a leaf view does not exceed the printable 		 * area of a page but does not fit vertically within the Graphics2D clip 		 * of the current page, the method records that this page should end at 		 * the start of the view. This information is stored in pageEndY. 		 */
DECL|method|printView (Graphics2D graphics2D, Shape allocation, View view)
name|boolean
name|printView
parameter_list|(
name|Graphics2D
name|graphics2D
parameter_list|,
name|Shape
name|allocation
parameter_list|,
name|View
name|view
parameter_list|)
block|{
name|boolean
name|pageExists
init|=
literal|false
decl_stmt|;
name|Rectangle
name|clipRectangle
init|=
name|graphics2D
operator|.
name|getClipBounds
argument_list|()
decl_stmt|;
name|Shape
name|childAllocation
decl_stmt|;
name|View
name|childView
decl_stmt|;
if|if
condition|(
name|view
operator|.
name|getViewCount
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|view
operator|.
name|getElement
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"td"
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|view
operator|.
name|getViewCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|childAllocation
operator|=
name|view
operator|.
name|getChildAllocation
argument_list|(
name|i
argument_list|,
name|allocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|childAllocation
operator|!=
literal|null
condition|)
block|{
name|childView
operator|=
name|view
operator|.
name|getView
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|printView
argument_list|(
name|graphics2D
argument_list|,
name|childAllocation
argument_list|,
name|childView
argument_list|)
condition|)
block|{
name|pageExists
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// I
if|if
condition|(
name|allocation
operator|.
name|getBounds
argument_list|()
operator|.
name|getMaxY
argument_list|()
operator|>=
name|clipRectangle
operator|.
name|getY
argument_list|()
condition|)
block|{
name|pageExists
operator|=
literal|true
expr_stmt|;
comment|// II
if|if
condition|(
operator|(
name|allocation
operator|.
name|getBounds
argument_list|()
operator|.
name|getHeight
argument_list|()
operator|>
name|clipRectangle
operator|.
name|getHeight
argument_list|()
operator|)
operator|&&
operator|(
name|allocation
operator|.
name|intersects
argument_list|(
name|clipRectangle
argument_list|)
operator|)
condition|)
block|{
name|view
operator|.
name|paint
argument_list|(
name|graphics2D
argument_list|,
name|allocation
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// III
if|if
condition|(
name|allocation
operator|.
name|getBounds
argument_list|()
operator|.
name|getY
argument_list|()
operator|>=
name|clipRectangle
operator|.
name|getY
argument_list|()
condition|)
block|{
if|if
condition|(
name|allocation
operator|.
name|getBounds
argument_list|()
operator|.
name|getMaxY
argument_list|()
operator|<=
name|clipRectangle
operator|.
name|getMaxY
argument_list|()
condition|)
block|{
name|view
operator|.
name|paint
argument_list|(
name|graphics2D
argument_list|,
name|allocation
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// IV
if|if
condition|(
name|allocation
operator|.
name|getBounds
argument_list|()
operator|.
name|getY
argument_list|()
operator|<
name|pageEndY
condition|)
block|{
name|pageEndY
operator|=
name|allocation
operator|.
name|getBounds
argument_list|()
operator|.
name|getY
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
return|return
name|pageExists
return|;
block|}
block|}
block|}
end_class

end_unit

