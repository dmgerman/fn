begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|net.sf.jabref.util
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|TransformerException
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|AuthorList
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexEntryType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|Globals
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|JabRefPreferences
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|imports
operator|.
name|BibtexParser
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|imports
operator|.
name|ParserResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jempbox
operator|.
name|impl
operator|.
name|DateConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jempbox
operator|.
name|impl
operator|.
name|XMLUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jempbox
operator|.
name|xmp
operator|.
name|XMPMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jempbox
operator|.
name|xmp
operator|.
name|XMPSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jempbox
operator|.
name|xmp
operator|.
name|XMPSchemaDublinCore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|COSVisitorException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocumentCatalog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocumentInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Element
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NamedNodeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import

begin_comment
comment|/**  * XMPUtils provide support for reading and writing BibTex data as XMP-Metadata  * in PDF-documents.  *   * @author Christopher Oezbek<oezi@oezi.de>  *   * TODO:  *   * Also read information from Dublin Core and Document Information if BibtexXMP  * is missing.  *   * Also write information as Dublin Core and Document Information.  *   * Synchronization  *   * @version $Revision$ ($Date$)  */
end_comment

begin_class
DECL|class|XMPUtil
specifier|public
class|class
name|XMPUtil
block|{
comment|/** 	 * Convenience method for readXMP(File). 	 *  	 * @param filename 	 *            The filename from which to open the file. 	 * @return BibtexEntryies found in the PDF or an empty list 	 * @throws IOException 	 */
DECL|method|readXMP (String filename)
specifier|public
specifier|static
name|List
name|readXMP
parameter_list|(
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|readXMP
argument_list|(
operator|new
name|File
argument_list|(
name|filename
argument_list|)
argument_list|)
return|;
block|}
comment|/** 	 * Try to write the given BibTexEntry in the XMP-stream of the given 	 * PDF-file. 	 *  	 * Throws an IOException if the file cannot be read or written, so the user 	 * can remove a lock or cancel the operation. 	 *  	 * The method will overwrite existing BibTeX-XMP-data, but keep other 	 * existing metadata. 	 *  	 * This is a convenience method for writeXMP(File, BibtexEntry). 	 *  	 * @param filename 	 *            The filename from which to open the file. 	 * @param entry 	 *            The entry to write. 	 * @throws TransformerException 	 *             If the entry was malformed or unsupported. 	 * @throws IOException 	 *             If the file could not be written to or could not be found. 	 */
DECL|method|writeXMP (String filename, BibtexEntry entry)
specifier|public
specifier|static
name|void
name|writeXMP
parameter_list|(
name|String
name|filename
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
name|writeXMP
argument_list|(
operator|new
name|File
argument_list|(
name|filename
argument_list|)
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Try to read the BibTexEntries from the XMP-stream of the given PDF-file. 	 *  	 * @param file 	 *            The file to read from. 	 *  	 * @throws IOException 	 *             Throws an IOException if the file cannot be read, so the user 	 *             than remove a lock or cancel the operation. 	 */
DECL|method|readXMP (File file)
specifier|public
specifier|static
name|List
name|readXMP
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|FileInputStream
name|is
init|=
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|readXMP
argument_list|(
name|is
argument_list|)
return|;
block|}
finally|finally
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** 	 * Try to read the given BibTexEntry from the XMP-stream of the given 	 * inputstream containing a PDF-file. 	 *  	 * @param file 	 *            The inputstream to read from. 	 *  	 * @throws IOException 	 *             Throws an IOException if the file cannot be read, so the user 	 *             than remove a lock or cancel the operation. 	 */
DECL|method|readXMP (InputStream inputStream)
specifier|public
specifier|static
name|List
name|readXMP
parameter_list|(
name|InputStream
name|inputStream
parameter_list|)
throws|throws
name|IOException
block|{
name|List
name|result
init|=
operator|new
name|LinkedList
argument_list|()
decl_stmt|;
name|PDDocument
name|document
init|=
literal|null
decl_stmt|;
try|try
block|{
name|document
operator|=
name|PDDocument
operator|.
name|load
argument_list|(
name|inputStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|document
operator|.
name|isEncrypted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|EncryptionNotSupportedException
argument_list|(
literal|"Error: Cannot read metadata from encrypted document."
argument_list|)
throw|;
block|}
name|XMPMetadata
name|meta
init|=
name|getXMPMetadata
argument_list|(
name|document
argument_list|)
decl_stmt|;
comment|// If we did not find any metadata, there is nothing to return.
if|if
condition|(
name|meta
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|List
name|schemas
init|=
name|meta
operator|.
name|getSchemasByNamespaceURI
argument_list|(
name|XMPSchemaBibtex
operator|.
name|NAMESPACE
argument_list|)
decl_stmt|;
name|Iterator
name|it
init|=
name|schemas
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|XMPSchemaBibtex
name|bib
init|=
operator|(
name|XMPSchemaBibtex
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|bib
operator|.
name|getBibtexEntry
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// If we did not find anything have a look if a Dublin Core exists
if|if
condition|(
name|result
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|schemas
operator|=
name|meta
operator|.
name|getSchemasByNamespaceURI
argument_list|(
name|XMPSchemaDublinCore
operator|.
name|NAMESPACE
argument_list|)
expr_stmt|;
name|it
operator|=
name|schemas
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|XMPSchemaDublinCore
name|dc
init|=
operator|(
name|XMPSchemaDublinCore
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|BibtexEntry
name|entry
init|=
name|getBibtexEntryFromDublinCore
argument_list|(
name|dc
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
name|result
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|BibtexEntry
name|entry
init|=
name|getBibtexEntryFromDocumentInformation
argument_list|(
name|document
operator|.
name|getDocumentInformation
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
name|result
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|document
operator|!=
literal|null
condition|)
name|document
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|getBibtexEntryFromDocumentInformation (PDDocumentInformation di)
specifier|public
specifier|static
name|BibtexEntry
name|getBibtexEntryFromDocumentInformation
parameter_list|(
name|PDDocumentInformation
name|di
parameter_list|)
block|{
name|BibtexEntry
name|entry
init|=
operator|new
name|BibtexEntry
argument_list|()
decl_stmt|;
name|String
name|s
init|=
name|di
operator|.
name|getAuthor
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
name|entry
operator|.
name|setField
argument_list|(
literal|"author"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|di
operator|.
name|getTitle
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
name|entry
operator|.
name|setField
argument_list|(
literal|"title"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|di
operator|.
name|getKeywords
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
name|entry
operator|.
name|setField
argument_list|(
literal|"keywords"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|di
operator|.
name|getSubject
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
name|entry
operator|.
name|setField
argument_list|(
literal|"abstract"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|COSDictionary
name|dict
init|=
name|di
operator|.
name|getDictionary
argument_list|()
decl_stmt|;
name|Iterator
name|it
init|=
name|dict
operator|.
name|keyList
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|key
init|=
operator|(
operator|(
name|COSName
operator|)
name|it
operator|.
name|next
argument_list|()
operator|)
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|startsWith
argument_list|(
literal|"bibtex/"
argument_list|)
condition|)
block|{
name|String
name|value
init|=
name|dict
operator|.
name|getString
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|key
operator|=
name|key
operator|.
name|substring
argument_list|(
literal|"bibtex/"
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"entrytype"
argument_list|)
condition|)
block|{
name|BibtexEntryType
name|type
init|=
name|BibtexEntryType
operator|.
name|getStandardType
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
name|entry
operator|.
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|entry
operator|.
name|setField
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Return null if no values were found
return|return
operator|(
name|entry
operator|.
name|getAllFields
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|?
name|entry
else|:
literal|null
operator|)
return|;
block|}
DECL|method|getBibtexEntryFromDublinCore (XMPSchemaDublinCore dcSchema)
specifier|public
specifier|static
name|BibtexEntry
name|getBibtexEntryFromDublinCore
parameter_list|(
name|XMPSchemaDublinCore
name|dcSchema
parameter_list|)
block|{
name|BibtexEntry
name|entry
init|=
operator|new
name|BibtexEntry
argument_list|()
decl_stmt|;
comment|/** 		 * Contributor -> Editor 		 */
name|List
name|contributors
init|=
name|dcSchema
operator|.
name|getContributors
argument_list|()
decl_stmt|;
if|if
condition|(
name|contributors
operator|!=
literal|null
condition|)
block|{
name|Iterator
name|it
init|=
name|contributors
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|StringBuffer
name|sb
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
name|entry
operator|.
name|setField
argument_list|(
literal|"editor"
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** 		 * Author -> Creator 		 */
name|List
name|creators
init|=
name|dcSchema
operator|.
name|getCreators
argument_list|()
decl_stmt|;
if|if
condition|(
name|creators
operator|!=
literal|null
condition|)
block|{
name|Iterator
name|it
init|=
name|creators
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|StringBuffer
name|sb
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
name|entry
operator|.
name|setField
argument_list|(
literal|"author"
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** 		 * Year + Month -> Date 		 */
name|List
name|dates
init|=
name|dcSchema
operator|.
name|getSequenceList
argument_list|(
literal|"dc:date"
argument_list|)
decl_stmt|;
if|if
condition|(
name|dates
operator|!=
literal|null
operator|&&
name|dates
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
name|date
init|=
operator|(
operator|(
name|String
operator|)
name|dates
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|Calendar
name|c
init|=
literal|null
decl_stmt|;
try|try
block|{
name|c
operator|=
name|DateConverter
operator|.
name|toCalendar
argument_list|(
name|date
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{  			}
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"year"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|c
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
operator|.
name|length
argument_list|()
operator|>
literal|4
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"month"
argument_list|,
name|Globals
operator|.
name|MONTHS
index|[
name|c
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** 		 * Abstract -> Description 		 */
name|String
name|s
init|=
name|dcSchema
operator|.
name|getDescription
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
name|entry
operator|.
name|setField
argument_list|(
literal|"abstract"
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/** 		 * Identifier -> DOI 		 */
name|s
operator|=
name|dcSchema
operator|.
name|getIdentifier
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
name|entry
operator|.
name|setField
argument_list|(
literal|"doi"
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/** 		 * Publisher -> Publisher 		 */
name|List
name|publishers
init|=
name|dcSchema
operator|.
name|getPublishers
argument_list|()
decl_stmt|;
if|if
condition|(
name|publishers
operator|!=
literal|null
condition|)
block|{
name|Iterator
name|it
init|=
name|dcSchema
operator|.
name|getPublishers
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|StringBuffer
name|sb
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
name|entry
operator|.
name|setField
argument_list|(
literal|"publishers"
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** 		 * Relation -> bibtexkey 		 *  		 * We abuse the relationship attribute to store all other values in the 		 * bibtex document 		 */
name|List
name|relationships
init|=
name|dcSchema
operator|.
name|getRelationships
argument_list|()
decl_stmt|;
if|if
condition|(
name|relationships
operator|!=
literal|null
condition|)
block|{
name|Iterator
name|it
init|=
name|relationships
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|s
operator|=
operator|(
name|String
operator|)
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
literal|"bibtex/"
argument_list|)
condition|)
block|{
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|"bibtex/"
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|i
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|s
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** 		 * Rights -> Rights 		 */
name|s
operator|=
name|dcSchema
operator|.
name|getRights
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
name|entry
operator|.
name|setField
argument_list|(
literal|"rights"
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/** 		 * Source -> Source 		 */
name|s
operator|=
name|dcSchema
operator|.
name|getSource
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
name|entry
operator|.
name|setField
argument_list|(
literal|"source"
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/** 		 * Subject -> Keywords 		 */
name|List
name|subjects
init|=
name|dcSchema
operator|.
name|getSubjects
argument_list|()
decl_stmt|;
if|if
condition|(
name|subjects
operator|!=
literal|null
condition|)
block|{
name|Iterator
name|it
init|=
name|subjects
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|StringBuffer
name|sb
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
name|entry
operator|.
name|setField
argument_list|(
literal|"keywords"
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** 		 * Title -> Title 		 */
name|s
operator|=
name|dcSchema
operator|.
name|getTitle
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
name|entry
operator|.
name|setField
argument_list|(
literal|"title"
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/** 		 * Type -> Type 		 */
name|List
name|l
init|=
name|dcSchema
operator|.
name|getTypes
argument_list|()
decl_stmt|;
if|if
condition|(
name|l
operator|!=
literal|null
operator|&&
name|l
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|s
operator|=
operator|(
name|String
operator|)
name|l
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|BibtexEntryType
name|type
init|=
name|BibtexEntryType
operator|.
name|getStandardType
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
name|entry
operator|.
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|entry
operator|.
name|getAllFields
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|?
name|entry
else|:
literal|null
operator|)
return|;
block|}
comment|/** 	 * Try to write the given BibTexEntry in the XMP-stream of the given 	 * PDF-file. 	 *  	 * Throws an IOException if the file cannot be read or written, so the user 	 * can remove a lock or cancel the operation. 	 *  	 * The method will overwrite existing BibTeX-XMP-data, but keep other 	 * existing metadata. 	 *  	 * This is a convenience method for writeXMP(File, Collection). 	 *  	 * @param file 	 *            The file to write to. 	 * @param entry 	 *            The entry to write. 	 * @throws TransformerException 	 *             If the entry was malformed or unsupported. 	 * @throws IOException 	 *             If the file could not be written to or could not be found. 	 */
DECL|method|writeXMP (File file, BibtexEntry entry)
specifier|public
specifier|static
name|void
name|writeXMP
parameter_list|(
name|File
name|file
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
name|List
name|l
init|=
operator|new
name|LinkedList
argument_list|()
decl_stmt|;
name|l
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|writeXMP
argument_list|(
name|file
argument_list|,
name|l
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Write the given BibtexEntries as XMP-metadata text to the given stream. 	 *  	 * The text that is written to the stream contains a complete XMP-document. 	 *  	 * @param bibtexEntries 	 *            The BibtexEntries to write XMP-metadata for. 	 * @throws TransformerException 	 *             Thrown if the bibtexEntries could not transformed to XMP. 	 * @throws IOException 	 *             Thrown if an IOException occured while writing to the stream. 	 */
DECL|method|toXMP (Collection bibtexEntries, OutputStream outputStream)
specifier|public
specifier|static
name|void
name|toXMP
parameter_list|(
name|Collection
name|bibtexEntries
parameter_list|,
name|OutputStream
name|outputStream
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
name|XMPMetadata
name|x
init|=
operator|new
name|XMPMetadata
argument_list|()
decl_stmt|;
name|Iterator
name|it
init|=
name|bibtexEntries
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BibtexEntry
name|e
init|=
operator|(
name|BibtexEntry
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|XMPSchemaBibtex
name|schema
init|=
operator|new
name|XMPSchemaBibtex
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|x
operator|.
name|addSchema
argument_list|(
name|schema
argument_list|)
expr_stmt|;
name|schema
operator|.
name|setBibtexEntry
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|x
operator|.
name|save
argument_list|(
name|outputStream
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Convenience method for toXMP(Collection, OutputStream) returning a String 	 * containing the XMP-metadata of the given collection of BibtexEntries. 	 *  	 * The resulting metadata string is wrapped as a complete XMP-document. 	 *  	 * @param bibtexEntries 	 *            The BibtexEntries to return XMP-metadata for. 	 * @return The XMP representation of the given bibtexEntries. 	 * @throws TransformerException 	 *             Thrown if the bibtexEntries could not transformed to XMP. 	 */
DECL|method|toXMP (Collection bibtexEntries)
specifier|public
specifier|static
name|String
name|toXMP
parameter_list|(
name|Collection
name|bibtexEntries
parameter_list|)
throws|throws
name|TransformerException
block|{
try|try
block|{
name|ByteArrayOutputStream
name|bs
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|toXMP
argument_list|(
name|bibtexEntries
argument_list|,
name|bs
argument_list|)
expr_stmt|;
return|return
name|bs
operator|.
name|toString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|TransformerException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** 	 * Will read the XMPMetadata from the given pdf file, closing the file 	 * afterwards. 	 *  	 * @param inputStream 	 *            The inputStream representing a PDF-file to read the 	 *            XMPMetadata from. 	 * @return The XMPMetadata object found in the file or null if none is 	 *         found. 	 * @throws IOException 	 */
DECL|method|readRawXMP (InputStream inputStream)
specifier|public
specifier|static
name|XMPMetadata
name|readRawXMP
parameter_list|(
name|InputStream
name|inputStream
parameter_list|)
throws|throws
name|IOException
block|{
name|PDDocument
name|document
init|=
literal|null
decl_stmt|;
try|try
block|{
name|document
operator|=
name|PDDocument
operator|.
name|load
argument_list|(
name|inputStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|document
operator|.
name|isEncrypted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|EncryptionNotSupportedException
argument_list|(
literal|"Error: Cannot read metadata from encrypted document."
argument_list|)
throw|;
block|}
return|return
name|getXMPMetadata
argument_list|(
name|document
argument_list|)
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|document
operator|!=
literal|null
condition|)
name|document
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getXMPMetadata (PDDocument document)
specifier|protected
specifier|static
name|XMPMetadata
name|getXMPMetadata
parameter_list|(
name|PDDocument
name|document
parameter_list|)
throws|throws
name|IOException
block|{
name|PDDocumentCatalog
name|catalog
init|=
name|document
operator|.
name|getDocumentCatalog
argument_list|()
decl_stmt|;
name|PDMetadata
name|metaRaw
init|=
name|catalog
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
if|if
condition|(
name|metaRaw
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|XMPMetadata
name|meta
init|=
operator|new
name|XMPMetadata
argument_list|(
name|XMLUtil
operator|.
name|parse
argument_list|(
name|metaRaw
operator|.
name|createInputStream
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|meta
operator|.
name|addXMLNSMapping
argument_list|(
name|XMPSchemaBibtex
operator|.
name|NAMESPACE
argument_list|,
name|XMPSchemaBibtex
operator|.
name|class
argument_list|)
expr_stmt|;
return|return
name|meta
return|;
block|}
comment|/** 	 * Will read the XMPMetadata from the given pdf file, closing the file 	 * afterwards. 	 *  	 * @param file 	 *            The file to read the XMPMetadata from. 	 * @return The XMPMetadata object found in the file or null if none is 	 *         found. 	 * @throws IOException 	 */
DECL|method|readRawXMP (File file)
specifier|public
specifier|static
name|XMPMetadata
name|readRawXMP
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|FileInputStream
name|is
init|=
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|readRawXMP
argument_list|(
name|is
argument_list|)
return|;
block|}
finally|finally
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|writeToDCSchema (XMPSchemaDublinCore dcSchema, BibtexEntry entry)
specifier|protected
specifier|static
name|void
name|writeToDCSchema
parameter_list|(
name|XMPSchemaDublinCore
name|dcSchema
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|)
block|{
comment|// Set all the values including key and entryType
name|Object
index|[]
name|fields
init|=
name|entry
operator|.
name|getAllFields
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|fields
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fields
index|[
name|j
index|]
operator|.
name|equals
argument_list|(
literal|"editor"
argument_list|)
condition|)
block|{
name|String
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|fields
index|[
name|j
index|]
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|/** 				 * Editor -> Contributor 				 *  				 * Field: dc:contributor 				 *  				 * Type: bag ProperName 				 *  				 * Category: External 				 *  				 * Description: Contributors to the resource (other than the 				 * authors). 				 *  				 * Bibtex-Fields used: editor 				 */
name|String
name|authors
init|=
name|o
operator|.
name|toString
argument_list|()
decl_stmt|;
name|AuthorList
name|list
init|=
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|authors
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|dcSchema
operator|.
name|addContributor
argument_list|(
name|list
operator|.
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getFirstLast
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/** 			 * ? -> Coverage 			 *  			 * Unmapped 			 *  			 * dc:coverage Text External The extent or scope of the resource. 			 */
comment|/** 			 * Author -> Creator 			 *  			 * Field: dc:creator 			 *  			 * Type: seq ProperName 			 *  			 * Category: External 			 *  			 * Description: The authors of the resource (listed in order of 			 * precedence, if significant). 			 *  			 * Bibtex-Fields used: author 			 */
if|if
condition|(
name|fields
index|[
name|j
index|]
operator|.
name|equals
argument_list|(
literal|"author"
argument_list|)
condition|)
block|{
name|String
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|fields
index|[
name|j
index|]
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|authors
init|=
name|o
operator|.
name|toString
argument_list|()
decl_stmt|;
name|AuthorList
name|list
init|=
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|authors
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|dcSchema
operator|.
name|addCreator
argument_list|(
name|list
operator|.
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getFirstLast
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|fields
index|[
name|j
index|]
operator|.
name|equals
argument_list|(
literal|"month"
argument_list|)
condition|)
block|{
comment|// Dealt with in year
continue|continue;
block|}
if|if
condition|(
name|fields
index|[
name|j
index|]
operator|.
name|equals
argument_list|(
literal|"year"
argument_list|)
condition|)
block|{
comment|/** 				 * Year + Month -> Date 				 *  				 * Field: dc:date 				 *  				 * Type: seq Date 				 *  				 * Category: External 				 *  				 * Description: Date(s) that something interesting happened to 				 * the resource. 				 *  				 * Bibtex-Fields used: year, month 				 */
name|String
name|publicationDate
init|=
name|Util
operator|.
name|getPublicationDate
argument_list|(
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|publicationDate
operator|!=
literal|null
condition|)
block|{
name|dcSchema
operator|.
name|addSequenceValue
argument_list|(
literal|"dc:date"
argument_list|,
name|publicationDate
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/** 			 * Abstract -> Description 			 *  			 * Field: dc:description 			 *  			 * Type: Lang Alt 			 *  			 * Category: External 			 *  			 * Description: A textual description of the content of the 			 * resource. Multiple values may be present for different languages. 			 *  			 * Bibtex-Fields used: abstract 			 */
if|if
condition|(
name|fields
index|[
name|j
index|]
operator|.
name|equals
argument_list|(
literal|"abstract"
argument_list|)
condition|)
block|{
name|String
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|fields
index|[
name|j
index|]
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|dcSchema
operator|.
name|setDescription
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/** 			 * DOI -> identifier 			 *  			 * Field: dc:identifier 			 *  			 * Type: Text 			 *  			 * Category: External 			 *  			 * Description: Unique identifier of the resource. 			 *  			 * Bibtex-Fields used: doi 			 */
if|if
condition|(
name|fields
index|[
name|j
index|]
operator|.
name|equals
argument_list|(
literal|"doi"
argument_list|)
condition|)
block|{
name|String
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|fields
index|[
name|j
index|]
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|dcSchema
operator|.
name|setIdentifier
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/** 			 * ? -> Language 			 *  			 * Unmapped 			 *  			 * dc:language bag Locale Internal An unordered array specifying the 			 * languages used in the resource. 			 */
comment|/** 			 * Publisher -> Publisher 			 *  			 * Field: dc:publisher 			 *  			 * Type: bag ProperName 			 *  			 * Category: External 			 *  			 * Description: Publishers. 			 *  			 * Bibtex-Fields used: doi 			 */
if|if
condition|(
name|fields
index|[
name|j
index|]
operator|.
name|equals
argument_list|(
literal|"publisher"
argument_list|)
condition|)
block|{
name|String
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|fields
index|[
name|j
index|]
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|dcSchema
operator|.
name|addPublisher
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/** 			 * ? -> Rights 			 *  			 * Unmapped 			 *  			 * dc:rights Lang Alt External Informal rights statement, selected 			 * by language. 			 */
comment|/** 			 * ? -> Source 			 *  			 * Unmapped 			 *  			 * dc:source Text External Unique identifier of the work from which 			 * this resource was derived. 			 */
comment|/** 			 * Keywords -> Subject 			 *  			 * Field: dc:subject 			 *  			 * Type: bag Text 			 *  			 * Category: External 			 *  			 * Description: An unordered array of descriptive phrases or 			 * keywords that specify the topic of the content of the resource. 			 *  			 * Bibtex-Fields used: doi 			 */
if|if
condition|(
name|fields
index|[
name|j
index|]
operator|.
name|equals
argument_list|(
literal|"keywords"
argument_list|)
condition|)
block|{
name|String
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|fields
index|[
name|j
index|]
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
index|[]
name|keywords
init|=
name|o
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keywords
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|dcSchema
operator|.
name|addSubject
argument_list|(
name|keywords
index|[
name|i
index|]
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/** 			 * Title -> Title 			 *  			 * Field: dc:title 			 *  			 * Type: Lang Alt 			 *  			 * Category: External 			 *  			 * Description: The title of the document, or the name given to the 			 * resource. Typically, it will be a name by which the resource is 			 * formally known. 			 *  			 * Bibtex-Fields used: title 			 */
if|if
condition|(
name|fields
index|[
name|j
index|]
operator|.
name|equals
argument_list|(
literal|"title"
argument_list|)
condition|)
block|{
name|String
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|fields
index|[
name|j
index|]
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|dcSchema
operator|.
name|setTitle
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/** 			 * bibtextype -> relation 			 *  			 * Field: dc:relation 			 *  			 * Type: bag Text 			 *  			 * Category: External 			 *  			 * Description: Relationships to other documents. 			 *  			 * Bibtex-Fields used: bibtextype 			 */
comment|/** 			 * All others (including the bibtex key) get packaged in the 			 * relation attribute 			 */
name|String
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|fields
index|[
name|j
index|]
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|dcSchema
operator|.
name|addRelation
argument_list|(
literal|"bibtex/"
operator|+
name|fields
index|[
name|j
index|]
operator|.
name|toString
argument_list|()
operator|+
literal|"/"
operator|+
name|o
argument_list|)
expr_stmt|;
block|}
comment|/** 		 * ? -> Format 		 *  		 * Unmapped 		 *  		 * dc:format MIMEType Internal The file format used when saving the 		 * resource. Tools and applications should set this property to the save 		 * format of the data. It may include appropriate qualifiers. 		 */
name|dcSchema
operator|.
name|setFormat
argument_list|(
literal|"application/pdf"
argument_list|)
expr_stmt|;
comment|/** 		 * Type -> Type 		 *  		 * Field: dc:type 		 *  		 * Type: bag open Choice 		 *  		 * Category: External 		 *  		 * Description: A document type; for example, novel, poem, or working 		 * paper. 		 *  		 * Bibtex-Fields used: title 		 */
name|Object
name|o
init|=
name|entry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
name|dcSchema
operator|.
name|addType
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Try to write the given BibTexEntry as a DublinCore XMP Schema 	 *  	 * Existing DublinCore schemas in the document are not modified. 	 *  	 * @param document 	 *            The pdf document to write to. 	 * @param entry 	 *            The Bibtex entry that is written as a schema. 	 * @throws IOException 	 * @throws TransformerException 	 */
DECL|method|writeDublinCore (PDDocument document, BibtexEntry entry)
specifier|public
specifier|static
name|void
name|writeDublinCore
parameter_list|(
name|PDDocument
name|document
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
name|List
name|l
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|l
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|writeDublinCore
argument_list|(
name|document
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Try to write the given BibTexEntries as DublinCore XMP Schemas 	 *  	 * Existing DublinCore schemas in the document are removed 	 *  	 * @param document 	 *            The pdf document to write to. 	 * @param c 	 *            The Bibtex entries that are written as schemas 	 * @throws IOException 	 * @throws TransformerException 	 */
DECL|method|writeDublinCore (PDDocument document, Collection c)
specifier|public
specifier|static
name|void
name|writeDublinCore
parameter_list|(
name|PDDocument
name|document
parameter_list|,
name|Collection
name|c
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
name|PDDocumentCatalog
name|catalog
init|=
name|document
operator|.
name|getDocumentCatalog
argument_list|()
decl_stmt|;
name|PDMetadata
name|metaRaw
init|=
name|catalog
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|XMPMetadata
name|meta
decl_stmt|;
if|if
condition|(
name|metaRaw
operator|!=
literal|null
condition|)
block|{
name|meta
operator|=
operator|new
name|XMPMetadata
argument_list|(
name|XMLUtil
operator|.
name|parse
argument_list|(
name|metaRaw
operator|.
name|createInputStream
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|meta
operator|=
operator|new
name|XMPMetadata
argument_list|()
expr_stmt|;
block|}
comment|// Remove all current Dublin-Core schemas
name|List
name|schemas
init|=
name|meta
operator|.
name|getSchemasByNamespaceURI
argument_list|(
name|XMPSchemaDublinCore
operator|.
name|NAMESPACE
argument_list|)
decl_stmt|;
name|Iterator
name|it
init|=
name|schemas
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|XMPSchema
name|bib
init|=
operator|(
name|XMPSchema
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|bib
operator|.
name|getElement
argument_list|()
operator|.
name|getParentNode
argument_list|()
operator|.
name|removeChild
argument_list|(
name|bib
operator|.
name|getElement
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|it
operator|=
name|c
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BibtexEntry
name|entry
init|=
operator|(
name|BibtexEntry
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|XMPSchemaDublinCore
name|dcSchema
init|=
operator|new
name|XMPSchemaDublinCore
argument_list|(
name|meta
argument_list|)
decl_stmt|;
name|writeToDCSchema
argument_list|(
name|dcSchema
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|meta
operator|.
name|addSchema
argument_list|(
name|dcSchema
argument_list|)
expr_stmt|;
block|}
comment|// Save to stream and then input that stream to the PDF
name|ByteArrayOutputStream
name|os
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|meta
operator|.
name|save
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|ByteArrayInputStream
name|is
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|os
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|PDMetadata
name|metadataStream
init|=
operator|new
name|PDMetadata
argument_list|(
name|document
argument_list|,
name|is
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|catalog
operator|.
name|setMetadata
argument_list|(
name|metadataStream
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Try to write the given BibTexEntry in the Document Information (the 	 * properties of the pdf). 	 *  	 * Existing fields values are overriden if the bibtex entry has the 	 * corresponding value set. 	 *  	 * @param document 	 *            The pdf document to write to. 	 * @param entry 	 *            The Bibtex entry that is written into the PDF properties. 	 */
DECL|method|writeDocumentInformation (PDDocument document, BibtexEntry entry)
specifier|public
specifier|static
name|void
name|writeDocumentInformation
parameter_list|(
name|PDDocument
name|document
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|)
block|{
name|PDDocumentInformation
name|di
init|=
name|document
operator|.
name|getDocumentInformation
argument_list|()
decl_stmt|;
comment|// Set all the values including key and entryType
name|Object
index|[]
name|fields
init|=
name|entry
operator|.
name|getAllFields
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fields
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"author"
argument_list|)
condition|)
block|{
name|di
operator|.
name|setAuthor
argument_list|(
name|entry
operator|.
name|getField
argument_list|(
literal|"author"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fields
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"title"
argument_list|)
condition|)
block|{
name|di
operator|.
name|setTitle
argument_list|(
name|entry
operator|.
name|getField
argument_list|(
literal|"title"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fields
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"keywords"
argument_list|)
condition|)
block|{
name|di
operator|.
name|setKeywords
argument_list|(
name|entry
operator|.
name|getField
argument_list|(
literal|"keywords"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fields
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"abstract"
argument_list|)
condition|)
block|{
name|di
operator|.
name|setSubject
argument_list|(
name|entry
operator|.
name|getField
argument_list|(
literal|"abstract"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|di
operator|.
name|setCustomMetadataValue
argument_list|(
literal|"bibtex/"
operator|+
name|fields
index|[
name|i
index|]
operator|.
name|toString
argument_list|()
argument_list|,
name|entry
operator|.
name|getField
argument_list|(
name|fields
index|[
name|i
index|]
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|di
operator|.
name|setCustomMetadataValue
argument_list|(
literal|"bibtex/entrytype"
argument_list|,
name|entry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Try to write the given BibTexEntry in the XMP-stream of the given 	 * PDF-file. 	 *  	 * Throws an IOException if the file cannot be read or written, so the user 	 * can remove a lock or cancel the operation. 	 *  	 * The method will overwrite existing BibTeX-XMP-data, but keep other 	 * existing metadata. 	 *  	 * @param file 	 *            The file to write the entries to. 	 * @param bibtexEntries 	 *            The entries to write to the file. 	 * @param writePDFInfo 	 *            Write information also in PDF document properties 	 * @throws TransformerException 	 *             If the entry was malformed or unsupported. 	 * @throws IOException 	 *             If the file could not be written to or could not be found. 	 */
DECL|method|writeXMP (File file, Collection bibtexEntries, boolean writePDFInfo)
specifier|public
specifier|static
name|void
name|writeXMP
parameter_list|(
name|File
name|file
parameter_list|,
name|Collection
name|bibtexEntries
parameter_list|,
name|boolean
name|writePDFInfo
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
name|PDDocument
name|document
init|=
literal|null
decl_stmt|;
try|try
block|{
name|document
operator|=
name|PDDocument
operator|.
name|load
argument_list|(
name|file
operator|.
name|getAbsoluteFile
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|document
operator|.
name|isEncrypted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|EncryptionNotSupportedException
argument_list|(
literal|"Error: Cannot add metadata to encrypted document."
argument_list|)
throw|;
block|}
if|if
condition|(
name|writePDFInfo
operator|&&
name|bibtexEntries
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|writeDocumentInformation
argument_list|(
name|document
argument_list|,
operator|(
name|BibtexEntry
operator|)
name|bibtexEntries
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|writeDublinCore
argument_list|(
name|document
argument_list|,
name|bibtexEntries
argument_list|)
expr_stmt|;
block|}
name|PDDocumentCatalog
name|catalog
init|=
name|document
operator|.
name|getDocumentCatalog
argument_list|()
decl_stmt|;
name|PDMetadata
name|metaRaw
init|=
name|catalog
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|XMPMetadata
name|meta
decl_stmt|;
if|if
condition|(
name|metaRaw
operator|!=
literal|null
condition|)
block|{
name|meta
operator|=
operator|new
name|XMPMetadata
argument_list|(
name|XMLUtil
operator|.
name|parse
argument_list|(
name|metaRaw
operator|.
name|createInputStream
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|meta
operator|=
operator|new
name|XMPMetadata
argument_list|()
expr_stmt|;
block|}
name|meta
operator|.
name|addXMLNSMapping
argument_list|(
name|XMPSchemaBibtex
operator|.
name|NAMESPACE
argument_list|,
name|XMPSchemaBibtex
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// Remove all current Bibtex-schemas
name|List
name|schemas
init|=
name|meta
operator|.
name|getSchemasByNamespaceURI
argument_list|(
name|XMPSchemaBibtex
operator|.
name|NAMESPACE
argument_list|)
decl_stmt|;
name|Iterator
name|it
init|=
name|schemas
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|XMPSchemaBibtex
name|bib
init|=
operator|(
name|XMPSchemaBibtex
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|bib
operator|.
name|getElement
argument_list|()
operator|.
name|getParentNode
argument_list|()
operator|.
name|removeChild
argument_list|(
name|bib
operator|.
name|getElement
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|it
operator|=
name|bibtexEntries
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BibtexEntry
name|e
init|=
operator|(
name|BibtexEntry
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|XMPSchemaBibtex
name|bibtex
init|=
operator|new
name|XMPSchemaBibtex
argument_list|(
name|meta
argument_list|)
decl_stmt|;
name|meta
operator|.
name|addSchema
argument_list|(
name|bibtex
argument_list|)
expr_stmt|;
name|bibtex
operator|.
name|setBibtexEntry
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Save to stream and then input that stream to the PDF
name|ByteArrayOutputStream
name|os
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|meta
operator|.
name|save
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|ByteArrayInputStream
name|is
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|os
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|PDMetadata
name|metadataStream
init|=
operator|new
name|PDMetadata
argument_list|(
name|document
argument_list|,
name|is
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|catalog
operator|.
name|setMetadata
argument_list|(
name|metadataStream
argument_list|)
expr_stmt|;
comment|// Save
try|try
block|{
name|document
operator|.
name|save
argument_list|(
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|COSVisitorException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|TransformerException
argument_list|(
literal|"Could not write XMP-metadata: "
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|document
operator|!=
literal|null
condition|)
block|{
name|document
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** 	 * Print usage information for the command line tool xmpUtil. 	 *  	 * @see net.sf.jabref.util.XMUtil.main() 	 */
DECL|method|usage ()
specifier|protected
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Read or write XMP-metadata from or to pdf file."
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Usage:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Read from PDF and print as bibtex:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  xmpUtil<pdf>"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Read from PDF and print raw XMP:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  xmpUtil -x<pdf>"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Write the entry in<bib> given by<key> to the PDF:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  xmpUtil<key><bib><pdf>"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Write all entries in<bib> to the PDF:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  xmpUtil<bib><pdf>"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"To report bugs visit http://jabref.sourceforge.net"
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Command-line tool for working with XMP-data. 	 *  	 * Read or write XMP-metadata from or to pdf file. 	 *  	 * Usage: 	 *<dl> 	 *<dd>Read from PDF and print as bibtex:</dd> 	 *<dt>xmpUtil PDF</dt> 	 *<dd>Read from PDF and print raw XMP:</dd> 	 *<dt>xmpUtil -x PDF</dt> 	 *<dd>Write the entry in BIB given by KEY to the PDF:</dd> 	 *<dt>xmpUtil KEY BIB PDF</dt> 	 *<dd>Write all entries in BIB to the PDF:</dd> 	 *<dt>xmpUtil BIB PDF</dt> 	 *</dl> 	 *  	 * @param args 	 *            Command line strings passed to utility. 	 * @throws IOException 	 *             If any of the given files could not be read or written. 	 * @throws TransformerException 	 *             If the given BibtexEntry is malformed. 	 */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
comment|// Don't forget to initialize the preferences
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|==
literal|null
condition|)
block|{
name|Globals
operator|.
name|prefs
operator|=
name|JabRefPreferences
operator|.
name|getInstance
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|args
operator|.
name|length
condition|)
block|{
case|case
literal|0
case|:
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
block|{
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|endsWith
argument_list|(
literal|".pdf"
argument_list|)
condition|)
block|{
comment|// Read from pdf and write as BibTex
name|List
name|l
init|=
name|XMPUtil
operator|.
name|readXMP
argument_list|(
operator|new
name|File
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|Iterator
name|it
init|=
name|l
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BibtexEntry
name|e
init|=
operator|(
name|BibtexEntry
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|e
operator|.
name|write
argument_list|(
name|sw
argument_list|,
operator|new
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|LatexFieldFormatter
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|sw
operator|.
name|getBuffer
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|endsWith
argument_list|(
literal|".bib"
argument_list|)
condition|)
block|{
comment|// Read from bib and write as XMP
name|ParserResult
name|result
init|=
name|BibtexParser
operator|.
name|parse
argument_list|(
operator|new
name|FileReader
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|Collection
name|c
init|=
name|result
operator|.
name|getDatabase
argument_list|()
operator|.
name|getEntries
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Could not find BibtexEntry in "
operator|+
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|XMPUtil
operator|.
name|toXMP
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|2
case|:
block|{
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"-x"
argument_list|)
operator|&&
name|args
index|[
literal|1
index|]
operator|.
name|endsWith
argument_list|(
literal|".pdf"
argument_list|)
condition|)
block|{
comment|// Read from pdf and write as BibTex
name|XMPMetadata
name|meta
init|=
name|XMPUtil
operator|.
name|readRawXMP
argument_list|(
operator|new
name|File
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|meta
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"The given pdf does not contain any XMP-metadata."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XMLUtil
operator|.
name|save
argument_list|(
name|meta
operator|.
name|getXMPDocument
argument_list|()
argument_list|,
name|System
operator|.
name|out
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|endsWith
argument_list|(
literal|".bib"
argument_list|)
operator|&&
name|args
index|[
literal|1
index|]
operator|.
name|endsWith
argument_list|(
literal|".pdf"
argument_list|)
condition|)
block|{
name|ParserResult
name|result
init|=
name|BibtexParser
operator|.
name|parse
argument_list|(
operator|new
name|FileReader
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|Collection
name|c
init|=
name|result
operator|.
name|getDatabase
argument_list|()
operator|.
name|getEntries
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Could not find BibtexEntry in "
operator|+
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XMPUtil
operator|.
name|writeXMP
argument_list|(
operator|new
name|File
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|c
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"XMP written."
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
literal|3
case|:
block|{
if|if
condition|(
operator|!
name|args
index|[
literal|1
index|]
operator|.
name|endsWith
argument_list|(
literal|".bib"
argument_list|)
operator|&&
operator|!
name|args
index|[
literal|2
index|]
operator|.
name|endsWith
argument_list|(
literal|".pdf"
argument_list|)
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
name|ParserResult
name|result
init|=
name|BibtexParser
operator|.
name|parse
argument_list|(
operator|new
name|FileReader
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|BibtexEntry
name|e
init|=
name|result
operator|.
name|getDatabase
argument_list|()
operator|.
name|getEntryByKey
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Could not find BibtexEntry "
operator|+
name|args
index|[
literal|0
index|]
operator|+
literal|" in "
operator|+
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XMPUtil
operator|.
name|writeXMP
argument_list|(
operator|new
name|File
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"XMP written."
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** 	 * Will try to read XMP metadata from the given file, returning whether 	 * metadata was found. 	 *  	 * Caution: This method is as expensive as it is reading the actual metadata 	 * itself from the PDF. 	 *  	 * @param is 	 *            The inputstream to read the PDF from. 	 * @return whether a BibtexEntry was found in the given PDF. 	 */
DECL|method|hasMetadata (InputStream is)
specifier|public
specifier|static
name|boolean
name|hasMetadata
parameter_list|(
name|InputStream
name|is
parameter_list|)
block|{
try|try
block|{
name|List
name|l
init|=
name|XMPUtil
operator|.
name|readXMP
argument_list|(
name|is
argument_list|)
decl_stmt|;
return|return
name|l
operator|.
name|size
argument_list|()
operator|>
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
end_class

end_unit

