begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|net.sf.jabref
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|WeakHashMap
import|;
end_import

begin_comment
comment|/**  * This is an immutable class representing information of either  *<CODE>author</CODE> or<CODE>editor</CODE> field in bibtex record.  *<p>  * Constructor performs parsing of raw field text and stores preformatted data.  * Various accessor methods return author/editor field in different formats.  *<p>  * Parsing algorithm is designed to satisfy two requirements:  * (a) when author's name is typed correctly, the result should  *     coincide with the one of BiBTeX;  * (b) for erroneous names, output should be reasonable (but may differ  *     from BiBTeX output).  * The following rules are used:  *<ol>  *<li> 'author field' is a sequence of tokens;  *<ul>  *<li> tokens are separated by sequences of whitespaces  *         (<CODE>Character.isWhitespace(c)==true</CODE>), commas (,),  *         dashes (-), and tildas (~);  *<li> every comma separates tokens, while sequences of other separators  *         are equivalent to a single separator; for example:  *         "a - b" consists of 2 tokens ("a" and "b"), while  *         "a,-,b" consists of 3 tokens ("a", "", and "b")  *<li> anything enclosed in braces belonges to a single token; for example:  *         "abc x{a,b,-~ c}x" consists of 2 tokens, while  *         "abc xa,b,-~ cx" consists of 4 tokens ("abc", "xa","b", and "cx");  *<li> a token followed immediately by a dash is "dash-terminated" token,  *         and all other tokens are "space-terminated" tokens; for example:  *         in "a-b- c - d" tokens "a" and "b" are dash-terminated and  *         "c" and "d" are space-terminated;  *<li> for the purposes of splitting of 'author name' into parts and  *         construction of abbreviation of first name,  *         one needs definitions of first latter of a token, case of a token,  *         and abbreviation of a token:  *<ul>  *<li> 'first letter' of a token is the first letter character  *              (<CODE>Character.isLetter(c)==true</CODE>) that does not  *              belong to a sequence of letters that immediately follows  *              "\" character, with one exception:  *              if "\" is followed by "aa", "AA", "ae", "AE", "l", "L", "o", "O",  *              "oe", "OE", "i", or "j" followed by non-letter, the 'first letter'  *              of a token is a letter that follows "\"; for example:  *              in "a{x}b" 'first letter' is "a",  *              in "{\"{U}}bel" 'first letter' is "U",  *              in "{\noopsort{\"o}}xyz" 'first letter' is "o",  *              in "{\AE}x" 'first letter' is "A",  *              in "\aex\ijk\Oe\j" 'first letter' is "j";  *              if there is no letter satisfying the above rule, 'first letter'  *              is undefined;  *<li> token is "lower-case" token, if its first letter id defined and  *              is lower-case (<CODE>Character.isLowerCase(c)==true</CODE>),  *              and token is "upper-case" token otherwise;  *<li> 'abbreviation' of a token is the shortest prefix of the token  *              that (a) contains 'first letter' and (b) is braces-balanced;  *              if 'first letter' is undefined, 'abbreviation' is the token  *              itself; in the above examples, 'abbreviation's are  *              "a", "{\"{U}}", "{\noopsort{\"o}}", "{\AE}", "\aex\ijk\Oe\j";  *</ul>  *<li> the behavior based on the above definitions will be erroneous only  *         in one case: if the first-name-token is "{\noopsort{A}}john",  *         we abbreviate it as "{\noopsort{A}}.", while BiBTeX produces "j.";  *         fixing this problem, however, requires processing of the preabmle;  *</ul>  *<li> 'author name's in 'author field' are subsequences of tokens separated  *      by token "and" ("and" is case-insensitive); if 'author name' is an  *      empty sequence of tokens, it is ignored; for examle, both  *      "John Smith and Peter Black" and "and and John Smith and and Peter Black"  *      consists of 2 'author name's "Johm Smith" and "Peter Black"  *      (in erroneous situations, this is a bit different from BiBTeX behavior);  *<li> 'author name' consists of 'first-part', 'von-part', 'last-part', and  *      'junior-part', each of which is a sequence of tokens;  *      how a sequence of tokens has to be splitted into these parts, depends  *      the number of commas:  *<ul>  *<li> no commas, all tokens are upper-case:  *          'junior-part' and 'von-part' are empty, 'last-part' consist  *          of the last token, 'first-part' consists of all other tokens  *          ('first-part' is empty, if 'author name' consists of a single token);  *          for example, in "John James Smith", 'last-part'="Smith" and  *          'first-part'="John James";  *<li> no commas, there exists lower-case token:  *          'junior-part' is empty, 'first-part' consists of all upper-case  *          tokens before the first lower-case token, 'von-part' consists of  *          lower-case tokens starting the first lower-case token and ending  *          the lower-case token that is followed by upper-case token,  *          'last-part' consists of the rest of tokens;  *          note that both 'first-part' and 'latst-part' may be empty and  *          'last-part' may contain lower-case tokens; for example:  *          in "von der", 'first-part'='last-part'="", 'von-part'="von der";  *          in "Charles Louis Xavier Joseph de la Vall{\'e}e la Poussin",  *          'first-part'="Charles Louis Xavier Joseph", 'von-part'="de la",  *          'last-part'="Vall{\'e}e la Poussin";  *<li> one comma:  *          'junior-part' is empty, 'first-part' consists of all tokens after comma,  *          'von-part' consists of the longest sequence of lower-case tokens  *          in the very beginning, 'last-part' consists of all tokens after  *          'von-part' and before comma; note that any part can be empty;  *          for example: in "de la Vall{\'e}e la Poussin, Charles Louis Xavier Joseph",  *          'first-part'="Charles Louis Xavier Joseph", 'von-part'="de la",  *          'last-part'="Vall{\'e}e la Poussin";  *          in "Joseph de la Vall{\'e}e la Poussin, Charles Louis Xavier",  *          'first-part'="Charles Louis Xavier", 'von-part'="",  *          'last-part'="Joseph de la Vall{\'e}e la Poussin";  *<li> two or more commas (any comma after the second one is ignored;  *          it merely separates tokens):  *          'junior-part' consists of all tokens between first and second commas,  *          'first-part' consists of all tokens after the second comma,  *          tokens before the first comma are splitted into 'von-part' and  *          'last-part' similarly to the case of one comma; for example:  *          in "de la Vall{\'e}e Poussin, Jr., Charles Louis Xavier Joseph",  *          'first-part'="Charles Louis Xavier Joseph", 'von-part'="de la",  *          'last-part'="Vall{\'e}e la Poussin", and 'junior-part'="Jr.";  *</ul>  *<li> when 'first-part', 'last-part', 'von-part', or 'junior-part' is reconstructed  *      from tokens, tokens in a part are separated either by space or by dash,  *      depending on whether the token before the separator was space-terminated  *      or dash-terminated; for the last token in a part it does not matter  *      whether it was dash- or space-terminated;  *<li> when 'first-part' is abbreviated, each token is replaced by its abbreviation  *      followed by a period; separators are the same as in the case of non-abbreviated  *      name; for example: in "Heinrich-{\"{U}}bel Kurt von Minich",  *      'first-part'="Heinrich-{\"{U}}bel Kurt", and its abbreviation is  *      "H.-{\"{U}}. K."  *</ol>  */
end_comment

begin_class
DECL|class|AuthorList
specifier|public
class|class
name|AuthorList
block|{
DECL|field|authors
specifier|private
name|Vector
name|authors
decl_stmt|;
comment|// of Author
comment|// Variables for storing computed strings, so they only need be created once:
DECL|field|authorsNatbib
DECL|field|authorsLastOnly
DECL|field|authorsLastFirst
DECL|field|authorLastFirstAnds
specifier|private
name|String
name|authorsNatbib
init|=
literal|null
decl_stmt|,
name|authorsLastOnly
init|=
literal|null
decl_stmt|,
name|authorsLastFirst
init|=
literal|null
decl_stmt|,
name|authorLastFirstAnds
init|=
literal|null
decl_stmt|,
DECL|field|authorsFirstFirst
DECL|field|authorsFirstFirstAnds
DECL|field|authorsAlph
name|authorsFirstFirst
init|=
literal|null
decl_stmt|,
name|authorsFirstFirstAnds
init|=
literal|null
decl_stmt|,
name|authorsAlph
init|=
literal|null
decl_stmt|;
comment|// The following variables are used only during parsing
DECL|field|orig
specifier|private
name|String
name|orig
decl_stmt|;
comment|// the raw bibtex author/editor field
comment|// the following variables are updated by getToken procedure
DECL|field|token_start
specifier|private
name|int
name|token_start
decl_stmt|;
comment|// index in orig
DECL|field|token_end
specifier|private
name|int
name|token_end
decl_stmt|;
comment|// to point 'abc' in '  abc xyz', start=2 and end=5
comment|// the following variables are valid only if getToken returns TOKEN_WORD
DECL|field|token_abbr
specifier|private
name|int
name|token_abbr
decl_stmt|;
comment|// end of token abbreviation (always: token_start< token_abbr<= token_end)
DECL|field|token_term
specifier|private
name|char
name|token_term
decl_stmt|;
comment|// either space or dash
DECL|field|token_case
specifier|private
name|boolean
name|token_case
decl_stmt|;
comment|// true if upper-case token, false if lower-case token
comment|// Tokens of one author name.
comment|// Each token occupies TGL consecutive entries in this vector (as described below)
DECL|field|tokens
specifier|private
name|Vector
name|tokens
decl_stmt|;
DECL|field|TOKEN_GROUP_LENGTH
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_GROUP_LENGTH
init|=
literal|4
decl_stmt|;
comment|// number of entries for a token
comment|// the following are offsets of an entry in a group of entries for one token
DECL|field|OFFSET_TOKEN
specifier|private
specifier|static
specifier|final
name|int
name|OFFSET_TOKEN
init|=
literal|0
decl_stmt|;
comment|// String -- token itself;
DECL|field|OFFSET_TOKEN_ABBR
specifier|private
specifier|static
specifier|final
name|int
name|OFFSET_TOKEN_ABBR
init|=
literal|1
decl_stmt|;
comment|// String -- token abbreviation;
DECL|field|OFFSET_TOKEN_TERM
specifier|private
specifier|static
specifier|final
name|int
name|OFFSET_TOKEN_TERM
init|=
literal|2
decl_stmt|;
comment|// Character -- token terminator (either " " or "-")
comment|//private static final int OFFSET_TOKEN_CASE = 3;    // Boolean -- true=uppercase, false=lowercase
comment|// the following are indices in 'tokens' vector created during parsing of author name
comment|// and later used to properly split author name into parts
DECL|field|von_start
name|int
name|von_start
decl_stmt|,
comment|// first lower-case token (-1 if all tokens upper-case)
DECL|field|last_start
name|last_start
decl_stmt|,
comment|// first upper-case token after first lower-case token (-1 if does not exist)
DECL|field|comma_first
name|comma_first
decl_stmt|,
comment|// token after first comma (-1 if no commas)
DECL|field|comma_second
name|comma_second
decl_stmt|;
comment|// token after second comma (-1 if no commas or only one comma)
comment|// Token types (returned by getToken procedure)
DECL|field|TOKEN_EOF
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_EOF
init|=
literal|0
decl_stmt|;
DECL|field|TOKEN_AND
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_AND
init|=
literal|1
decl_stmt|;
DECL|field|TOKEN_COMMA
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_COMMA
init|=
literal|2
decl_stmt|;
DECL|field|TOKEN_WORD
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_WORD
init|=
literal|3
decl_stmt|;
comment|// Constant Hashtable containing names of TeX special characters
DECL|field|tex_names
specifier|private
specifier|static
specifier|final
name|java
operator|.
name|util
operator|.
name|Hashtable
name|tex_names
init|=
operator|new
name|java
operator|.
name|util
operator|.
name|Hashtable
argument_list|()
decl_stmt|;
comment|// and static constructor to initialize it
static|static
block|{
name|tex_names
operator|.
name|put
argument_list|(
literal|"aa"
argument_list|,
literal|"aa"
argument_list|)
expr_stmt|;
comment|// only keys are important in this table
name|tex_names
operator|.
name|put
argument_list|(
literal|"ae"
argument_list|,
literal|"ae"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"l"
argument_list|,
literal|"l"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"o"
argument_list|,
literal|"o"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"oe"
argument_list|,
literal|"oe"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"i"
argument_list|,
literal|"i"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"AA"
argument_list|,
literal|"AA"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"AE"
argument_list|,
literal|"AE"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"L"
argument_list|,
literal|"L"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"O"
argument_list|,
literal|"O"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"OE"
argument_list|,
literal|"OE"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|put
argument_list|(
literal|"j"
argument_list|,
literal|"j"
argument_list|)
expr_stmt|;
block|}
DECL|field|authorCache
specifier|static
name|WeakHashMap
name|authorCache
init|=
operator|new
name|WeakHashMap
argument_list|()
decl_stmt|;
comment|/**      * Parses the parameter strings and stores preformatted author information.      * @param bibtex_authors contents of either<CODE>author</CODE> or      *<CODE>editor</CODE> bibtex field.      */
DECL|method|AuthorList (String bibtex_authors)
specifier|public
name|AuthorList
parameter_list|(
name|String
name|bibtex_authors
parameter_list|)
block|{
name|authors
operator|=
operator|new
name|Vector
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|// 5 seems to be reasonable initial size
name|orig
operator|=
name|bibtex_authors
expr_stmt|;
comment|// initialization
name|token_start
operator|=
literal|0
expr_stmt|;
name|token_end
operator|=
literal|0
expr_stmt|;
comment|// of parser
while|while
condition|(
name|token_start
operator|<
name|orig
operator|.
name|length
argument_list|()
condition|)
block|{
name|Author
name|author
init|=
name|getAuthor
argument_list|()
decl_stmt|;
if|if
condition|(
name|author
operator|!=
literal|null
condition|)
name|authors
operator|.
name|add
argument_list|(
name|author
argument_list|)
expr_stmt|;
block|}
comment|// clean-up
name|orig
operator|=
literal|null
expr_stmt|;
name|tokens
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|fixAuthor_Natbib (final String inOrig)
specifier|public
specifier|static
name|String
name|fixAuthor_Natbib
parameter_list|(
specifier|final
name|String
name|inOrig
parameter_list|)
block|{
name|AuthorList
name|authors
init|=
operator|new
name|AuthorList
argument_list|(
name|inOrig
argument_list|)
decl_stmt|;
return|return
name|authors
operator|.
name|getAuthorsNatbib
argument_list|()
return|;
block|}
DECL|method|getAuthorList (String inOrig)
specifier|public
specifier|static
name|AuthorList
name|getAuthorList
parameter_list|(
name|String
name|inOrig
parameter_list|)
block|{
name|Object
name|o
init|=
name|authorCache
operator|.
name|get
argument_list|(
name|inOrig
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
name|AuthorList
name|authors
init|=
operator|new
name|AuthorList
argument_list|(
name|inOrig
argument_list|)
decl_stmt|;
name|authorCache
operator|.
name|put
argument_list|(
name|inOrig
argument_list|,
name|authors
argument_list|)
expr_stmt|;
return|return
name|authors
return|;
block|}
else|else
return|return
operator|(
name|AuthorList
operator|)
name|o
return|;
block|}
DECL|method|fixAuthor_firstNameFirstCommas (final String inOrig, final boolean abbr)
specifier|public
specifier|static
name|String
name|fixAuthor_firstNameFirstCommas
parameter_list|(
specifier|final
name|String
name|inOrig
parameter_list|,
specifier|final
name|boolean
name|abbr
parameter_list|)
block|{
name|AuthorList
name|authors
init|=
name|getAuthorList
argument_list|(
name|inOrig
argument_list|)
decl_stmt|;
return|return
name|authors
operator|.
name|getAuthorsFirstFirst
argument_list|(
name|abbr
argument_list|)
return|;
block|}
DECL|method|fixAuthor_firstNameFirst (final String inOrig)
specifier|public
specifier|static
name|String
name|fixAuthor_firstNameFirst
parameter_list|(
specifier|final
name|String
name|inOrig
parameter_list|)
block|{
name|AuthorList
name|authors
init|=
name|getAuthorList
argument_list|(
name|inOrig
argument_list|)
decl_stmt|;
return|return
name|authors
operator|.
name|getAuthorsFirstFirstAnds
argument_list|()
return|;
block|}
DECL|method|fixAuthor_lastNameFirstCommas (final String inOrig, final boolean abbr)
specifier|public
specifier|static
name|String
name|fixAuthor_lastNameFirstCommas
parameter_list|(
specifier|final
name|String
name|inOrig
parameter_list|,
specifier|final
name|boolean
name|abbr
parameter_list|)
block|{
name|AuthorList
name|authors
init|=
name|getAuthorList
argument_list|(
name|inOrig
argument_list|)
decl_stmt|;
return|return
name|authors
operator|.
name|getAuthorsLastFirst
argument_list|(
name|abbr
argument_list|)
return|;
block|}
DECL|method|fixAuthor_lastNameFirst (final String inOrig)
specifier|public
specifier|static
name|String
name|fixAuthor_lastNameFirst
parameter_list|(
specifier|final
name|String
name|inOrig
parameter_list|)
block|{
name|AuthorList
name|authors
init|=
name|getAuthorList
argument_list|(
name|inOrig
argument_list|)
decl_stmt|;
return|return
name|authors
operator|.
name|getAuthorsLastFirstAnds
argument_list|()
return|;
block|}
DECL|method|fixAuthor_lastNameOnlyCommas (final String inOrig)
specifier|public
specifier|static
name|String
name|fixAuthor_lastNameOnlyCommas
parameter_list|(
specifier|final
name|String
name|inOrig
parameter_list|)
block|{
name|AuthorList
name|authors
init|=
name|getAuthorList
argument_list|(
name|inOrig
argument_list|)
decl_stmt|;
return|return
name|authors
operator|.
name|getAuthorsLastOnly
argument_list|()
return|;
block|}
DECL|method|fixAuthorForAlphabetization (final String inOrig)
specifier|public
specifier|static
name|String
name|fixAuthorForAlphabetization
parameter_list|(
specifier|final
name|String
name|inOrig
parameter_list|)
block|{
name|AuthorList
name|authors
init|=
name|getAuthorList
argument_list|(
name|inOrig
argument_list|)
decl_stmt|;
return|return
name|authors
operator|.
name|getAuthorsForAlphabetization
argument_list|()
return|;
block|}
comment|/**      * Parses one author name and returns preformatted information.      * @return Preformatted author name;<CODE>null</CODE> if author name is empty.      */
DECL|method|getAuthor ()
specifier|private
name|Author
name|getAuthor
parameter_list|()
block|{
name|tokens
operator|=
operator|new
name|Vector
argument_list|()
expr_stmt|;
comment|// initialization
name|von_start
operator|=
operator|-
literal|1
expr_stmt|;
name|last_start
operator|=
operator|-
literal|1
expr_stmt|;
name|comma_first
operator|=
operator|-
literal|1
expr_stmt|;
name|comma_second
operator|=
operator|-
literal|1
expr_stmt|;
comment|// First step: collect tokens in 'tokens' Vector and calculate indices
name|token_loop
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|token
init|=
name|getToken
argument_list|()
decl_stmt|;
name|cases
label|:
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|TOKEN_EOF
case|:
case|case
name|TOKEN_AND
case|:
break|break
name|token_loop
break|;
case|case
name|TOKEN_COMMA
case|:
if|if
condition|(
name|comma_first
operator|<
literal|0
condition|)
name|comma_first
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|comma_second
operator|<
literal|0
condition|)
name|comma_second
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
break|break
name|cases
break|;
case|case
name|TOKEN_WORD
case|:
name|tokens
operator|.
name|add
argument_list|(
name|orig
operator|.
name|substring
argument_list|(
name|token_start
argument_list|,
name|token_end
argument_list|)
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|orig
operator|.
name|substring
argument_list|(
name|token_start
argument_list|,
name|token_abbr
argument_list|)
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
operator|new
name|Character
argument_list|(
name|token_term
argument_list|)
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|Boolean
operator|.
name|valueOf
argument_list|(
name|token_case
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|comma_first
operator|>=
literal|0
condition|)
break|break
name|cases
break|;
if|if
condition|(
name|last_start
operator|>=
literal|0
condition|)
break|break
name|cases
break|;
if|if
condition|(
name|von_start
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|token_case
condition|)
block|{
name|von_start
operator|=
name|tokens
operator|.
name|size
argument_list|()
operator|-
name|TOKEN_GROUP_LENGTH
expr_stmt|;
break|break
name|cases
break|;
block|}
block|}
elseif|else
if|if
condition|(
name|last_start
operator|<
literal|0
operator|&&
name|token_case
condition|)
block|{
name|last_start
operator|=
name|tokens
operator|.
name|size
argument_list|()
operator|-
name|TOKEN_GROUP_LENGTH
expr_stmt|;
break|break
name|cases
break|;
block|}
block|}
block|}
comment|// end token_loop
comment|// Second step: split name into parts (here: calculate indices
comment|// of parts in 'tokens' Vector)
if|if
condition|(
name|tokens
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
comment|// no author information
comment|// the following negatives indicate absence of the corresponding part
name|int
name|first_part_start
init|=
operator|-
literal|1
decl_stmt|,
name|von_part_start
init|=
operator|-
literal|1
decl_stmt|,
name|last_part_start
init|=
operator|-
literal|1
decl_stmt|,
name|jr_part_start
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|first_part_end
init|=
literal|0
decl_stmt|,
name|von_part_end
init|=
literal|0
decl_stmt|,
name|last_part_end
init|=
literal|0
decl_stmt|,
name|jr_part_end
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|comma_first
operator|<
literal|0
condition|)
block|{
comment|// no commas
if|if
condition|(
name|von_start
operator|<
literal|0
condition|)
block|{
comment|// no 'von part'
name|last_part_end
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
name|last_part_start
operator|=
name|tokens
operator|.
name|size
argument_list|()
operator|-
name|TOKEN_GROUP_LENGTH
expr_stmt|;
name|first_part_end
operator|=
name|last_part_start
expr_stmt|;
if|if
condition|(
name|first_part_end
operator|>
literal|0
condition|)
name|first_part_start
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// 'von part' is present
if|if
condition|(
name|last_start
operator|>=
literal|0
condition|)
block|{
name|last_part_end
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
name|last_part_start
operator|=
name|last_start
expr_stmt|;
name|von_part_end
operator|=
name|last_part_start
expr_stmt|;
block|}
else|else
block|{
name|von_part_end
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|von_part_start
operator|=
name|von_start
expr_stmt|;
name|first_part_end
operator|=
name|von_part_start
expr_stmt|;
if|if
condition|(
name|first_part_end
operator|>
literal|0
condition|)
name|first_part_start
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// commas are present: it affects only 'first part' and 'junior part'
name|first_part_end
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|comma_second
operator|<
literal|0
condition|)
block|{
comment|// one comma
if|if
condition|(
name|comma_first
operator|<
name|first_part_end
condition|)
name|first_part_start
operator|=
name|comma_first
expr_stmt|;
block|}
else|else
block|{
comment|// two or more commas
if|if
condition|(
name|comma_second
operator|<
name|first_part_end
condition|)
name|first_part_start
operator|=
name|comma_second
expr_stmt|;
name|jr_part_end
operator|=
name|comma_second
expr_stmt|;
if|if
condition|(
name|comma_first
operator|<
name|jr_part_end
condition|)
name|jr_part_start
operator|=
name|comma_first
expr_stmt|;
block|}
if|if
condition|(
name|von_start
operator|!=
literal|0
condition|)
block|{
comment|// no 'von part'
name|last_part_end
operator|=
name|comma_first
expr_stmt|;
if|if
condition|(
name|last_part_end
operator|>
literal|0
condition|)
name|last_part_start
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// 'von part' is present
if|if
condition|(
name|last_start
operator|<
literal|0
condition|)
block|{
name|von_part_end
operator|=
name|comma_first
expr_stmt|;
block|}
else|else
block|{
name|last_part_end
operator|=
name|comma_first
expr_stmt|;
name|last_part_start
operator|=
name|last_start
expr_stmt|;
name|von_part_end
operator|=
name|last_part_start
expr_stmt|;
block|}
name|von_part_start
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// Third step: do actual splitting, construct Author object
return|return
operator|new
name|Author
argument_list|(
operator|(
name|first_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|first_part_start
argument_list|,
name|first_part_end
argument_list|,
name|OFFSET_TOKEN
argument_list|,
literal|false
argument_list|)
operator|)
argument_list|,
operator|(
name|first_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|first_part_start
argument_list|,
name|first_part_end
argument_list|,
name|OFFSET_TOKEN_ABBR
argument_list|,
literal|true
argument_list|)
operator|)
argument_list|,
operator|(
name|von_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|von_part_start
argument_list|,
name|von_part_end
argument_list|,
name|OFFSET_TOKEN
argument_list|,
literal|false
argument_list|)
operator|)
argument_list|,
operator|(
name|last_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|last_part_start
argument_list|,
name|last_part_end
argument_list|,
name|OFFSET_TOKEN
argument_list|,
literal|false
argument_list|)
operator|)
argument_list|,
operator|(
name|jr_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|jr_part_start
argument_list|,
name|jr_part_end
argument_list|,
name|OFFSET_TOKEN
argument_list|,
literal|false
argument_list|)
operator|)
argument_list|)
return|;
block|}
comment|/**      * Concatenates list of tokens from 'tokens' Vector.      * Tokens are separated by spaces or dashes, dependeing on stored in 'tokens'.      * Callers always ensure that start< end; thus, there exists at least      * one token to be concatenated.      * @param start index of the first token to be concatenated in 'tokens' Vector      * (always divisible by TOKEN_GROUP_LENGTH).      * @param end index of the first token not to be concatenated in 'tokens' Vector      * (always divisible by TOKEN_GROUP_LENGTH).      * @param offset offset within token group (used to request concatenation of      * either full tokens or abbreviation).      * @param dot_after<CODE>true</CODE> -- add period after each token,      *<CODE>false</CODE> -- do not add.      * @return the result of concatenation.      */
DECL|method|concatTokens (int start, int end, int offset, boolean dot_after)
specifier|private
name|String
name|concatTokens
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|offset
parameter_list|,
name|boolean
name|dot_after
parameter_list|)
block|{
name|StringBuffer
name|res
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
comment|// Here we always have start< end
name|res
operator|.
name|append
argument_list|(
operator|(
name|String
operator|)
name|tokens
operator|.
name|get
argument_list|(
name|start
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot_after
condition|)
name|res
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|start
operator|+=
name|TOKEN_GROUP_LENGTH
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|tokens
operator|.
name|get
argument_list|(
name|start
operator|-
name|TOKEN_GROUP_LENGTH
operator|+
name|OFFSET_TOKEN_TERM
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
operator|(
name|String
operator|)
name|tokens
operator|.
name|get
argument_list|(
name|start
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot_after
condition|)
name|res
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|start
operator|+=
name|TOKEN_GROUP_LENGTH
expr_stmt|;
block|}
return|return
name|res
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Parses the next token.      *<p>      * The string being parsed is stored in global variable<CODE>orig</CODE>,      * and position which parsing has to start from is stored in global      * variable<CODE>token_end</CODE>; thus,<CODE>token_end</CODE> has to be      * set to 0 before the first invocation. Procedure updates<CODE>token_end</CODE>;      * thus, subsequent invocations do not require any additional variable settings.      *<p>      * The type of the token is returned; if it is<CODE>TOKEN_WORD</CODE>, additional      * information is given  in global variables<CODE>token_start</CODE>,<CODE>token_end</CODE>,      *<CODE>token_abbr</CODE>,<CODE>token_term</CODE>, and<CODE>token_case</CODE>;      * namely:<CODE>orig.substring(token_start,token_end)</CODE> is the thext of the token,      *<CODE>orig.substring(token_start,token_abbr)</CODE> is the token abbreviation,      *<CODE>token_term</CODE> contains token terminator (space or dash),      * and<CODE>token_case</CODE> is<CODE>true</CODE>, if token is upper-case      * and<CODE>false</CODE> if token is lower-case.      * @return<CODE>TOKEN_EOF</CODE> -- no more tokens,      *<CODE>TOKEN_COMMA</CODE> -- token is comma,      *<CODE>TOKEN_AND</CODE> -- token is the word "and" (or "And", or "aND", etc.),      *<CODE>TOKEN_WORD</CODE> -- token is a word; additional information is given      * in global variables<CODE>token_start</CODE>,<CODE>token_end</CODE>,      *<CODE>token_abbr</CODE>,<CODE>token_term</CODE>, and<CODE>token_case</CODE>.      */
DECL|method|getToken ()
specifier|private
name|int
name|getToken
parameter_list|()
block|{
name|token_start
operator|=
name|token_end
expr_stmt|;
while|while
condition|(
name|token_start
operator|<
name|orig
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|orig
operator|.
name|charAt
argument_list|(
name|token_start
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|==
literal|'~'
operator|||
name|c
operator|==
literal|'-'
operator|||
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|)
condition|)
break|break;
name|token_start
operator|++
expr_stmt|;
block|}
name|token_end
operator|=
name|token_start
expr_stmt|;
if|if
condition|(
name|token_start
operator|>=
name|orig
operator|.
name|length
argument_list|()
condition|)
return|return
name|TOKEN_EOF
return|;
if|if
condition|(
name|orig
operator|.
name|charAt
argument_list|(
name|token_start
argument_list|)
operator|==
literal|','
condition|)
block|{
name|token_end
operator|++
expr_stmt|;
return|return
name|TOKEN_COMMA
return|;
block|}
name|token_abbr
operator|=
operator|-
literal|1
expr_stmt|;
name|token_term
operator|=
literal|' '
expr_stmt|;
name|token_case
operator|=
literal|true
expr_stmt|;
name|int
name|braces_level
init|=
literal|0
decl_stmt|;
name|int
name|current_backslash
init|=
operator|-
literal|1
decl_stmt|;
name|boolean
name|first_letter_is_found
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|token_end
operator|<
name|orig
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|orig
operator|.
name|charAt
argument_list|(
name|token_end
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
name|braces_level
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|braces_level
operator|>
literal|0
condition|)
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|braces_level
operator|--
expr_stmt|;
if|if
condition|(
name|first_letter_is_found
operator|&&
name|token_abbr
operator|<
literal|0
operator|&&
name|braces_level
operator|==
literal|0
condition|)
name|token_abbr
operator|=
name|token_end
expr_stmt|;
if|if
condition|(
operator|!
name|first_letter_is_found
operator|&&
name|current_backslash
operator|<
literal|0
operator|&&
name|Character
operator|.
name|isLetter
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|token_case
operator|=
name|Character
operator|.
name|isUpperCase
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|first_letter_is_found
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|current_backslash
operator|>=
literal|0
operator|&&
operator|!
name|Character
operator|.
name|isLetter
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first_letter_is_found
condition|)
block|{
name|String
name|tex_cmd_name
init|=
name|orig
operator|.
name|substring
argument_list|(
name|current_backslash
operator|+
literal|1
argument_list|,
name|token_end
argument_list|)
decl_stmt|;
if|if
condition|(
name|tex_names
operator|.
name|get
argument_list|(
name|tex_cmd_name
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|token_case
operator|=
name|Character
operator|.
name|isUpperCase
argument_list|(
name|tex_cmd_name
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|first_letter_is_found
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|current_backslash
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|current_backslash
operator|=
name|token_end
expr_stmt|;
if|if
condition|(
name|braces_level
operator|==
literal|0
condition|)
if|if
condition|(
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|'~'
operator|||
comment|/*c=='-' ||*/
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
comment|// Morten Alver 18 Apr 2006: Removed check for hyphen '-' above to prevent
comment|// problems with names like Bailey-Jones getting broken up and sorted wrong.
name|token_end
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|token_abbr
operator|<
literal|0
condition|)
name|token_abbr
operator|=
name|token_end
expr_stmt|;
if|if
condition|(
name|token_end
operator|<
name|orig
operator|.
name|length
argument_list|()
operator|&&
name|orig
operator|.
name|charAt
argument_list|(
name|token_end
argument_list|)
operator|==
literal|'-'
condition|)
name|token_term
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|orig
operator|.
name|substring
argument_list|(
name|token_start
argument_list|,
name|token_end
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"and"
argument_list|)
condition|)
return|return
name|TOKEN_AND
return|;
else|else
return|return
name|TOKEN_WORD
return|;
block|}
comment|/**      * Returns the number of author names in this object.      * @return the number of author names in this object.      */
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|authors
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Returns the<CODE>Author</CODE> object for ith author.      * @param i index of the author (from 0 to<CODE>size()-1</CODE>).      * @return the<CODE>Author</CODE> object.      */
DECL|method|getAuthor (int i)
specifier|public
name|Author
name|getAuthor
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
operator|(
name|Author
operator|)
name|authors
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/**      * Returns the list of authors in "natbib" format.      *<p>      * "John Smith" ==> "Smith";      * "John Smith and Black Brown, Peter" ==> "Smith and Black Brown";      * "John von Neumann and John Smith and Black Brown, Peter" ==> "von Neumann et al.".      * @return formatted list of authors.      */
DECL|method|getAuthorsNatbib ()
specifier|public
name|String
name|getAuthorsNatbib
parameter_list|()
block|{
comment|// Check if we've computed this before:
if|if
condition|(
name|authorsNatbib
operator|!=
literal|null
condition|)
return|return
name|authorsNatbib
return|;
name|StringBuffer
name|res
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getLastOnly
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|1
argument_list|)
operator|.
name|getLastOnly
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" et al."
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsNatbib
operator|=
name|res
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsNatbib
return|;
block|}
comment|/**      * Returns the list of authors separated by commas with last name only;      * If the list consists of three or more authors, "and" is inserted before      * the last author's name.      *<p>      * "John Smith" ==> "Smith";      * "John Smith and Black Brown, Peter" ==> "Smith and Black Brown" ;      * "John von Neumann and John Smith and Black Brown, Peter" ==>      * "von Neumann, Smith and Black Brown".      * @return formatted list of authors.      */
DECL|method|getAuthorsLastOnly ()
specifier|public
name|String
name|getAuthorsLastOnly
parameter_list|()
block|{
comment|// Check if we've computed this before:
if|if
condition|(
name|authorsLastOnly
operator|!=
literal|null
condition|)
return|return
name|authorsLastOnly
return|;
name|StringBuffer
name|res
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getLastOnly
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getLastOnly
argument_list|()
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|size
argument_list|()
operator|>
literal|2
condition|)
name|res
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getLastOnly
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsLastOnly
operator|=
name|res
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsLastOnly
return|;
block|}
comment|/**      * Returns the list of authors separated by commas with first names after last name;      * first names are abbreviated or not depending on parameter.      * If the list consists of three or more authors, "and" is inserted before      * the last author's name.      *<p>      * "John Smith" ==> "Smith, John" or "Smith, J.";      * "John Smith and Black Brown, Peter" ==>      * "Smith, John and Black Brown, Peter" or "Smith, J. and Black Brown, P.";      * "John von Neumann and John Smith and Black Brown, Peter" ==>      * "von Neumann, John, Smith, John and Black Brown, Peter" or      * "von Neumann, J., Smith, J. and Black Brown, P.".      * @param abbr<CODE>true</CODE> -- abbreviate first names,      *<CODE>false</CODE> -- do not abbreviate.      * @return formatted list of authors.      */
DECL|method|getAuthorsLastFirst (boolean abbr)
specifier|public
name|String
name|getAuthorsLastFirst
parameter_list|(
name|boolean
name|abbr
parameter_list|)
block|{
comment|// Check if we've computed this before:
if|if
condition|(
name|authorsLastFirst
operator|!=
literal|null
condition|)
return|return
name|authorsLastFirst
return|;
name|StringBuffer
name|res
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getLastFirst
argument_list|(
name|abbr
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getLastFirst
argument_list|(
name|abbr
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|size
argument_list|()
operator|>
literal|2
condition|)
name|res
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getLastFirst
argument_list|(
name|abbr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsLastFirst
operator|=
name|res
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsLastFirst
return|;
block|}
comment|/**      * Returns the list of authors separated by "and"s with first names after last name;      * first names are not abbreviated.      *<p>      * "John Smith" ==> "Smith, John";      * "John Smith and Black Brown, Peter" ==> "Smith, John and Black Brown, Peter";      * "John von Neumann and John Smith and Black Brown, Peter" ==>      * "von Neumann, John and Smith, John and Black Brown, Peter".      * @return formatted list of authors.      */
DECL|method|getAuthorsLastFirstAnds ()
specifier|public
name|String
name|getAuthorsLastFirstAnds
parameter_list|()
block|{
comment|// Check if we've computed this before:
if|if
condition|(
name|authorLastFirstAnds
operator|!=
literal|null
condition|)
return|return
name|authorLastFirstAnds
return|;
name|StringBuffer
name|res
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getLastFirst
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getLastFirst
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|authorLastFirstAnds
operator|=
name|res
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorLastFirstAnds
return|;
block|}
comment|/**      * Returns the list of authors separated by commas with first names before last name;      * first names are abbreviated or not depending on parameter.      * If the list consists of three or more authors, "and" is inserted before      * the last author's name.      *<p>      * "John Smith" ==> "John Smith" or "J. Smith";      * "John Smith and Black Brown, Peter" ==>      * "John Smith and Peter Black Brown" or "J. Smith and P. Black Brown";      * "John von Neumann and John Smith and Black Brown, Peter" ==>      * "John von Neumann, John Smith and Peter Black Brown" or      * "J. von Neumann, J. Smith and P. Black Brown".      * @param abbr<CODE>true</CODE> -- abbreviate first names,      *<CODE>false</CODE> -- do not abbreviate.      * @return formatted list of authors.      */
DECL|method|getAuthorsFirstFirst (boolean abbr)
specifier|public
name|String
name|getAuthorsFirstFirst
parameter_list|(
name|boolean
name|abbr
parameter_list|)
block|{
comment|// Check if we've computed this before:
if|if
condition|(
name|authorsFirstFirst
operator|!=
literal|null
condition|)
return|return
name|authorsFirstFirst
return|;
name|StringBuffer
name|res
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getFirstLast
argument_list|(
name|abbr
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getFirstLast
argument_list|(
name|abbr
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|size
argument_list|()
operator|>
literal|2
condition|)
name|res
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getFirstLast
argument_list|(
name|abbr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsFirstFirst
operator|=
name|res
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsFirstFirst
return|;
block|}
comment|/**      * Returns the list of authors separated by "and"s with first names before last name;      * first names are not abbreviated.      *<p>      * "John Smith" ==> "John Smith";      * "John Smith and Black Brown, Peter" ==> "John Smith and Peter Black Brown";      * "John von Neumann and John Smith and Black Brown, Peter" ==>      * "John von Neumann and John Smith and Peter Black Brown".      * @return formatted list of authors.      */
DECL|method|getAuthorsFirstFirstAnds ()
specifier|public
name|String
name|getAuthorsFirstFirstAnds
parameter_list|()
block|{
comment|// Check if we've computed this before:
if|if
condition|(
name|authorsFirstFirstAnds
operator|!=
literal|null
condition|)
return|return
name|authorsFirstFirstAnds
return|;
name|StringBuffer
name|res
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getFirstLast
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getFirstLast
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsFirstFirstAnds
operator|=
name|res
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsFirstFirstAnds
return|;
block|}
comment|/**      * Returns the list of authors in a form suitable for alphabetization. This means that      * last names come first, never preceded by "von" particles, and that any braces are      * removed. First names are abbreviated so the same name is treated similarly if abbreviated      * in one case and not in another.      * This form is not intended to be suitable for presentation, only for sorting.      *      *<p>      * "John Smith" ==> "Smith, J.";      * "John von Neumann      * @return formatted list of authors      */
DECL|method|getAuthorsForAlphabetization ()
specifier|public
name|String
name|getAuthorsForAlphabetization
parameter_list|()
block|{
if|if
condition|(
name|authorsAlph
operator|!=
literal|null
condition|)
return|return
name|authorsAlph
return|;
name|StringBuffer
name|res
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getNameForAlphabetization
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getNameForAlphabetization
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsAlph
operator|=
name|res
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsAlph
return|;
block|}
comment|/**      *  This is an immutable class that keeps information regarding single author.      *  It is just a container for the information, with very simple methods      *  to access it.      *<p>      *  Current usage: only methods<code>getLastOnly</code>,      *<code>getFirstLast</code>, and<code>getLastFirst</code> are used;      *  all other methods are provided for completeness.      */
DECL|class|Author
specifier|private
specifier|static
class|class
name|Author
block|{
DECL|field|first_part
specifier|private
specifier|final
name|String
name|first_part
decl_stmt|;
DECL|field|first_abbr
specifier|private
specifier|final
name|String
name|first_abbr
decl_stmt|;
DECL|field|von_part
specifier|private
specifier|final
name|String
name|von_part
decl_stmt|;
DECL|field|last_part
specifier|private
specifier|final
name|String
name|last_part
decl_stmt|;
DECL|field|jr_part
specifier|private
specifier|final
name|String
name|jr_part
decl_stmt|;
comment|/**          * Creates the Author object.          * If any part of the name is absent,<CODE>null</CODE> must be passes;          * otherwise other methods may return erroneous results.          * @param first the first name of the author (may consist of several tokens,          * like "Charles Louis Xavier Joseph" in          * "Charles Louis Xavier Joseph de la Vall{\'e}e Poussin")          * @param firstabbr the abbreviated first name of the author (may consist          * of several tokens, like "C. L. X. J." in          * "Charles Louis Xavier Joseph de la Vall{\'e}e Poussin").          * It is a responsibility of the caller to create a reasonable          * abbreviation of the first name.          * @param von the von part of the author's name (may consist of          * several tokens, like "de la" in          * "Charles Louis Xavier Joseph de la Vall{\'e}e Poussin")          * @param last the lats name of the author (may consist of several tokens,          * like "Vall{\'e}e Poussin" in          * "Charles Louis Xavier Joseph de la Vall{\'e}e Poussin")          * @param jr the junior part of the author's name (may consist of          * several tokens, like "Jr. III" in          * "Smith, Jr. III, John")          */
DECL|method|Author (String first, String firstabbr, String von, String last, String jr)
specifier|public
name|Author
parameter_list|(
name|String
name|first
parameter_list|,
name|String
name|firstabbr
parameter_list|,
name|String
name|von
parameter_list|,
name|String
name|last
parameter_list|,
name|String
name|jr
parameter_list|)
block|{
name|first_part
operator|=
name|first
expr_stmt|;
name|first_abbr
operator|=
name|firstabbr
expr_stmt|;
name|von_part
operator|=
name|von
expr_stmt|;
name|last_part
operator|=
name|last
expr_stmt|;
name|jr_part
operator|=
name|jr
expr_stmt|;
block|}
comment|/**          * Retunrns the first name of the author stored in this object.          * @return first name of the author (may consist of several tokens)          */
DECL|method|getFirst ()
specifier|public
name|String
name|getFirst
parameter_list|()
block|{
return|return
name|first_part
return|;
block|}
comment|/**          * Retunrns the abbreviated first name of the author stored in this object.          * @return abbreviated first name of the author (may consist of several tokens)          */
DECL|method|getFirstAbbr ()
specifier|public
name|String
name|getFirstAbbr
parameter_list|()
block|{
return|return
name|first_abbr
return|;
block|}
comment|/**          * Retunrns the von part of the author's name stored in this object.          * @return von part of the author's name (may consist of several tokens)          */
DECL|method|getVon ()
specifier|public
name|String
name|getVon
parameter_list|()
block|{
return|return
name|von_part
return|;
block|}
comment|/**          * Retunrns the last name of the author stored in this object.          * @return last name of the author (may consist of several tokens)          */
DECL|method|getLast ()
specifier|public
name|String
name|getLast
parameter_list|()
block|{
return|return
name|last_part
return|;
block|}
comment|/**          * Retunrns the junior part of the author's name stored in this object.          * @return junior part of the author's name (may consist of several tokens)          */
DECL|method|getJr ()
specifier|public
name|String
name|getJr
parameter_list|()
block|{
return|return
name|jr_part
return|;
block|}
comment|/**          * Returns von part followed by last name.          * If both fields were specified as<CODE>null</CODE>,          * the empty string<CODE>""</CODE> is returned.          * @return 'von Last'          */
DECL|method|getLastOnly ()
specifier|public
name|String
name|getLastOnly
parameter_list|()
block|{
if|if
condition|(
name|von_part
operator|==
literal|null
condition|)
block|{
return|return
operator|(
name|last_part
operator|==
literal|null
condition|?
literal|""
else|:
name|last_part
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|last_part
operator|==
literal|null
condition|?
name|von_part
else|:
name|von_part
operator|+
literal|" "
operator|+
name|last_part
operator|)
return|;
block|}
block|}
comment|/**          * Returns the author's name in form 'von Last, Jr., First' with the first name          * full or abbreviated depending on parameter.          * @param abbr<CODE>true</CODE> - abbreviate first name,          *<CODE>false</CODE> - do not abbreviate          * @return 'von Last, Jr., First' (if<CODE>abbr==false</CODE>) or          * 'von Last, Jr., F.' (if<CODE>abbr==true</CODE>)          */
DECL|method|getLastFirst (boolean abbr)
specifier|public
name|String
name|getLastFirst
parameter_list|(
name|boolean
name|abbr
parameter_list|)
block|{
name|String
name|res
init|=
name|getLastOnly
argument_list|()
decl_stmt|;
if|if
condition|(
name|jr_part
operator|!=
literal|null
condition|)
name|res
operator|+=
literal|", "
operator|+
name|jr_part
expr_stmt|;
if|if
condition|(
name|abbr
condition|)
block|{
if|if
condition|(
name|first_abbr
operator|!=
literal|null
condition|)
name|res
operator|+=
literal|", "
operator|+
name|first_abbr
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|first_part
operator|!=
literal|null
condition|)
name|res
operator|+=
literal|", "
operator|+
name|first_part
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
comment|/**          * Returns the author's name in form 'First von Last, Jr.' with the first name          * full or abbreviated depending on parameter.          * @param abbr<CODE>true</CODE> - abbreviate first name,          *<CODE>false</CODE> - do not abbreviate          * @return 'First von Last, Jr.' (if<CODE>abbr==false</CODE>) or          * 'F. von Last, Jr.' (if<CODE>abbr==true</CODE>)          */
DECL|method|getFirstLast (boolean abbr)
specifier|public
name|String
name|getFirstLast
parameter_list|(
name|boolean
name|abbr
parameter_list|)
block|{
name|String
name|res
init|=
name|getLastOnly
argument_list|()
decl_stmt|;
if|if
condition|(
name|abbr
condition|)
block|{
name|res
operator|=
operator|(
name|first_abbr
operator|==
literal|null
condition|?
literal|""
else|:
name|first_abbr
operator|+
literal|" "
operator|)
operator|+
name|res
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
operator|(
name|first_part
operator|==
literal|null
condition|?
literal|""
else|:
name|first_part
operator|+
literal|" "
operator|)
operator|+
name|res
expr_stmt|;
block|}
if|if
condition|(
name|jr_part
operator|!=
literal|null
condition|)
name|res
operator|+=
literal|", "
operator|+
name|jr_part
expr_stmt|;
return|return
name|res
return|;
block|}
DECL|method|getNameForAlphabetization ()
specifier|public
name|String
name|getNameForAlphabetization
parameter_list|()
block|{
name|StringBuffer
name|res
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|last_part
operator|!=
literal|null
condition|)
name|res
operator|.
name|append
argument_list|(
name|last_part
argument_list|)
expr_stmt|;
if|if
condition|(
name|jr_part
operator|!=
literal|null
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|jr_part
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|first_abbr
operator|!=
literal|null
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|first_abbr
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|res
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|res
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'{'
operator|)
condition|)
name|res
operator|.
name|deleteCharAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|res
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|//end Author
block|}
end_class

begin_comment
comment|//end AuthorList
end_comment

end_unit

