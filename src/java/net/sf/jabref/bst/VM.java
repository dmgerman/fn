begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|net.sf.jabref.bst
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|bst
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|AuthorList
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexDatabase
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|CommonTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|Tree
import|;
end_import

begin_comment
comment|/**  *   * A Bibtex Virtual machine that can execute .bst files.  *   * Documentation can be found in the original bibtex distribution:  *   * http://texcatalogue.sarovar.org/entries/bibtex.html#Download  *   * @author $Author$  * @version $Revision$ ($Date$)  *   */
end_comment

begin_class
DECL|class|VM
specifier|public
class|class
name|VM
implements|implements
name|Warn
block|{
DECL|field|out
name|PrintStream
name|out
init|=
name|System
operator|.
name|out
decl_stmt|;
DECL|class|Identifier
specifier|public
class|class
name|Identifier
block|{
DECL|field|name
specifier|public
name|String
name|name
decl_stmt|;
DECL|method|Identifier (String name)
specifier|public
name|Identifier
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
block|}
DECL|class|Variable
specifier|public
class|class
name|Variable
block|{
DECL|field|name
specifier|public
name|String
name|name
decl_stmt|;
DECL|method|Variable (String name)
specifier|public
name|Variable
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
block|}
DECL|interface|BstFunction
specifier|public
interface|interface
name|BstFunction
block|{
DECL|method|execute (BstEntry context)
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
function_decl|;
block|}
DECL|field|FALSE
specifier|public
specifier|static
specifier|final
name|Integer
name|FALSE
init|=
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|TRUE
specifier|public
specifier|static
specifier|final
name|Integer
name|TRUE
init|=
operator|new
name|Integer
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|field|buildInFunctions
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|BstFunction
argument_list|>
name|buildInFunctions
decl_stmt|;
DECL|field|file
specifier|public
name|File
name|file
decl_stmt|;
DECL|method|VM (File f)
specifier|public
name|VM
parameter_list|(
name|File
name|f
parameter_list|)
throws|throws
name|RecognitionException
throws|,
name|IOException
block|{
name|this
argument_list|(
operator|new
name|ANTLRFileStream
argument_list|(
name|f
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|file
operator|=
name|f
expr_stmt|;
block|}
DECL|method|VM (String s)
specifier|public
name|VM
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|RecognitionException
block|{
name|this
argument_list|(
operator|new
name|ANTLRStringStream
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|charStream2CommonTree (CharStream bst)
specifier|public
specifier|static
name|CommonTree
name|charStream2CommonTree
parameter_list|(
name|CharStream
name|bst
parameter_list|)
throws|throws
name|RecognitionException
block|{
name|BstLexer
name|lex
init|=
operator|new
name|BstLexer
argument_list|(
name|bst
argument_list|)
decl_stmt|;
name|CommonTokenStream
name|tokens
init|=
operator|new
name|CommonTokenStream
argument_list|(
name|lex
argument_list|)
decl_stmt|;
name|BstParser
name|parser
init|=
operator|new
name|BstParser
argument_list|(
name|tokens
argument_list|)
decl_stmt|;
name|BstParser
operator|.
name|program_return
name|r
init|=
name|parser
operator|.
name|program
argument_list|()
decl_stmt|;
return|return
operator|(
name|CommonTree
operator|)
name|r
operator|.
name|getTree
argument_list|()
return|;
block|}
DECL|method|VM (CharStream bst)
specifier|public
name|VM
parameter_list|(
name|CharStream
name|bst
parameter_list|)
throws|throws
name|RecognitionException
block|{
name|this
argument_list|(
name|charStream2CommonTree
argument_list|(
name|bst
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|VM (CommonTree tree)
specifier|public
name|VM
parameter_list|(
name|CommonTree
name|tree
parameter_list|)
block|{
name|this
operator|.
name|tree
operator|=
name|tree
expr_stmt|;
name|this
operator|.
name|buildInFunctions
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BstFunction
argument_list|>
argument_list|(
literal|37
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|">"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops the top two (integer) literals, compares them, and pushes 			 * the integer 1 if the second is greater than the first, 0 			 * otherwise. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation>"
argument_list|)
throw|;
block|}
name|Object
name|o2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|Integer
operator|&&
name|o2
operator|instanceof
name|Integer
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only compare two integers with>"
argument_list|)
throw|;
block|}
if|if
condition|(
name|o1
operator|==
literal|null
operator|^
name|o2
operator|==
literal|null
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|o1
operator|==
name|o2
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
name|stack
operator|.
name|push
argument_list|(
operator|(
operator|(
name|Integer
operator|)
name|o1
operator|)
operator|.
name|compareTo
argument_list|(
operator|(
name|Integer
operator|)
name|o2
argument_list|)
operator|>
literal|0
condition|?
name|VM
operator|.
name|TRUE
else|:
name|VM
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"<"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** Analogous. */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation<"
argument_list|)
throw|;
block|}
name|Object
name|o2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|Integer
operator|&&
name|o2
operator|instanceof
name|Integer
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only compare two integers with<"
argument_list|)
throw|;
block|}
if|if
condition|(
name|o1
operator|==
literal|null
operator|^
name|o2
operator|==
literal|null
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|o1
operator|==
name|o2
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
name|stack
operator|.
name|push
argument_list|(
operator|(
operator|(
name|Integer
operator|)
name|o1
operator|)
operator|.
name|compareTo
argument_list|(
operator|(
name|Integer
operator|)
name|o2
argument_list|)
operator|<
literal|0
condition|?
name|VM
operator|.
name|TRUE
else|:
name|VM
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"="
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops the top two (both integer or both string) literals, compares 			 * them, and pushes the integer 1 if they're equal, 0 otherwise. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation ="
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|o2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|o1
operator|==
literal|null
operator|^
name|o2
operator|==
literal|null
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|o1
operator|==
name|o2
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|stack
operator|.
name|push
argument_list|(
name|o1
operator|.
name|equals
argument_list|(
name|o2
argument_list|)
condition|?
name|VM
operator|.
name|TRUE
else|:
name|VM
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"+"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** Pops the top two (integer) literals and pushes their sum. */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation +"
argument_list|)
throw|;
block|}
name|Object
name|o2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|Integer
operator|&&
name|o2
operator|instanceof
name|Integer
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only compare two integers with +"
argument_list|)
throw|;
block|}
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Integer
argument_list|(
operator|(
operator|(
name|Integer
operator|)
name|o1
operator|)
operator|.
name|intValue
argument_list|()
operator|+
operator|(
operator|(
name|Integer
operator|)
name|o2
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"-"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops the top two (integer) literals and pushes their difference 			 * (the first subtracted from the second). 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation -"
argument_list|)
throw|;
block|}
name|Object
name|o2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|Integer
operator|&&
name|o2
operator|instanceof
name|Integer
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only subtract two integers with -"
argument_list|)
throw|;
block|}
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Integer
argument_list|(
operator|(
operator|(
name|Integer
operator|)
name|o1
operator|)
operator|.
name|intValue
argument_list|()
operator|-
operator|(
operator|(
name|Integer
operator|)
name|o2
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"*"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops the top two (string) literals, concatenates them (in reverse 			 * order, that is, the order in which pushed), and pushes the 			 * resulting string. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation *"
argument_list|)
throw|;
block|}
name|Object
name|o2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|String
operator|&&
name|o2
operator|instanceof
name|String
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only concatenate two String with *"
argument_list|)
throw|;
block|}
name|stack
operator|.
name|push
argument_list|(
operator|(
operator|(
name|String
operator|)
name|o1
operator|)
operator|+
operator|(
operator|(
name|String
operator|)
name|o2
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|":="
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops the top two literals and assigns to the first (which must be 			 * a global or entry variable) the value of the second. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Invalid call to operation :="
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|o2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|assign
argument_list|(
name|context
argument_list|,
name|o1
argument_list|,
name|o2
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"add.period$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
name|Pattern
name|p
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"([^\\.\\?\\!\\}\\s])(\\}|\\s)*$"
argument_list|)
decl_stmt|;
comment|/** 			 * Pops the top (string) literal, adds a `.' to it if the last non 			 * '}' character isn't a `.', `?', or `!', and pushes this resulting 			 * string. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation add.period$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|String
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only add a period to a string for add.period$"
argument_list|)
throw|;
block|}
name|String
name|s
init|=
operator|(
name|String
operator|)
name|o1
decl_stmt|;
name|Matcher
name|m
init|=
name|p
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|m
operator|.
name|appendReplacement
argument_list|(
name|sb
argument_list|,
name|m
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|String
name|group2
init|=
name|m
operator|.
name|group
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|group2
operator|!=
literal|null
condition|)
name|sb
operator|.
name|append
argument_list|(
name|m
operator|.
name|group
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stack
operator|.
name|push
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"call.type$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Executes the function whose name is the entry type of an entry. 			 * For example if an entry is of type book, this function executes 			 * the book function. When given as an argument to the ITERATE 			 * command, call.type$ actually produces the output for the entries. 			 * For an entry with an unknown type, it executes the function 			 * default.type. Thus you should define (before the READ command) 			 * one function for each standard entry type as well as a 			 * default.type function. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Call.type$ can only be called from within a context (ITERATE or REVERSE)."
argument_list|)
throw|;
block|}
name|VM
operator|.
name|this
operator|.
name|execute
argument_list|(
name|context
operator|.
name|entry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"change.case$"
argument_list|,
operator|new
name|ChangeCaseFunction
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"chr.to.int$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops the top (string) literal, makes sure it's a single 			 * character, converts it to the corresponding ASCII integer, and 			 * pushes this integer. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation chr.to.int$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|String
operator|&&
operator|(
operator|(
name|String
operator|)
name|o1
operator|)
operator|.
name|length
argument_list|()
operator|==
literal|1
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only perform chr.to.int$ on string with length 1"
argument_list|)
throw|;
block|}
name|String
name|s
init|=
operator|(
name|String
operator|)
name|o1
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Integer
argument_list|(
operator|(
name|int
operator|)
name|s
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"cite$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pushes the string that was the \cite-command argument for this 			 * entry. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|context
operator|.
name|entry
operator|.
name|getCiteKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"duplicate$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops the top literal from the stack and pushes two copies of it. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation duplicate$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|o1
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|o1
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"empty$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops the top literal and pushes the integer 1 if it's a missing 			 * field or a string having no non-white-space characters, 0 			 * otherwise. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation empty$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|o1
operator|==
literal|null
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|String
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Operand does not match function empty$"
argument_list|)
throw|;
block|}
name|String
name|s
init|=
operator|(
name|String
operator|)
name|o1
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|s
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|?
name|VM
operator|.
name|TRUE
else|:
name|VM
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"format.name$"
argument_list|,
operator|new
name|FormatNameFunction
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"if$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops the top three literals (they are two function literals and 			 * an integer literal, in that order); if the integer is greater 			 * than 0, it executes the second literal, else it executes the 			 * first. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|3
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation ="
argument_list|)
throw|;
block|}
name|Object
name|f1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|f2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|i
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|f1
operator|instanceof
name|Identifier
operator|||
name|f1
operator|instanceof
name|Tree
operator|)
operator|&&
operator|(
name|f2
operator|instanceof
name|Identifier
operator|||
name|f2
operator|instanceof
name|Tree
operator|)
operator|&&
operator|(
name|i
operator|instanceof
name|Integer
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Expecting two functions and an integer for if$."
argument_list|)
throw|;
block|}
name|Object
name|toExe
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|Integer
operator|)
name|i
operator|)
operator|.
name|intValue
argument_list|()
operator|>
literal|0
condition|)
block|{
name|toExe
operator|=
name|f2
expr_stmt|;
block|}
else|else
block|{
name|toExe
operator|=
name|f1
expr_stmt|;
block|}
name|VM
operator|.
name|this
operator|.
name|executeInContext
argument_list|(
name|toExe
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"int.to.chr$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops the top (integer) literal, interpreted as the ASCII integer 			 * value of a single character, converts it to the corresponding 			 * single-character string, and pushes this string. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation int.to.chr$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|Integer
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only perform operation int.to.chr$ on an Integer"
argument_list|)
throw|;
block|}
name|Integer
name|i
init|=
operator|(
name|Integer
operator|)
name|o1
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
operator|(
name|char
operator|)
name|i
operator|.
name|intValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"int.to.str$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops the top (integer) literal, converts it to its (unique) 			 * string equivalent, and pushes this string. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation int.to.str$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|Integer
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only transform an integer to an string using int.to.str$"
argument_list|)
throw|;
block|}
name|stack
operator|.
name|push
argument_list|(
operator|(
operator|(
name|Integer
operator|)
name|o1
operator|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"missing$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops the top literal and pushes the integer 1 if it's a missing 			 * field, 0 otherwise. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation missing$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|o1
operator|==
literal|null
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|String
operator|)
condition|)
block|{
name|warn
argument_list|(
literal|"Not a string or missing field in operation missing$"
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|stack
operator|.
name|push
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"newline$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Writes onto the bbl file what's accumulated in the output buffer. 			 * It writes a blank line if and only if the output buffer is empty. 			 * Since write$ does reasonable line breaking, you should use this 			 * function only when you want a blank line or an explicit line 			 * break. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
name|VM
operator|.
name|this
operator|.
name|bbl
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"num.names$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops the top (string) literal and pushes the number of names the 			 * string represents one plus the number of occurrences of the 			 * substring "and" (ignoring case differences) surrounded by 			 * non-null white-space at the top brace level. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation num.names$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|String
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Need a string at the top of the stack for num.names$"
argument_list|)
throw|;
block|}
name|String
name|s
init|=
operator|(
name|String
operator|)
name|o1
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Integer
argument_list|(
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|s
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"pop$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops the top of the stack but doesn't print it; this gets rid of 			 * an unwanted stack literal. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"preamble$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * The |built_in| function {\.{preamble\$}} pushes onto the stack 			 * the concatenation of all the \.{preamble} strings read from the 			 * database files. (or the empty string if there where none) 			 *  			 * @PREAMBLE strings read from the database files. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|preamble
operator|!=
literal|null
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|preamble
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stack
operator|.
name|push
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|/** 		 * Pops the top (string) literal, removes nonalphanumeric characters 		 * except for white-space characters and hyphens and ties (these all get 		 * converted to a space), removes certain alphabetic characters 		 * contained in the control sequences associated with a \special 		 * character", and pushes the resulting string. 		 */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"purify$"
argument_list|,
operator|new
name|PurifyFunction
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"quote$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pushes the string consisting of the double-quote character. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
name|stack
operator|.
name|push
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"skip$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Is a no-op. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
comment|// Nothing to do! Yeah!
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"stack$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops and prints the whole stack; it's meant to be used for style 			 * designers while debugging. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
while|while
condition|(
operator|!
name|stack
operator|.
name|empty
argument_list|()
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|stack
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"substring$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops the top three literals (they are the two integers literals 			 * len and start, and a string literal, in that order). It pushes 			 * the substring of the (at most) len consecutive characters 			 * starting at the startth character (assuming 1-based indexing) if 			 * start is positive, and ending at the start-th character 			 * (including) from the end if start is negative (where the first 			 * character from the end is the last character). 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|3
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation substring$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|o2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|o3
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|o1
operator|instanceof
name|Integer
operator|)
operator|&&
operator|(
name|o2
operator|instanceof
name|Integer
operator|)
operator|&&
operator|(
name|o3
operator|instanceof
name|String
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Expecting two integers and a string for substring$"
argument_list|)
throw|;
block|}
name|Integer
name|len
init|=
operator|(
name|Integer
operator|)
name|o1
decl_stmt|;
name|Integer
name|start
init|=
operator|(
name|Integer
operator|)
name|o2
decl_stmt|;
name|int
name|lenI
init|=
name|len
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|int
name|startI
init|=
name|start
operator|.
name|intValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|lenI
operator|>
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|2
condition|)
name|lenI
operator|=
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|startI
operator|>
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|2
condition|)
name|startI
operator|=
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|startI
operator|<
name|Integer
operator|.
name|MIN_VALUE
operator|/
literal|2
condition|)
name|startI
operator|=
operator|-
name|Integer
operator|.
name|MIN_VALUE
operator|/
literal|2
expr_stmt|;
name|String
name|s
init|=
operator|(
name|String
operator|)
name|o3
decl_stmt|;
if|if
condition|(
name|startI
operator|<
literal|0
condition|)
block|{
name|startI
operator|+=
name|s
operator|.
name|length
argument_list|()
operator|+
literal|1
expr_stmt|;
name|startI
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|startI
operator|+
literal|1
operator|-
name|lenI
argument_list|)
expr_stmt|;
block|}
name|stack
operator|.
name|push
argument_list|(
name|s
operator|.
name|substring
argument_list|(
name|startI
operator|-
literal|1
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|startI
operator|-
literal|1
operator|+
name|lenI
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"swap$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Swaps the top two literals on the stack. text.length$ Pops the 			 * top (string) literal, and pushes the number of text char- acters 			 * it contains, where an accented character (more precisely, a 			 * \special character", defined in Section 4) counts as a single 			 * text character, even if it's missing its matching right brace, 			 * and where braces don't count as text characters. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation swap$"
argument_list|)
throw|;
block|}
name|Object
name|f1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|f2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|f1
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|f2
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"text.length$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * text.length$ Pops the top (string) literal, and pushes the number 			 * of text characters it contains, where an accented character (more 			 * precisely, a "special character", defined in Section 4) counts as 			 * a single text character, even if it's missing its matching right 			 * brace, and where braces don't count as text characters. 			 *  			 * From BibTeXing: For the purposes of counting letters in labels, 			 * BibTEX considers everything contained inside the braces as a 			 * single letter. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation text.length$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|String
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only perform operation on a string text.length$"
argument_list|)
throw|;
block|}
name|String
name|s
init|=
operator|(
name|String
operator|)
name|o1
decl_stmt|;
name|char
index|[]
name|c
init|=
name|s
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|// Comments from bibtex.web:
comment|// sp_ptr := str_start[pop_lit1];
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|// sp_end := str_start[pop_lit1+1];
name|int
name|n
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// sp_brace_level := 0;
name|int
name|braceLevel
init|=
literal|0
decl_stmt|;
comment|// while (sp_ptr< sp_end) do begin
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
comment|// incr(sp_ptr);
name|i
operator|++
expr_stmt|;
comment|// if (str_pool[sp_ptr-1] = left_brace) then
comment|// begin
if|if
condition|(
name|c
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'{'
condition|)
block|{
comment|// incr(sp_brace_level);
name|braceLevel
operator|++
expr_stmt|;
comment|// if ((sp_brace_level = 1) and (sp_ptr< sp_end)) then
if|if
condition|(
name|braceLevel
operator|==
literal|1
operator|&&
name|i
operator|<
name|n
condition|)
comment|// if (str_pool[sp_ptr] = backslash) then
comment|// begin
if|if
condition|(
name|c
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
comment|// incr(sp_ptr); {skip over the |backslash|}
name|i
operator|++
expr_stmt|;
comment|// skip over backslash
comment|// while ((sp_ptr< sp_end) and (sp_brace_level
comment|//> 0)) do begin
while|while
condition|(
name|i
argument_list|<
name|n
operator|&&
name|braceLevel
argument_list|>
literal|0
condition|)
block|{
comment|// if (str_pool[sp_ptr] = right_brace) then
if|if
condition|(
name|c
index|[
name|i
index|]
operator|==
literal|'}'
condition|)
comment|// decr(sp_brace_level)
name|braceLevel
operator|--
expr_stmt|;
comment|// else if (str_pool[sp_ptr] = left_brace)
comment|// then
elseif|else
if|if
condition|(
name|c
index|[
name|i
index|]
operator|==
literal|'{'
condition|)
comment|// incr(sp_brace_level);
name|braceLevel
operator|++
expr_stmt|;
comment|// incr(sp_ptr);
name|i
operator|++
expr_stmt|;
comment|// end;
block|}
comment|// incr(num_text_chars);
name|result
operator|++
expr_stmt|;
comment|// end;
block|}
comment|// end
block|}
comment|// else if (str_pool[sp_ptr-1] = right_brace) then
comment|// begin
elseif|else
if|if
condition|(
name|c
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
comment|// if (sp_brace_level> 0) then
if|if
condition|(
name|braceLevel
operator|>
literal|0
condition|)
comment|// decr(sp_brace_level);
name|braceLevel
operator|--
expr_stmt|;
comment|// end
block|}
comment|// else
else|else
comment|// incr(num_text_chars);
name|result
operator|++
expr_stmt|;
block|}
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Integer
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|/** 		 * Pops the top two literals (the integer literal len and a string 		 * literal, in that order). It pushes the substring of the (at most) len 		 * consecutive text characters starting from the beginning of the 		 * string. This function is similar to substring$, but this one 		 * considers a \special character", even if it's missing its matching 		 * right brace, to be a single text character (rather than however many 		 * ASCII characters it actually comprises), and this function doesn't 		 * consider braces to be text characters; furthermore, this function 		 * appends any needed matching right braces. 		 */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"text.prefix$"
argument_list|,
operator|new
name|TextPrefixFunction
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"top$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops and prints the top of the stack on the terminal and log 			 * file. It's useful for debugging. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|stack
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"type$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pushes the current entry's type (book, article, etc.), but pushes 			 * the null string if the type is either unknown or undefined. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|context
operator|.
name|entry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"warning$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops the top (string) literal and prints it following a warning 			 * message. This also increments a count of the number of warning 			 * messages issued. 			 */
name|int
name|warning
init|=
literal|1
decl_stmt|;
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"Warning (#"
operator|+
operator|(
name|warning
operator|++
operator|)
operator|+
literal|"): "
operator|+
name|stack
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"while$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops the top two (function) literals, and keeps executing the 			 * second as long as the (integer) literal left on the stack by 			 * executing the first is greater than 0. 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation while$"
argument_list|)
throw|;
block|}
name|Object
name|f2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|f1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|f1
operator|instanceof
name|Identifier
operator|||
name|f1
operator|instanceof
name|Tree
operator|)
operator|&&
operator|(
name|f2
operator|instanceof
name|Identifier
operator|||
name|f2
operator|instanceof
name|Tree
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Expecting two functions for while$."
argument_list|)
throw|;
block|}
do|do
block|{
name|VM
operator|.
name|this
operator|.
name|executeInContext
argument_list|(
name|f1
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|Object
name|i
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|instanceof
name|Integer
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"First parameter to while has to return an integer but was "
operator|+
name|i
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
operator|(
name|Integer
operator|)
name|i
operator|)
operator|.
name|intValue
argument_list|()
operator|<=
literal|0
condition|)
block|{
break|break;
block|}
name|VM
operator|.
name|this
operator|.
name|executeInContext
argument_list|(
name|f2
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|true
condition|)
do|;
block|}
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"width$"
argument_list|,
operator|new
name|WidthFunction
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"write$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
comment|/** 			 * Pops the top (string) literal and writes it on the output buffer 			 * (which will result in stuff being written onto the bbl file when 			 * the buffer fills up). 			 */
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
name|String
name|s
init|=
operator|(
name|String
operator|)
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|VM
operator|.
name|this
operator|.
name|bbl
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|assign (BstEntry context, Object o1, Object o2)
specifier|protected
name|boolean
name|assign
parameter_list|(
name|BstEntry
name|context
parameter_list|,
name|Object
name|o1
parameter_list|,
name|Object
name|o2
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|Identifier
operator|)
operator|||
operator|!
operator|(
name|o2
operator|instanceof
name|String
operator|||
name|o2
operator|instanceof
name|Integer
operator|)
condition|)
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Invalid parameters"
argument_list|)
throw|;
name|String
name|name
init|=
operator|(
operator|(
name|Identifier
operator|)
name|o1
operator|)
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|o2
operator|instanceof
name|String
condition|)
block|{
if|if
condition|(
name|context
operator|!=
literal|null
operator|&&
name|context
operator|.
name|strings
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|context
operator|.
name|strings
operator|.
name|put
argument_list|(
name|name
argument_list|,
operator|(
name|String
operator|)
name|o2
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|strings
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|strings
operator|.
name|put
argument_list|(
name|name
argument_list|,
operator|(
name|String
operator|)
name|o2
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|o2
operator|instanceof
name|Integer
condition|)
block|{
if|if
condition|(
name|context
operator|!=
literal|null
operator|&&
name|context
operator|.
name|integers
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|context
operator|.
name|integers
operator|.
name|put
argument_list|(
name|name
argument_list|,
operator|(
name|Integer
operator|)
name|o2
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|integers
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|integers
operator|.
name|put
argument_list|(
name|name
argument_list|,
operator|(
name|Integer
operator|)
name|o2
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|field|tree
name|CommonTree
name|tree
decl_stmt|;
DECL|field|bbl
specifier|private
name|StringBuffer
name|bbl
decl_stmt|;
DECL|field|preamble
name|String
name|preamble
decl_stmt|;
DECL|method|run (BibtexDatabase db)
specifier|public
name|String
name|run
parameter_list|(
name|BibtexDatabase
name|db
parameter_list|)
block|{
name|preamble
operator|=
name|db
operator|.
name|getPreamble
argument_list|()
expr_stmt|;
return|return
name|run
argument_list|(
name|db
operator|.
name|getEntries
argument_list|()
argument_list|)
return|;
block|}
DECL|method|run (Collection<BibtexEntry> bibtex)
specifier|public
name|String
name|run
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|bibtex
parameter_list|)
block|{
name|reset
argument_list|()
expr_stmt|;
block|{
comment|// Create entries
name|entries
operator|=
operator|new
name|Vector
argument_list|<
name|BstEntry
argument_list|>
argument_list|(
name|bibtex
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|ListIterator
argument_list|<
name|BstEntry
argument_list|>
name|i
init|=
name|entries
operator|.
name|listIterator
argument_list|()
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|bibtex
control|)
block|{
name|i
operator|.
name|add
argument_list|(
operator|new
name|BstEntry
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// assert tree.getType() == Bst.COMMANDS;
comment|// Go
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tree
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Tree
name|child
init|=
name|tree
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|BstParser
operator|.
name|STRINGS
case|:
name|strings
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|INTEGERS
case|:
name|integers
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|FUNCTION
case|:
name|function
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|EXECUTE
case|:
name|execute
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|SORT
case|:
name|sort
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|ITERATE
case|:
name|iterate
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|REVERSE
case|:
name|reverse
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|ENTRY
case|:
name|entry
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|READ
case|:
name|read
argument_list|()
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|MACRO
case|:
name|macro
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|bbl
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|reset ()
specifier|private
name|void
name|reset
parameter_list|()
block|{
name|bbl
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
name|entries
operator|=
literal|null
expr_stmt|;
name|strings
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|integers
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
name|integers
operator|.
name|put
argument_list|(
literal|"entry.max$"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
expr_stmt|;
name|integers
operator|.
name|put
argument_list|(
literal|"global.max$"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
expr_stmt|;
name|functions
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BstFunction
argument_list|>
argument_list|()
expr_stmt|;
name|functions
operator|.
name|putAll
argument_list|(
name|buildInFunctions
argument_list|)
expr_stmt|;
name|stack
operator|=
operator|new
name|Stack
argument_list|<
name|Object
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|/** 	 * Dredges up from the database file the field values for each entry in the 	 * list. It has no arguments. If a database entry doesn't have a value for a 	 * field (and probably no database entry will have a value for every field), 	 * that field variable is marked as missing for the entry. 	 *  	 * We use null for the missing entry designator. 	 *  	 * @param child 	 */
DECL|method|read ()
specifier|private
name|void
name|read
parameter_list|()
block|{
name|Iterator
argument_list|<
name|BstEntry
argument_list|>
name|i
init|=
name|entries
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BstEntry
name|e
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mEntry
range|:
name|e
operator|.
name|fields
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Object
name|fieldValue
init|=
name|e
operator|.
name|entry
operator|.
name|getField
argument_list|(
name|mEntry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|mEntry
operator|.
name|setValue
argument_list|(
operator|(
name|fieldValue
operator|==
literal|null
condition|?
literal|null
else|:
name|fieldValue
operator|.
name|toString
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|=
name|entries
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BstEntry
name|e
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|e
operator|.
name|fields
operator|.
name|containsKey
argument_list|(
literal|"crossref"
argument_list|)
condition|)
block|{
name|e
operator|.
name|fields
operator|.
name|put
argument_list|(
literal|"crossref"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** 	 * Defines a string macro. It has two arguments; the first is the macro's 	 * name, which is treated like any other variable or function name, and the 	 * second is its definition, which must be double-quote-delimited. You must 	 * have one for each three-letter month abbreviation; in addition, you 	 * should have one for common journal names. The user's database may 	 * override any definition you define using this command. If you want to 	 * define a string the user can't touch, use the FUNCTION command, which has 	 * a compatible syntax. 	 *  	 * @param child 	 */
DECL|method|macro (Tree child)
specifier|private
name|void
name|macro
parameter_list|(
name|Tree
name|child
parameter_list|)
block|{
name|String
name|name
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
name|replacement
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|functions
operator|.
name|put
argument_list|(
name|name
argument_list|,
operator|new
name|MacroFunction
argument_list|(
name|replacement
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|class|MacroFunction
specifier|public
class|class
name|MacroFunction
implements|implements
name|BstFunction
block|{
DECL|field|replacement
name|String
name|replacement
decl_stmt|;
DECL|method|MacroFunction (String replacement)
specifier|public
name|MacroFunction
parameter_list|(
name|String
name|replacement
parameter_list|)
block|{
name|this
operator|.
name|replacement
operator|=
name|replacement
expr_stmt|;
block|}
DECL|method|execute (BstEntry context)
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
name|VM
operator|.
name|this
operator|.
name|push
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Declares the fields and entry variables. It has three arguments, each a 	 * (possibly empty) list of variable names. The three lists are of: fields, 	 * integer entry variables, and string entry variables. There is an 	 * additional field that BibTEX automatically declares, crossref, used for 	 * cross ref- erencing. And there is an additional string entry variable 	 * automatically declared, sort.key$, used by the SORT command. Each of 	 * these variables has a value for each entry on the list. 	 */
DECL|method|entry (Tree child)
specifier|private
name|void
name|entry
parameter_list|(
name|Tree
name|child
parameter_list|)
block|{
block|{
comment|// Fields first
name|Tree
name|t
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// assert t.getType() == Bst.IDLIST;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|t
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|t
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
for|for
control|(
name|BstEntry
name|entry
range|:
name|entries
control|)
block|{
name|entry
operator|.
name|fields
operator|.
name|put
argument_list|(
name|name
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|{
comment|// Integers
name|Tree
name|t
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// assert t.getType() == Bst.IDLIST;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|t
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|t
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
for|for
control|(
name|BstEntry
name|entry
range|:
name|entries
control|)
block|{
name|entry
operator|.
name|integers
operator|.
name|put
argument_list|(
name|name
argument_list|,
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|{
comment|// Strings
name|Tree
name|t
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|// assert t.getType() == Bst.IDLIST;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|t
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|t
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
for|for
control|(
name|BstEntry
name|entry
range|:
name|entries
control|)
block|{
name|entry
operator|.
name|strings
operator|.
name|put
argument_list|(
name|name
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|BstEntry
name|entry
range|:
name|entries
control|)
block|{
name|entry
operator|.
name|strings
operator|.
name|put
argument_list|(
literal|"sort.key$"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|reverse (Tree child)
specifier|private
name|void
name|reverse
parameter_list|(
name|Tree
name|child
parameter_list|)
block|{
name|BstFunction
name|f
init|=
name|functions
operator|.
name|get
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|ListIterator
argument_list|<
name|BstEntry
argument_list|>
name|i
init|=
name|entries
operator|.
name|listIterator
argument_list|(
name|entries
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasPrevious
argument_list|()
condition|)
block|{
name|f
operator|.
name|execute
argument_list|(
name|i
operator|.
name|previous
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|iterate (Tree child)
specifier|private
name|void
name|iterate
parameter_list|(
name|Tree
name|child
parameter_list|)
block|{
name|BstFunction
name|f
init|=
name|functions
operator|.
name|get
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|BstEntry
argument_list|>
name|i
init|=
name|entries
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|f
operator|.
name|execute
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Sorts the entry list using the values of the string entry variable 	 * sort.key$. It has no arguments. 	 *  	 * @param child 	 */
DECL|method|sort (Tree child)
specifier|private
name|void
name|sort
parameter_list|(
name|Tree
name|child
parameter_list|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|entries
argument_list|,
operator|new
name|Comparator
argument_list|<
name|BstEntry
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|BstEntry
name|o1
parameter_list|,
name|BstEntry
name|o2
parameter_list|)
block|{
return|return
operator|(
operator|(
name|String
operator|)
name|o1
operator|.
name|strings
operator|.
name|get
argument_list|(
literal|"sort.key$"
argument_list|)
operator|)
operator|.
name|compareTo
argument_list|(
operator|(
name|String
operator|)
name|o2
operator|.
name|strings
operator|.
name|get
argument_list|(
literal|"sort.key$"
argument_list|)
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|executeInContext (Object o, BstEntry context)
specifier|public
name|void
name|executeInContext
parameter_list|(
name|Object
name|o
parameter_list|,
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Tree
condition|)
block|{
name|Tree
name|t
init|=
operator|(
name|Tree
operator|)
name|o
decl_stmt|;
operator|new
name|StackFunction
argument_list|(
name|t
argument_list|)
operator|.
name|execute
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Identifier
condition|)
block|{
name|execute
argument_list|(
operator|(
operator|(
name|Identifier
operator|)
name|o
operator|)
operator|.
name|getName
argument_list|()
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|execute (Tree child)
specifier|public
name|void
name|execute
parameter_list|(
name|Tree
name|child
parameter_list|)
block|{
name|execute
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|class|StackFunction
specifier|public
class|class
name|StackFunction
implements|implements
name|BstFunction
block|{
DECL|field|tree
name|Tree
name|tree
decl_stmt|;
DECL|method|getTree ()
specifier|public
name|Tree
name|getTree
parameter_list|()
block|{
return|return
name|tree
return|;
block|}
DECL|method|StackFunction (Tree stack)
specifier|public
name|StackFunction
parameter_list|(
name|Tree
name|stack
parameter_list|)
block|{
comment|// assert stack.getType() == Bst.STACK;
name|tree
operator|=
name|stack
expr_stmt|;
block|}
DECL|method|execute (BstEntry context)
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tree
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Tree
name|c
init|=
name|tree
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
try|try
block|{
switch|switch
condition|(
name|c
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|BstParser
operator|.
name|STRING
case|:
block|{
name|String
name|s
init|=
name|c
operator|.
name|getText
argument_list|()
decl_stmt|;
name|push
argument_list|(
name|s
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BstParser
operator|.
name|INTEGER
case|:
name|push
argument_list|(
operator|new
name|Integer
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|c
operator|.
name|getText
argument_list|()
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|QUOTED
case|:
name|push
argument_list|(
operator|new
name|Identifier
argument_list|(
name|c
operator|.
name|getText
argument_list|()
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|STACK
case|:
name|push
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
name|VM
operator|.
name|this
operator|.
name|execute
argument_list|(
name|c
operator|.
name|getText
argument_list|()
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|VMException
name|e
parameter_list|)
block|{
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"ERROR "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|" ("
operator|+
name|file
operator|.
name|getPath
argument_list|()
operator|+
literal|":"
operator|+
name|c
operator|.
name|getLine
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"ERROR "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|" ("
operator|+
name|c
operator|.
name|getLine
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
block|}
block|}
DECL|method|push (Tree t)
specifier|private
name|void
name|push
parameter_list|(
name|Tree
name|t
parameter_list|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
DECL|method|execute (String name, BstEntry context)
specifier|public
name|void
name|execute
parameter_list|(
name|String
name|name
parameter_list|,
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|fields
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|context
operator|.
name|fields
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|context
operator|.
name|strings
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|context
operator|.
name|strings
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|context
operator|.
name|integers
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|context
operator|.
name|integers
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|strings
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|strings
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|integers
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|integers
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|functions
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|functions
operator|.
name|get
argument_list|(
name|name
argument_list|)
operator|.
name|execute
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return;
block|}
throw|throw
operator|new
name|VMException
argument_list|(
literal|"No matching identifier found: "
operator|+
name|name
argument_list|)
throw|;
block|}
DECL|method|function (Tree child)
specifier|private
name|void
name|function
parameter_list|(
name|Tree
name|child
parameter_list|)
block|{
name|String
name|name
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|Tree
name|stack
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|functions
operator|.
name|put
argument_list|(
name|name
argument_list|,
operator|new
name|StackFunction
argument_list|(
name|stack
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Declares global integer variables. It has one argument, a list of 	 * variable names. There are two such automatically-declared variables, 	 * entry.max$ and global.max$, used for limiting the lengths of string vari- 	 * ables. You may have any number of these commands, but a variable's 	 * declaration must precede its use. 	 *  	 * @param child 	 */
DECL|method|integers (Tree child)
specifier|private
name|void
name|integers
parameter_list|(
name|Tree
name|child
parameter_list|)
block|{
name|Tree
name|t
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// assert t.getType() == Bst.IDLIST;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|t
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|t
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|integers
operator|.
name|put
argument_list|(
name|name
argument_list|,
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Declares global string variables. It has one argument, a list of variable 	 * names. You may have any number of these commands, but a variable's 	 * declaration must precede its use. 	 *  	 * @param child 	 */
DECL|method|strings (Tree child)
specifier|private
name|void
name|strings
parameter_list|(
name|Tree
name|child
parameter_list|)
block|{
name|Tree
name|t
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// assert t.getType() == Bst.IDLIST;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|t
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|t
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|strings
operator|.
name|put
argument_list|(
name|name
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|BstEntry
specifier|public
class|class
name|BstEntry
block|{
DECL|method|BstEntry (BibtexEntry e)
specifier|public
name|BstEntry
parameter_list|(
name|BibtexEntry
name|e
parameter_list|)
block|{
name|this
operator|.
name|entry
operator|=
name|e
expr_stmt|;
block|}
DECL|field|entry
name|BibtexEntry
name|entry
decl_stmt|;
DECL|field|strings
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|strings
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|fields
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|fields
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|integers
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|integers
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|getFields ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getFields
parameter_list|()
block|{
return|return
name|fields
return|;
block|}
DECL|method|getBibtexEntry ()
specifier|public
name|BibtexEntry
name|getBibtexEntry
parameter_list|()
block|{
return|return
name|entry
return|;
block|}
block|}
DECL|field|entries
name|Vector
argument_list|<
name|BstEntry
argument_list|>
name|entries
decl_stmt|;
DECL|field|strings
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|strings
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|integers
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|integers
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|functions
name|Map
argument_list|<
name|String
argument_list|,
name|BstFunction
argument_list|>
name|functions
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BstFunction
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|stack
name|Stack
argument_list|<
name|Object
argument_list|>
name|stack
init|=
operator|new
name|Stack
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|push (Integer integer)
specifier|public
name|void
name|push
parameter_list|(
name|Integer
name|integer
parameter_list|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|integer
argument_list|)
expr_stmt|;
block|}
DECL|method|push (String string)
specifier|public
name|void
name|push
parameter_list|(
name|String
name|string
parameter_list|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
DECL|method|push (Identifier identifier)
specifier|public
name|void
name|push
parameter_list|(
name|Identifier
name|identifier
parameter_list|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
block|}
DECL|method|getStrings ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getStrings
parameter_list|()
block|{
return|return
name|strings
return|;
block|}
DECL|method|getIntegers ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|getIntegers
parameter_list|()
block|{
return|return
name|integers
return|;
block|}
DECL|method|getEntries ()
specifier|public
name|Vector
argument_list|<
name|BstEntry
argument_list|>
name|getEntries
parameter_list|()
block|{
return|return
name|entries
return|;
block|}
DECL|method|getFunctions ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|BstFunction
argument_list|>
name|getFunctions
parameter_list|()
block|{
return|return
name|functions
return|;
block|}
DECL|method|getStack ()
specifier|public
name|Stack
argument_list|<
name|Object
argument_list|>
name|getStack
parameter_list|()
block|{
return|return
name|stack
return|;
block|}
DECL|method|warn (String string)
specifier|public
name|void
name|warn
parameter_list|(
name|String
name|string
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

