begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2003 Nizar N. Batada, Morten O. Alver  All programs in this directory and subdirectories are published under the GNU General Public License as described below.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA  Further information about the GNU GPL is available at: http://www.gnu.org/copyleft/gpl.ja.html  */
end_comment

begin_package
DECL|package|net.sf.jabref.export
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|LayoutFormatter
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|format
operator|.
name|AuthorLastFirst
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|format
operator|.
name|RemoveLatexCommands
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|format
operator|.
name|ResolvePDF
import|;
end_import

begin_import
import|import
name|ca
operator|.
name|odell
operator|.
name|glazedlists
operator|.
name|BasicEventList
import|;
end_import

begin_import
import|import
name|ca
operator|.
name|odell
operator|.
name|glazedlists
operator|.
name|SortedList
import|;
end_import

begin_class
DECL|class|FileActions
specifier|public
class|class
name|FileActions
block|{
DECL|field|refPat
specifier|private
specifier|static
name|Pattern
name|refPat
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"(#[A-Za-z]+#)"
argument_list|)
decl_stmt|;
comment|// Used to detect string references in strings
DECL|method|writePreamble (Writer fw, String preamble)
specifier|private
specifier|static
name|void
name|writePreamble
parameter_list|(
name|Writer
name|fw
parameter_list|,
name|String
name|preamble
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|preamble
operator|!=
literal|null
condition|)
block|{
name|fw
operator|.
name|write
argument_list|(
literal|"@PREAMBLE{"
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|preamble
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"}"
operator|+
name|Globals
operator|.
name|NEWLINE
operator|+
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Write all strings in alphabetical order, modified to produce a safe (for BibTeX) order of the strings      * if they reference each other.      * @param fw The Writer to send the output to.      * @param database The database whose strings we should write.      * @throws IOException If anthing goes wrong in writing.      */
DECL|method|writeStrings (Writer fw, BibtexDatabase database)
specifier|private
specifier|static
name|void
name|writeStrings
parameter_list|(
name|Writer
name|fw
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|BibtexString
argument_list|>
name|strings
init|=
operator|new
name|ArrayList
argument_list|<
name|BibtexString
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|database
operator|.
name|getStringKeySet
argument_list|()
control|)
block|{
name|strings
operator|.
name|add
argument_list|(
name|database
operator|.
name|getString
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|strings
argument_list|,
operator|new
name|BibtexStringComparator
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// First, make a Map of all entries:
name|HashMap
argument_list|<
name|String
argument_list|,
name|BibtexString
argument_list|>
name|remaining
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BibtexString
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|BibtexString
argument_list|>
name|i
init|=
name|strings
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BibtexString
name|string
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|remaining
operator|.
name|put
argument_list|(
name|string
operator|.
name|getName
argument_list|()
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|BibtexString
argument_list|>
name|i
init|=
name|strings
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BibtexString
name|bs
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|remaining
operator|.
name|containsKey
argument_list|(
name|bs
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
name|writeString
argument_list|(
name|fw
argument_list|,
name|bs
argument_list|,
name|remaining
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeString (Writer fw, BibtexString bs, HashMap<String, BibtexString> remaining)
specifier|private
specifier|static
name|void
name|writeString
parameter_list|(
name|Writer
name|fw
parameter_list|,
name|BibtexString
name|bs
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|BibtexString
argument_list|>
name|remaining
parameter_list|)
throws|throws
name|IOException
block|{
comment|// First remove this from the "remaining" list so it can't cause problem with circular refs:
name|remaining
operator|.
name|remove
argument_list|(
name|bs
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Then we go through the string looking for references to other strings. If we find references
comment|// to strings that we will write, but still haven't, we write those before proceeding. This ensures
comment|// that the string order will be acceptable for BibTeX.
name|String
name|content
init|=
name|bs
operator|.
name|getContent
argument_list|()
decl_stmt|;
name|Matcher
name|m
decl_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|refPat
operator|.
name|matcher
argument_list|(
name|content
argument_list|)
operator|)
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|foundLabel
init|=
name|m
operator|.
name|group
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
name|restIndex
init|=
name|content
operator|.
name|indexOf
argument_list|(
name|foundLabel
argument_list|)
operator|+
name|foundLabel
operator|.
name|length
argument_list|()
decl_stmt|;
name|content
operator|=
name|content
operator|.
name|substring
argument_list|(
name|restIndex
argument_list|)
expr_stmt|;
name|Object
name|referred
init|=
name|remaining
operator|.
name|get
argument_list|(
name|foundLabel
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|foundLabel
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|// If the label we found exists as a key in the "remaining" Map, we go on and write it now:
if|if
condition|(
name|referred
operator|!=
literal|null
condition|)
name|writeString
argument_list|(
name|fw
argument_list|,
operator|(
name|BibtexString
operator|)
name|referred
argument_list|,
name|remaining
argument_list|)
expr_stmt|;
block|}
name|fw
operator|.
name|write
argument_list|(
literal|"@STRING{"
operator|+
name|bs
operator|.
name|getName
argument_list|()
operator|+
literal|" = "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bs
operator|.
name|getContent
argument_list|()
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
name|fw
operator|.
name|write
argument_list|(
operator|(
operator|new
name|LatexFieldFormatter
argument_list|()
operator|)
operator|.
name|format
argument_list|(
name|bs
operator|.
name|getContent
argument_list|()
argument_list|,
name|Globals
operator|.
name|BIBTEX_STRING
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fw
operator|.
name|write
argument_list|(
literal|"{}"
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"}"
operator|+
name|Globals
operator|.
name|NEWLINE
operator|+
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes the JabRef signature and the encoding.      *      * @param encoding String the name of the encoding, which is part of the header.      */
DECL|method|writeBibFileHeader (Writer out, String encoding)
specifier|private
specifier|static
name|void
name|writeBibFileHeader
parameter_list|(
name|Writer
name|out
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|write
argument_list|(
literal|"% "
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|GUIGlobals
operator|.
name|SIGNATURE
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
literal|" "
operator|+
name|GUIGlobals
operator|.
name|version
operator|+
literal|"."
operator|+
name|Globals
operator|.
name|NEWLINE
operator|+
literal|"% "
operator|+
name|GUIGlobals
operator|.
name|encPrefix
operator|+
name|encoding
operator|+
name|Globals
operator|.
name|NEWLINE
operator|+
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Saves the database to file. Two boolean values indicate whether      * only entries with a nonzero Globals.SEARCH value and only      * entries with a nonzero Globals.GROUPSEARCH value should be      * saved. This can be used to let the user save only the results of      * a search. False and false means all entries are saved.      */
DECL|method|saveDatabase (BibtexDatabase database, MetaData metaData, File file, JabRefPreferences prefs, boolean checkSearch, boolean checkGroup, String encoding)
specifier|public
specifier|static
name|SaveSession
name|saveDatabase
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|MetaData
name|metaData
parameter_list|,
name|File
name|file
parameter_list|,
name|JabRefPreferences
name|prefs
parameter_list|,
name|boolean
name|checkSearch
parameter_list|,
name|boolean
name|checkGroup
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|SaveException
block|{
name|TreeMap
argument_list|<
name|String
argument_list|,
name|BibtexEntryType
argument_list|>
name|types
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|BibtexEntryType
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|backup
init|=
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"backup"
argument_list|)
decl_stmt|;
name|SaveSession
name|session
decl_stmt|;
name|BibtexEntry
name|exceptionCause
init|=
literal|null
decl_stmt|;
try|try
block|{
name|session
operator|=
operator|new
name|SaveSession
argument_list|(
name|file
argument_list|,
name|encoding
argument_list|,
name|backup
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error from encoding: '"
operator|+
name|encoding
operator|+
literal|"' Len: "
operator|+
name|encoding
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
comment|// we must catch all exceptions to be able notify users that
comment|// saving failed, no matter what the reason was
comment|// (and they won't just quit JabRef thinking
comment|// everyting worked and loosing data)
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|SaveException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
try|try
block|{
comment|// Get our data stream. This stream writes only to a temporary file,
comment|// until committed.
name|VerifyingWriter
name|fw
init|=
name|session
operator|.
name|getWriter
argument_list|()
decl_stmt|;
comment|// Write signature.
name|writeBibFileHeader
argument_list|(
name|fw
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
comment|// Write preamble if there is one.
name|writePreamble
argument_list|(
name|fw
argument_list|,
name|database
operator|.
name|getPreamble
argument_list|()
argument_list|)
expr_stmt|;
comment|// Write strings if there are any.
name|writeStrings
argument_list|(
name|fw
argument_list|,
name|database
argument_list|)
expr_stmt|;
comment|// Write database entries. Take care, using CrossRefEntry-
comment|// Comparator, that referred entries occur after referring
comment|// ones. Apart from crossref requirements, entries will be
comment|// sorted as they appear on the screen.
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|sorter
init|=
name|getSortedEntries
argument_list|(
name|database
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|FieldFormatter
name|ff
init|=
operator|new
name|LatexFieldFormatter
argument_list|()
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|be
range|:
name|sorter
control|)
block|{
name|exceptionCause
operator|=
name|be
expr_stmt|;
comment|// Check if we must write the type definition for this
comment|// entry, as well. Our criterion is that all non-standard
comment|// types (*not* customized standard types) must be written.
name|BibtexEntryType
name|tp
init|=
name|be
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|BibtexEntryType
operator|.
name|getStandardType
argument_list|(
name|tp
operator|.
name|getName
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
name|types
operator|.
name|put
argument_list|(
name|tp
operator|.
name|getName
argument_list|()
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
comment|// Check if the entry should be written.
name|boolean
name|write
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|checkSearch
operator|&&
operator|!
name|nonZeroField
argument_list|(
name|be
argument_list|,
name|BibtexFields
operator|.
name|SEARCH
argument_list|)
condition|)
block|{
name|write
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|checkGroup
operator|&&
operator|!
name|nonZeroField
argument_list|(
name|be
argument_list|,
name|BibtexFields
operator|.
name|GROUPSEARCH
argument_list|)
condition|)
block|{
name|write
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|write
condition|)
block|{
name|be
operator|.
name|write
argument_list|(
name|fw
argument_list|,
name|ff
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Write meta data.
if|if
condition|(
name|metaData
operator|!=
literal|null
condition|)
block|{
name|metaData
operator|.
name|writeMetaData
argument_list|(
name|fw
argument_list|)
expr_stmt|;
block|}
comment|// Write type definitions, if any:
if|if
condition|(
name|types
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|i
init|=
name|types
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|CustomEntryType
name|tp
init|=
operator|(
name|CustomEntryType
operator|)
name|types
operator|.
name|get
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|tp
operator|.
name|save
argument_list|(
name|fw
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
block|}
name|fw
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
try|try
block|{
name|session
operator|.
name|cancel
argument_list|()
expr_stmt|;
comment|// repairAfterError(file, backup, INIT_OK);
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Argh, another error? Can we do anything?
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|SaveException
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
operator|+
literal|"\n"
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"Warning: could not complete file repair; your file may "
operator|+
literal|"have been corrupted. Error message: "
argument_list|)
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|SaveException
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|exceptionCause
argument_list|)
throw|;
block|}
return|return
name|session
return|;
block|}
comment|/** 	 * Saves the database to file, including only the entries included in the 	 * supplied input array bes. 	 *  	 * @return A List containing warnings, if any. 	 */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|savePartOfDatabase (BibtexDatabase database, MetaData metaData, File file, JabRefPreferences prefs, BibtexEntry[] bes, String encoding)
specifier|public
specifier|static
name|SaveSession
name|savePartOfDatabase
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|MetaData
name|metaData
parameter_list|,
name|File
name|file
parameter_list|,
name|JabRefPreferences
name|prefs
parameter_list|,
name|BibtexEntry
index|[]
name|bes
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|SaveException
block|{
name|TreeMap
argument_list|<
name|String
argument_list|,
name|BibtexEntryType
argument_list|>
name|types
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|BibtexEntryType
argument_list|>
argument_list|()
decl_stmt|;
comment|// Map
comment|// to
comment|// collect
comment|// entry
comment|// type
comment|// definitions
comment|// that we must save along with entries using them.
name|BibtexEntry
name|be
init|=
literal|null
decl_stmt|;
name|boolean
name|backup
init|=
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"backup"
argument_list|)
decl_stmt|;
name|SaveSession
name|session
decl_stmt|;
try|try
block|{
name|session
operator|=
operator|new
name|SaveSession
argument_list|(
name|file
argument_list|,
name|encoding
argument_list|,
name|backup
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SaveException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
try|try
block|{
comment|// Define our data stream.
name|VerifyingWriter
name|fw
init|=
name|session
operator|.
name|getWriter
argument_list|()
decl_stmt|;
comment|// Write signature.
name|writeBibFileHeader
argument_list|(
name|fw
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
comment|// Write preamble if there is one.
name|writePreamble
argument_list|(
name|fw
argument_list|,
name|database
operator|.
name|getPreamble
argument_list|()
argument_list|)
expr_stmt|;
comment|// Write strings if there are any.
name|writeStrings
argument_list|(
name|fw
argument_list|,
name|database
argument_list|)
expr_stmt|;
comment|// Write database entries. Take care, using CrossRefEntry-
comment|// Comparator, that referred entries occur after referring
comment|// ones. Apart from crossref requirements, entries will be
comment|// sorted as they appear on the screen.
name|String
name|pri
decl_stmt|,
name|sec
decl_stmt|,
name|ter
decl_stmt|;
name|boolean
name|priD
decl_stmt|,
name|secD
decl_stmt|,
name|terD
decl_stmt|;
if|if
condition|(
operator|!
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"saveInStandardOrder"
argument_list|)
condition|)
block|{
comment|// The setting is to save according to the current table order.
name|pri
operator|=
name|prefs
operator|.
name|get
argument_list|(
literal|"priSort"
argument_list|)
expr_stmt|;
name|sec
operator|=
name|prefs
operator|.
name|get
argument_list|(
literal|"secSort"
argument_list|)
expr_stmt|;
comment|// sorted as they appear on the screen.
name|ter
operator|=
name|prefs
operator|.
name|get
argument_list|(
literal|"terSort"
argument_list|)
expr_stmt|;
name|priD
operator|=
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"priDescending"
argument_list|)
expr_stmt|;
name|secD
operator|=
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"secDescending"
argument_list|)
expr_stmt|;
name|terD
operator|=
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"terDescending"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The setting is to save in standard order: author, editor, year
name|pri
operator|=
literal|"author"
expr_stmt|;
name|sec
operator|=
literal|"editor"
expr_stmt|;
name|ter
operator|=
literal|"year"
expr_stmt|;
name|priD
operator|=
literal|false
expr_stmt|;
name|secD
operator|=
literal|false
expr_stmt|;
name|terD
operator|=
literal|true
expr_stmt|;
block|}
name|List
argument_list|<
name|Comparator
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|>
name|comparators
init|=
operator|new
name|ArrayList
argument_list|<
name|Comparator
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|CrossRefEntryComparator
argument_list|()
argument_list|)
expr_stmt|;
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|FieldComparator
argument_list|(
name|pri
argument_list|,
name|priD
argument_list|)
argument_list|)
expr_stmt|;
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|FieldComparator
argument_list|(
name|sec
argument_list|,
name|secD
argument_list|)
argument_list|)
expr_stmt|;
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|FieldComparator
argument_list|(
name|ter
argument_list|,
name|terD
argument_list|)
argument_list|)
expr_stmt|;
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|FieldComparator
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
argument_list|)
expr_stmt|;
comment|// Use glazed lists to get a sorted view of the entries:
name|BasicEventList
name|entryList
init|=
operator|new
name|BasicEventList
argument_list|()
decl_stmt|;
name|SortedList
name|sorter
init|=
operator|new
name|SortedList
argument_list|(
name|entryList
argument_list|,
operator|new
name|FieldComparatorStack
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|(
name|comparators
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sorter
operator|.
name|add
argument_list|(
name|bes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|FieldFormatter
name|ff
init|=
operator|new
name|LatexFieldFormatter
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|BibtexEntry
argument_list|>
name|i
init|=
name|sorter
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|be
operator|=
operator|(
name|i
operator|.
name|next
argument_list|()
operator|)
expr_stmt|;
comment|// Check if we must write the type definition for this
comment|// entry, as well. Our criterion is that all non-standard
comment|// types (*not* customized standard types) must be written.
name|BibtexEntryType
name|tp
init|=
name|be
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|BibtexEntryType
operator|.
name|getStandardType
argument_list|(
name|tp
operator|.
name|getName
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
name|types
operator|.
name|put
argument_list|(
name|tp
operator|.
name|getName
argument_list|()
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
name|be
operator|.
name|write
argument_list|(
name|fw
argument_list|,
name|ff
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
comment|// Write meta data.
if|if
condition|(
name|metaData
operator|!=
literal|null
condition|)
block|{
name|metaData
operator|.
name|writeMetaData
argument_list|(
name|fw
argument_list|)
expr_stmt|;
block|}
comment|// Write type definitions, if any:
if|if
condition|(
name|types
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|i
init|=
name|types
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|CustomEntryType
name|tp
init|=
operator|(
name|CustomEntryType
operator|)
name|types
operator|.
name|get
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|tp
operator|.
name|save
argument_list|(
name|fw
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
block|}
name|fw
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
try|try
block|{
name|session
operator|.
name|cancel
argument_list|()
expr_stmt|;
comment|//repairAfterError(file, backup, status);
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Argh, another error? Can we do anything?
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|SaveException
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
operator|+
literal|"\n"
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"Warning: could not complete file repair; your file may "
operator|+
literal|"have been corrupted. Error message: "
argument_list|)
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|SaveException
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|be
argument_list|)
throw|;
block|}
return|return
name|session
return|;
block|}
DECL|method|exportToCSV (BibtexDatabase database, File outFile, JabRefPreferences prefs)
specifier|public
specifier|static
name|void
name|exportToCSV
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|File
name|outFile
parameter_list|,
name|JabRefPreferences
name|prefs
parameter_list|)
throws|throws
name|Exception
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|fieldFormatters
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|fieldFormatters
operator|.
name|put
argument_list|(
literal|"default"
argument_list|,
operator|new
name|RemoveLatexCommands
argument_list|()
argument_list|)
expr_stmt|;
name|fieldFormatters
operator|.
name|put
argument_list|(
literal|"author"
argument_list|,
operator|new
name|Object
index|[]
block|{
operator|new
name|AuthorLastFirst
argument_list|()
block|,
operator|new
name|RemoveLatexCommands
argument_list|()
block|}
argument_list|)
expr_stmt|;
name|fieldFormatters
operator|.
name|put
argument_list|(
literal|"pdf"
argument_list|,
operator|new
name|ResolvePDF
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|SEPARATOR
init|=
literal|"\t"
decl_stmt|;
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|sorted
init|=
name|getSortedEntries
argument_list|(
name|database
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|fields
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|BibtexFields
operator|.
name|numberOfPublicFields
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|fields
operator|.
name|add
argument_list|(
name|BibtexFields
operator|.
name|getFieldName
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|//	try {
name|Object
index|[]
name|o
init|=
name|fields
operator|.
name|toArray
argument_list|()
decl_stmt|;
name|FileWriter
name|out
init|=
operator|new
name|FileWriter
argument_list|(
name|outFile
argument_list|)
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
operator|(
name|String
operator|)
name|o
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|o
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|write
argument_list|(
name|SEPARATOR
operator|+
operator|(
name|String
operator|)
name|o
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|write
argument_list|(
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|sorted
control|)
block|{
name|writeField
argument_list|(
name|database
argument_list|,
name|entry
argument_list|,
operator|(
name|String
operator|)
name|o
index|[
literal|0
index|]
argument_list|,
name|fieldFormatters
argument_list|,
name|out
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|o
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|out
operator|.
name|write
argument_list|(
name|SEPARATOR
argument_list|)
expr_stmt|;
name|writeField
argument_list|(
name|database
argument_list|,
name|entry
argument_list|,
operator|(
name|String
operator|)
name|o
index|[
name|j
index|]
argument_list|,
name|fieldFormatters
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|write
argument_list|(
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
comment|//	} catch (Throwable ex) {}
block|}
DECL|method|writeField (BibtexDatabase database, BibtexEntry entry, String field, HashMap<String, Object> fieldFormatters, Writer out)
specifier|private
specifier|static
name|void
name|writeField
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|,
name|String
name|field
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|fieldFormatters
parameter_list|,
name|Writer
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|s
init|=
name|BibtexDatabase
operator|.
name|getResolvedField
argument_list|(
name|field
argument_list|,
name|entry
argument_list|,
name|database
argument_list|)
decl_stmt|;
name|Object
name|form
init|=
name|fieldFormatters
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|form
operator|==
literal|null
condition|)
name|form
operator|=
name|fieldFormatters
operator|.
name|get
argument_list|(
literal|"default"
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|instanceof
name|LayoutFormatter
condition|)
block|{
name|s
operator|=
operator|(
operator|(
name|LayoutFormatter
operator|)
name|form
operator|)
operator|.
name|format
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|form
operator|instanceof
name|Object
index|[]
condition|)
block|{
name|Object
index|[]
name|forms
init|=
operator|(
name|Object
index|[]
operator|)
name|form
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|forms
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|(
call|(
name|LayoutFormatter
call|)
argument_list|(
name|forms
index|[
name|i
index|]
argument_list|)
operator|)
operator|.
name|format
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|out
operator|.
name|write
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method attempts to get a Reader for the file path given, either by      * loading it as a resource (from within jar), or as a normal file.      * If unsuccessful (e.g. file not found), an IOException is thrown.      */
DECL|method|getReader (String name)
specifier|public
specifier|static
name|Reader
name|getReader
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|Reader
name|reader
init|=
literal|null
decl_stmt|;
comment|// Try loading as a resource first. This works for files inside the jar:
name|URL
name|reso
init|=
name|Globals
operator|.
name|class
operator|.
name|getResource
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|// If that didn't work, try loading as a normal file URL:
if|if
condition|(
name|reso
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|reader
operator|=
operator|new
name|InputStreamReader
argument_list|(
name|reso
operator|.
name|openStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Could not find layout file"
argument_list|)
operator|+
literal|": '"
operator|+
name|name
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|name
argument_list|)
decl_stmt|;
try|try
block|{
name|reader
operator|=
operator|new
name|FileReader
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Could not find layout file"
argument_list|)
operator|+
literal|": '"
operator|+
name|name
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
return|return
name|reader
return|;
block|}
comment|/*     * We have begun to use getSortedEntries() for both database save operations     * and non-database save operations.  In a non-database save operation     * (such as the exportDatabase call), we do not wish to use the     * global preference of saving in standard order.     */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getSortedEntries (BibtexDatabase database, Set<String> keySet, boolean isSaveOperation)
specifier|public
specifier|static
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|getSortedEntries
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|keySet
parameter_list|,
name|boolean
name|isSaveOperation
parameter_list|)
block|{
name|FieldComparatorStack
argument_list|<
name|BibtexEntry
argument_list|>
name|comparatorStack
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"saveInOriginalOrder"
argument_list|)
condition|)
block|{
comment|// Sort entries based on their creation order, utilizing the fact
comment|// that IDs used for entries are increasing, sortable numbers.
name|List
argument_list|<
name|Comparator
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|>
name|comparators
init|=
operator|new
name|ArrayList
argument_list|<
name|Comparator
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|CrossRefEntryComparator
argument_list|()
argument_list|)
expr_stmt|;
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|IdComparator
argument_list|()
argument_list|)
expr_stmt|;
name|comparatorStack
operator|=
operator|new
name|FieldComparatorStack
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|(
name|comparators
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|pri
decl_stmt|,
name|sec
decl_stmt|,
name|ter
decl_stmt|;
name|boolean
name|priD
decl_stmt|,
name|secD
decl_stmt|,
name|terD
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|isSaveOperation
operator|||
operator|!
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"saveInStandardOrder"
argument_list|)
condition|)
block|{
comment|// The setting is to save according to the current table order.
name|pri
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"priSort"
argument_list|)
expr_stmt|;
name|sec
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"secSort"
argument_list|)
expr_stmt|;
comment|// sorted as they appear on the screen.
name|ter
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"terSort"
argument_list|)
expr_stmt|;
name|priD
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"priDescending"
argument_list|)
expr_stmt|;
name|secD
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"secDescending"
argument_list|)
expr_stmt|;
name|terD
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"terDescending"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The setting is to save in standard order: author, editor, year
name|pri
operator|=
literal|"author"
expr_stmt|;
name|sec
operator|=
literal|"editor"
expr_stmt|;
name|ter
operator|=
literal|"year"
expr_stmt|;
name|priD
operator|=
literal|false
expr_stmt|;
name|secD
operator|=
literal|false
expr_stmt|;
name|terD
operator|=
literal|true
expr_stmt|;
block|}
name|List
argument_list|<
name|Comparator
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|>
name|comparators
init|=
operator|new
name|ArrayList
argument_list|<
name|Comparator
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|isSaveOperation
condition|)
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|CrossRefEntryComparator
argument_list|()
argument_list|)
expr_stmt|;
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|FieldComparator
argument_list|(
name|pri
argument_list|,
name|priD
argument_list|)
argument_list|)
expr_stmt|;
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|FieldComparator
argument_list|(
name|sec
argument_list|,
name|secD
argument_list|)
argument_list|)
expr_stmt|;
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|FieldComparator
argument_list|(
name|ter
argument_list|,
name|terD
argument_list|)
argument_list|)
expr_stmt|;
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|FieldComparator
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
argument_list|)
expr_stmt|;
name|comparatorStack
operator|=
operator|new
name|FieldComparatorStack
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|(
name|comparators
argument_list|)
expr_stmt|;
block|}
comment|// Use glazed lists to get a sorted view of the entries:
name|BasicEventList
name|entryList
init|=
operator|new
name|BasicEventList
argument_list|()
decl_stmt|;
name|SortedList
name|sorter
init|=
operator|new
name|SortedList
argument_list|(
name|entryList
argument_list|,
name|comparatorStack
argument_list|)
decl_stmt|;
if|if
condition|(
name|keySet
operator|==
literal|null
condition|)
name|keySet
operator|=
name|database
operator|.
name|getKeySet
argument_list|()
expr_stmt|;
if|if
condition|(
name|keySet
operator|!=
literal|null
condition|)
block|{
name|Iterator
argument_list|<
name|String
argument_list|>
name|i
init|=
name|keySet
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|sorter
operator|.
name|add
argument_list|(
name|database
operator|.
name|getEntryById
argument_list|(
operator|(
name|i
operator|.
name|next
argument_list|()
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sorter
return|;
block|}
comment|/** Returns true iff the entry has a nonzero value in its field.      */
DECL|method|nonZeroField (BibtexEntry be, String field)
specifier|private
specifier|static
name|boolean
name|nonZeroField
parameter_list|(
name|BibtexEntry
name|be
parameter_list|,
name|String
name|field
parameter_list|)
block|{
name|String
name|o
init|=
call|(
name|String
call|)
argument_list|(
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|o
operator|.
name|equals
argument_list|(
literal|"0"
argument_list|)
operator|)
return|;
block|}
block|}
end_class

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//  END OF FILE.
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

end_unit

