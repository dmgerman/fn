begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2003 Nizar N. Batada, Morten O. Alver  All programs in this directory and subdirectories are published under the GNU General Public License as described below.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA  Further information about the GNU GPL is available at: http://www.gnu.org/copyleft/gpl.ja.html  */
end_comment

begin_package
DECL|package|net.sf.jabref.export
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
package|;
end_package

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|*
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|dom
operator|.
name|*
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|stream
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|Layout
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|LayoutHelper
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|LayoutFormatter
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|format
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|mods
operator|.
name|*
import|;
end_import

begin_class
DECL|class|FileActions
specifier|public
class|class
name|FileActions
block|{
DECL|method|writePreamble (Writer fw, String preamble)
specifier|private
specifier|static
name|void
name|writePreamble
parameter_list|(
name|Writer
name|fw
parameter_list|,
name|String
name|preamble
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|preamble
operator|!=
literal|null
condition|)
block|{
name|fw
operator|.
name|write
argument_list|(
literal|"@PREAMBLE{"
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|preamble
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"}"
operator|+
name|Globals
operator|.
name|NEWLINE
operator|+
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeStrings (Writer fw, BibtexDatabase database)
specifier|private
specifier|static
name|void
name|writeStrings
parameter_list|(
name|Writer
name|fw
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
throws|throws
name|IOException
block|{
name|TreeSet
name|strings
init|=
operator|new
name|TreeSet
argument_list|(
operator|new
name|BibtexStringComparator
argument_list|(
literal|true
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|database
operator|.
name|getStringKeySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|strings
operator|.
name|add
argument_list|(
name|database
operator|.
name|getString
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|strings
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BibtexString
name|bs
init|=
operator|(
name|BibtexString
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"@STRING{"
operator|+
name|bs
operator|.
name|getName
argument_list|()
operator|+
literal|" = "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bs
operator|.
name|getContent
argument_list|()
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
name|fw
operator|.
name|write
argument_list|(
operator|(
operator|new
name|LatexFieldFormatter
argument_list|()
operator|)
operator|.
name|format
argument_list|(
name|bs
operator|.
name|getContent
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fw
operator|.
name|write
argument_list|(
literal|"{}"
argument_list|)
expr_stmt|;
comment|//Util.writeField(bs.getName(), bs.getContent(), fw) ;
name|fw
operator|.
name|write
argument_list|(
literal|"}"
operator|+
name|Globals
operator|.
name|NEWLINE
operator|+
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Writes the JabRef signature and the encoding.      *      * @param encoding String the name of the encoding, which is part of the header.      */
DECL|method|writeBibFileHeader (Writer out, String encoding)
specifier|private
specifier|static
name|void
name|writeBibFileHeader
parameter_list|(
name|Writer
name|out
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|write
argument_list|(
name|GUIGlobals
operator|.
name|SIGNATURE
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
literal|" "
operator|+
name|GUIGlobals
operator|.
name|version
operator|+
literal|"."
operator|+
name|Globals
operator|.
name|NEWLINE
operator|+
name|GUIGlobals
operator|.
name|encPrefix
operator|+
name|encoding
operator|+
name|Globals
operator|.
name|NEWLINE
operator|+
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Saves the database to file. Two boolean values indicate whether      * only entries with a nonzero Globals.SEARCH value and only      * entries with a nonzero Globals.GROUPSEARCH value should be      * saved. This can be used to let the user save only the results of      * a search. False and false means all entries are saved.      */
DECL|method|saveDatabase (BibtexDatabase database, MetaData metaData, File file, JabRefPreferences prefs, boolean checkSearch, boolean checkGroup, String encoding)
specifier|public
specifier|static
name|SaveSession
name|saveDatabase
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|MetaData
name|metaData
parameter_list|,
name|File
name|file
parameter_list|,
name|JabRefPreferences
name|prefs
parameter_list|,
name|boolean
name|checkSearch
parameter_list|,
name|boolean
name|checkGroup
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|SaveException
block|{
name|BibtexEntry
name|be
init|=
literal|null
decl_stmt|;
name|TreeMap
name|types
init|=
operator|new
name|TreeMap
argument_list|()
decl_stmt|;
comment|// Map to collect entry type definitions
comment|// that we must save along with entries using them.
name|boolean
name|backup
init|=
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"backup"
argument_list|)
decl_stmt|;
name|SaveSession
name|session
decl_stmt|;
try|try
block|{
name|session
operator|=
operator|new
name|SaveSession
argument_list|(
name|file
argument_list|,
name|encoding
argument_list|,
name|backup
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SaveException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
try|try
block|{
comment|// Get our data stream. This stream writes only to a temporary file, until committed.
name|VerifyingWriter
name|fw
init|=
name|session
operator|.
name|getWriter
argument_list|()
decl_stmt|;
comment|// Write signature.
name|writeBibFileHeader
argument_list|(
name|fw
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
comment|// Write preamble if there is one.
name|writePreamble
argument_list|(
name|fw
argument_list|,
name|database
operator|.
name|getPreamble
argument_list|()
argument_list|)
expr_stmt|;
comment|// Write strings if there are any.
name|writeStrings
argument_list|(
name|fw
argument_list|,
name|database
argument_list|)
expr_stmt|;
comment|// Write database entries. Take care, using CrossRefEntry-
comment|// Comparator, that referred entries occur after referring
comment|// ones. Apart from crossref requirements, entries will be
comment|// sorted as they appear on the screen.
name|Set
name|sorter
init|=
name|getSortedEntries
argument_list|(
name|database
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|FieldFormatter
name|ff
init|=
operator|new
name|LatexFieldFormatter
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|sorter
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|be
operator|=
call|(
name|BibtexEntry
call|)
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check if we must write the type definition for this
comment|// entry, as well. Our criterion is that all non-standard
comment|// types (*not* customized standard types) must be written.
name|BibtexEntryType
name|tp
init|=
name|be
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|BibtexEntryType
operator|.
name|getStandardType
argument_list|(
name|tp
operator|.
name|getName
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
name|types
operator|.
name|put
argument_list|(
name|tp
operator|.
name|getName
argument_list|()
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
comment|// Check if the entry should be written.
name|boolean
name|write
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|checkSearch
operator|&&
operator|!
name|nonZeroField
argument_list|(
name|be
argument_list|,
name|Globals
operator|.
name|SEARCH
argument_list|)
condition|)
block|{
name|write
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|checkGroup
operator|&&
operator|!
name|nonZeroField
argument_list|(
name|be
argument_list|,
name|Globals
operator|.
name|GROUPSEARCH
argument_list|)
condition|)
block|{
name|write
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|write
condition|)
block|{
name|be
operator|.
name|write
argument_list|(
name|fw
argument_list|,
name|ff
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Write meta data.
if|if
condition|(
name|metaData
operator|!=
literal|null
condition|)
block|{
name|metaData
operator|.
name|writeMetaData
argument_list|(
name|fw
argument_list|)
expr_stmt|;
block|}
comment|// Write type definitions, if any:
if|if
condition|(
name|types
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|types
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|CustomEntryType
name|tp
init|=
operator|(
name|CustomEntryType
operator|)
name|types
operator|.
name|get
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|tp
operator|.
name|save
argument_list|(
name|fw
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
block|}
name|fw
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
try|try
block|{
name|session
operator|.
name|cancel
argument_list|()
expr_stmt|;
comment|//repairAfterError(file, backup, INIT_OK);
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Argh, another error? Can we do anything?
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|SaveException
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
operator|+
literal|"\n"
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"Warning: could not complete file repair; your file may "
operator|+
literal|"have been corrupted. Error message: "
argument_list|)
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|SaveException
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|be
argument_list|)
throw|;
block|}
return|return
name|session
return|;
block|}
comment|/**      * Saves the database to file, including only the entries included      * in the supplied input array bes.      *      * @return A List containing warnings, if any.      */
DECL|method|savePartOfDatabase (BibtexDatabase database, MetaData metaData, File file, JabRefPreferences prefs, BibtexEntry[] bes, String encoding)
specifier|public
specifier|static
name|SaveSession
name|savePartOfDatabase
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|MetaData
name|metaData
parameter_list|,
name|File
name|file
parameter_list|,
name|JabRefPreferences
name|prefs
parameter_list|,
name|BibtexEntry
index|[]
name|bes
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|SaveException
block|{
name|TreeMap
name|types
init|=
operator|new
name|TreeMap
argument_list|()
decl_stmt|;
comment|// Map to collect entry type definitions
comment|// that we must save along with entries using them.
name|BibtexEntry
name|be
init|=
literal|null
decl_stmt|;
name|boolean
name|backup
init|=
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"backup"
argument_list|)
decl_stmt|;
name|SaveSession
name|session
decl_stmt|;
try|try
block|{
name|session
operator|=
operator|new
name|SaveSession
argument_list|(
name|file
argument_list|,
name|encoding
argument_list|,
name|backup
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SaveException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
try|try
block|{
comment|// Define our data stream.
name|VerifyingWriter
name|fw
init|=
name|getWriter
argument_list|(
name|file
argument_list|,
name|encoding
argument_list|)
decl_stmt|;
comment|// Write signature.
name|writeBibFileHeader
argument_list|(
name|fw
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
comment|// Write preamble if there is one.
name|writePreamble
argument_list|(
name|fw
argument_list|,
name|database
operator|.
name|getPreamble
argument_list|()
argument_list|)
expr_stmt|;
comment|// Write strings if there are any.
name|writeStrings
argument_list|(
name|fw
argument_list|,
name|database
argument_list|)
expr_stmt|;
comment|// Write database entries. Take care, using CrossRefEntry-
comment|// Comparator, that referred entries occur after referring
comment|// ones. Apart from crossref requirements, entries will be
comment|// sorted as they appear on the screen.
name|String
name|pri
decl_stmt|,
name|sec
decl_stmt|,
name|ter
decl_stmt|;
name|boolean
name|priD
decl_stmt|,
name|secD
decl_stmt|,
name|terD
decl_stmt|,
name|priBinary
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"saveInStandardOrder"
argument_list|)
condition|)
block|{
comment|// The setting is to save according to the current table order.
name|priBinary
operator|=
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"priBinary"
argument_list|)
expr_stmt|;
name|pri
operator|=
name|prefs
operator|.
name|get
argument_list|(
literal|"priSort"
argument_list|)
expr_stmt|;
name|sec
operator|=
name|prefs
operator|.
name|get
argument_list|(
literal|"secSort"
argument_list|)
expr_stmt|;
comment|// sorted as they appear on the screen.
name|ter
operator|=
name|prefs
operator|.
name|get
argument_list|(
literal|"terSort"
argument_list|)
expr_stmt|;
name|priD
operator|=
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"priDescending"
argument_list|)
expr_stmt|;
name|secD
operator|=
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"secDescending"
argument_list|)
expr_stmt|;
name|terD
operator|=
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"terDescending"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The setting is to save in standard order: author, editor, year
name|pri
operator|=
literal|"author"
expr_stmt|;
name|sec
operator|=
literal|"editor"
expr_stmt|;
name|ter
operator|=
literal|"year"
expr_stmt|;
name|priD
operator|=
literal|false
expr_stmt|;
name|secD
operator|=
literal|false
expr_stmt|;
name|terD
operator|=
literal|true
expr_stmt|;
block|}
name|EntryComparator
name|comp
init|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|,
name|Globals
operator|.
name|KEY_FIELD
argument_list|)
decl_stmt|;
name|comp
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
name|terD
argument_list|,
name|ter
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|comp
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
name|secD
argument_list|,
name|sec
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|comp
operator|=
operator|new
name|EntryComparator
argument_list|(
name|priBinary
argument_list|,
name|priD
argument_list|,
name|pri
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|TreeSet
name|sorter
init|=
operator|new
name|TreeSet
argument_list|(
operator|new
name|CrossRefEntryComparator
argument_list|(
name|comp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sorter
operator|.
name|add
argument_list|(
name|bes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|FieldFormatter
name|ff
init|=
operator|new
name|LatexFieldFormatter
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|sorter
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|be
operator|=
call|(
name|BibtexEntry
call|)
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check if we must write the type definition for this
comment|// entry, as well. Our criterion is that all non-standard
comment|// types (*not* customized standard types) must be written.
name|BibtexEntryType
name|tp
init|=
name|be
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|BibtexEntryType
operator|.
name|getStandardType
argument_list|(
name|tp
operator|.
name|getName
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
name|types
operator|.
name|put
argument_list|(
name|tp
operator|.
name|getName
argument_list|()
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
name|be
operator|.
name|write
argument_list|(
name|fw
argument_list|,
name|ff
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
comment|// Write meta data.
if|if
condition|(
name|metaData
operator|!=
literal|null
condition|)
block|{
name|metaData
operator|.
name|writeMetaData
argument_list|(
name|fw
argument_list|)
expr_stmt|;
block|}
comment|// Write type definitions, if any:
if|if
condition|(
name|types
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|types
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|CustomEntryType
name|tp
init|=
operator|(
name|CustomEntryType
operator|)
name|types
operator|.
name|get
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|tp
operator|.
name|save
argument_list|(
name|fw
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
block|}
name|fw
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
try|try
block|{
name|session
operator|.
name|cancel
argument_list|()
expr_stmt|;
comment|//repairAfterError(file, backup, status);
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Argh, another error? Can we do anything?
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|SaveException
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
operator|+
literal|"\n"
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"Warning: could not complete file repair; your file may "
operator|+
literal|"have been corrupted. Error message: "
argument_list|)
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|SaveException
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|be
argument_list|)
throw|;
block|}
return|return
name|session
return|;
block|}
DECL|method|getWriter (File f, String encoding)
specifier|public
specifier|static
name|VerifyingWriter
name|getWriter
parameter_list|(
name|File
name|f
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|IOException
block|{
name|VerifyingWriter
name|ow
decl_stmt|;
name|ow
operator|=
operator|new
name|VerifyingWriter
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|f
argument_list|)
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
return|return
name|ow
return|;
block|}
DECL|method|exportCustomDatabase (BibtexDatabase database, String directory, String lfName, File outFile)
specifier|public
specifier|static
name|void
name|exportCustomDatabase
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|String
name|directory
parameter_list|,
name|String
name|lfName
parameter_list|,
name|File
name|outFile
parameter_list|)
throws|throws
name|Exception
block|{
name|exportDatabase
argument_list|(
name|database
argument_list|,
name|directory
argument_list|,
name|lfName
argument_list|,
name|outFile
argument_list|)
expr_stmt|;
block|}
DECL|method|exportDatabase (BibtexDatabase database, String lfName, File outFile)
specifier|public
specifier|static
name|void
name|exportDatabase
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|String
name|lfName
parameter_list|,
name|File
name|outFile
parameter_list|)
throws|throws
name|Exception
block|{
name|exportDatabase
argument_list|(
name|database
argument_list|,
name|Globals
operator|.
name|LAYOUT_PREFIX
argument_list|,
name|lfName
argument_list|,
name|outFile
argument_list|)
expr_stmt|;
block|}
DECL|method|exportDatabase (BibtexDatabase database, String prefix, String lfName, File outFile)
specifier|public
specifier|static
name|void
name|exportDatabase
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|String
name|prefix
parameter_list|,
name|String
name|lfName
parameter_list|,
name|File
name|outFile
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|lfName
operator|.
name|equals
argument_list|(
literal|"oocalc"
argument_list|)
condition|)
block|{
name|OpenOfficeDocumentCreator
operator|.
name|exportOpenOfficeCalc
argument_list|(
name|outFile
argument_list|,
name|database
argument_list|)
expr_stmt|;
return|return;
block|}
name|String
name|encoding
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"defaultEncoding"
argument_list|)
decl_stmt|;
comment|//"iso-8859-1";
name|OutputStreamWriter
name|ps
init|=
literal|null
decl_stmt|;
name|ps
operator|=
operator|new
name|OutputStreamWriter
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|outFile
argument_list|)
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|exportDatabase
argument_list|(
name|database
argument_list|,
literal|null
argument_list|,
name|prefix
argument_list|,
name|lfName
argument_list|,
name|ps
argument_list|)
expr_stmt|;
block|}
DECL|method|exportDatabase (BibtexDatabase database, Set entries, String prefix, String lfName, Writer ps)
specifier|public
specifier|static
name|void
name|exportDatabase
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|Set
name|entries
parameter_list|,
name|String
name|prefix
parameter_list|,
name|String
name|lfName
parameter_list|,
name|Writer
name|ps
parameter_list|)
throws|throws
name|Exception
block|{
name|Object
index|[]
name|keys
init|=
name|database
operator|.
name|getKeySet
argument_list|()
operator|.
name|toArray
argument_list|()
decl_stmt|;
name|String
name|key
decl_stmt|,
name|type
decl_stmt|;
name|Reader
name|reader
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|lfName
operator|.
name|equals
argument_list|(
literal|"mods"
argument_list|)
condition|)
block|{
name|MODSDatabase
name|md
init|=
operator|new
name|MODSDatabase
argument_list|(
name|database
argument_list|)
decl_stmt|;
try|try
block|{
name|DOMSource
name|source
init|=
operator|new
name|DOMSource
argument_list|(
name|md
operator|.
name|getDOMrepresentation
argument_list|()
argument_list|)
decl_stmt|;
name|StreamResult
name|result
init|=
operator|new
name|StreamResult
argument_list|(
name|ps
argument_list|)
decl_stmt|;
name|Transformer
name|trans
init|=
name|TransformerFactory
operator|.
name|newInstance
argument_list|()
operator|.
name|newTransformer
argument_list|()
decl_stmt|;
name|trans
operator|.
name|setOutputProperty
argument_list|(
name|OutputKeys
operator|.
name|INDENT
argument_list|,
literal|"yes"
argument_list|)
expr_stmt|;
name|trans
operator|.
name|transform
argument_list|(
name|source
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|ps
operator|.
name|close
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// Print header
try|try
block|{
name|reader
operator|=
name|getReader
argument_list|(
name|prefix
operator|+
name|lfName
operator|+
literal|".begin.layout"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|reader
operator|.
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|ps
operator|.
name|write
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{}
comment|// If an exception was cast, export filter doesn't have a begin file.
comment|// Write database entrie; entries will be sorted as they
comment|// appear on the screen, or sorted by author, depending on
comment|// Preferences.
comment|// We also supply the Set entries - if we are to export only certain entries,
comment|// it will be non-null, and be used to choose entries. Otherwise, it will be
comment|// null, and be ignored.
name|TreeSet
name|sorted
init|=
name|getSortedEntries
argument_list|(
name|database
argument_list|,
name|entries
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// Load default layout
name|reader
operator|=
name|getReader
argument_list|(
name|prefix
operator|+
name|lfName
operator|+
literal|".layout"
argument_list|)
expr_stmt|;
comment|//Util.pr(prefix+lfName+".layout");
name|LayoutHelper
name|layoutHelper
init|=
operator|new
name|LayoutHelper
argument_list|(
name|reader
argument_list|)
decl_stmt|;
name|Layout
name|defLayout
init|=
name|layoutHelper
operator|.
name|getLayoutFromText
argument_list|(
name|Globals
operator|.
name|FORMATTER_PACKAGE
argument_list|)
decl_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|HashMap
name|layouts
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
name|Layout
name|layout
decl_stmt|;
name|Iterator
name|i
init|=
name|sorted
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
comment|// Get the entry
name|BibtexEntry
name|entry
init|=
call|(
name|BibtexEntry
call|)
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
comment|//System.out.println(entry.getType().getName());
comment|// Get the layout
name|type
operator|=
name|entry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
if|if
condition|(
name|layouts
operator|.
name|containsKey
argument_list|(
name|type
argument_list|)
condition|)
name|layout
operator|=
operator|(
name|Layout
operator|)
name|layouts
operator|.
name|get
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
try|try
block|{
comment|// We try to get a type-specific layout for this entry.
name|reader
operator|=
name|getReader
argument_list|(
name|prefix
operator|+
name|lfName
operator|+
literal|"."
operator|+
name|type
operator|+
literal|".layout"
argument_list|)
expr_stmt|;
name|layoutHelper
operator|=
operator|new
name|LayoutHelper
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|layout
operator|=
name|layoutHelper
operator|.
name|getLayoutFromText
argument_list|(
name|Globals
operator|.
name|FORMATTER_PACKAGE
argument_list|)
expr_stmt|;
name|layouts
operator|.
name|put
argument_list|(
name|type
argument_list|,
name|layout
argument_list|)
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// The exception indicates that no type-specific layout exists, so we
comment|// go with the default one.
name|layout
operator|=
name|defLayout
expr_stmt|;
block|}
block|}
comment|//Layout layout = layoutHelper.getLayoutFromText();
comment|// Write the entry
name|ps
operator|.
name|write
argument_list|(
name|layout
operator|.
name|doLayout
argument_list|(
name|entry
argument_list|,
name|database
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Print footer
try|try
block|{
name|reader
operator|=
name|getReader
argument_list|(
name|prefix
operator|+
name|lfName
operator|+
literal|".end.layout"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|reader
operator|.
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|ps
operator|.
name|write
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{}
comment|// If an exception was cast, export filter doesn't have a end file.
name|ps
operator|.
name|flush
argument_list|()
expr_stmt|;
name|ps
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|exportEntries (BibtexDatabase database, BibtexEntry[] bes, String lfName, boolean custom, String directory, Writer sw)
specifier|public
specifier|static
name|void
name|exportEntries
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|BibtexEntry
index|[]
name|bes
parameter_list|,
name|String
name|lfName
parameter_list|,
name|boolean
name|custom
parameter_list|,
name|String
name|directory
parameter_list|,
name|Writer
name|sw
parameter_list|)
throws|throws
name|Exception
block|{
name|HashSet
name|keys
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bes
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|keys
operator|.
name|add
argument_list|(
name|bes
index|[
name|i
index|]
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|exportDatabase
argument_list|(
name|database
argument_list|,
name|keys
argument_list|,
operator|(
name|custom
condition|?
name|directory
else|:
name|Globals
operator|.
name|LAYOUT_PREFIX
operator|)
argument_list|,
name|lfName
argument_list|,
name|sw
argument_list|)
expr_stmt|;
block|}
DECL|method|exportToCSV (BibtexDatabase database, File outFile, JabRefPreferences prefs)
specifier|public
specifier|static
name|void
name|exportToCSV
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|File
name|outFile
parameter_list|,
name|JabRefPreferences
name|prefs
parameter_list|)
throws|throws
name|Exception
block|{
name|HashMap
name|fieldFormatters
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
name|fieldFormatters
operator|.
name|put
argument_list|(
literal|"default"
argument_list|,
operator|new
name|RemoveLatexCommands
argument_list|()
argument_list|)
expr_stmt|;
name|fieldFormatters
operator|.
name|put
argument_list|(
literal|"author"
argument_list|,
operator|new
name|Object
index|[]
block|{
operator|new
name|AuthorLastFirst
argument_list|()
block|,
operator|new
name|RemoveLatexCommands
argument_list|()
block|}
argument_list|)
expr_stmt|;
name|fieldFormatters
operator|.
name|put
argument_list|(
literal|"pdf"
argument_list|,
operator|new
name|ResolvePDF
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|SEPARATOR
init|=
literal|"\t"
decl_stmt|;
name|TreeSet
name|sorted
init|=
name|getSortedEntries
argument_list|(
name|database
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Set
name|fields
init|=
operator|new
name|TreeSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|GUIGlobals
operator|.
name|ALL_FIELDS
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|fields
operator|.
name|add
argument_list|(
name|GUIGlobals
operator|.
name|ALL_FIELDS
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|//	try {
name|Object
index|[]
name|o
init|=
name|fields
operator|.
name|toArray
argument_list|()
decl_stmt|;
name|FileWriter
name|out
init|=
operator|new
name|FileWriter
argument_list|(
name|outFile
argument_list|)
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
operator|(
name|String
operator|)
name|o
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|o
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|write
argument_list|(
name|SEPARATOR
operator|+
operator|(
name|String
operator|)
name|o
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|write
argument_list|(
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|sorted
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BibtexEntry
name|entry
init|=
operator|(
name|BibtexEntry
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|writeField
argument_list|(
name|database
argument_list|,
name|entry
argument_list|,
operator|(
name|String
operator|)
name|o
index|[
literal|0
index|]
argument_list|,
name|fieldFormatters
argument_list|,
name|out
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|o
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|out
operator|.
name|write
argument_list|(
name|SEPARATOR
argument_list|)
expr_stmt|;
name|writeField
argument_list|(
name|database
argument_list|,
name|entry
argument_list|,
operator|(
name|String
operator|)
name|o
index|[
name|j
index|]
argument_list|,
name|fieldFormatters
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|write
argument_list|(
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
comment|//	} catch (Throwable ex) {}
block|}
DECL|method|writeField (BibtexDatabase database, BibtexEntry entry, String field, HashMap fieldFormatters, Writer out)
specifier|private
specifier|static
name|void
name|writeField
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|,
name|String
name|field
parameter_list|,
name|HashMap
name|fieldFormatters
parameter_list|,
name|Writer
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|s
init|=
operator|(
name|String
operator|)
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|s
operator|=
name|database
operator|.
name|resolveForStrings
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|Object
name|form
init|=
name|fieldFormatters
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|form
operator|==
literal|null
condition|)
name|form
operator|=
name|fieldFormatters
operator|.
name|get
argument_list|(
literal|"default"
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|instanceof
name|LayoutFormatter
condition|)
block|{
name|s
operator|=
operator|(
operator|(
name|LayoutFormatter
operator|)
name|form
operator|)
operator|.
name|format
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|form
operator|instanceof
name|Object
index|[]
condition|)
block|{
name|Object
index|[]
name|forms
init|=
operator|(
name|Object
index|[]
operator|)
name|form
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|forms
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|(
call|(
name|LayoutFormatter
call|)
argument_list|(
name|forms
index|[
name|i
index|]
argument_list|)
operator|)
operator|.
name|format
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|out
operator|.
name|write
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method attempts to get a Reader for the file path given, either by      * loading it as a resource (from within jar), or as a normal file.      * If unsuccessful (e.g. file not found), an IOException is thrown.      */
DECL|method|getReader (String name)
specifier|private
specifier|static
name|Reader
name|getReader
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|Reader
name|reader
init|=
literal|null
decl_stmt|;
comment|// Try loading as a resource first. This works for files inside the jar:
name|URL
name|reso
init|=
name|JabRefFrame
operator|.
name|class
operator|.
name|getResource
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|// If that didn't work, try loading as a normal file URL:
if|if
condition|(
name|reso
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|reader
operator|=
operator|new
name|InputStreamReader
argument_list|(
name|reso
operator|.
name|openStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Could not find layout file"
argument_list|)
operator|+
literal|": '"
operator|+
name|name
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|name
argument_list|)
decl_stmt|;
try|try
block|{
name|reader
operator|=
operator|new
name|FileReader
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Could not find layout file"
argument_list|)
operator|+
literal|": '"
operator|+
name|name
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
return|return
name|reader
return|;
block|}
comment|/*      * We have begun to use getSortedEntries() for both database save operations      * and non-database save operations.  In a non-database save operation      * (such as the exportDatabase call), we do not wish to use the       * global preference of saving in standard order.      */
DECL|method|getSortedEntries (BibtexDatabase database, Set keySet, boolean isSaveOperation)
specifier|protected
specifier|static
name|TreeSet
name|getSortedEntries
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|Set
name|keySet
parameter_list|,
name|boolean
name|isSaveOperation
parameter_list|)
block|{
name|String
name|pri
decl_stmt|,
name|sec
decl_stmt|,
name|ter
decl_stmt|;
name|boolean
name|priD
decl_stmt|,
name|secD
decl_stmt|,
name|terD
decl_stmt|,
name|priBinary
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|isSaveOperation
operator|||
operator|!
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"saveInStandardOrder"
argument_list|)
condition|)
block|{
comment|// The setting is to save according to the current table order.
name|priBinary
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"priBinary"
argument_list|)
expr_stmt|;
name|pri
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"priSort"
argument_list|)
expr_stmt|;
name|sec
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"secSort"
argument_list|)
expr_stmt|;
comment|// sorted as they appear on the screen.
name|ter
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"terSort"
argument_list|)
expr_stmt|;
name|priD
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"priDescending"
argument_list|)
expr_stmt|;
name|secD
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"secDescending"
argument_list|)
expr_stmt|;
name|terD
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"terDescending"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The setting is to save in standard order: author, editor, year
name|pri
operator|=
literal|"author"
expr_stmt|;
name|sec
operator|=
literal|"editor"
expr_stmt|;
name|ter
operator|=
literal|"year"
expr_stmt|;
name|priD
operator|=
literal|false
expr_stmt|;
name|secD
operator|=
literal|false
expr_stmt|;
name|terD
operator|=
literal|true
expr_stmt|;
block|}
name|EntryComparator
name|comp
init|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|,
name|Globals
operator|.
name|KEY_FIELD
argument_list|)
decl_stmt|;
name|comp
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
name|terD
argument_list|,
name|ter
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|comp
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
name|secD
argument_list|,
name|sec
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|comp
operator|=
operator|new
name|EntryComparator
argument_list|(
name|priBinary
argument_list|,
name|priD
argument_list|,
name|pri
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|TreeSet
name|sorter
init|=
operator|new
name|TreeSet
argument_list|(
operator|new
name|CrossRefEntryComparator
argument_list|(
name|comp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|keySet
operator|==
literal|null
condition|)
name|keySet
operator|=
name|database
operator|.
name|getKeySet
argument_list|()
expr_stmt|;
if|if
condition|(
name|keySet
operator|!=
literal|null
condition|)
block|{
name|Iterator
name|i
init|=
name|keySet
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|sorter
operator|.
name|add
argument_list|(
name|database
operator|.
name|getEntryById
argument_list|(
call|(
name|String
call|)
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sorter
return|;
block|}
comment|/** Returns true iff the entry has a nonzero value in its field.      */
DECL|method|nonZeroField (BibtexEntry be, String field)
specifier|private
specifier|static
name|boolean
name|nonZeroField
parameter_list|(
name|BibtexEntry
name|be
parameter_list|,
name|String
name|field
parameter_list|)
block|{
name|String
name|o
init|=
call|(
name|String
call|)
argument_list|(
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|o
operator|.
name|equals
argument_list|(
literal|"0"
argument_list|)
operator|)
return|;
block|}
block|}
end_class

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//  END OF FILE.
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

end_unit

