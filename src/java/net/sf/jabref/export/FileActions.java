begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2003 Nizar N. Batada, Morten O. Alver  All programs in this directory and subdirectories are published under the GNU General Public License as described below.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA  Further information about the GNU GPL is available at: http://www.gnu.org/copyleft/gpl.ja.html  */
end_comment

begin_package
DECL|package|net.sf.jabref.export
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|Layout
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|LayoutHelper
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * DOCUMENT ME!  *  * @author $author$  * @version $Revision$  */
end_comment

begin_class
DECL|class|FileActions
specifier|public
class|class
name|FileActions
block|{
comment|//~ Methods ////////////////////////////////////////////////////////////////
comment|/**      * Saves the database to file. Two boolean values indicate whether      * only entries with a nonzero Globals.SEARCH value and only      * entries with a nonzero Globals.GROUPSEARCH value should be      * saved. This can be used to let the user save only the results of      * a search. False and false means all entries are saved.      */
DECL|method|saveDatabase (BibtexDatabase database, MetaData metaData, File file, JabRefPreferences prefs, boolean checkSearch, boolean checkGroup)
specifier|public
specifier|static
name|void
name|saveDatabase
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|MetaData
name|metaData
parameter_list|,
name|File
name|file
parameter_list|,
name|JabRefPreferences
name|prefs
parameter_list|,
name|boolean
name|checkSearch
parameter_list|,
name|boolean
name|checkGroup
parameter_list|)
throws|throws
name|SaveException
block|{
name|BibtexEntry
name|be
init|=
literal|null
decl_stmt|;
try|try
block|{
name|String
name|name
init|=
name|file
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|path
init|=
name|file
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|File
name|temp
init|=
operator|new
name|File
argument_list|(
name|path
argument_list|,
name|name
operator|+
name|GUIGlobals
operator|.
name|tempExt
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"backup"
argument_list|)
condition|)
block|{
name|File
name|back
init|=
operator|new
name|File
argument_list|(
name|path
argument_list|,
name|name
operator|+
name|GUIGlobals
operator|.
name|backupExt
argument_list|)
decl_stmt|;
if|if
condition|(
name|back
operator|.
name|exists
argument_list|()
condition|)
block|{
name|back
operator|.
name|renameTo
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
name|file
operator|.
name|renameTo
argument_list|(
name|back
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|.
name|exists
argument_list|()
condition|)
block|{
name|temp
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
name|file
operator|.
name|renameTo
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Define our data stream.
name|FileWriter
name|fw
init|=
operator|new
name|FileWriter
argument_list|(
name|file
argument_list|)
decl_stmt|;
comment|// Write signature.
name|fw
operator|.
name|write
argument_list|(
name|GUIGlobals
operator|.
name|SIGNATURE
argument_list|)
expr_stmt|;
comment|// Write preamble if there is one.
name|String
name|preamble
init|=
name|database
operator|.
name|getPreamble
argument_list|()
decl_stmt|;
if|if
condition|(
name|preamble
operator|!=
literal|null
condition|)
block|{
name|fw
operator|.
name|write
argument_list|(
literal|"@PREAMBLE{"
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|preamble
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
comment|// Write strings if there are any.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|database
operator|.
name|getStringCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|BibtexString
name|bs
init|=
name|database
operator|.
name|getString
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|//fw.write("@STRING{"+bs.getName()+" = \""+bs.getContent()+"\"}\n\n");
name|fw
operator|.
name|write
argument_list|(
literal|"@STRING{"
operator|+
name|bs
operator|.
name|getName
argument_list|()
operator|+
literal|" = "
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
operator|(
operator|new
name|LatexFieldFormatter
argument_list|()
operator|)
operator|.
name|format
argument_list|(
name|bs
operator|.
name|getContent
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|//Util.writeField(bs.getName(), bs.getContent(), fw);
name|fw
operator|.
name|write
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
comment|// Write database entries. Take care, using CrossRefEntry-
comment|// Comparator, that referred entries occur after referring
comment|// ones. Apart from crossref requirements, entries will be
comment|// sorted as they appear on the screen.
name|String
name|pri
init|=
name|prefs
operator|.
name|get
argument_list|(
literal|"priSort"
argument_list|)
decl_stmt|;
comment|// Write database entries. Take care, using CrossRefEntry-
comment|// Comparator, that referred entries occur after referring
comment|// ones. Apart from crossref requirements, entries will be
comment|// sorted as they appear on the screen.
name|String
name|sec
init|=
name|prefs
operator|.
name|get
argument_list|(
literal|"secSort"
argument_list|)
decl_stmt|;
comment|// Write database entries. Take care, using CrossRefEntry-
comment|// Comparator, that referred entries occur after referring
comment|// ones. Apart from crossref requirements, entries will be
comment|// sorted as they appear on the screen.
name|String
name|ter
init|=
name|prefs
operator|.
name|get
argument_list|(
literal|"terSort"
argument_list|)
decl_stmt|;
name|TreeSet
name|sorter
init|=
operator|new
name|TreeSet
argument_list|(
operator|new
name|CrossRefEntryComparator
argument_list|(
operator|new
name|EntryComparator
argument_list|(
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"priDescending"
argument_list|)
argument_list|,
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"secDescending"
argument_list|)
argument_list|,
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"terDescending"
argument_list|)
argument_list|,
name|pri
argument_list|,
name|sec
argument_list|,
name|ter
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Set
name|keySet
init|=
name|database
operator|.
name|getKeySet
argument_list|()
decl_stmt|;
if|if
condition|(
name|keySet
operator|!=
literal|null
condition|)
block|{
name|Iterator
name|i
init|=
name|keySet
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|sorter
operator|.
name|add
argument_list|(
name|database
operator|.
name|getEntryById
argument_list|(
call|(
name|String
call|)
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|FieldFormatter
name|ff
init|=
operator|new
name|LatexFieldFormatter
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|sorter
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|be
operator|=
call|(
name|BibtexEntry
call|)
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check if the entry should be written.
name|boolean
name|write
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|checkSearch
operator|&&
operator|!
name|nonZeroField
argument_list|(
name|be
argument_list|,
name|Globals
operator|.
name|SEARCH
argument_list|)
condition|)
block|{
name|write
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|checkGroup
operator|&&
operator|!
name|nonZeroField
argument_list|(
name|be
argument_list|,
name|Globals
operator|.
name|GROUPSEARCH
argument_list|)
condition|)
block|{
name|write
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|write
condition|)
block|{
name|be
operator|.
name|write
argument_list|(
name|fw
argument_list|,
name|ff
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Write meta data.
if|if
condition|(
name|metaData
operator|!=
literal|null
condition|)
block|{
name|metaData
operator|.
name|writeMetaData
argument_list|(
name|fw
argument_list|)
expr_stmt|;
block|}
name|fw
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
comment|//ex.printStackTrace();
comment|// Repair the file with our temp file since saving failed.
name|String
name|name
init|=
name|file
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// Repair the file with our temp file since saving failed.
name|String
name|path
init|=
name|file
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|File
name|temp
init|=
operator|new
name|File
argument_list|(
name|path
argument_list|,
name|name
operator|+
name|GUIGlobals
operator|.
name|tempExt
argument_list|)
decl_stmt|;
name|File
name|back
init|=
operator|new
name|File
argument_list|(
name|path
argument_list|,
name|name
operator|+
name|GUIGlobals
operator|.
name|backupExt
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
name|file
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|.
name|exists
argument_list|()
condition|)
block|{
name|temp
operator|.
name|renameTo
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|back
operator|.
name|renameTo
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|SaveException
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|be
argument_list|)
throw|;
block|}
block|}
DECL|method|exportDatabase (BibtexDatabase database, Reader formatReader, File outFile, JabRefPreferences prefs)
specifier|public
specifier|static
name|void
name|exportDatabase
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|Reader
name|formatReader
parameter_list|,
name|File
name|outFile
parameter_list|,
name|JabRefPreferences
name|prefs
parameter_list|)
throws|throws
name|IOException
block|{
name|PrintStream
name|ps
init|=
literal|null
decl_stmt|;
try|try
block|{
name|LayoutHelper
name|layoutHelper
init|=
operator|new
name|LayoutHelper
argument_list|(
name|formatReader
argument_list|)
decl_stmt|;
name|Layout
name|layout
init|=
name|layoutHelper
operator|.
name|getLayoutFromText
argument_list|()
decl_stmt|;
name|Object
index|[]
name|keys
init|=
name|database
operator|.
name|getKeySet
argument_list|()
operator|.
name|toArray
argument_list|()
decl_stmt|;
name|String
name|key
decl_stmt|;
name|ps
operator|=
operator|new
name|PrintStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|outFile
argument_list|)
argument_list|)
expr_stmt|;
comment|// Write database entrie; entries will be sorted as they
comment|// appear on the screen.
name|String
name|pri
init|=
name|prefs
operator|.
name|get
argument_list|(
literal|"priSort"
argument_list|)
decl_stmt|,
name|sec
init|=
name|prefs
operator|.
name|get
argument_list|(
literal|"secSort"
argument_list|)
decl_stmt|,
name|ter
init|=
name|prefs
operator|.
name|get
argument_list|(
literal|"terSort"
argument_list|)
decl_stmt|;
name|EntrySorter
name|sorter
init|=
name|database
operator|.
name|getSorter
argument_list|(
operator|new
name|EntryComparator
argument_list|(
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"priDescending"
argument_list|)
argument_list|,
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"secDescending"
argument_list|)
argument_list|,
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"terDescending"
argument_list|)
argument_list|,
name|pri
argument_list|,
name|sec
argument_list|,
name|ter
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sorter
operator|.
name|getEntryCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|key
operator|=
operator|(
name|String
operator|)
name|sorter
operator|.
name|getIdAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|BibtexEntry
name|entry
init|=
name|database
operator|.
name|getEntryById
argument_list|(
name|key
argument_list|)
decl_stmt|;
comment|//System.out.println(layout.doLayout(entry));
name|ps
operator|.
name|println
argument_list|(
name|layout
operator|.
name|doLayout
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Returns true iff the entry has a nonzero value in its field.      */
DECL|method|nonZeroField (BibtexEntry be, String field)
specifier|private
specifier|static
name|boolean
name|nonZeroField
parameter_list|(
name|BibtexEntry
name|be
parameter_list|,
name|String
name|field
parameter_list|)
block|{
name|String
name|o
init|=
call|(
name|String
call|)
argument_list|(
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|o
operator|.
name|equals
argument_list|(
literal|"0"
argument_list|)
operator|)
return|;
block|}
block|}
end_class

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//  END OF FILE.
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

end_unit

