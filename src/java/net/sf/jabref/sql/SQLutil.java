begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003-2011 JabRef contributors.     This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License along     with this program; if not, write to the Free Software Foundation, Inc.,     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */
end_comment

begin_package
DECL|package|net.sf.jabref.sql
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|sql
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|DriverManager
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLWarning
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexDatabase
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexEntryType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexFields
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexString
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|Globals
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|MetaData
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|FileActions
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|AbstractGroup
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|AllEntriesGroup
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|ExplicitGroup
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|GroupTreeNode
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|KeywordGroup
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|SearchGroup
import|;
end_import

begin_comment
comment|/**  *  * @author pattonlk  */
end_comment

begin_class
DECL|class|SQLutil
specifier|public
class|class
name|SQLutil
block|{
DECL|enum|DBTYPE
specifier|public
enum|enum
name|DBTYPE
block|{
DECL|enumConstant|MYSQL
DECL|enumConstant|DERBY
DECL|enumConstant|POSTGRESQL
name|MYSQL
block|,
name|DERBY
block|,
name|POSTGRESQL
block|}
DECL|field|fields
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|String
argument_list|>
name|fields
init|=
literal|null
decl_stmt|;
DECL|field|fieldstr
specifier|private
specifier|static
name|String
name|fieldstr
init|=
literal|null
decl_stmt|;
comment|/**      * returns the DBTYPE associated with a DBStrings ServerType      *      * @param dbstrings      *          The DBStrings to query      * @return The DBTYPE associated withthe dbstrings ServerType      */
DECL|method|getDBType (DBStrings dbstrings)
specifier|public
specifier|static
name|DBTYPE
name|getDBType
parameter_list|(
name|DBStrings
name|dbstrings
parameter_list|)
block|{
name|DBTYPE
name|dbtype
init|=
literal|null
decl_stmt|;
name|String
name|srvtype
init|=
name|dbstrings
operator|.
name|getServerType
argument_list|()
decl_stmt|;
if|if
condition|(
name|srvtype
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"mysql"
argument_list|)
condition|)
block|{
name|dbtype
operator|=
name|DBTYPE
operator|.
name|MYSQL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|srvtype
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"derby"
argument_list|)
condition|)
block|{
name|dbtype
operator|=
name|DBTYPE
operator|.
name|DERBY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|srvtype
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"postgresql"
argument_list|)
condition|)
block|{
name|dbtype
operator|=
name|DBTYPE
operator|.
name|POSTGRESQL
expr_stmt|;
block|}
return|return
name|dbtype
return|;
block|}
comment|/**      * This routine returns the JDBC url corresponding to the DBStrings input.      *      * @param dbstrings      *          The DBStrings to use to make the connection      * @return The JDBC url corresponding to the input DBStrings      */
DECL|method|createJDBCurl (DBStrings dbs)
specifier|public
specifier|static
name|String
name|createJDBCurl
parameter_list|(
name|DBStrings
name|dbs
parameter_list|)
block|{
name|String
name|url
init|=
literal|""
decl_stmt|;
name|String
name|servertype
init|=
name|dbs
operator|.
name|getServerType
argument_list|()
decl_stmt|;
if|if
condition|(
name|servertype
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"mysql"
argument_list|)
condition|)
block|{
name|url
operator|=
literal|"jdbc:"
operator|+
name|dbs
operator|.
name|getServerType
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"://"
operator|+
name|dbs
operator|.
name|getServerHostname
argument_list|()
operator|+
literal|"/"
operator|+
name|dbs
operator|.
name|getDatabase
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|servertype
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"postgresql"
argument_list|)
condition|)
block|{
name|url
operator|=
literal|"jdbc:"
operator|+
name|dbs
operator|.
name|getServerType
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"://"
operator|+
name|dbs
operator|.
name|getServerHostname
argument_list|()
operator|+
literal|"/"
operator|+
name|dbs
operator|.
name|getDatabase
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|servertype
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"derby"
argument_list|)
condition|)
block|{
name|url
operator|=
literal|"jdbc:"
operator|+
name|dbs
operator|.
name|getServerType
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|":"
operator|+
name|dbs
operator|.
name|getDatabase
argument_list|()
operator|+
literal|";create=true"
expr_stmt|;
block|}
return|return
name|url
return|;
block|}
DECL|method|getJDBCdriver (DBStrings dbstrings)
specifier|public
specifier|static
name|String
name|getJDBCdriver
parameter_list|(
name|DBStrings
name|dbstrings
parameter_list|)
block|{
name|String
name|driver
init|=
literal|""
decl_stmt|;
name|String
name|servertype
init|=
name|dbstrings
operator|.
name|getServerType
argument_list|()
decl_stmt|;
if|if
condition|(
name|servertype
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"mysql"
argument_list|)
condition|)
block|{
name|driver
operator|=
literal|"com.mysql.jdbc.Driver"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|servertype
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"derby"
argument_list|)
condition|)
block|{
name|driver
operator|=
literal|"org.apache.derby.jdbc.EmbeddedDriver"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|servertype
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"postgresql"
argument_list|)
condition|)
block|{
name|driver
operator|=
literal|"org.postgresql.Driver"
expr_stmt|;
block|}
return|return
name|driver
return|;
block|}
comment|/**      * This routine accepts the location of a MySQL database specified as a url as       * well as the username and password for the MySQL user with appropriate access      * to this database.  The routine returns a valid Connection object if the MySQL       * database is successfully opened. It returns a null object otherwise.      */
DECL|method|connectToDB (DBStrings dbstrings)
specifier|public
specifier|static
name|Connection
name|connectToDB
parameter_list|(
name|DBStrings
name|dbstrings
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|url
init|=
name|createJDBCurl
argument_list|(
name|dbstrings
argument_list|)
decl_stmt|;
name|String
name|drv
init|=
name|getJDBCdriver
argument_list|(
name|dbstrings
argument_list|)
decl_stmt|;
name|Class
operator|.
name|forName
argument_list|(
name|drv
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
name|Connection
name|conn
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
name|url
argument_list|,
name|dbstrings
operator|.
name|getUsername
argument_list|()
argument_list|,
name|dbstrings
operator|.
name|getPassword
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|conn
return|;
block|}
comment|/**      * Utility method for processing DML with proper output      *      * @param out      *          The output (PrintStream or Connection) object to which the DML should be sent      * @param dml      *          The DML statements to be processed      * @return the result of the statement      */
DECL|method|processDMLWithResults ( Object out, String dml)
specifier|private
specifier|static
name|Object
name|processDMLWithResults
parameter_list|(
name|Object
name|out
parameter_list|,
name|String
name|dml
parameter_list|)
throws|throws
name|SQLException
block|{
if|if
condition|(
name|out
operator|instanceof
name|PrintStream
condition|)
block|{
comment|// TODO: how to handle the PrintStream case?
name|PrintStream
name|fout
init|=
operator|(
name|PrintStream
operator|)
name|out
decl_stmt|;
name|fout
operator|.
name|println
argument_list|(
name|dml
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|out
operator|instanceof
name|Connection
condition|)
block|{
name|Connection
name|conn
init|=
operator|(
name|Connection
operator|)
name|out
decl_stmt|;
return|return
name|execDMLWithResults
argument_list|(
name|conn
argument_list|,
name|dml
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|processDMLWithSingleResult (Connection conn, String query)
specifier|private
specifier|static
name|String
name|processDMLWithSingleResult
parameter_list|(
name|Connection
name|conn
parameter_list|,
name|String
name|query
parameter_list|)
throws|throws
name|SQLException
block|{
name|Object
name|res
init|=
name|execDMLWithResults
argument_list|(
name|conn
argument_list|,
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|instanceof
name|Statement
condition|)
block|{
name|Statement
name|st
init|=
operator|(
name|Statement
operator|)
name|res
decl_stmt|;
name|ResultSet
name|rs
init|=
name|st
operator|.
name|getResultSet
argument_list|()
decl_stmt|;
name|rs
operator|.
name|next
argument_list|()
expr_stmt|;
name|String
name|returned
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|st
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|returned
return|;
block|}
else|else
return|return
literal|null
return|;
block|}
comment|/**      * Utility method for executing DML      *      * @param conn      *          The DML Connection object that will execute the SQL      * @param dml      *          The DML statements to be executed      */
DECL|method|execDMLWithResults (Connection conn, String dml)
specifier|public
specifier|static
name|Statement
name|execDMLWithResults
parameter_list|(
name|Connection
name|conn
parameter_list|,
name|String
name|dml
parameter_list|)
throws|throws
name|SQLException
block|{
comment|// System.out.println(dml); // remove
name|Statement
name|stmnt
init|=
name|conn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|stmnt
operator|.
name|executeQuery
argument_list|(
name|dml
argument_list|)
expr_stmt|;
name|SQLWarning
name|warn
init|=
name|stmnt
operator|.
name|getWarnings
argument_list|()
decl_stmt|;
if|if
condition|(
name|warn
operator|!=
literal|null
condition|)
block|{
comment|//TODO handle SQL warnings
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|warn
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"("
operator|+
name|dml
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
name|stmnt
return|;
block|}
comment|/**      * Utility method for processing DML with proper output      *      * @param out      *          The output (PrintStream or Connection) object to which the DML should be sent      * @param dml      *          The DML statements to be processed      */
DECL|method|processDML (Object out, String dml)
specifier|private
specifier|static
name|void
name|processDML
parameter_list|(
name|Object
name|out
parameter_list|,
name|String
name|dml
parameter_list|)
throws|throws
name|SQLException
block|{
if|if
condition|(
name|out
operator|instanceof
name|PrintStream
condition|)
block|{
name|PrintStream
name|fout
init|=
operator|(
name|PrintStream
operator|)
name|out
decl_stmt|;
name|fout
operator|.
name|println
argument_list|(
name|dml
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|instanceof
name|Connection
condition|)
block|{
name|Connection
name|conn
init|=
operator|(
name|Connection
operator|)
name|out
decl_stmt|;
name|execDML
argument_list|(
name|conn
argument_list|,
name|dml
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Utility method for executing DML      *      * @param conn      *          The DML Connection object that will execute the SQL      * @param dml      *          The DML statements to be executed      */
DECL|method|execDML (Connection conn, String dml)
specifier|public
specifier|static
name|void
name|execDML
parameter_list|(
name|Connection
name|conn
parameter_list|,
name|String
name|dml
parameter_list|)
throws|throws
name|SQLException
block|{
comment|// System.out.println(dml); // remove
name|Statement
name|stmnt
init|=
name|conn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|stmnt
operator|.
name|execute
argument_list|(
name|dml
argument_list|)
expr_stmt|;
name|SQLWarning
name|warn
init|=
name|stmnt
operator|.
name|getWarnings
argument_list|()
decl_stmt|;
if|if
condition|(
name|warn
operator|!=
literal|null
condition|)
block|{
comment|//TODO handle SQL warnings
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|warn
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"("
operator|+
name|dml
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|stmnt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|getFields ()
specifier|public
specifier|static
name|ArrayList
argument_list|<
name|String
argument_list|>
name|getFields
parameter_list|()
block|{
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
name|refreshFields
argument_list|()
expr_stmt|;
block|}
return|return
name|fields
return|;
block|}
comment|/**      * loop through entry types to get required, optional, general and utility       * fields for this type.      */
DECL|method|refreshFields ()
specifier|public
specifier|static
name|void
name|refreshFields
parameter_list|()
block|{
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
name|fields
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fields
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|BibtexEntryType
name|val
range|:
name|BibtexEntryType
operator|.
name|ALL_TYPES
operator|.
name|values
argument_list|()
control|)
block|{
name|fields
operator|=
name|uniqueInsert
argument_list|(
name|fields
argument_list|,
name|val
operator|.
name|getRequiredFields
argument_list|()
argument_list|)
expr_stmt|;
name|fields
operator|=
name|uniqueInsert
argument_list|(
name|fields
argument_list|,
name|val
operator|.
name|getOptionalFields
argument_list|()
argument_list|)
expr_stmt|;
name|fields
operator|=
name|uniqueInsert
argument_list|(
name|fields
argument_list|,
name|val
operator|.
name|getGeneralFields
argument_list|()
argument_list|)
expr_stmt|;
name|fields
operator|=
name|uniqueInsert
argument_list|(
name|fields
argument_list|,
name|val
operator|.
name|getUtilityFields
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//fields = uniqueInsert(fields, new String[] {"owner", "timestamp"});
comment|// create comma separated list of field names
name|fieldstr
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|fieldstr
operator|=
name|fieldstr
operator|+
literal|", "
expr_stmt|;
name|fieldstr
operator|=
name|fieldstr
operator|+
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Inserts the elements of a String array into an ArrayList making sure not      * to duplicate entries in the ArrayList      *       * @param list      *            The ArrayList containing unique entries      * @param array      *            The String array to be inserted into the ArrayList      * @return The updated ArrayList with new unique entries      */
DECL|method|uniqueInsert (ArrayList<String> list, String[] array)
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|String
argument_list|>
name|uniqueInsert
parameter_list|(
name|ArrayList
argument_list|<
name|String
argument_list|>
name|list
parameter_list|,
name|String
index|[]
name|array
parameter_list|)
block|{
if|if
condition|(
name|array
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|array
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|list
operator|.
name|contains
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
condition|)
name|list
operator|.
name|add
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
comment|/**      * Accepts the BibtexDatabase and MetaData, generates the DML required to      * create and populate SQL database tables, and writes this DML to the       * specified output file.      *      * @param database      *          The BibtexDatabase to export      * @param metaData      *          The MetaData object containing the groups information      * @param keySet      *          The set of IDs of the entries to export.      * @param file      *          The name of the file to which the DML should be written      */
DECL|method|exportDatabase (final BibtexDatabase database, final MetaData metaData, Set<String> keySet, String file, DBTYPE dbtype )
specifier|public
specifier|static
name|void
name|exportDatabase
parameter_list|(
specifier|final
name|BibtexDatabase
name|database
parameter_list|,
specifier|final
name|MetaData
name|metaData
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|keySet
parameter_list|,
name|String
name|file
parameter_list|,
name|DBTYPE
name|dbtype
parameter_list|)
throws|throws
name|Exception
block|{
comment|// open output file
name|File
name|outfile
init|=
operator|new
name|File
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|outfile
operator|.
name|exists
argument_list|()
condition|)
name|outfile
operator|.
name|delete
argument_list|()
expr_stmt|;
name|BufferedOutputStream
name|writer
init|=
literal|null
decl_stmt|;
name|writer
operator|=
operator|new
name|BufferedOutputStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|outfile
argument_list|)
argument_list|)
expr_stmt|;
name|PrintStream
name|fout
init|=
literal|null
decl_stmt|;
name|fout
operator|=
operator|new
name|PrintStream
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|exportDatabase_worker
argument_list|(
name|dbtype
argument_list|,
name|database
argument_list|,
name|metaData
argument_list|,
name|keySet
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|fout
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|importDatabase (Set<String> keySet, DBStrings dbStrings)
specifier|public
specifier|static
name|Object
index|[]
name|importDatabase
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|keySet
parameter_list|,
name|DBStrings
name|dbStrings
parameter_list|)
throws|throws
name|Exception
block|{
name|DBTYPE
name|dbtype
init|=
name|getDBType
argument_list|(
name|dbStrings
argument_list|)
decl_stmt|;
name|Object
index|[]
name|result
init|=
literal|null
decl_stmt|;
name|Connection
name|conn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|conn
operator|=
name|SQLutil
operator|.
name|connectToDB
argument_list|(
name|dbStrings
argument_list|)
expr_stmt|;
comment|// conn.setAutoCommit(false);
name|result
operator|=
name|importDatabase_worker
argument_list|(
name|dbtype
argument_list|,
name|keySet
argument_list|,
name|conn
argument_list|)
expr_stmt|;
comment|/*if (!conn.getAutoCommit()) {                 conn.commit();                 conn.setAutoCommit(true);             }*/
name|conn
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
throw|throw
name|ex
throw|;
block|}
return|return
name|result
return|;
block|}
DECL|method|importDatabase_worker (DBTYPE dbtype, Set<String> keySet, Connection conn)
specifier|private
specifier|static
name|Object
index|[]
name|importDatabase_worker
parameter_list|(
name|DBTYPE
name|dbtype
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|keySet
parameter_list|,
name|Connection
name|conn
parameter_list|)
throws|throws
name|Exception
block|{
name|BibtexDatabase
name|database
init|=
operator|new
name|BibtexDatabase
argument_list|()
decl_stmt|;
comment|// Find entry type IDs and their mappings to type names:
name|HashMap
argument_list|<
name|String
argument_list|,
name|BibtexEntryType
argument_list|>
name|types
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BibtexEntryType
argument_list|>
argument_list|()
decl_stmt|;
name|Object
name|res
init|=
name|processDMLWithResults
argument_list|(
name|conn
argument_list|,
literal|"SELECT entry_types_id,label FROM entry_types;"
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|instanceof
name|Statement
condition|)
block|{
name|Statement
name|statement
init|=
operator|(
name|Statement
operator|)
name|res
decl_stmt|;
name|ResultSet
name|rs
init|=
name|statement
operator|.
name|getResultSet
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|types
operator|.
name|put
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
argument_list|,
name|BibtexEntryType
operator|.
name|getType
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterator
init|=
name|types
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
comment|// Read the column names from the entry table:
switch|switch
condition|(
name|dbtype
condition|)
block|{
case|case
name|MYSQL
case|:
name|res
operator|=
name|processDMLWithResults
argument_list|(
name|conn
argument_list|,
literal|"SHOW columns FROM entries;"
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTGRESQL
case|:
name|res
operator|=
name|processDMLWithResults
argument_list|(
name|conn
argument_list|,
literal|"select a.attname from pg_attribute a, pg_class b where b.relfilenode=a.attrelid and b.relname=\'entries\' and a.attname not in (\'tableoid\',\'cmax\',\'xmax\',\'cmin\'\'xmin\',\'ctid\');"
argument_list|)
expr_stmt|;
break|break;
default|default:
block|}
name|ArrayList
argument_list|<
name|String
argument_list|>
name|colNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|res
operator|instanceof
name|Statement
condition|)
block|{
name|Statement
name|statement
init|=
operator|(
name|Statement
operator|)
name|res
decl_stmt|;
name|ResultSet
name|rs
init|=
name|statement
operator|.
name|getResultSet
argument_list|()
decl_stmt|;
name|boolean
name|started
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
if|if
condition|(
name|started
condition|)
name|colNames
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
operator|.
name|equals
argument_list|(
literal|"cite_key"
argument_list|)
condition|)
name|started
operator|=
literal|true
expr_stmt|;
block|}
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Read the entries and create BibtexEntry instances:
name|HashMap
argument_list|<
name|String
argument_list|,
name|BibtexEntry
argument_list|>
name|entries
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BibtexEntry
argument_list|>
argument_list|()
decl_stmt|;
name|res
operator|=
name|processDMLWithResults
argument_list|(
name|conn
argument_list|,
literal|"SELECT * FROM entries;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|instanceof
name|Statement
condition|)
block|{
name|Statement
name|statement
init|=
operator|(
name|Statement
operator|)
name|res
decl_stmt|;
name|ResultSet
name|rs
init|=
name|statement
operator|.
name|getResultSet
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|String
name|id
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"entries_id"
argument_list|)
decl_stmt|;
name|BibtexEntry
name|entry
init|=
operator|new
name|BibtexEntry
argument_list|(
name|Util
operator|.
name|createNeutralId
argument_list|()
argument_list|,
name|types
operator|.
name|get
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|entry
operator|.
name|setField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|"cite_key"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterator
init|=
name|colNames
operator|.
name|iterator
argument_list|()
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|col
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|value
init|=
name|rs
operator|.
name|getString
argument_list|(
name|col
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
name|entry
operator|.
name|setField
argument_list|(
name|col
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|//System.out.println("col: "+col+": "+rs.getString(col));
block|}
name|entries
operator|.
name|put
argument_list|(
name|id
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|database
operator|.
name|insertEntry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Import strings and preamble:
name|res
operator|=
name|processDMLWithResults
argument_list|(
name|conn
argument_list|,
literal|"SELECT * FROM strings;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|instanceof
name|Statement
condition|)
block|{
name|Statement
name|statement
init|=
operator|(
name|Statement
operator|)
name|res
decl_stmt|;
name|ResultSet
name|rs
init|=
name|statement
operator|.
name|getResultSet
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|String
name|label
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"label"
argument_list|)
decl_stmt|,
name|content
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"content"
argument_list|)
decl_stmt|;
if|if
condition|(
name|label
operator|.
name|equals
argument_list|(
literal|"@PREAMBLE"
argument_list|)
condition|)
block|{
name|database
operator|.
name|setPreamble
argument_list|(
name|content
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BibtexString
name|string
init|=
operator|new
name|BibtexString
argument_list|(
name|Util
operator|.
name|createNeutralId
argument_list|()
argument_list|,
name|label
argument_list|,
name|content
argument_list|)
decl_stmt|;
name|database
operator|.
name|addString
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
block|}
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|MetaData
name|metaData
init|=
operator|new
name|MetaData
argument_list|()
decl_stmt|;
name|metaData
operator|.
name|initializeNewDatabase
argument_list|()
expr_stmt|;
comment|// Read the groups tree:
name|importGroupsTree
argument_list|(
name|dbtype
argument_list|,
name|metaData
argument_list|,
name|entries
argument_list|,
name|conn
argument_list|)
expr_stmt|;
return|return
operator|new
name|Object
index|[]
block|{
name|database
block|,
name|metaData
block|}
return|;
block|}
DECL|method|importGroupsTree (DBTYPE dbtype, MetaData metaData, HashMap<String,BibtexEntry> entries, Connection conn)
specifier|public
specifier|static
name|void
name|importGroupsTree
parameter_list|(
name|DBTYPE
name|dbtype
parameter_list|,
name|MetaData
name|metaData
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
name|Connection
name|conn
parameter_list|)
throws|throws
name|SQLException
block|{
name|Object
name|res
init|=
name|processDMLWithResults
argument_list|(
name|conn
argument_list|,
literal|"SELECT * FROM groups ORDER BY groups_id;"
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|instanceof
name|Statement
condition|)
block|{
name|Statement
name|statement
init|=
operator|(
name|Statement
operator|)
name|res
decl_stmt|;
name|ResultSet
name|rs
init|=
name|statement
operator|.
name|getResultSet
argument_list|()
decl_stmt|;
name|GroupTreeNode
name|rootNode
init|=
operator|new
name|GroupTreeNode
argument_list|(
operator|new
name|AllEntriesGroup
argument_list|()
argument_list|)
decl_stmt|;
comment|// Create a lookup map for finding the parent to add each group to:
name|HashMap
argument_list|<
name|String
argument_list|,
name|GroupTreeNode
argument_list|>
name|groups
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|GroupTreeNode
argument_list|>
argument_list|()
decl_stmt|;
name|LinkedHashMap
argument_list|<
name|GroupTreeNode
argument_list|,
name|String
argument_list|>
name|parentIds
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|GroupTreeNode
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|AbstractGroup
name|group
init|=
literal|null
decl_stmt|;
name|String
name|typeId
init|=
name|findGroupTypeName
argument_list|(
name|dbtype
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|"group_types_id"
argument_list|)
argument_list|,
name|conn
argument_list|)
decl_stmt|;
if|if
condition|(
name|typeId
operator|.
name|equals
argument_list|(
name|AllEntriesGroup
operator|.
name|ID
argument_list|)
condition|)
block|{
comment|// register the id of the root node:
name|groups
operator|.
name|put
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|"groups_id"
argument_list|)
argument_list|,
name|rootNode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typeId
operator|.
name|equals
argument_list|(
name|ExplicitGroup
operator|.
name|ID
argument_list|)
condition|)
block|{
name|group
operator|=
operator|new
name|ExplicitGroup
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|"label"
argument_list|)
argument_list|,
name|rs
operator|.
name|getInt
argument_list|(
literal|"hierarchical_context"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typeId
operator|.
name|equals
argument_list|(
name|KeywordGroup
operator|.
name|ID
argument_list|)
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Keyw: "
operator|+
name|rs
operator|.
name|getBoolean
argument_list|(
literal|"case_sensitive"
argument_list|)
argument_list|)
expr_stmt|;
name|group
operator|=
operator|new
name|KeywordGroup
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|"label"
argument_list|)
argument_list|,
name|Util
operator|.
name|unquote
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|"search_field"
argument_list|)
argument_list|,
literal|'\\'
argument_list|)
argument_list|,
name|Util
operator|.
name|unquote
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|"search_expression"
argument_list|)
argument_list|,
literal|'\\'
argument_list|)
argument_list|,
name|rs
operator|.
name|getBoolean
argument_list|(
literal|"case_sensitive"
argument_list|)
argument_list|,
name|rs
operator|.
name|getBoolean
argument_list|(
literal|"reg_exp"
argument_list|)
argument_list|,
name|rs
operator|.
name|getInt
argument_list|(
literal|"hierarchical_context"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typeId
operator|.
name|equals
argument_list|(
name|SearchGroup
operator|.
name|ID
argument_list|)
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Search: "
operator|+
name|rs
operator|.
name|getBoolean
argument_list|(
literal|"case_sensitive"
argument_list|)
argument_list|)
expr_stmt|;
name|group
operator|=
operator|new
name|SearchGroup
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|"label"
argument_list|)
argument_list|,
name|Util
operator|.
name|unquote
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|"search_expression"
argument_list|)
argument_list|,
literal|'\\'
argument_list|)
argument_list|,
name|rs
operator|.
name|getBoolean
argument_list|(
literal|"case_sensitive"
argument_list|)
argument_list|,
name|rs
operator|.
name|getBoolean
argument_list|(
literal|"reg_exp"
argument_list|)
argument_list|,
name|rs
operator|.
name|getInt
argument_list|(
literal|"hierarchical_context"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|group
operator|!=
literal|null
condition|)
block|{
name|GroupTreeNode
name|node
init|=
operator|new
name|GroupTreeNode
argument_list|(
name|group
argument_list|)
decl_stmt|;
name|parentIds
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|"parent_id"
argument_list|)
argument_list|)
expr_stmt|;
name|groups
operator|.
name|put
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|"groups_id"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Ok, we have collected a map of all groups and their parent IDs,
comment|// and another map of all group IDs and their group nodes.
comment|// Now we need to build the groups tree:
for|for
control|(
name|Iterator
argument_list|<
name|GroupTreeNode
argument_list|>
name|i
init|=
name|parentIds
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|GroupTreeNode
name|node
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|parentId
init|=
name|parentIds
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|// Look up the parent:
name|GroupTreeNode
name|parent
init|=
name|groups
operator|.
name|get
argument_list|(
name|parentId
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
comment|// TODO: missing parent
block|}
else|else
block|{
name|parent
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If we have explicit groups, set up group membership:
name|res
operator|=
name|processDMLWithResults
argument_list|(
name|conn
argument_list|,
literal|"SELECT * FROM entry_group;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|instanceof
name|Statement
condition|)
block|{
name|statement
operator|=
operator|(
name|Statement
operator|)
name|res
expr_stmt|;
name|rs
operator|=
name|statement
operator|.
name|getResultSet
argument_list|()
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|String
name|entryId
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"entries_id"
argument_list|)
decl_stmt|,
name|groupId
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"groups_id"
argument_list|)
decl_stmt|;
name|GroupTreeNode
name|node
init|=
name|groups
operator|.
name|get
argument_list|(
name|groupId
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|node
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|node
operator|.
name|getGroup
argument_list|()
operator|instanceof
name|ExplicitGroup
operator|)
condition|)
block|{
name|ExplicitGroup
name|group
init|=
operator|(
name|ExplicitGroup
operator|)
name|node
operator|.
name|getGroup
argument_list|()
decl_stmt|;
name|group
operator|.
name|addEntry
argument_list|(
name|entries
operator|.
name|get
argument_list|(
name|entryId
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: unable to find explicit group with the given id
block|}
block|}
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Finally, set the groups tree for the metadata:
name|metaData
operator|.
name|setGroups
argument_list|(
name|rootNode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Look up the group type name from the type ID in the database.      * @param groupId The database's groups id      * @param conn The database connection      * @return The name (JabRef type id) of the group type.      * @throws SQLException      */
DECL|method|findGroupTypeName (DBTYPE dbtype, String groupId, Connection conn)
specifier|public
specifier|static
name|String
name|findGroupTypeName
parameter_list|(
name|DBTYPE
name|dbtype
parameter_list|,
name|String
name|groupId
parameter_list|,
name|Connection
name|conn
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|res
init|=
literal|""
decl_stmt|;
switch|switch
condition|(
name|dbtype
condition|)
block|{
case|case
name|MYSQL
case|:
name|res
operator|=
name|processDMLWithSingleResult
argument_list|(
name|conn
argument_list|,
literal|"SELECT label FROM group_types WHERE group_types_id=\""
operator|+
name|groupId
operator|+
literal|"\";"
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTGRESQL
case|:
name|res
operator|=
name|processDMLWithSingleResult
argument_list|(
name|conn
argument_list|,
literal|"SELECT label FROM group_types WHERE group_types_id=\'"
operator|+
name|groupId
operator|+
literal|"\';"
argument_list|)
expr_stmt|;
break|break;
default|default:
block|}
return|return
name|res
return|;
block|}
comment|/**      * Accepts the BibtexDatabase and MetaData, generates the DML required to      * create and populate SQL database tables, and writes this DML to the       * specified SQL database.      *      * @param database      *          The BibtexDatabase to export      * @param metaData      *          The MetaData object containing the groups information      * @param keySet      *          The set of IDs of the entries to export.      * @param dbStrings      *          The necessary database connection information      */
DECL|method|exportDatabase (final BibtexDatabase database, final MetaData metaData, Set<String> keySet, DBStrings dbStrings)
specifier|public
specifier|static
name|void
name|exportDatabase
parameter_list|(
specifier|final
name|BibtexDatabase
name|database
parameter_list|,
specifier|final
name|MetaData
name|metaData
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|keySet
parameter_list|,
name|DBStrings
name|dbStrings
parameter_list|)
throws|throws
name|Exception
block|{
name|DBTYPE
name|dbtype
init|=
name|getDBType
argument_list|(
name|dbStrings
argument_list|)
decl_stmt|;
name|Connection
name|conn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|conn
operator|=
name|SQLutil
operator|.
name|connectToDB
argument_list|(
name|dbStrings
argument_list|)
expr_stmt|;
comment|// conn.setAutoCommit(false);
name|exportDatabase_worker
argument_list|(
name|dbtype
argument_list|,
name|database
argument_list|,
name|metaData
argument_list|,
name|keySet
argument_list|,
name|conn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conn
operator|.
name|getAutoCommit
argument_list|()
condition|)
block|{
name|conn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|conn
operator|.
name|setAutoCommit
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|conn
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|conn
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|conn
operator|.
name|getAutoCommit
argument_list|()
condition|)
block|{
name|conn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
block|}
throw|throw
name|ex
throw|;
block|}
block|}
comment|/**      * Worker method for the exportDatabase methods.      *      * @param dbtype      *          The DBTYPE of the database      * @param database      *          The BibtexDatabase to export      * @param metaData      *          The MetaData object containing the groups information      * @param keySet      *            The set of IDs of the entries to export.      * @param out      *          The output (PrintStream or Connection) object to which the DML should be written.      */
DECL|method|exportDatabase_worker (DBTYPE dbtype, final BibtexDatabase database, final MetaData metaData, Set<String> keySet, Object out)
specifier|private
specifier|static
name|void
name|exportDatabase_worker
parameter_list|(
name|DBTYPE
name|dbtype
parameter_list|,
specifier|final
name|BibtexDatabase
name|database
parameter_list|,
specifier|final
name|MetaData
name|metaData
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|keySet
parameter_list|,
name|Object
name|out
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
init|=
name|FileActions
operator|.
name|getSortedEntries
argument_list|(
name|database
argument_list|,
name|keySet
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// create MySQL tables
name|dmlCreateTables
argument_list|(
name|dbtype
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|// populate entry_type table
name|dmlPopTab_ET
argument_list|(
name|dbtype
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|// populate entries table
name|dmlPopTab_FD
argument_list|(
name|dbtype
argument_list|,
name|entries
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|// populate strings table:
name|dmlPopTab_ST
argument_list|(
name|database
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|GroupTreeNode
name|gtn
init|=
name|metaData
operator|.
name|getGroups
argument_list|()
decl_stmt|;
comment|// populate group_types table
name|dmlPopTab_GT
argument_list|(
name|dbtype
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|// populate groups table
name|dmlPopTab_GP
argument_list|(
name|dbtype
argument_list|,
name|gtn
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|// populate entry_group table
name|dmlPopTab_EG
argument_list|(
name|dbtype
argument_list|,
name|gtn
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes the table creation DML to the specififed file.      *       * @param dbtype      *          Indicates the type of database to be written to       * @param fout      *          The output (PrintStream or Connection) object to which the DML should be written      */
DECL|method|dmlCreateTables (DBTYPE dbtype, Object out)
specifier|private
specifier|static
name|void
name|dmlCreateTables
parameter_list|(
name|DBTYPE
name|dbtype
parameter_list|,
name|Object
name|out
parameter_list|)
throws|throws
name|SQLException
block|{
comment|// make sure fields are initialized
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
name|refreshFields
argument_list|()
expr_stmt|;
block|}
comment|// build the DML tables specification
name|String
name|dml1
init|=
literal|""
decl_stmt|,
name|dml2
init|=
literal|""
decl_stmt|;
switch|switch
condition|(
name|dbtype
condition|)
block|{
case|case
name|MYSQL
case|:
comment|// drop tables
name|processDML
argument_list|(
name|out
argument_list|,
literal|"DROP TABLE IF EXISTS entry_types;"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"DROP TABLE IF EXISTS entries;"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"DROP TABLE IF EXISTS strings;"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"DROP TABLE IF EXISTS group_types;"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"DROP TABLE IF EXISTS groups;"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"DROP TABLE IF EXISTS entry_group;"
argument_list|)
expr_stmt|;
comment|// generate DML that specifies DB columns corresponding to fields
name|dml1
operator|=
name|SQLutil
operator|.
name|fieldsAsCols
argument_list|(
name|fields
argument_list|,
literal|" VARCHAR(3) DEFAULT NULL"
argument_list|)
expr_stmt|;
name|dml2
operator|=
name|SQLutil
operator|.
name|fieldsAsCols
argument_list|(
name|fields
argument_list|,
literal|" TEXT DEFAULT NULL"
argument_list|)
expr_stmt|;
comment|// create tables
name|dmlTable_mysql
argument_list|(
name|dml1
argument_list|,
name|dml2
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTGRESQL
case|:
comment|// drop tables
name|processDML
argument_list|(
name|out
argument_list|,
literal|"DROP TABLE IF EXISTS entry_types CASCADE;"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"DROP TABLE IF EXISTS entries CASCADE;"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"DROP TABLE IF EXISTS strings;"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"DROP TABLE IF EXISTS group_types;"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"DROP TABLE IF EXISTS groups CASCADE;"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"DROP TABLE IF EXISTS entry_group;"
argument_list|)
expr_stmt|;
comment|// generate DML that specifies DB columns corresponding to fields
name|dml1
operator|=
name|SQLutil
operator|.
name|fieldsAsCols
argument_list|(
name|fields
argument_list|,
literal|" VARCHAR(3) DEFAULT NULL"
argument_list|)
expr_stmt|;
name|dml2
operator|=
name|SQLutil
operator|.
name|fieldsAsCols
argument_list|(
name|fields
argument_list|,
literal|" TEXT DEFAULT NULL"
argument_list|)
expr_stmt|;
comment|// create tables
name|dmlTable_postgresql
argument_list|(
name|dml1
argument_list|,
name|dml2
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|DERBY
case|:
comment|// drop tables
if|if
condition|(
name|out
operator|instanceof
name|Connection
condition|)
block|{
name|Connection
name|conn
init|=
operator|(
name|Connection
operator|)
name|out
decl_stmt|;
name|boolean
name|commitNow
init|=
name|conn
operator|.
name|getAutoCommit
argument_list|()
decl_stmt|;
name|conn
operator|.
name|setAutoCommit
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|//TODO: determine which tables are present, and drop them
name|conn
operator|.
name|setAutoCommit
argument_list|(
name|commitNow
argument_list|)
expr_stmt|;
block|}
comment|// generate DML that specifies DB columns corresponding to fields
name|dml1
operator|=
name|SQLutil
operator|.
name|fieldsAsCols
argument_list|(
name|fields
argument_list|,
literal|" VARCHAR(3) DEFAULT NULL"
argument_list|)
expr_stmt|;
name|dml2
operator|=
name|SQLutil
operator|.
name|fieldsAsCols
argument_list|(
name|fields
argument_list|,
literal|" LONG VARCHAR DEFAULT NULL"
argument_list|)
expr_stmt|;
comment|// create tables
name|dmlTable_derby
argument_list|(
name|dml1
argument_list|,
name|dml2
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
default|default:
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error: Do not recognize database enumeration."
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/**      * Generates DML specifying table columns and their datatypes. The output of      * this routine should be used within a CREATE TABLE statement.      *       * @param fields      *            Contains unique field names      * @param datatype      *            Specifies the SQL data type that the fields should take on.      * @return The DML code to be included in a CREATE TABLE statement.      */
DECL|method|fieldsAsCols (ArrayList<String> fields, String datatype)
specifier|private
specifier|static
name|String
name|fieldsAsCols
parameter_list|(
name|ArrayList
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|,
name|String
name|datatype
parameter_list|)
block|{
name|String
name|str
init|=
literal|""
decl_stmt|;
name|ListIterator
argument_list|<
name|String
argument_list|>
name|li
init|=
name|fields
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|li
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|str
operator|=
name|str
operator|+
name|li
operator|.
name|next
argument_list|()
operator|+
literal|" "
operator|+
name|datatype
expr_stmt|;
if|if
condition|(
name|li
operator|.
name|hasNext
argument_list|()
condition|)
name|str
operator|=
name|str
operator|+
literal|", "
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
comment|/**      * Generates DML code necessary to create all tables in a MySQL database,       * and writes it to appropriate output.      *      * @param dml1      *            Column specifications for fields in entry_type table.      * @param dml2      *            Column specifications for fields in entries table.      * @param out      *            The output (PrintStream or Connection) object to which the DML should be written.      * @return DML to create all MySQL tables.      */
DECL|method|dmlTable_mysql (String dml1, String dml2, Object out)
specifier|private
specifier|static
name|void
name|dmlTable_mysql
parameter_list|(
name|String
name|dml1
parameter_list|,
name|String
name|dml2
parameter_list|,
name|Object
name|out
parameter_list|)
throws|throws
name|SQLException
block|{
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE TABLE entry_types ( \n"
operator|+
literal|"entry_types_id    INT UNSIGNED  NOT NULL AUTO_INCREMENT, \n"
operator|+
literal|"label			 TEXT, \n"
operator|+
name|dml1
operator|+
literal|", \n"
operator|+
literal|"PRIMARY KEY (entry_types_id) \n"
operator|+
literal|");"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE TABLE entries ( \n"
operator|+
literal|"entries_id      INTEGER         NOT NULL AUTO_INCREMENT, \n"
operator|+
literal|"jabref_eid      VARCHAR("
operator|+
name|Util
operator|.
name|getMinimumIntegerDigits
argument_list|()
operator|+
literal|")   DEFAULT NULL, \n"
operator|+
literal|"entry_types_id  INT UNSIGNED         DEFAULT NULL, \n"
operator|+
literal|"cite_key        VARCHAR(100)     DEFAULT NULL, \n"
operator|+
name|dml2
operator|+
literal|",\n"
operator|+
literal|"PRIMARY KEY (entries_id), \n"
operator|+
literal|"INDEX(entry_types_id), \n"
operator|+
literal|"FOREIGN KEY (entry_types_id) REFERENCES entry_types(entry_types_id) \n"
operator|+
literal|");"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE TABLE strings ( \n"
operator|+
literal|"strings_id      INTEGER         NOT NULL AUTO_INCREMENT, \n"
operator|+
literal|"label      VARCHAR(100)  DEFAULT NULL, \n"
operator|+
literal|"content    VARCHAR(200)  DEFAULT NULL, \n"
operator|+
literal|"PRIMARY KEY (strings_id) \n"
operator|+
literal|");"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE TABLE group_types ( \n"
operator|+
literal|"group_types_id  INTEGER     NOT NULL AUTO_INCREMENT, \n"
operator|+
literal|"label   VARCHAR(100)    DEFAULT NULL, \n"
operator|+
literal|"PRIMARY KEY (group_types_id) \n"
operator|+
literal|");"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE TABLE groups ( \n"
operator|+
literal|"groups_id       INTEGER         NOT NULL AUTO_INCREMENT, \n"
operator|+
literal|"group_types_id  INTEGER         DEFAULT NULL, \n"
operator|+
literal|"label           VARCHAR(100)    DEFAULT NULL, \n"
operator|+
literal|"parent_id       INTEGER         DEFAULT NULL, \n"
operator|+
literal|"search_field       VARCHAR(100)          DEFAULT NULL, \n"
operator|+
literal|"search_expression  VARCHAR(200)          DEFAULT NULL, \n"
operator|+
literal|"case_sensitive  BOOL          DEFAULT NULL, \n"
operator|+
literal|"reg_exp BOOL DEFAULT NULL, \n"
operator|+
literal|"hierarchical_context INTEGER DEFAULT NULL, \n"
operator|+
literal|"PRIMARY KEY (groups_id) \n"
operator|+
literal|");"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE TABLE entry_group ( \n"
operator|+
literal|"entries_id       INTEGER        NOT NULL AUTO_INCREMENT, \n"
operator|+
literal|"groups_id        INTEGER        DEFAULT NULL, \n"
operator|+
literal|"INDEX(entries_id), \n"
operator|+
literal|"INDEX(groups_id), \n"
operator|+
literal|"FOREIGN KEY (entries_id) REFERENCES entries(entries_id), \n"
operator|+
literal|"FOREIGN KEY (groups_id)  REFERENCES groups(groups_id) \n"
operator|+
literal|");"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/**      * Generates DML code necessary to create all tables in a PostgreSQL database,       * and writes it to appropriate output.      *      * @param dml1      *            Column specifications for fields in entry_type table.      * @param dml2      *            Column specifications for fields in entries table.      * @param out      *            The output (PrintStream or Connection) object to which the DML should be written.      * @return DML to create all MySQL tables.      */
DECL|method|dmlTable_postgresql (String dml1, String dml2, Object out)
specifier|private
specifier|static
name|void
name|dmlTable_postgresql
parameter_list|(
name|String
name|dml1
parameter_list|,
name|String
name|dml2
parameter_list|,
name|Object
name|out
parameter_list|)
throws|throws
name|SQLException
block|{
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE TABLE entry_types ( \n"
operator|+
literal|"entry_types_id    SERIAL, \n"
operator|+
literal|"label			 TEXT, \n"
operator|+
name|dml1
operator|+
literal|", \n"
operator|+
literal|"PRIMARY KEY (entry_types_id) \n"
operator|+
literal|");"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE TABLE entries ( \n"
operator|+
literal|"entries_id      SERIAL, \n"
operator|+
literal|"jabref_eid      VARCHAR("
operator|+
name|Util
operator|.
name|getMinimumIntegerDigits
argument_list|()
operator|+
literal|")   DEFAULT NULL, \n"
operator|+
literal|"entry_types_id  INTEGER DEFAULT NULL, \n"
operator|+
literal|"cite_key        VARCHAR(100)     DEFAULT NULL, \n"
operator|+
name|dml2
operator|+
literal|",\n"
operator|+
literal|"PRIMARY KEY (entries_id), \n"
operator|+
literal|"FOREIGN KEY (entry_types_id) REFERENCES entry_types (entry_types_id) \n"
operator|+
literal|");"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE TABLE strings ( \n"
operator|+
literal|"strings_id      SERIAL, \n"
operator|+
literal|"label      VARCHAR(100)  DEFAULT NULL, \n"
operator|+
literal|"content    VARCHAR(200)  DEFAULT NULL, \n"
operator|+
literal|"PRIMARY KEY (strings_id) \n"
operator|+
literal|");"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE TABLE group_types ( \n"
operator|+
literal|"group_types_id  SERIAL, \n"
operator|+
literal|"label   VARCHAR(100)    DEFAULT NULL, \n"
operator|+
literal|"PRIMARY KEY (group_types_id) \n"
operator|+
literal|");"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE TABLE groups ( \n"
operator|+
literal|"groups_id       SERIAL, \n"
operator|+
literal|"group_types_id  INTEGER         DEFAULT NULL, \n"
operator|+
literal|"label           VARCHAR(100)    DEFAULT NULL, \n"
operator|+
literal|"parent_id       INTEGER         DEFAULT NULL, \n"
operator|+
literal|"search_field       VARCHAR(100)          DEFAULT NULL, \n"
operator|+
literal|"search_expression  VARCHAR(200)          DEFAULT NULL, \n"
operator|+
literal|"case_sensitive  BOOLEAN       DEFAULT NULL, \n"
operator|+
literal|"reg_exp BOOLEAN DEFAULT NULL, \n"
operator|+
literal|"hierarchical_context INTEGER DEFAULT NULL, \n"
operator|+
literal|"PRIMARY KEY (groups_id) \n"
operator|+
literal|");"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE TABLE entry_group ( \n"
operator|+
literal|"entries_id       SERIAL, \n"
operator|+
literal|"groups_id        INTEGER        DEFAULT NULL, \n"
operator|+
literal|"FOREIGN KEY (entries_id) REFERENCES entries (entries_id), \n"
operator|+
literal|"FOREIGN KEY (groups_id)  REFERENCES groups (groups_id) \n"
operator|+
literal|");"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE INDEX entry_types_id_index ON entries (entry_types_id);"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE INDEX entries_id_index ON entry_group (entries_id);"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE INDEX groups_id_index ON entry_group (groups_id);"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/**      * Generates DML code necessary to create all tables in a Derby database,       * and writes it to appropriate output.      *      * @param dml1      *            Column specifications for fields in entry_type table.      * @param dml2      *            Column specifications for fields in entries table.      * @param out      *            The output (PrintStream or Connection) object to which the DML should be written.      * @return DML to create all Derby tables.      */
DECL|method|dmlTable_derby (String dml1, String dml2, Object out)
specifier|private
specifier|static
name|void
name|dmlTable_derby
parameter_list|(
name|String
name|dml1
parameter_list|,
name|String
name|dml2
parameter_list|,
name|Object
name|out
parameter_list|)
throws|throws
name|SQLException
block|{
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE TABLE entry_types ( "
operator|+
literal|"entry_types_id INT  NOT NULL PRIMARY KEY GENERATED ALWAYS AS IDENTITY, "
operator|+
name|dml1
operator|+
literal|", "
operator|+
literal|"label LONG VARCHAR"
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE TABLE entries ( "
operator|+
literal|"entries_id      INTEGER         NOT NULL PRIMARY KEY GENERATED ALWAYS AS IDENTITY, "
operator|+
literal|"jabref_eid      VARCHAR("
operator|+
name|Util
operator|.
name|getMinimumIntegerDigits
argument_list|()
operator|+
literal|")   DEFAULT NULL, "
operator|+
literal|"entry_types_id  INTEGER         DEFAULT NULL, "
operator|+
literal|"cite_key        VARCHAR(100)     DEFAULT NULL, "
operator|+
name|dml2
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"ALTER TABLE entries ADD CONSTRAINT entries_fk "
operator|+
literal|"FOREIGN KEY (\"entry_types_id\") REFERENCES \"entry_types\" (\"entry_types_id\")"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE TABLE group_types ( "
operator|+
literal|"group_types_id INT  NOT NULL PRIMARY KEY GENERATED ALWAYS AS IDENTITY, "
operator|+
literal|"label LONG VARCHAR"
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE TABLE groups ( "
operator|+
literal|"groups_id       INTEGER         NOT NULL PRIMARY KEY GENERATED ALWAYS AS IDENTITY, "
operator|+
literal|"group_types_id  INTEGER         DEFAULT NULL, "
operator|+
literal|"label           VARCHAR(100)    DEFAULT NULL, "
operator|+
literal|"parent_id       INTEGER         DEFAULT NULL  "
operator|+
literal|"search_field       VARCHAR(100)          DEFAULT NULL, "
operator|+
literal|"search_expression  VARCHAR(200)          DEFAULT NULL, "
operator|+
literal|"case_sensitive  BOOL          DEFAULT NULL, "
operator|+
literal|"reg_exp BOOL DEFAULT NULL"
operator|+
literal|"hierarchical_context INTEGER DEFAULT NULL, "
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"CREATE TABLE entry_group ( "
operator|+
literal|"entries_id       INTEGER        NOT NULL PRIMARY KEY GENERATED ALWAYS AS IDENTITY, "
operator|+
literal|"groups_id        INTEGER        DEFAULT NULL "
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"ALTER TABLE entry_group ADD CONSTRAINT entries_group_fk"
operator|+
literal|"FOREIGN KEY (\"entries_id\") REFERENCES \"entry_fields\" (\"entries_id\")"
argument_list|)
expr_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
literal|"ALTER TABLE entry_group ADD CONSTRAINT groups_fk"
operator|+
literal|"FOREIGN KEY (\"groups_id\") REFERENCES \"groups\" (\"groups_id\")"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/**      * Generates the DML required to populate the group_types table with      * JabRef data.      *      * @param out      *  The output (PrintSream or Connection) object to which the DML should be written.      * @throws SQLException      */
DECL|method|dmlPopTab_GT ( DBTYPE dbtype,Object out)
specifier|private
specifier|static
name|void
name|dmlPopTab_GT
parameter_list|(
name|DBTYPE
name|dbtype
parameter_list|,
name|Object
name|out
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
index|[]
name|typeNames
init|=
operator|new
name|String
index|[]
block|{
name|AllEntriesGroup
operator|.
name|ID
block|,
name|ExplicitGroup
operator|.
name|ID
block|,
name|KeywordGroup
operator|.
name|ID
block|,
name|SearchGroup
operator|.
name|ID
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|typeNames
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|typeName
init|=
name|typeNames
index|[
name|i
index|]
decl_stmt|;
name|String
name|insert
init|=
literal|""
decl_stmt|;
switch|switch
condition|(
name|dbtype
condition|)
block|{
case|case
name|MYSQL
case|:
name|insert
operator|=
literal|"INSERT INTO group_types (label) VALUES (\""
operator|+
name|typeName
operator|+
literal|"\");"
expr_stmt|;
break|break;
case|case
name|POSTGRESQL
case|:
name|insert
operator|=
literal|"INSERT INTO group_types (label) VALUES (\'"
operator|+
name|typeName
operator|+
literal|"\');"
expr_stmt|;
break|break;
default|default:
block|}
comment|// handle DML according to output type
name|processDML
argument_list|(
name|out
argument_list|,
name|insert
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Generates the DML required to populate the entry_types table with jabref      * data.      *       * @param out      *          The output (PrintSream or Connection) object to which the DML should be written.      */
DECL|method|dmlPopTab_ET ( DBTYPE dbtype, Object out)
specifier|private
specifier|static
name|void
name|dmlPopTab_ET
parameter_list|(
name|DBTYPE
name|dbtype
parameter_list|,
name|Object
name|out
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|dml
init|=
literal|""
decl_stmt|;
name|String
name|insert
init|=
literal|"INSERT INTO entry_types (label, "
operator|+
name|fieldstr
operator|+
literal|") VALUES ("
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|fieldID
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
name|fieldID
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// loop through entry types
for|for
control|(
name|BibtexEntryType
name|val
range|:
name|BibtexEntryType
operator|.
name|ALL_TYPES
operator|.
name|values
argument_list|()
control|)
block|{
comment|// set ID for each field corresponding to its relationship to the
comment|// entry type
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldID
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|fieldID
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|fieldID
operator|=
name|setFieldID
argument_list|(
name|fields
argument_list|,
name|fieldID
argument_list|,
name|val
operator|.
name|getRequiredFields
argument_list|()
argument_list|,
literal|"req"
argument_list|)
expr_stmt|;
name|fieldID
operator|=
name|setFieldID
argument_list|(
name|fields
argument_list|,
name|fieldID
argument_list|,
name|val
operator|.
name|getOptionalFields
argument_list|()
argument_list|,
literal|"opt"
argument_list|)
expr_stmt|;
name|fieldID
operator|=
name|setFieldID
argument_list|(
name|fields
argument_list|,
name|fieldID
argument_list|,
name|val
operator|.
name|getGeneralFields
argument_list|()
argument_list|,
literal|"gen"
argument_list|)
expr_stmt|;
name|fieldID
operator|=
name|setFieldID
argument_list|(
name|fields
argument_list|,
name|fieldID
argument_list|,
name|val
operator|.
name|getUtilityFields
argument_list|()
argument_list|,
literal|"uti"
argument_list|)
expr_stmt|;
comment|// build DML insert statement
switch|switch
condition|(
name|dbtype
condition|)
block|{
case|case
name|MYSQL
case|:
name|dml
operator|=
name|insert
operator|+
literal|"\""
operator|+
name|val
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"\""
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldID
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|dml
operator|=
name|dml
operator|+
literal|", "
expr_stmt|;
if|if
condition|(
name|fieldID
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|!=
literal|""
condition|)
block|{
name|dml
operator|=
name|dml
operator|+
literal|"\""
operator|+
name|fieldID
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|+
literal|"\""
expr_stmt|;
block|}
else|else
block|{
name|dml
operator|=
name|dml
operator|+
literal|"NULL"
expr_stmt|;
block|}
block|}
break|break;
case|case
name|POSTGRESQL
case|:
name|dml
operator|=
name|insert
operator|+
literal|"\'"
operator|+
name|val
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"\'"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldID
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|dml
operator|=
name|dml
operator|+
literal|", "
expr_stmt|;
if|if
condition|(
name|fieldID
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|!=
literal|""
condition|)
block|{
name|dml
operator|=
name|dml
operator|+
literal|"\'"
operator|+
name|fieldID
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|+
literal|"\'"
expr_stmt|;
block|}
else|else
block|{
name|dml
operator|=
name|dml
operator|+
literal|"NULL"
expr_stmt|;
block|}
block|}
break|break;
default|default:
block|}
name|dml
operator|=
name|dml
operator|+
literal|");"
expr_stmt|;
comment|// handle DML according to output type
name|processDML
argument_list|(
name|out
argument_list|,
name|dml
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/**      * A utility function for facilitating the assignment of a code to each      * field name that represents the relationship of that field to a specific      * entry type.      *       * @param fields      *            A list of all fields.      * @param fieldID      *            A list for holding the codes.      * @param fieldstr      *            A String array containing the fields to be coded.      * @param ID      *            The code that should be assigned to the specified fields.      * @return The updated code list.      */
DECL|method|setFieldID (ArrayList<String> fields, ArrayList<String> fieldID, String[] fieldstr, String ID)
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|String
argument_list|>
name|setFieldID
parameter_list|(
name|ArrayList
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|fieldID
parameter_list|,
name|String
index|[]
name|fieldstr
parameter_list|,
name|String
name|ID
parameter_list|)
block|{
if|if
condition|(
name|fieldstr
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldstr
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|fieldID
operator|.
name|set
argument_list|(
name|fields
operator|.
name|indexOf
argument_list|(
name|fieldstr
index|[
name|i
index|]
argument_list|)
argument_list|,
name|ID
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|fieldID
return|;
block|}
comment|/**      * Generates the DML required to populate the entries table with jabref      * data and writes it to the output PrintStream.      *       * @param entries      *          The BibtexEntries to export           * @param out      *          The output (PrintStream or Connection) object to which the DML should be written.      */
DECL|method|dmlPopTab_FD (DBTYPE dbtype,List<BibtexEntry> entries, Object out)
specifier|private
specifier|static
name|void
name|dmlPopTab_FD
parameter_list|(
name|DBTYPE
name|dbtype
parameter_list|,
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
name|Object
name|out
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|dml
init|=
literal|""
decl_stmt|;
name|String
name|val
init|=
literal|""
decl_stmt|;
name|String
name|insert
init|=
literal|"INSERT INTO entries (jabref_eid, entry_types_id, cite_key, "
operator|+
name|fieldstr
operator|+
literal|") VALUES ("
decl_stmt|;
comment|// loop throught the entries that are to be exported
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
comment|// build DML insert statement
switch|switch
condition|(
name|dbtype
condition|)
block|{
case|case
name|MYSQL
case|:
name|dml
operator|=
name|insert
operator|+
literal|"\""
operator|+
name|entry
operator|.
name|getId
argument_list|()
operator|+
literal|"\""
operator|+
literal|", (SELECT entry_types_id FROM entry_types WHERE label=\""
operator|+
name|entry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"\"), \""
operator|+
name|entry
operator|.
name|getCiteKey
argument_list|()
operator|+
literal|"\""
expr_stmt|;
break|break;
case|case
name|POSTGRESQL
case|:
name|dml
operator|=
name|insert
operator|+
literal|"\'"
operator|+
name|entry
operator|.
name|getId
argument_list|()
operator|+
literal|"\'"
operator|+
literal|", (SELECT entry_types_id FROM entry_types WHERE label=\'"
operator|+
name|entry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"\'), \'"
operator|+
name|entry
operator|.
name|getCiteKey
argument_list|()
operator|+
literal|"\'"
expr_stmt|;
break|break;
default|default:
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|dml
operator|=
name|dml
operator|+
literal|", "
expr_stmt|;
name|val
operator|=
name|entry
operator|.
name|getField
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|dbtype
condition|)
block|{
case|case
name|MYSQL
case|:
comment|//escape slashes and quotes for MySQL
name|val
operator|=
name|val
operator|.
name|replace
argument_list|(
literal|"\\"
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
name|val
operator|=
name|val
operator|.
name|replace
argument_list|(
literal|"\""
argument_list|,
literal|"\\\""
argument_list|)
expr_stmt|;
name|val
operator|=
name|val
operator|.
name|replace
argument_list|(
literal|"\'"
argument_list|,
literal|"\\\'"
argument_list|)
expr_stmt|;
name|val
operator|=
name|val
operator|.
name|replace
argument_list|(
literal|"`"
argument_list|,
literal|"\\`"
argument_list|)
expr_stmt|;
name|dml
operator|=
name|dml
operator|+
literal|"\""
operator|+
name|val
operator|+
literal|"\""
expr_stmt|;
break|break;
case|case
name|POSTGRESQL
case|:
comment|//escape slashes and quotes for PostgreSQL
name|val
operator|=
name|val
operator|.
name|replace
argument_list|(
literal|"\\"
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
name|val
operator|=
name|val
operator|.
name|replace
argument_list|(
literal|"\""
argument_list|,
literal|"\\\""
argument_list|)
expr_stmt|;
name|val
operator|=
name|val
operator|.
name|replace
argument_list|(
literal|"\'"
argument_list|,
literal|"\\\'"
argument_list|)
expr_stmt|;
name|val
operator|=
name|val
operator|.
name|replace
argument_list|(
literal|"`"
argument_list|,
literal|"\\`"
argument_list|)
expr_stmt|;
name|dml
operator|=
name|dml
operator|+
literal|"\'"
operator|+
name|val
operator|+
literal|"\'"
expr_stmt|;
break|break;
default|default:
block|}
block|}
else|else
block|{
name|dml
operator|=
name|dml
operator|+
literal|"NULL"
expr_stmt|;
block|}
block|}
name|dml
operator|=
name|dml
operator|+
literal|");"
expr_stmt|;
comment|// handle DML according to output type
name|processDML
argument_list|(
name|out
argument_list|,
name|dml
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
DECL|method|dmlPopTab_ST (BibtexDatabase database, Object out)
specifier|private
specifier|static
name|void
name|dmlPopTab_ST
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|Object
name|out
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|insert
init|=
literal|"INSERT INTO strings (label, content) VALUES ("
decl_stmt|;
comment|// Insert preamble as a string:
if|if
condition|(
name|database
operator|.
name|getPreamble
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|String
name|dml
init|=
name|insert
operator|+
literal|"\"@PREAMBLE\", "
operator|+
literal|"\""
operator|+
name|Util
operator|.
name|quote
argument_list|(
name|database
operator|.
name|getPreamble
argument_list|()
argument_list|,
literal|"\""
argument_list|,
literal|'\\'
argument_list|)
operator|+
literal|"\""
operator|+
literal|");"
decl_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
name|dml
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|keys
init|=
name|database
operator|.
name|getStringKeySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterator
init|=
name|keys
operator|.
name|iterator
argument_list|()
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|key
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|BibtexString
name|string
init|=
name|database
operator|.
name|getString
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|String
name|dml
init|=
name|insert
operator|+
literal|"\""
operator|+
name|Util
operator|.
name|quote
argument_list|(
name|string
operator|.
name|getName
argument_list|()
argument_list|,
literal|"\""
argument_list|,
literal|'\\'
argument_list|)
operator|+
literal|"\", "
operator|+
literal|"\""
operator|+
name|Util
operator|.
name|quote
argument_list|(
name|string
operator|.
name|getContent
argument_list|()
argument_list|,
literal|"\""
argument_list|,
literal|'\\'
argument_list|)
operator|+
literal|"\""
operator|+
literal|");"
decl_stmt|;
name|processDML
argument_list|(
name|out
argument_list|,
name|dml
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Generates the DML required to populate the groups table with jabref      * data, and writes this DML to the output file.      *       * @param cursor      *            The current GroupTreeNode in the GroupsTree      * @param out      *            The output (PrintStream or Connection) object to which the DML should be written.      */
DECL|method|dmlPopTab_GP (DBTYPE dbtype, GroupTreeNode cursor, Object out)
specifier|private
specifier|static
name|int
name|dmlPopTab_GP
parameter_list|(
name|DBTYPE
name|dbtype
parameter_list|,
name|GroupTreeNode
name|cursor
parameter_list|,
name|Object
name|out
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|cnt
init|=
name|dmlPopTab_GP_worker
argument_list|(
name|dbtype
argument_list|,
name|cursor
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|out
argument_list|)
decl_stmt|;
return|return
name|cnt
return|;
block|}
comment|/**      * Recursive worker method for the dmlPopTab_GP methods.      *      * @param cursor      *            The current GroupTreeNode in the GroupsTree      * @param parentID      *            The integer ID associated with the cursors's parent node      * @param ID      *            The integer value to associate with the cursor      * @param out      *            The output (PrintStream or Connection) object to which the DML should be written.      */
DECL|method|dmlPopTab_GP_worker (DBTYPE dbtype, GroupTreeNode cursor, int parentID, int ID, Object out)
specifier|private
specifier|static
name|int
name|dmlPopTab_GP_worker
parameter_list|(
name|DBTYPE
name|dbtype
parameter_list|,
name|GroupTreeNode
name|cursor
parameter_list|,
name|int
name|parentID
parameter_list|,
name|int
name|ID
parameter_list|,
name|Object
name|out
parameter_list|)
throws|throws
name|SQLException
block|{
name|AbstractGroup
name|group
init|=
name|cursor
operator|.
name|getGroup
argument_list|()
decl_stmt|;
name|String
name|searchField
init|=
literal|null
decl_stmt|,
name|searchExpr
init|=
literal|null
decl_stmt|,
name|caseSensitive
init|=
literal|null
decl_stmt|,
name|reg_exp
init|=
literal|null
decl_stmt|;
name|int
name|hierContext
init|=
name|group
operator|.
name|getHierarchicalContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|group
operator|instanceof
name|KeywordGroup
condition|)
block|{
name|searchField
operator|=
operator|(
operator|(
name|KeywordGroup
operator|)
name|group
operator|)
operator|.
name|getSearchField
argument_list|()
expr_stmt|;
name|searchExpr
operator|=
operator|(
operator|(
name|KeywordGroup
operator|)
name|group
operator|)
operator|.
name|getSearchExpression
argument_list|()
expr_stmt|;
name|caseSensitive
operator|=
operator|(
operator|(
name|KeywordGroup
operator|)
name|group
operator|)
operator|.
name|isCaseSensitive
argument_list|()
condition|?
literal|"1"
else|:
literal|"0"
expr_stmt|;
name|reg_exp
operator|=
operator|(
operator|(
name|KeywordGroup
operator|)
name|group
operator|)
operator|.
name|isRegExp
argument_list|()
condition|?
literal|"1"
else|:
literal|"0"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|group
operator|instanceof
name|SearchGroup
condition|)
block|{
name|searchExpr
operator|=
operator|(
operator|(
name|SearchGroup
operator|)
name|group
operator|)
operator|.
name|getSearchExpression
argument_list|()
expr_stmt|;
name|caseSensitive
operator|=
operator|(
operator|(
name|SearchGroup
operator|)
name|group
operator|)
operator|.
name|isCaseSensitive
argument_list|()
condition|?
literal|"1"
else|:
literal|"0"
expr_stmt|;
name|reg_exp
operator|=
operator|(
operator|(
name|SearchGroup
operator|)
name|group
operator|)
operator|.
name|isRegExp
argument_list|()
condition|?
literal|"1"
else|:
literal|"0"
expr_stmt|;
block|}
comment|// Protect all quotes in the group descriptions:
if|if
condition|(
name|searchField
operator|!=
literal|null
condition|)
name|searchField
operator|=
name|Util
operator|.
name|quote
argument_list|(
name|searchField
argument_list|,
literal|"\""
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchExpr
operator|!=
literal|null
condition|)
name|searchExpr
operator|=
name|Util
operator|.
name|quote
argument_list|(
name|searchExpr
argument_list|,
literal|"\""
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
comment|// handle DML according to output type
switch|switch
condition|(
name|dbtype
condition|)
block|{
case|case
name|MYSQL
case|:
name|processDML
argument_list|(
name|out
argument_list|,
literal|"INSERT INTO groups (groups_id, label, parent_id, group_types_id, search_field, "
operator|+
literal|"search_expression, case_sensitive, reg_exp, hierarchical_context) "
operator|+
literal|"VALUES ("
operator|+
name|ID
operator|+
literal|", \""
operator|+
name|cursor
operator|.
name|getGroup
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"\", "
operator|+
name|parentID
operator|+
literal|", (SELECT group_types_id FROM group_types where label=\""
operator|+
name|group
operator|.
name|getTypeId
argument_list|()
operator|+
literal|"\")"
operator|+
literal|", "
operator|+
operator|(
name|searchField
operator|!=
literal|null
condition|?
literal|"\""
operator|+
name|searchField
operator|+
literal|"\""
else|:
literal|"NULL"
operator|)
operator|+
literal|", "
operator|+
operator|(
name|searchExpr
operator|!=
literal|null
condition|?
literal|"\""
operator|+
name|searchExpr
operator|+
literal|"\""
else|:
literal|"NULL"
operator|)
operator|+
literal|", "
operator|+
operator|(
name|caseSensitive
operator|!=
literal|null
condition|?
literal|"\""
operator|+
name|caseSensitive
operator|+
literal|"\""
else|:
literal|"NULL"
operator|)
operator|+
literal|", "
operator|+
operator|(
name|reg_exp
operator|!=
literal|null
condition|?
literal|"\""
operator|+
name|reg_exp
operator|+
literal|"\""
else|:
literal|"NULL"
operator|)
operator|+
literal|", "
operator|+
name|hierContext
operator|+
literal|");"
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTGRESQL
case|:
name|processDML
argument_list|(
name|out
argument_list|,
literal|"INSERT INTO groups (groups_id, label, parent_id, group_types_id, search_field, "
operator|+
literal|"search_expression, case_sensitive, reg_exp, hierarchical_context) "
operator|+
literal|"VALUES ("
operator|+
name|ID
operator|+
literal|", \'"
operator|+
name|cursor
operator|.
name|getGroup
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"\', "
operator|+
name|parentID
operator|+
literal|", (SELECT group_types_id FROM group_types where label=\'"
operator|+
name|group
operator|.
name|getTypeId
argument_list|()
operator|+
literal|"\')"
operator|+
literal|", "
operator|+
operator|(
name|searchField
operator|!=
literal|null
condition|?
literal|"\'"
operator|+
name|searchField
operator|+
literal|"\'"
else|:
literal|"NULL"
operator|)
operator|+
literal|", "
operator|+
operator|(
name|searchExpr
operator|!=
literal|null
condition|?
literal|"\'"
operator|+
name|searchExpr
operator|+
literal|"\'"
else|:
literal|"NULL"
operator|)
operator|+
literal|", "
operator|+
operator|(
name|caseSensitive
operator|!=
literal|null
condition|?
literal|"\'"
operator|+
name|caseSensitive
operator|+
literal|"\'"
else|:
literal|"NULL"
operator|)
operator|+
literal|", "
operator|+
operator|(
name|reg_exp
operator|!=
literal|null
condition|?
literal|"\'"
operator|+
name|reg_exp
operator|+
literal|"\'"
else|:
literal|"NULL"
operator|)
operator|+
literal|", "
operator|+
name|hierContext
operator|+
literal|");"
argument_list|)
expr_stmt|;
break|break;
default|default:
block|}
comment|// recurse on child nodes (depth-first traversal)
name|int
name|myID
init|=
name|ID
decl_stmt|;
for|for
control|(
name|Enumeration
argument_list|<
name|GroupTreeNode
argument_list|>
name|e
init|=
name|cursor
operator|.
name|children
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
name|ID
operator|=
name|dmlPopTab_GP_worker
argument_list|(
name|dbtype
argument_list|,
name|e
operator|.
name|nextElement
argument_list|()
argument_list|,
name|myID
argument_list|,
operator|++
name|ID
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
name|ID
return|;
block|}
comment|/**      * Generates the DML required to populate the entry_group table with jabref      * data, and writes the DML to the PrintStream.      *       * @param cursor      *            The current GroupTreeNode in the GroupsTree      * @param out      *            The output (PrintStream or Connection) object to which the DML should be written.      */
DECL|method|dmlPopTab_EG (DBTYPE dbtype,GroupTreeNode cursor, Object fout)
specifier|private
specifier|static
name|int
name|dmlPopTab_EG
parameter_list|(
name|DBTYPE
name|dbtype
parameter_list|,
name|GroupTreeNode
name|cursor
parameter_list|,
name|Object
name|fout
parameter_list|)
throws|throws
name|SQLException
block|{
name|int
name|cnt
init|=
name|dmlPopTab_EG_worker
argument_list|(
name|dbtype
argument_list|,
name|cursor
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|fout
argument_list|)
decl_stmt|;
return|return
name|cnt
return|;
block|}
comment|/**      * Recursive worker method for the dmlPopTab_EG methods.      *       * @param cursor      *            The current GroupTreeNode in the GroupsTree      * @param parentID      *            The integer ID associated with the cursors's parent node      * @param ID      *            The integer value to associate with the cursor      * @param out      *            The output (PrintStream or Connection) object to which the DML should be written.      */
DECL|method|dmlPopTab_EG_worker (DBTYPE dbtype,GroupTreeNode cursor, int parentID, int ID, Object out)
specifier|private
specifier|static
name|int
name|dmlPopTab_EG_worker
parameter_list|(
name|DBTYPE
name|dbtype
parameter_list|,
name|GroupTreeNode
name|cursor
parameter_list|,
name|int
name|parentID
parameter_list|,
name|int
name|ID
parameter_list|,
name|Object
name|out
parameter_list|)
throws|throws
name|SQLException
block|{
comment|// if this group contains entries...
if|if
condition|(
name|cursor
operator|.
name|getGroup
argument_list|()
operator|instanceof
name|ExplicitGroup
condition|)
block|{
comment|// build INSERT statement for each entry belonging to this group
name|ExplicitGroup
name|grp
init|=
operator|(
name|ExplicitGroup
operator|)
name|cursor
operator|.
name|getGroup
argument_list|()
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|be
range|:
name|grp
operator|.
name|getEntries
argument_list|()
control|)
block|{
comment|// handle DML according to output type
switch|switch
condition|(
name|dbtype
condition|)
block|{
case|case
name|MYSQL
case|:
name|processDML
argument_list|(
name|out
argument_list|,
literal|"INSERT INTO entry_group (entries_id, groups_id) "
operator|+
literal|"VALUES ("
operator|+
literal|"(SELECT entries_id FROM entries WHERE jabref_eid="
operator|+
literal|"\""
operator|+
name|be
operator|.
name|getId
argument_list|()
operator|+
literal|"\""
operator|+
literal|"), "
operator|+
literal|"(SELECT groups_id FROM groups WHERE groups_id="
operator|+
literal|"\""
operator|+
name|ID
operator|+
literal|"\")"
operator|+
literal|");"
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTGRESQL
case|:
name|processDML
argument_list|(
name|out
argument_list|,
literal|"INSERT INTO entry_group (entries_id, groups_id) "
operator|+
literal|"VALUES ("
operator|+
literal|"(SELECT entries_id FROM entries WHERE jabref_eid="
operator|+
literal|"\'"
operator|+
name|be
operator|.
name|getId
argument_list|()
operator|+
literal|"\'"
operator|+
literal|"), "
operator|+
literal|"(SELECT groups_id FROM groups WHERE groups_id="
operator|+
literal|"\'"
operator|+
name|ID
operator|+
literal|"\')"
operator|+
literal|");"
argument_list|)
expr_stmt|;
break|break;
default|default:
block|}
block|}
block|}
comment|// recurse on child nodes (depth-first traversal)
name|int
name|myID
init|=
name|ID
decl_stmt|;
for|for
control|(
name|Enumeration
argument_list|<
name|GroupTreeNode
argument_list|>
name|e
init|=
name|cursor
operator|.
name|children
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
name|ID
operator|=
name|dmlPopTab_EG_worker
argument_list|(
name|dbtype
argument_list|,
name|e
operator|.
name|nextElement
argument_list|()
argument_list|,
name|myID
argument_list|,
operator|++
name|ID
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
name|ID
return|;
block|}
comment|/**      * Processes a SQLException, and returns a more user-friendly message      *       * @param ex      *            The SQLException raised      * @param dbtype      *            DBTYPE specifying the type of database that raised the exception      */
DECL|method|getExceptionMessage (Exception ex, DBTYPE dbtype)
specifier|public
specifier|static
name|String
name|getExceptionMessage
parameter_list|(
name|Exception
name|ex
parameter_list|,
name|DBTYPE
name|dbtype
parameter_list|)
block|{
name|String
name|errorMessage
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|dbtype
condition|)
block|{
case|case
name|MYSQL
case|:
name|errorMessage
operator|=
name|getExceptionMessage_MySQL
argument_list|(
name|ex
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTGRESQL
case|:
name|errorMessage
operator|=
name|getExceptionMessage_MySQL
argument_list|(
name|ex
argument_list|)
expr_stmt|;
break|break;
case|case
name|DERBY
case|:
name|errorMessage
operator|=
name|getExceptionMessage_MySQL
argument_list|(
name|ex
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errorMessage
operator|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Could not determine exception message."
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|errorMessage
return|;
block|}
comment|/**      * Handles work for getExceptionMessage when dbtype is MYSQL      *       * @param ex      *            The SQLException raised      */
DECL|method|getExceptionMessage_MySQL (Exception ex)
specifier|public
specifier|static
name|String
name|getExceptionMessage_MySQL
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|String
name|msg
init|=
literal|null
decl_stmt|;
comment|// handle case where exception is SQL related
if|if
condition|(
name|ex
operator|instanceof
name|SQLException
condition|)
block|{
name|SQLException
name|sqlex
init|=
operator|(
name|SQLException
operator|)
name|ex
decl_stmt|;
comment|// desc  : Unkown DB
comment|// code  : 1049
comment|// state : 42000
comment|// msg   : Unkown database 'database_name'
comment|// type  : SQLException
comment|// tested with MySQL
if|if
condition|(
name|sqlex
operator|.
name|getSQLState
argument_list|()
operator|.
name|equals
argument_list|(
literal|"42000"
argument_list|)
condition|)
block|{
name|msg
operator|=
name|Globals
operator|.
name|lang
argument_list|(
name|sqlex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// desc  : command denied
comment|// code  : 1142
comment|// state : 42000
comment|// msg   : * command denied to user 'username'@'hostname' for table 'table_name'
comment|// tested with MySQL
if|if
condition|(
name|sqlex
operator|.
name|getSQLState
argument_list|()
operator|.
name|equals
argument_list|(
literal|"42000"
argument_list|)
condition|)
block|{
name|msg
operator|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"User does not have sufficient privileges.\n"
argument_list|)
expr_stmt|;
name|msg
operator|=
name|msg
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"("
operator|+
name|sqlex
operator|.
name|getMessage
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|// desc  : Invalid username and/or password
comment|// code  : 1045
comment|// state : 28000
comment|// msg   : Access denied for user 'username'@'hostname' (using password: ...)
comment|// type  : SQLException
comment|// tested with MySQL
if|if
condition|(
name|sqlex
operator|.
name|getSQLState
argument_list|()
operator|.
name|equals
argument_list|(
literal|"28000"
argument_list|)
condition|)
block|{
name|msg
operator|=
name|Globals
operator|.
name|lang
argument_list|(
name|sqlex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// desc  : Cannot connect to SQL server
comment|// code  : 0
comment|// state : 08S01
comment|// msg   : Communications link failure due to underlying exception
comment|// type  : java.net.UnknownHostException
comment|// tested with MySQL
if|if
condition|(
name|sqlex
operator|.
name|getSQLState
argument_list|()
operator|.
name|equals
argument_list|(
literal|"08S01"
argument_list|)
condition|)
block|{
name|msg
operator|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Cannot connect to SQL server at the specified host."
argument_list|)
expr_stmt|;
block|}
comment|// for debugging...
if|if
condition|(
literal|false
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"-------------------------------------"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|sqlex
operator|.
name|getErrorCode
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|sqlex
operator|.
name|getSQLState
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|sqlex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"-------------------------------------"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// handle case where exception is non-SQL related
if|if
condition|(
name|msg
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|ex
operator|.
name|getMessage
argument_list|()
operator|==
literal|null
condition|)
block|{
name|msg
operator|=
name|ex
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
name|ex
operator|.
name|getMessage
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|msg
return|;
block|}
block|}
end_class

end_unit

