begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr.preprocessor
package|package
name|antlr
operator|.
name|preprocessor
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/license.html  *  * $Id$  */
end_comment

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|IndexedVector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_class
DECL|class|Grammar
class|class
name|Grammar
block|{
DECL|field|name
specifier|protected
name|String
name|name
decl_stmt|;
DECL|field|fileName
specifier|protected
name|String
name|fileName
decl_stmt|;
comment|// where does it come from?
DECL|field|superGrammar
specifier|protected
name|String
name|superGrammar
decl_stmt|;
comment|// null if no super class
DECL|field|type
specifier|protected
name|String
name|type
decl_stmt|;
comment|// lexer? parser? tree parser?
DECL|field|rules
specifier|protected
name|IndexedVector
name|rules
decl_stmt|;
comment|// text of rules as they were read in
DECL|field|options
specifier|protected
name|IndexedVector
name|options
decl_stmt|;
comment|// rule options
DECL|field|tokenSection
specifier|protected
name|String
name|tokenSection
decl_stmt|;
comment|// the tokens{} stuff
DECL|field|preambleAction
specifier|protected
name|String
name|preambleAction
decl_stmt|;
comment|// action right before grammar
DECL|field|memberAction
specifier|protected
name|String
name|memberAction
decl_stmt|;
comment|// action inside grammar
DECL|field|hier
specifier|protected
name|Hierarchy
name|hier
decl_stmt|;
comment|// hierarchy of grammars
DECL|field|predefined
specifier|protected
name|boolean
name|predefined
init|=
literal|false
decl_stmt|;
comment|// one of the predefined grammars?
DECL|field|alreadyExpanded
specifier|protected
name|boolean
name|alreadyExpanded
init|=
literal|false
decl_stmt|;
DECL|field|specifiedVocabulary
specifier|protected
name|boolean
name|specifiedVocabulary
init|=
literal|false
decl_stmt|;
comment|// found importVocab option?
comment|/** if not derived from another grammar, might still specify a non-ANTLR 	 *  class to derive from like this "class T extends Parser(MyParserClass);" 	 */
DECL|field|superClass
specifier|protected
name|String
name|superClass
init|=
literal|null
decl_stmt|;
DECL|field|importVocab
specifier|protected
name|String
name|importVocab
init|=
literal|null
decl_stmt|;
DECL|field|exportVocab
specifier|protected
name|String
name|exportVocab
init|=
literal|null
decl_stmt|;
DECL|field|antlrTool
specifier|protected
name|antlr
operator|.
name|Tool
name|antlrTool
decl_stmt|;
DECL|method|Grammar (antlr.Tool tool, String name, String superGrammar, IndexedVector rules)
specifier|public
name|Grammar
parameter_list|(
name|antlr
operator|.
name|Tool
name|tool
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|superGrammar
parameter_list|,
name|IndexedVector
name|rules
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|superGrammar
operator|=
name|superGrammar
expr_stmt|;
name|this
operator|.
name|rules
operator|=
name|rules
expr_stmt|;
name|this
operator|.
name|antlrTool
operator|=
name|tool
expr_stmt|;
block|}
DECL|method|addOption (Option o)
specifier|public
name|void
name|addOption
parameter_list|(
name|Option
name|o
parameter_list|)
block|{
if|if
condition|(
name|options
operator|==
literal|null
condition|)
block|{
comment|// if not already there, create it
name|options
operator|=
operator|new
name|IndexedVector
argument_list|()
expr_stmt|;
block|}
name|options
operator|.
name|appendElement
argument_list|(
name|o
operator|.
name|getName
argument_list|()
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
DECL|method|addRule (Rule r)
specifier|public
name|void
name|addRule
parameter_list|(
name|Rule
name|r
parameter_list|)
block|{
name|rules
operator|.
name|appendElement
argument_list|(
name|r
operator|.
name|getName
argument_list|()
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
comment|/** Copy all nonoverridden rules, vocabulary, and options into this grammar from      *  supergrammar chain.  The change is made in place; e.g., this grammar's vector      *  of rules gets bigger.  This has side-effects: all grammars on path to      *  root of hierarchy are expanded also.      */
DECL|method|expandInPlace ()
specifier|public
name|void
name|expandInPlace
parameter_list|()
block|{
comment|// if this grammar already expanded, just return
if|if
condition|(
name|alreadyExpanded
condition|)
block|{
return|return;
block|}
comment|// Expand super grammar first (unless it's a predefined or subgrammar of predefined)
name|Grammar
name|superG
init|=
name|getSuperGrammar
argument_list|()
decl_stmt|;
if|if
condition|(
name|superG
operator|==
literal|null
condition|)
return|return;
comment|// error (didn't provide superclass)
if|if
condition|(
name|exportVocab
operator|==
literal|null
condition|)
block|{
comment|// if no exportVocab for this grammar, make it same as grammar name
name|exportVocab
operator|=
name|getName
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|superG
operator|.
name|isPredefined
argument_list|()
condition|)
return|return;
comment|// can't expand Lexer, Parser, ...
name|superG
operator|.
name|expandInPlace
argument_list|()
expr_stmt|;
comment|// expand current grammar now.
name|alreadyExpanded
operator|=
literal|true
expr_stmt|;
comment|// track whether a grammar file needed to have a grammar expanded
name|GrammarFile
name|gf
init|=
name|hier
operator|.
name|getFile
argument_list|(
name|getFileName
argument_list|()
argument_list|)
decl_stmt|;
name|gf
operator|.
name|setExpanded
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Copy rules from supergrammar into this grammar
name|IndexedVector
name|inhRules
init|=
name|superG
operator|.
name|getRules
argument_list|()
decl_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|inhRules
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Rule
name|r
init|=
operator|(
name|Rule
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|inherit
argument_list|(
name|r
argument_list|,
name|superG
argument_list|)
expr_stmt|;
block|}
comment|// Copy options from supergrammar into this grammar
comment|// Modify tokdef options so that they point to dir of enclosing grammar
name|IndexedVector
name|inhOptions
init|=
name|superG
operator|.
name|getOptions
argument_list|()
decl_stmt|;
if|if
condition|(
name|inhOptions
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Enumeration
name|e
init|=
name|inhOptions
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Option
name|o
init|=
operator|(
name|Option
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|inherit
argument_list|(
name|o
argument_list|,
name|superG
argument_list|)
expr_stmt|;
block|}
block|}
comment|// add an option to load the superGrammar's output vocab
if|if
condition|(
operator|(
name|options
operator|!=
literal|null
operator|&&
name|options
operator|.
name|getElement
argument_list|(
literal|"importVocab"
argument_list|)
operator|==
literal|null
operator|)
operator|||
name|options
operator|==
literal|null
condition|)
block|{
comment|// no importVocab found, add one that grabs superG's output vocab
name|Option
name|inputV
init|=
operator|new
name|Option
argument_list|(
literal|"importVocab"
argument_list|,
name|superG
operator|.
name|exportVocab
operator|+
literal|";"
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|addOption
argument_list|(
name|inputV
argument_list|)
expr_stmt|;
comment|// copy output vocab file to current dir
name|String
name|originatingGrFileName
init|=
name|superG
operator|.
name|getFileName
argument_list|()
decl_stmt|;
name|String
name|path
init|=
name|antlrTool
operator|.
name|pathToFile
argument_list|(
name|originatingGrFileName
argument_list|)
decl_stmt|;
name|String
name|superExportVocabFileName
init|=
name|path
operator|+
name|superG
operator|.
name|exportVocab
operator|+
name|antlr
operator|.
name|CodeGenerator
operator|.
name|TokenTypesFileSuffix
operator|+
name|antlr
operator|.
name|CodeGenerator
operator|.
name|TokenTypesFileExt
decl_stmt|;
name|String
name|newImportVocabFileName
init|=
name|antlrTool
operator|.
name|fileMinusPath
argument_list|(
name|superExportVocabFileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|equals
argument_list|(
literal|"."
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
argument_list|)
condition|)
block|{
comment|// don't copy tokdef file onto itself (must be current directory)
comment|// System.out.println("importVocab file same dir; leaving as " + superExportVocabFileName);
block|}
else|else
block|{
try|try
block|{
name|antlrTool
operator|.
name|copyFile
argument_list|(
name|superExportVocabFileName
argument_list|,
name|newImportVocabFileName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|io
parameter_list|)
block|{
name|antlrTool
operator|.
name|toolError
argument_list|(
literal|"cannot find/copy importVocab file "
operator|+
name|superExportVocabFileName
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// copy member action from supergrammar into this grammar
name|inherit
argument_list|(
name|superG
operator|.
name|memberAction
argument_list|,
name|superG
argument_list|)
expr_stmt|;
block|}
DECL|method|getFileName ()
specifier|public
name|String
name|getFileName
parameter_list|()
block|{
return|return
name|fileName
return|;
block|}
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|method|getOptions ()
specifier|public
name|IndexedVector
name|getOptions
parameter_list|()
block|{
return|return
name|options
return|;
block|}
DECL|method|getRules ()
specifier|public
name|IndexedVector
name|getRules
parameter_list|()
block|{
return|return
name|rules
return|;
block|}
DECL|method|getSuperGrammar ()
specifier|public
name|Grammar
name|getSuperGrammar
parameter_list|()
block|{
if|if
condition|(
name|superGrammar
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|Grammar
name|g
init|=
operator|(
name|Grammar
operator|)
name|hier
operator|.
name|getGrammar
argument_list|(
name|superGrammar
argument_list|)
decl_stmt|;
return|return
name|g
return|;
block|}
DECL|method|getSuperGrammarName ()
specifier|public
name|String
name|getSuperGrammarName
parameter_list|()
block|{
return|return
name|superGrammar
return|;
block|}
DECL|method|getType ()
specifier|public
name|String
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
DECL|method|inherit (Option o, Grammar superG)
specifier|public
name|void
name|inherit
parameter_list|(
name|Option
name|o
parameter_list|,
name|Grammar
name|superG
parameter_list|)
block|{
comment|// do NOT inherit importVocab/exportVocab options under any circumstances
if|if
condition|(
name|o
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"importVocab"
argument_list|)
operator|||
name|o
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"exportVocab"
argument_list|)
condition|)
block|{
return|return;
block|}
name|Option
name|overriddenOption
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|options
operator|!=
literal|null
condition|)
block|{
comment|// do we even have options?
name|overriddenOption
operator|=
operator|(
name|Option
operator|)
name|options
operator|.
name|getElement
argument_list|(
name|o
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// if overridden, do not add to this grammar
if|if
condition|(
name|overriddenOption
operator|==
literal|null
condition|)
block|{
comment|// not overridden
name|addOption
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|// copy option into this grammar--not overridden
block|}
block|}
DECL|method|inherit (Rule r, Grammar superG)
specifier|public
name|void
name|inherit
parameter_list|(
name|Rule
name|r
parameter_list|,
name|Grammar
name|superG
parameter_list|)
block|{
comment|// if overridden, do not add to this grammar
name|Rule
name|overriddenRule
init|=
operator|(
name|Rule
operator|)
name|rules
operator|.
name|getElement
argument_list|(
name|r
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|overriddenRule
operator|!=
literal|null
condition|)
block|{
comment|// rule is overridden in this grammar.
if|if
condition|(
operator|!
name|overriddenRule
operator|.
name|sameSignature
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// warn if different sig
name|antlrTool
operator|.
name|warning
argument_list|(
literal|"rule "
operator|+
name|getName
argument_list|()
operator|+
literal|"."
operator|+
name|overriddenRule
operator|.
name|getName
argument_list|()
operator|+
literal|" has different signature than "
operator|+
name|superG
operator|.
name|getName
argument_list|()
operator|+
literal|"."
operator|+
name|overriddenRule
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// not overridden, copy rule into this
name|addRule
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|inherit (String memberAction, Grammar superG)
specifier|public
name|void
name|inherit
parameter_list|(
name|String
name|memberAction
parameter_list|,
name|Grammar
name|superG
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|memberAction
operator|!=
literal|null
condition|)
return|return;
comment|// do nothing if already have member action
if|if
condition|(
name|memberAction
operator|!=
literal|null
condition|)
block|{
comment|// don't have one here, use supergrammar's action
name|this
operator|.
name|memberAction
operator|=
name|memberAction
expr_stmt|;
block|}
block|}
DECL|method|isPredefined ()
specifier|public
name|boolean
name|isPredefined
parameter_list|()
block|{
return|return
name|predefined
return|;
block|}
DECL|method|setFileName (String f)
specifier|public
name|void
name|setFileName
parameter_list|(
name|String
name|f
parameter_list|)
block|{
name|fileName
operator|=
name|f
expr_stmt|;
block|}
DECL|method|setHierarchy (Hierarchy hier)
specifier|public
name|void
name|setHierarchy
parameter_list|(
name|Hierarchy
name|hier
parameter_list|)
block|{
name|this
operator|.
name|hier
operator|=
name|hier
expr_stmt|;
block|}
DECL|method|setMemberAction (String a)
specifier|public
name|void
name|setMemberAction
parameter_list|(
name|String
name|a
parameter_list|)
block|{
name|memberAction
operator|=
name|a
expr_stmt|;
block|}
DECL|method|setOptions (IndexedVector options)
specifier|public
name|void
name|setOptions
parameter_list|(
name|IndexedVector
name|options
parameter_list|)
block|{
name|this
operator|.
name|options
operator|=
name|options
expr_stmt|;
block|}
DECL|method|setPreambleAction (String a)
specifier|public
name|void
name|setPreambleAction
parameter_list|(
name|String
name|a
parameter_list|)
block|{
name|preambleAction
operator|=
name|a
expr_stmt|;
block|}
DECL|method|setPredefined (boolean b)
specifier|public
name|void
name|setPredefined
parameter_list|(
name|boolean
name|b
parameter_list|)
block|{
name|predefined
operator|=
name|b
expr_stmt|;
block|}
DECL|method|setTokenSection (String tk)
specifier|public
name|void
name|setTokenSection
parameter_list|(
name|String
name|tk
parameter_list|)
block|{
name|tokenSection
operator|=
name|tk
expr_stmt|;
block|}
DECL|method|setType (String t)
specifier|public
name|void
name|setType
parameter_list|(
name|String
name|t
parameter_list|)
block|{
name|type
operator|=
name|t
expr_stmt|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuffer
name|s
init|=
operator|new
name|StringBuffer
argument_list|(
literal|10000
argument_list|)
decl_stmt|;
if|if
condition|(
name|preambleAction
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
name|preambleAction
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|superGrammar
operator|==
literal|null
condition|)
block|{
return|return
literal|"class "
operator|+
name|name
operator|+
literal|";"
return|;
block|}
if|if
condition|(
name|superClass
operator|!=
literal|null
condition|)
block|{
comment|// replace with specified superclass not actual grammar
comment|// user must make sure that the superclass derives from super grammar class
name|s
operator|.
name|append
argument_list|(
literal|"class "
operator|+
name|name
operator|+
literal|" extends "
operator|+
name|superClass
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|.
name|append
argument_list|(
literal|"class "
operator|+
name|name
operator|+
literal|" extends "
operator|+
name|type
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|append
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
name|Hierarchy
operator|.
name|optionsToString
argument_list|(
name|options
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tokenSection
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
name|tokenSection
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|memberAction
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
name|memberAction
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rules
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Rule
name|r
init|=
operator|(
name|Rule
operator|)
name|rules
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|r
operator|.
name|enclosingGrammar
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|"// inherited from grammar "
operator|+
name|r
operator|.
name|enclosingGrammar
operator|.
name|getName
argument_list|()
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|append
argument_list|(
name|r
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

