begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr.preprocessor
package|package
name|antlr
operator|.
name|preprocessor
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/license.html  *  * $Id$  */
end_comment

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|IndexedVector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_comment
comment|/** Stores header action, grammar preamble, file options, and  *  list of grammars in the file  */
end_comment

begin_class
DECL|class|GrammarFile
specifier|public
class|class
name|GrammarFile
block|{
DECL|field|fileName
specifier|protected
name|String
name|fileName
decl_stmt|;
DECL|field|headerAction
specifier|protected
name|String
name|headerAction
init|=
literal|""
decl_stmt|;
DECL|field|options
specifier|protected
name|IndexedVector
name|options
decl_stmt|;
DECL|field|grammars
specifier|protected
name|IndexedVector
name|grammars
decl_stmt|;
DECL|field|expanded
specifier|protected
name|boolean
name|expanded
init|=
literal|false
decl_stmt|;
comment|// any grammars expanded within?
DECL|field|tool
specifier|protected
name|antlr
operator|.
name|Tool
name|tool
decl_stmt|;
DECL|method|GrammarFile (antlr.Tool tool, String f)
specifier|public
name|GrammarFile
parameter_list|(
name|antlr
operator|.
name|Tool
name|tool
parameter_list|,
name|String
name|f
parameter_list|)
block|{
name|fileName
operator|=
name|f
expr_stmt|;
name|grammars
operator|=
operator|new
name|IndexedVector
argument_list|()
expr_stmt|;
name|this
operator|.
name|tool
operator|=
name|tool
expr_stmt|;
block|}
DECL|method|addGrammar (Grammar g)
specifier|public
name|void
name|addGrammar
parameter_list|(
name|Grammar
name|g
parameter_list|)
block|{
name|grammars
operator|.
name|appendElement
argument_list|(
name|g
operator|.
name|getName
argument_list|()
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
DECL|method|generateExpandedFile ()
specifier|public
name|void
name|generateExpandedFile
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|expanded
condition|)
block|{
return|return;
comment|// don't generate if nothing got expanded
block|}
name|String
name|expandedFileName
init|=
name|nameForExpandedGrammarFile
argument_list|(
name|this
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|// create the new grammar file with expanded grammars
name|PrintWriter
name|expF
init|=
name|tool
operator|.
name|openOutputFile
argument_list|(
name|expandedFileName
argument_list|)
decl_stmt|;
name|expF
operator|.
name|println
argument_list|(
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|expF
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|getGrammars ()
specifier|public
name|IndexedVector
name|getGrammars
parameter_list|()
block|{
return|return
name|grammars
return|;
block|}
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|fileName
return|;
block|}
DECL|method|nameForExpandedGrammarFile (String f)
specifier|public
name|String
name|nameForExpandedGrammarFile
parameter_list|(
name|String
name|f
parameter_list|)
block|{
if|if
condition|(
name|expanded
condition|)
block|{
comment|// strip path to original input, make expanded file in current dir
return|return
literal|"expanded"
operator|+
name|tool
operator|.
name|fileMinusPath
argument_list|(
name|f
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|f
return|;
block|}
block|}
DECL|method|setExpanded (boolean exp)
specifier|public
name|void
name|setExpanded
parameter_list|(
name|boolean
name|exp
parameter_list|)
block|{
name|expanded
operator|=
name|exp
expr_stmt|;
block|}
DECL|method|addHeaderAction (String a)
specifier|public
name|void
name|addHeaderAction
parameter_list|(
name|String
name|a
parameter_list|)
block|{
name|headerAction
operator|+=
name|a
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
expr_stmt|;
block|}
DECL|method|setOptions (IndexedVector o)
specifier|public
name|void
name|setOptions
parameter_list|(
name|IndexedVector
name|o
parameter_list|)
block|{
name|options
operator|=
name|o
expr_stmt|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|h
init|=
name|headerAction
operator|==
literal|null
condition|?
literal|""
else|:
name|headerAction
decl_stmt|;
name|String
name|o
init|=
name|options
operator|==
literal|null
condition|?
literal|""
else|:
name|Hierarchy
operator|.
name|optionsToString
argument_list|(
name|options
argument_list|)
decl_stmt|;
name|StringBuffer
name|s
init|=
operator|new
name|StringBuffer
argument_list|(
literal|10000
argument_list|)
decl_stmt|;
name|s
operator|.
name|append
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|o
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|grammars
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Grammar
name|g
init|=
operator|(
name|Grammar
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|s
operator|.
name|append
argument_list|(
name|g
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

