begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr.preprocessor
package|package
name|antlr
operator|.
name|preprocessor
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/license.html  *  * $Id$  */
end_comment

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_comment
comment|/** Tester for the preprocessor */
end_comment

begin_class
DECL|class|Tool
specifier|public
class|class
name|Tool
block|{
DECL|field|theHierarchy
specifier|protected
name|Hierarchy
name|theHierarchy
decl_stmt|;
DECL|field|grammarFileName
specifier|protected
name|String
name|grammarFileName
decl_stmt|;
DECL|field|args
specifier|protected
name|String
index|[]
name|args
decl_stmt|;
DECL|field|nargs
specifier|protected
name|int
name|nargs
decl_stmt|;
comment|// how many args in new args list
DECL|field|grammars
specifier|protected
name|Vector
name|grammars
decl_stmt|;
DECL|field|antlrTool
specifier|protected
name|antlr
operator|.
name|Tool
name|antlrTool
decl_stmt|;
DECL|method|Tool (antlr.Tool t, String[] args)
specifier|public
name|Tool
parameter_list|(
name|antlr
operator|.
name|Tool
name|t
parameter_list|,
name|String
index|[]
name|args
parameter_list|)
block|{
name|antlrTool
operator|=
name|t
expr_stmt|;
name|processArguments
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|antlr
operator|.
name|Tool
name|antlrTool
init|=
operator|new
name|antlr
operator|.
name|Tool
argument_list|()
decl_stmt|;
name|Tool
name|theTool
init|=
operator|new
name|Tool
argument_list|(
name|antlrTool
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|theTool
operator|.
name|preprocess
argument_list|()
expr_stmt|;
name|String
index|[]
name|a
init|=
name|theTool
operator|.
name|preprocessedArgList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|a
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|" "
operator|+
name|a
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
DECL|method|preprocess ()
specifier|public
name|boolean
name|preprocess
parameter_list|()
block|{
if|if
condition|(
name|grammarFileName
operator|==
literal|null
condition|)
block|{
name|antlrTool
operator|.
name|toolError
argument_list|(
literal|"no grammar file specified"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|grammars
operator|!=
literal|null
condition|)
block|{
name|theHierarchy
operator|=
operator|new
name|Hierarchy
argument_list|(
name|antlrTool
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|grammars
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|String
name|f
init|=
operator|(
name|String
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
try|try
block|{
name|theHierarchy
operator|.
name|readGrammarFile
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fe
parameter_list|)
block|{
name|antlrTool
operator|.
name|toolError
argument_list|(
literal|"file "
operator|+
name|f
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
comment|// do the actual inheritance stuff
name|boolean
name|complete
init|=
name|theHierarchy
operator|.
name|verifyThatHierarchyIsComplete
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|complete
condition|)
return|return
literal|false
return|;
name|theHierarchy
operator|.
name|expandGrammarsInFile
argument_list|(
name|grammarFileName
argument_list|)
expr_stmt|;
name|GrammarFile
name|gf
init|=
name|theHierarchy
operator|.
name|getFile
argument_list|(
name|grammarFileName
argument_list|)
decl_stmt|;
name|String
name|expandedFileName
init|=
name|gf
operator|.
name|nameForExpandedGrammarFile
argument_list|(
name|grammarFileName
argument_list|)
decl_stmt|;
comment|// generate the output file if necessary
if|if
condition|(
name|expandedFileName
operator|.
name|equals
argument_list|(
name|grammarFileName
argument_list|)
condition|)
block|{
name|args
index|[
name|nargs
operator|++
index|]
operator|=
name|grammarFileName
expr_stmt|;
comment|// add to argument list
block|}
else|else
block|{
try|try
block|{
name|gf
operator|.
name|generateExpandedFile
argument_list|()
expr_stmt|;
comment|// generate file to feed ANTLR
name|args
index|[
name|nargs
operator|++
index|]
operator|=
name|antlrTool
operator|.
name|getOutputDirectory
argument_list|()
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
operator|+
name|expandedFileName
expr_stmt|;
comment|// add to argument list
block|}
catch|catch
parameter_list|(
name|IOException
name|io
parameter_list|)
block|{
name|antlrTool
operator|.
name|toolError
argument_list|(
literal|"cannot write expanded grammar file "
operator|+
name|expandedFileName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/** create new arg list with correct length to pass to ANTLR */
DECL|method|preprocessedArgList ()
specifier|public
name|String
index|[]
name|preprocessedArgList
parameter_list|()
block|{
name|String
index|[]
name|a
init|=
operator|new
name|String
index|[
name|nargs
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
name|a
argument_list|,
literal|0
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
name|args
operator|=
name|a
expr_stmt|;
return|return
name|args
return|;
block|}
comment|/** Process -glib options and grammar file.  Create a new args list      *  that does not contain the -glib option.  The grammar file name      *  might be modified and, hence, is not added yet to args list.      */
DECL|method|processArguments (String[] incomingArgs)
specifier|private
name|void
name|processArguments
parameter_list|(
name|String
index|[]
name|incomingArgs
parameter_list|)
block|{
name|this
operator|.
name|nargs
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|args
operator|=
operator|new
name|String
index|[
name|incomingArgs
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|incomingArgs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|incomingArgs
index|[
name|i
index|]
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|antlrTool
operator|.
name|warning
argument_list|(
literal|"Zero length argument ignoring..."
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|incomingArgs
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-glib"
argument_list|)
condition|)
block|{
comment|// if on a pc and they use a '/', warn them
if|if
condition|(
name|File
operator|.
name|separator
operator|.
name|equals
argument_list|(
literal|"\\"
argument_list|)
operator|&&
name|incomingArgs
index|[
name|i
index|]
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|antlrTool
operator|.
name|warning
argument_list|(
literal|"-glib cannot deal with '/' on a PC: use '\\'; ignoring..."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|grammars
operator|=
name|antlrTool
operator|.
name|parseSeparatedList
argument_list|(
name|incomingArgs
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|incomingArgs
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-o"
argument_list|)
condition|)
block|{
name|args
index|[
name|this
operator|.
name|nargs
operator|++
index|]
operator|=
name|incomingArgs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|incomingArgs
operator|.
name|length
condition|)
block|{
name|antlrTool
operator|.
name|error
argument_list|(
literal|"missing output directory with -o option; ignoring"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|++
expr_stmt|;
name|args
index|[
name|this
operator|.
name|nargs
operator|++
index|]
operator|=
name|incomingArgs
index|[
name|i
index|]
expr_stmt|;
name|antlrTool
operator|.
name|setOutputDirectory
argument_list|(
name|incomingArgs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|incomingArgs
index|[
name|i
index|]
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'-'
condition|)
block|{
name|args
index|[
name|this
operator|.
name|nargs
operator|++
index|]
operator|=
name|incomingArgs
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
comment|// Must be the grammar file
name|grammarFileName
operator|=
name|incomingArgs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|grammars
operator|==
literal|null
condition|)
block|{
name|grammars
operator|=
operator|new
name|Vector
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|grammars
operator|.
name|appendElement
argument_list|(
name|grammarFileName
argument_list|)
expr_stmt|;
comment|// process it too
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|incomingArgs
operator|.
name|length
condition|)
block|{
name|antlrTool
operator|.
name|warning
argument_list|(
literal|"grammar file must be last; ignoring other arguments..."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

