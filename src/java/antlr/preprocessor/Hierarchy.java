begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr.preprocessor
package|package
name|antlr
operator|.
name|preprocessor
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/license.html  *  * $Id$  */
end_comment

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|IndexedVector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|*
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|preprocessor
operator|.
name|Grammar
import|;
end_import

begin_class
DECL|class|Hierarchy
specifier|public
class|class
name|Hierarchy
block|{
DECL|field|LexerRoot
specifier|protected
name|Grammar
name|LexerRoot
init|=
literal|null
decl_stmt|;
DECL|field|ParserRoot
specifier|protected
name|Grammar
name|ParserRoot
init|=
literal|null
decl_stmt|;
DECL|field|TreeParserRoot
specifier|protected
name|Grammar
name|TreeParserRoot
init|=
literal|null
decl_stmt|;
DECL|field|symbols
specifier|protected
name|Hashtable
name|symbols
decl_stmt|;
comment|// table of grammars
DECL|field|files
specifier|protected
name|Hashtable
name|files
decl_stmt|;
comment|// table of grammar files read in
DECL|field|antlrTool
specifier|protected
name|antlr
operator|.
name|Tool
name|antlrTool
decl_stmt|;
DECL|method|Hierarchy (antlr.Tool tool)
specifier|public
name|Hierarchy
parameter_list|(
name|antlr
operator|.
name|Tool
name|tool
parameter_list|)
block|{
name|this
operator|.
name|antlrTool
operator|=
name|tool
expr_stmt|;
name|LexerRoot
operator|=
operator|new
name|Grammar
argument_list|(
name|tool
argument_list|,
literal|"Lexer"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|ParserRoot
operator|=
operator|new
name|Grammar
argument_list|(
name|tool
argument_list|,
literal|"Parser"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|TreeParserRoot
operator|=
operator|new
name|Grammar
argument_list|(
name|tool
argument_list|,
literal|"TreeParser"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|symbols
operator|=
operator|new
name|Hashtable
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|files
operator|=
operator|new
name|Hashtable
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|LexerRoot
operator|.
name|setPredefined
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ParserRoot
operator|.
name|setPredefined
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|TreeParserRoot
operator|.
name|setPredefined
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|symbols
operator|.
name|put
argument_list|(
name|LexerRoot
operator|.
name|getName
argument_list|()
argument_list|,
name|LexerRoot
argument_list|)
expr_stmt|;
name|symbols
operator|.
name|put
argument_list|(
name|ParserRoot
operator|.
name|getName
argument_list|()
argument_list|,
name|ParserRoot
argument_list|)
expr_stmt|;
name|symbols
operator|.
name|put
argument_list|(
name|TreeParserRoot
operator|.
name|getName
argument_list|()
argument_list|,
name|TreeParserRoot
argument_list|)
expr_stmt|;
block|}
DECL|method|addGrammar (Grammar gr)
specifier|public
name|void
name|addGrammar
parameter_list|(
name|Grammar
name|gr
parameter_list|)
block|{
name|gr
operator|.
name|setHierarchy
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// add grammar to hierarchy
name|symbols
operator|.
name|put
argument_list|(
name|gr
operator|.
name|getName
argument_list|()
argument_list|,
name|gr
argument_list|)
expr_stmt|;
comment|// add grammar to file.
name|GrammarFile
name|f
init|=
name|getFile
argument_list|(
name|gr
operator|.
name|getFileName
argument_list|()
argument_list|)
decl_stmt|;
name|f
operator|.
name|addGrammar
argument_list|(
name|gr
argument_list|)
expr_stmt|;
block|}
DECL|method|addGrammarFile (GrammarFile gf)
specifier|public
name|void
name|addGrammarFile
parameter_list|(
name|GrammarFile
name|gf
parameter_list|)
block|{
name|files
operator|.
name|put
argument_list|(
name|gf
operator|.
name|getName
argument_list|()
argument_list|,
name|gf
argument_list|)
expr_stmt|;
block|}
DECL|method|expandGrammarsInFile (String fileName)
specifier|public
name|void
name|expandGrammarsInFile
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
name|GrammarFile
name|f
init|=
name|getFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|f
operator|.
name|getGrammars
argument_list|()
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Grammar
name|g
init|=
operator|(
name|Grammar
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|g
operator|.
name|expandInPlace
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|findRoot (Grammar g)
specifier|public
name|Grammar
name|findRoot
parameter_list|(
name|Grammar
name|g
parameter_list|)
block|{
if|if
condition|(
name|g
operator|.
name|getSuperGrammarName
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// at root
return|return
name|g
return|;
block|}
comment|// return root of super.
name|Grammar
name|sg
init|=
name|g
operator|.
name|getSuperGrammar
argument_list|()
decl_stmt|;
if|if
condition|(
name|sg
operator|==
literal|null
condition|)
return|return
name|g
return|;
comment|// return this grammar if super missing
return|return
name|findRoot
argument_list|(
name|sg
argument_list|)
return|;
block|}
DECL|method|getFile (String fileName)
specifier|public
name|GrammarFile
name|getFile
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
return|return
operator|(
name|GrammarFile
operator|)
name|files
operator|.
name|get
argument_list|(
name|fileName
argument_list|)
return|;
block|}
DECL|method|getGrammar (String gr)
specifier|public
name|Grammar
name|getGrammar
parameter_list|(
name|String
name|gr
parameter_list|)
block|{
return|return
operator|(
name|Grammar
operator|)
name|symbols
operator|.
name|get
argument_list|(
name|gr
argument_list|)
return|;
block|}
DECL|method|optionsToString (IndexedVector options)
specifier|public
specifier|static
name|String
name|optionsToString
parameter_list|(
name|IndexedVector
name|options
parameter_list|)
block|{
name|String
name|s
init|=
literal|"options {"
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|options
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|s
operator|+=
operator|(
name|Option
operator|)
name|e
operator|.
name|nextElement
argument_list|()
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
expr_stmt|;
block|}
name|s
operator|+=
literal|"}"
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
DECL|method|readGrammarFile (String file)
specifier|public
name|void
name|readGrammarFile
parameter_list|(
name|String
name|file
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|Reader
name|grStream
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|FileReader
argument_list|(
name|file
argument_list|)
argument_list|)
decl_stmt|;
name|addGrammarFile
argument_list|(
operator|new
name|GrammarFile
argument_list|(
name|antlrTool
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create the simplified grammar lexer/parser
name|PreprocessorLexer
name|ppLexer
init|=
operator|new
name|PreprocessorLexer
argument_list|(
name|grStream
argument_list|)
decl_stmt|;
name|ppLexer
operator|.
name|setFilename
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|Preprocessor
name|pp
init|=
operator|new
name|Preprocessor
argument_list|(
name|ppLexer
argument_list|)
decl_stmt|;
name|pp
operator|.
name|setTool
argument_list|(
name|antlrTool
argument_list|)
expr_stmt|;
name|pp
operator|.
name|setFilename
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|// populate the hierarchy with class(es) read in
try|try
block|{
name|pp
operator|.
name|grammarFile
argument_list|(
name|this
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TokenStreamException
name|io
parameter_list|)
block|{
name|antlrTool
operator|.
name|toolError
argument_list|(
literal|"Token stream error reading grammar(s):\n"
operator|+
name|io
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ANTLRException
name|se
parameter_list|)
block|{
name|antlrTool
operator|.
name|toolError
argument_list|(
literal|"error reading grammar(s):\n"
operator|+
name|se
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Return true if hierarchy is complete, false if not */
DECL|method|verifyThatHierarchyIsComplete ()
specifier|public
name|boolean
name|verifyThatHierarchyIsComplete
parameter_list|()
block|{
name|boolean
name|complete
init|=
literal|true
decl_stmt|;
comment|// Make a pass to ensure all grammars are defined
for|for
control|(
name|Enumeration
name|e
init|=
name|symbols
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Grammar
name|c
init|=
operator|(
name|Grammar
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|getSuperGrammarName
argument_list|()
operator|==
literal|null
condition|)
block|{
continue|continue;
comment|// at root: ignore predefined roots
block|}
name|Grammar
name|superG
init|=
name|c
operator|.
name|getSuperGrammar
argument_list|()
decl_stmt|;
if|if
condition|(
name|superG
operator|==
literal|null
condition|)
block|{
name|antlrTool
operator|.
name|toolError
argument_list|(
literal|"grammar "
operator|+
name|c
operator|.
name|getSuperGrammarName
argument_list|()
operator|+
literal|" not defined"
argument_list|)
expr_stmt|;
name|complete
operator|=
literal|false
expr_stmt|;
name|symbols
operator|.
name|remove
argument_list|(
name|c
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// super not defined, kill sub
block|}
block|}
if|if
condition|(
operator|!
name|complete
condition|)
return|return
literal|false
return|;
comment|// Make another pass to set the 'type' field of each grammar
comment|// This makes it easy later to ask a grammar what its type
comment|// is w/o having to search hierarchy.
for|for
control|(
name|Enumeration
name|e
init|=
name|symbols
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Grammar
name|c
init|=
operator|(
name|Grammar
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|getSuperGrammarName
argument_list|()
operator|==
literal|null
condition|)
block|{
continue|continue;
comment|// ignore predefined roots
block|}
name|c
operator|.
name|setType
argument_list|(
name|findRoot
argument_list|(
name|c
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|getTool ()
specifier|public
name|antlr
operator|.
name|Tool
name|getTool
parameter_list|()
block|{
return|return
name|antlrTool
return|;
block|}
DECL|method|setTool (antlr.Tool antlrTool)
specifier|public
name|void
name|setTool
parameter_list|(
name|antlr
operator|.
name|Tool
name|antlrTool
parameter_list|)
block|{
name|this
operator|.
name|antlrTool
operator|=
name|antlrTool
expr_stmt|;
block|}
block|}
end_class

end_unit

