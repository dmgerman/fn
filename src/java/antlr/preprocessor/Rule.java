begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr.preprocessor
package|package
name|antlr
operator|.
name|preprocessor
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/license.html  *  * $Id$  */
end_comment

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|IndexedVector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_class
DECL|class|Rule
class|class
name|Rule
block|{
DECL|field|name
specifier|protected
name|String
name|name
decl_stmt|;
DECL|field|block
specifier|protected
name|String
name|block
decl_stmt|;
DECL|field|args
specifier|protected
name|String
name|args
decl_stmt|;
DECL|field|returnValue
specifier|protected
name|String
name|returnValue
decl_stmt|;
DECL|field|throwsSpec
specifier|protected
name|String
name|throwsSpec
decl_stmt|;
DECL|field|initAction
specifier|protected
name|String
name|initAction
decl_stmt|;
DECL|field|options
specifier|protected
name|IndexedVector
name|options
decl_stmt|;
DECL|field|visibility
specifier|protected
name|String
name|visibility
decl_stmt|;
DECL|field|enclosingGrammar
specifier|protected
name|Grammar
name|enclosingGrammar
decl_stmt|;
DECL|field|bang
specifier|protected
name|boolean
name|bang
init|=
literal|false
decl_stmt|;
DECL|method|Rule (String n, String b, IndexedVector options, Grammar gr)
specifier|public
name|Rule
parameter_list|(
name|String
name|n
parameter_list|,
name|String
name|b
parameter_list|,
name|IndexedVector
name|options
parameter_list|,
name|Grammar
name|gr
parameter_list|)
block|{
name|name
operator|=
name|n
expr_stmt|;
name|block
operator|=
name|b
expr_stmt|;
name|this
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|setEnclosingGrammar
argument_list|(
name|gr
argument_list|)
expr_stmt|;
block|}
DECL|method|getArgs ()
specifier|public
name|String
name|getArgs
parameter_list|()
block|{
return|return
name|args
return|;
block|}
DECL|method|getBang ()
specifier|public
name|boolean
name|getBang
parameter_list|()
block|{
return|return
name|bang
return|;
block|}
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|method|getReturnValue ()
specifier|public
name|String
name|getReturnValue
parameter_list|()
block|{
return|return
name|returnValue
return|;
block|}
DECL|method|getVisibility ()
specifier|public
name|String
name|getVisibility
parameter_list|()
block|{
return|return
name|visibility
return|;
block|}
comment|/** If 'rule' narrows the visible of 'this', return true;      *  For example, 'this' is public and 'rule' is private,      *  true is returned.  You cannot narrow the vis. of      *  a rule.      */
DECL|method|narrowerVisibility (Rule rule)
specifier|public
name|boolean
name|narrowerVisibility
parameter_list|(
name|Rule
name|rule
parameter_list|)
block|{
if|if
condition|(
name|visibility
operator|.
name|equals
argument_list|(
literal|"public"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rule
operator|.
name|equals
argument_list|(
literal|"public"
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
comment|// everything narrower than public
block|}
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|visibility
operator|.
name|equals
argument_list|(
literal|"protected"
argument_list|)
condition|)
block|{
if|if
condition|(
name|rule
operator|.
name|equals
argument_list|(
literal|"private"
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
comment|// private narrower than protected
block|}
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|visibility
operator|.
name|equals
argument_list|(
literal|"private"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
comment|// nothing is narrower than private
block|}
return|return
literal|false
return|;
block|}
comment|/** Two rules have the same signature if they have:      *  	same name      *		same return value      *		same args      *	I do a simple string compare now, but later      *	the type could be pulled out so it is insensitive      *	to names of args etc...      */
DECL|method|sameSignature (Rule rule)
specifier|public
name|boolean
name|sameSignature
parameter_list|(
name|Rule
name|rule
parameter_list|)
block|{
name|boolean
name|nSame
init|=
literal|true
decl_stmt|;
name|boolean
name|aSame
init|=
literal|true
decl_stmt|;
name|boolean
name|rSame
init|=
literal|true
decl_stmt|;
name|nSame
operator|=
name|name
operator|.
name|equals
argument_list|(
name|rule
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|!=
literal|null
condition|)
block|{
name|aSame
operator|=
name|args
operator|.
name|equals
argument_list|(
name|rule
operator|.
name|getArgs
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|returnValue
operator|!=
literal|null
condition|)
block|{
name|rSame
operator|=
name|returnValue
operator|.
name|equals
argument_list|(
name|rule
operator|.
name|getReturnValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|nSame
operator|&&
name|aSame
operator|&&
name|rSame
return|;
block|}
DECL|method|setArgs (String a)
specifier|public
name|void
name|setArgs
parameter_list|(
name|String
name|a
parameter_list|)
block|{
name|args
operator|=
name|a
expr_stmt|;
block|}
DECL|method|setBang ()
specifier|public
name|void
name|setBang
parameter_list|()
block|{
name|bang
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|setEnclosingGrammar (Grammar g)
specifier|public
name|void
name|setEnclosingGrammar
parameter_list|(
name|Grammar
name|g
parameter_list|)
block|{
name|enclosingGrammar
operator|=
name|g
expr_stmt|;
block|}
DECL|method|setInitAction (String a)
specifier|public
name|void
name|setInitAction
parameter_list|(
name|String
name|a
parameter_list|)
block|{
name|initAction
operator|=
name|a
expr_stmt|;
block|}
DECL|method|setOptions (IndexedVector options)
specifier|public
name|void
name|setOptions
parameter_list|(
name|IndexedVector
name|options
parameter_list|)
block|{
name|this
operator|.
name|options
operator|=
name|options
expr_stmt|;
block|}
DECL|method|setReturnValue (String ret)
specifier|public
name|void
name|setReturnValue
parameter_list|(
name|String
name|ret
parameter_list|)
block|{
name|returnValue
operator|=
name|ret
expr_stmt|;
block|}
DECL|method|setThrowsSpec (String t)
specifier|public
name|void
name|setThrowsSpec
parameter_list|(
name|String
name|t
parameter_list|)
block|{
name|throwsSpec
operator|=
name|t
expr_stmt|;
block|}
DECL|method|setVisibility (String v)
specifier|public
name|void
name|setVisibility
parameter_list|(
name|String
name|v
parameter_list|)
block|{
name|visibility
operator|=
name|v
expr_stmt|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|s
init|=
literal|""
decl_stmt|;
name|String
name|retString
init|=
name|returnValue
operator|==
literal|null
condition|?
literal|""
else|:
literal|"returns "
operator|+
name|returnValue
decl_stmt|;
name|String
name|argString
init|=
name|args
operator|==
literal|null
condition|?
literal|""
else|:
name|args
decl_stmt|;
name|String
name|bang
init|=
name|getBang
argument_list|()
condition|?
literal|"!"
else|:
literal|""
decl_stmt|;
name|s
operator|+=
name|visibility
operator|==
literal|null
condition|?
literal|""
else|:
name|visibility
operator|+
literal|" "
expr_stmt|;
name|s
operator|+=
name|name
operator|+
name|bang
operator|+
name|argString
operator|+
literal|" "
operator|+
name|retString
operator|+
name|throwsSpec
expr_stmt|;
if|if
condition|(
name|options
operator|!=
literal|null
condition|)
block|{
name|s
operator|+=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
operator|+
literal|"options {"
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|options
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|s
operator|+=
operator|(
name|Option
operator|)
name|e
operator|.
name|nextElement
argument_list|()
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
expr_stmt|;
block|}
name|s
operator|+=
literal|"}"
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|initAction
operator|!=
literal|null
condition|)
block|{
name|s
operator|+=
name|initAction
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
expr_stmt|;
block|}
name|s
operator|+=
name|block
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
end_class

end_unit

