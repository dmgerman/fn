begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/RIGHTS.html  *  * $Id$  */
end_comment

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|Vector
import|;
end_import

begin_comment
comment|/**A Grammar holds a set of rules (which are stored  * in a symbol table).  Most of the time a grammar  * needs a code generator and an LLkAnalyzer too.  */
end_comment

begin_class
DECL|class|Grammar
specifier|public
specifier|abstract
class|class
name|Grammar
block|{
DECL|field|tool
specifier|protected
name|Tool
name|tool
decl_stmt|;
DECL|field|generator
specifier|protected
name|CodeGenerator
name|generator
decl_stmt|;
DECL|field|theLLkAnalyzer
specifier|protected
name|LLkGrammarAnalyzer
name|theLLkAnalyzer
decl_stmt|;
DECL|field|symbols
specifier|protected
name|Hashtable
name|symbols
decl_stmt|;
DECL|field|buildAST
specifier|protected
name|boolean
name|buildAST
init|=
literal|false
decl_stmt|;
DECL|field|analyzerDebug
specifier|protected
name|boolean
name|analyzerDebug
init|=
literal|false
decl_stmt|;
DECL|field|interactive
specifier|protected
name|boolean
name|interactive
init|=
literal|false
decl_stmt|;
DECL|field|superClass
specifier|protected
name|String
name|superClass
init|=
literal|null
decl_stmt|;
comment|/** The token manager associated with the grammar, if any. 	// The token manager is responsible for maintaining the set of valid tokens, and 	// is conceptually shared between the lexer and parser.  This may be either a 	// LexerGrammar or a ImportVocabTokenManager.     */
DECL|field|tokenManager
specifier|protected
name|TokenManager
name|tokenManager
decl_stmt|;
comment|/** The name of the export vocabulary...used to generate the output 	 *  token types interchange file. 	 */
DECL|field|exportVocab
specifier|protected
name|String
name|exportVocab
init|=
literal|null
decl_stmt|;
comment|/** The name of the import vocabulary.  "Initial conditions" 	 */
DECL|field|importVocab
specifier|protected
name|String
name|importVocab
init|=
literal|null
decl_stmt|;
comment|// Mapping from String keys to Token option values
DECL|field|options
specifier|protected
name|Hashtable
name|options
decl_stmt|;
comment|// Vector of RuleSymbol entries
DECL|field|rules
specifier|protected
name|Vector
name|rules
decl_stmt|;
DECL|field|preambleAction
specifier|protected
name|Token
name|preambleAction
init|=
operator|new
name|CommonToken
argument_list|(
name|Token
operator|.
name|INVALID_TYPE
argument_list|,
literal|""
argument_list|)
decl_stmt|;
DECL|field|className
specifier|protected
name|String
name|className
init|=
literal|null
decl_stmt|;
DECL|field|fileName
specifier|protected
name|String
name|fileName
init|=
literal|null
decl_stmt|;
DECL|field|classMemberAction
specifier|protected
name|Token
name|classMemberAction
init|=
operator|new
name|CommonToken
argument_list|(
name|Token
operator|.
name|INVALID_TYPE
argument_list|,
literal|""
argument_list|)
decl_stmt|;
DECL|field|hasSyntacticPredicate
specifier|protected
name|boolean
name|hasSyntacticPredicate
init|=
literal|false
decl_stmt|;
DECL|field|hasUserErrorHandling
specifier|protected
name|boolean
name|hasUserErrorHandling
init|=
literal|false
decl_stmt|;
comment|// max lookahead that can be attempted for this parser.
DECL|field|maxk
specifier|protected
name|int
name|maxk
init|=
literal|1
decl_stmt|;
comment|// options
DECL|field|traceRules
specifier|protected
name|boolean
name|traceRules
init|=
literal|false
decl_stmt|;
DECL|field|debuggingOutput
specifier|protected
name|boolean
name|debuggingOutput
init|=
literal|false
decl_stmt|;
DECL|field|defaultErrorHandler
specifier|protected
name|boolean
name|defaultErrorHandler
init|=
literal|true
decl_stmt|;
DECL|field|comment
specifier|protected
name|String
name|comment
init|=
literal|null
decl_stmt|;
comment|// javadoc comment
DECL|method|Grammar (String className_, Tool tool_, String superClass)
specifier|public
name|Grammar
parameter_list|(
name|String
name|className_
parameter_list|,
name|Tool
name|tool_
parameter_list|,
name|String
name|superClass
parameter_list|)
block|{
name|className
operator|=
name|className_
expr_stmt|;
name|tool
operator|=
name|tool_
expr_stmt|;
name|symbols
operator|=
operator|new
name|Hashtable
argument_list|()
expr_stmt|;
name|options
operator|=
operator|new
name|Hashtable
argument_list|()
expr_stmt|;
name|rules
operator|=
operator|new
name|Vector
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|this
operator|.
name|superClass
operator|=
name|superClass
expr_stmt|;
block|}
comment|/** Define a rule */
DECL|method|define (RuleSymbol rs)
specifier|public
name|void
name|define
parameter_list|(
name|RuleSymbol
name|rs
parameter_list|)
block|{
name|rules
operator|.
name|appendElement
argument_list|(
name|rs
argument_list|)
expr_stmt|;
comment|// add the symbol to the rules hash table
name|symbols
operator|.
name|put
argument_list|(
name|rs
operator|.
name|getId
argument_list|()
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
comment|/** Top-level call to generate the code for this grammar */
DECL|method|generate ()
specifier|public
specifier|abstract
name|void
name|generate
parameter_list|()
throws|throws
name|IOException
function_decl|;
DECL|method|getClassName ()
specifier|protected
name|String
name|getClassName
parameter_list|()
block|{
return|return
name|className
return|;
block|}
comment|/* Does this grammar have a default error handler? */
DECL|method|getDefaultErrorHandler ()
specifier|public
name|boolean
name|getDefaultErrorHandler
parameter_list|()
block|{
return|return
name|defaultErrorHandler
return|;
block|}
DECL|method|getFilename ()
specifier|public
name|String
name|getFilename
parameter_list|()
block|{
return|return
name|fileName
return|;
block|}
comment|/** Get an integer option.  Given the name of the option find its       * associated integer value.  If the associated value is not an integer or      * is not in the table, then throw an exception of type NumberFormatException.      * @param key The name of the option      * @return The value associated with the key.      */
DECL|method|getIntegerOption (String key)
specifier|public
name|int
name|getIntegerOption
parameter_list|(
name|String
name|key
parameter_list|)
throws|throws
name|NumberFormatException
block|{
name|Token
name|t
init|=
operator|(
name|Token
operator|)
name|options
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|null
operator|||
name|t
operator|.
name|getType
argument_list|()
operator|!=
name|ANTLRTokenTypes
operator|.
name|INT
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|()
throw|;
block|}
else|else
block|{
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|t
operator|.
name|getText
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/** Get an option.  Given the name of the option find its associated value.      * @param key The name of the option      * @return The value associated with the key, or null if the key has not been set.      */
DECL|method|getOption (String key)
specifier|public
name|Token
name|getOption
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
operator|(
name|Token
operator|)
name|options
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|// Get name of class from which generated parser/lexer inherits
DECL|method|getSuperClass ()
specifier|protected
specifier|abstract
name|String
name|getSuperClass
parameter_list|()
function_decl|;
DECL|method|getSymbol (String s)
specifier|public
name|GrammarSymbol
name|getSymbol
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
operator|(
name|GrammarSymbol
operator|)
name|symbols
operator|.
name|get
argument_list|(
name|s
argument_list|)
return|;
block|}
DECL|method|getSymbols ()
specifier|public
name|Enumeration
name|getSymbols
parameter_list|()
block|{
return|return
name|symbols
operator|.
name|elements
argument_list|()
return|;
block|}
comment|/** Check the existence of an option in the table 	 * @param key The name of the option 	 * @return true if the option is in the table 	 */
DECL|method|hasOption (String key)
specifier|public
name|boolean
name|hasOption
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|options
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/** Is a rule symbol defined? (not used for tokens) */
DECL|method|isDefined (String s)
specifier|public
name|boolean
name|isDefined
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|symbols
operator|.
name|containsKey
argument_list|(
name|s
argument_list|)
return|;
block|}
comment|/**Process command line arguments.  Implemented in subclasses */
DECL|method|processArguments (String[] args)
specifier|public
specifier|abstract
name|void
name|processArguments
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
function_decl|;
DECL|method|setCodeGenerator (CodeGenerator gen)
specifier|public
name|void
name|setCodeGenerator
parameter_list|(
name|CodeGenerator
name|gen
parameter_list|)
block|{
name|generator
operator|=
name|gen
expr_stmt|;
block|}
DECL|method|setFilename (String s)
specifier|public
name|void
name|setFilename
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|fileName
operator|=
name|s
expr_stmt|;
block|}
DECL|method|setGrammarAnalyzer (LLkGrammarAnalyzer a)
specifier|public
name|void
name|setGrammarAnalyzer
parameter_list|(
name|LLkGrammarAnalyzer
name|a
parameter_list|)
block|{
name|theLLkAnalyzer
operator|=
name|a
expr_stmt|;
block|}
comment|/** Set a generic option. 	 * This associates a generic option key with a Token value. 	 * No validation is performed by this method, although users of the value 	 * (code generation and/or analysis) may require certain formats. 	 * The value is stored as a token so that the location of an error 	 * can be reported. 	 * @param key The name of the option. 	 * @param value The value to associate with the key. 	 * @return true if the option was a valid generic grammar option, false o/w 	 */
DECL|method|setOption (String key, Token value)
specifier|public
name|boolean
name|setOption
parameter_list|(
name|String
name|key
parameter_list|,
name|Token
name|value
parameter_list|)
block|{
name|options
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|String
name|s
init|=
name|value
operator|.
name|getText
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"k"
argument_list|)
condition|)
block|{
try|try
block|{
name|maxk
operator|=
name|getIntegerOption
argument_list|(
literal|"k"
argument_list|)
expr_stmt|;
comment|//System.out.println("setting lookahead to " + maxk);
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"option 'k' must be an integer (was "
operator|+
name|value
operator|.
name|getText
argument_list|()
operator|+
literal|")"
argument_list|,
name|getFilename
argument_list|()
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"codeGenMakeSwitchThreshold"
argument_list|)
condition|)
block|{
try|try
block|{
name|i
operator|=
name|getIntegerOption
argument_list|(
literal|"codeGenMakeSwitchThreshold"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"option 'codeGenMakeSwitchThreshold' must be an integer"
argument_list|,
name|getFilename
argument_list|()
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"codeGenBitsetTestThreshold"
argument_list|)
condition|)
block|{
try|try
block|{
name|i
operator|=
name|getIntegerOption
argument_list|(
literal|"codeGenBitsetTestThreshold"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"option 'codeGenBitsetTestThreshold' must be an integer"
argument_list|,
name|getFilename
argument_list|()
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"defaultErrorHandler"
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|defaultErrorHandler
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|defaultErrorHandler
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"Value for defaultErrorHandler must be true or false"
argument_list|,
name|getFilename
argument_list|()
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"analyzerDebug"
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|analyzerDebug
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|analyzerDebug
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"option 'analyzerDebug' must be true or false"
argument_list|,
name|getFilename
argument_list|()
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"codeGenDebug"
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|analyzerDebug
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|analyzerDebug
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"option 'codeGenDebug' must be true or false"
argument_list|,
name|getFilename
argument_list|()
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"classHeaderSuffix"
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"namespaceAntlr"
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"namespaceStd"
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"genHashLines"
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|setTokenManager (TokenManager tokenManager_)
specifier|public
name|void
name|setTokenManager
parameter_list|(
name|TokenManager
name|tokenManager_
parameter_list|)
block|{
name|tokenManager
operator|=
name|tokenManager_
expr_stmt|;
block|}
comment|/** Print out the grammar without actions */
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|(
literal|20000
argument_list|)
decl_stmt|;
name|Enumeration
name|ids
init|=
name|rules
operator|.
name|elements
argument_list|()
decl_stmt|;
while|while
condition|(
name|ids
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|ids
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|id
operator|.
name|equals
argument_list|(
literal|"mnextToken"
argument_list|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|rs
operator|.
name|getBlock
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

