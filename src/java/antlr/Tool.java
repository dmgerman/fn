begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/RIGHTS.html  *  * $Id$  */
end_comment

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|Vector
import|;
end_import

begin_class
DECL|class|Tool
specifier|public
class|class
name|Tool
block|{
DECL|field|version
specifier|public
specifier|static
specifier|final
name|String
name|version
init|=
literal|"2.7.1"
decl_stmt|;
comment|/** Object that handles analysis errors */
DECL|field|errorHandler
name|ToolErrorHandler
name|errorHandler
decl_stmt|;
comment|/** Was there an error during parsing or analysis? */
DECL|field|hasError
specifier|protected
name|boolean
name|hasError
init|=
literal|false
decl_stmt|;
comment|/** Generate diagnostics? (vs code) */
DECL|field|genDiagnostics
name|boolean
name|genDiagnostics
init|=
literal|false
decl_stmt|;
comment|/** Generate HTML vs code? */
DECL|field|genHTML
name|boolean
name|genHTML
init|=
literal|false
decl_stmt|;
comment|/** Current output directory for generated files */
DECL|field|outputDir
specifier|protected
specifier|static
name|String
name|outputDir
init|=
literal|"."
decl_stmt|;
comment|// Grammar input
DECL|field|grammarFile
name|String
name|grammarFile
decl_stmt|;
DECL|field|f
specifier|transient
name|Reader
name|f
init|=
operator|new
name|InputStreamReader
argument_list|(
name|System
operator|.
name|in
argument_list|)
decl_stmt|;
comment|// SAS: changed for proper text io
comment|//	transient DataInputStream in = null;
DECL|field|literalsPrefix
specifier|protected
specifier|static
name|String
name|literalsPrefix
init|=
literal|"LITERAL_"
decl_stmt|;
DECL|field|upperCaseMangledLiterals
specifier|protected
specifier|static
name|boolean
name|upperCaseMangledLiterals
init|=
literal|false
decl_stmt|;
comment|/** C++ file level options */
DECL|field|nameSpace
specifier|protected
specifier|static
name|NameSpace
name|nameSpace
init|=
literal|null
decl_stmt|;
DECL|field|namespaceAntlr
specifier|protected
specifier|static
name|String
name|namespaceAntlr
init|=
literal|null
decl_stmt|;
DECL|field|namespaceStd
specifier|protected
specifier|static
name|String
name|namespaceStd
init|=
literal|null
decl_stmt|;
DECL|field|genHashLines
specifier|protected
specifier|static
name|boolean
name|genHashLines
init|=
literal|true
decl_stmt|;
DECL|field|cmdLineArgValid
specifier|private
specifier|static
name|BitSet
name|cmdLineArgValid
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
comment|/** Construct a new Tool. */
DECL|method|Tool ()
specifier|public
name|Tool
parameter_list|()
block|{
name|errorHandler
operator|=
operator|new
name|DefaultToolErrorHandler
argument_list|()
expr_stmt|;
block|}
DECL|method|setFileLineFormatter (FileLineFormatter formatter)
specifier|public
specifier|static
name|void
name|setFileLineFormatter
parameter_list|(
name|FileLineFormatter
name|formatter
parameter_list|)
block|{
name|FileLineFormatter
operator|.
name|setFormatter
argument_list|(
name|formatter
argument_list|)
expr_stmt|;
block|}
DECL|method|checkForInvalidArguments (String[] args, BitSet cmdLineArgValid)
specifier|private
specifier|static
name|void
name|checkForInvalidArguments
parameter_list|(
name|String
index|[]
name|args
parameter_list|,
name|BitSet
name|cmdLineArgValid
parameter_list|)
block|{
comment|// check for invalid command line args
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|args
operator|.
name|length
condition|;
name|a
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|cmdLineArgValid
operator|.
name|member
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"invalid command-line argument: "
operator|+
name|args
index|[
name|a
index|]
operator|+
literal|"; ignored"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** This example is from the book _Java in a Nutshell_ by David      * Flanagan.  Written by David Flanagan.  Copyright (c) 1996      * O'Reilly& Associates.  You may study, use, modify, and      * distribute this example for any purpose.  This example is      * provided WITHOUT WARRANTY either expressed or implied.  */
DECL|method|copyFile (String source_name, String dest_name)
specifier|public
specifier|static
name|void
name|copyFile
parameter_list|(
name|String
name|source_name
parameter_list|,
name|String
name|dest_name
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|source_file
init|=
operator|new
name|File
argument_list|(
name|source_name
argument_list|)
decl_stmt|;
name|File
name|destination_file
init|=
operator|new
name|File
argument_list|(
name|dest_name
argument_list|)
decl_stmt|;
name|FileReader
name|source
init|=
literal|null
decl_stmt|;
comment|// SAS: changed for proper text io
name|FileWriter
name|destination
init|=
literal|null
decl_stmt|;
name|char
index|[]
name|buffer
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
try|try
block|{
comment|// First make sure the specified source file
comment|// exists, is a file, and is readable.
if|if
condition|(
operator|!
name|source_file
operator|.
name|exists
argument_list|()
operator|||
operator|!
name|source_file
operator|.
name|isFile
argument_list|()
condition|)
throw|throw
operator|new
name|FileCopyException
argument_list|(
literal|"FileCopy: no such source file: "
operator|+
name|source_name
argument_list|)
throw|;
if|if
condition|(
operator|!
name|source_file
operator|.
name|canRead
argument_list|()
condition|)
throw|throw
operator|new
name|FileCopyException
argument_list|(
literal|"FileCopy: source file "
operator|+
literal|"is unreadable: "
operator|+
name|source_name
argument_list|)
throw|;
comment|// If the destination exists, make sure it is a writeable file
comment|// and ask before overwriting it.  If the destination doesn't
comment|// exist, make sure the directory exists and is writeable.
if|if
condition|(
name|destination_file
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|destination_file
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
name|System
operator|.
name|in
argument_list|)
decl_stmt|;
name|String
name|response
decl_stmt|;
if|if
condition|(
operator|!
name|destination_file
operator|.
name|canWrite
argument_list|()
condition|)
throw|throw
operator|new
name|FileCopyException
argument_list|(
literal|"FileCopy: destination "
operator|+
literal|"file is unwriteable: "
operator|+
name|dest_name
argument_list|)
throw|;
comment|/* 		      System.out.print("File " + dest_name + 		      " already exists.  Overwrite? (Y/N): "); 		      System.out.flush(); 		      response = in.readLine(); 		      if (!response.equals("Y")&& !response.equals("y")) 		      throw new FileCopyException("FileCopy: copy cancelled."); 		    */
block|}
else|else
block|{
throw|throw
operator|new
name|FileCopyException
argument_list|(
literal|"FileCopy: destination "
operator|+
literal|"is not a file: "
operator|+
name|dest_name
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|File
name|parentdir
init|=
name|parent
argument_list|(
name|destination_file
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parentdir
operator|.
name|exists
argument_list|()
condition|)
throw|throw
operator|new
name|FileCopyException
argument_list|(
literal|"FileCopy: destination "
operator|+
literal|"directory doesn't exist: "
operator|+
name|dest_name
argument_list|)
throw|;
if|if
condition|(
operator|!
name|parentdir
operator|.
name|canWrite
argument_list|()
condition|)
throw|throw
operator|new
name|FileCopyException
argument_list|(
literal|"FileCopy: destination "
operator|+
literal|"directory is unwriteable: "
operator|+
name|dest_name
argument_list|)
throw|;
block|}
comment|// If we've gotten this far, then everything is okay; we can
comment|// copy the file.
name|source
operator|=
operator|new
name|FileReader
argument_list|(
name|source_file
argument_list|)
expr_stmt|;
name|destination
operator|=
operator|new
name|FileWriter
argument_list|(
name|destination_file
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|new
name|char
index|[
literal|1024
index|]
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|bytes_read
operator|=
name|source
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|==
operator|-
literal|1
condition|)
break|break;
name|destination
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
block|}
block|}
comment|// No matter what happens, always close any streams we've opened.
finally|finally
block|{
if|if
condition|(
name|source
operator|!=
literal|null
condition|)
try|try
block|{
name|source
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
empty_stmt|;
block|}
if|if
condition|(
name|destination
operator|!=
literal|null
condition|)
try|try
block|{
name|destination
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
empty_stmt|;
block|}
block|}
block|}
comment|/** Perform processing on the grammar file.  Can only be called      * from main() @param args The command-line arguments passed to      * main()      */
DECL|method|doEverything (String[] args)
specifier|protected
name|void
name|doEverything
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
comment|// SAS: removed "private" so subclass can call
comment|//      (The subclass is for the VAJ interface)
comment|// run the preprocessor to handle inheritance first.
name|antlr
operator|.
name|preprocessor
operator|.
name|Tool
name|preTool
init|=
operator|new
name|antlr
operator|.
name|preprocessor
operator|.
name|Tool
argument_list|(
name|this
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|preTool
operator|.
name|preprocess
argument_list|()
condition|)
block|{
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
name|modifiedArgs
init|=
name|preTool
operator|.
name|preprocessedArgList
argument_list|()
decl_stmt|;
comment|// process arguments for the Tool
name|processArguments
argument_list|(
name|modifiedArgs
argument_list|)
expr_stmt|;
name|f
operator|=
name|getGrammarReader
argument_list|()
expr_stmt|;
name|TokenBuffer
name|tokenBuf
init|=
operator|new
name|TokenBuffer
argument_list|(
operator|new
name|ANTLRLexer
argument_list|(
name|f
argument_list|)
argument_list|)
decl_stmt|;
name|LLkAnalyzer
name|analyzer
init|=
operator|new
name|LLkAnalyzer
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|MakeGrammar
name|behavior
init|=
operator|new
name|MakeGrammar
argument_list|(
name|this
argument_list|,
name|args
argument_list|,
name|analyzer
argument_list|)
decl_stmt|;
try|try
block|{
name|ANTLRParser
name|p
init|=
operator|new
name|ANTLRParser
argument_list|(
name|tokenBuf
argument_list|,
name|behavior
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|p
operator|.
name|setFilename
argument_list|(
name|grammarFile
argument_list|)
expr_stmt|;
name|p
operator|.
name|grammar
argument_list|()
expr_stmt|;
if|if
condition|(
name|hasError
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Exiting due to errors."
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|checkForInvalidArguments
argument_list|(
name|modifiedArgs
argument_list|,
name|cmdLineArgValid
argument_list|)
expr_stmt|;
comment|// Create the right code generator according to the "language" option
name|CodeGenerator
name|codeGen
decl_stmt|;
comment|// SAS: created getLanguage() method so subclass can override
comment|//      (necessary for VAJ interface)
name|String
name|codeGenClassName
init|=
literal|"antlr."
operator|+
name|getLanguage
argument_list|(
name|behavior
argument_list|)
operator|+
literal|"CodeGenerator"
decl_stmt|;
try|try
block|{
name|Class
name|codeGenClass
init|=
name|Class
operator|.
name|forName
argument_list|(
name|codeGenClassName
argument_list|)
decl_stmt|;
name|codeGen
operator|=
operator|(
name|CodeGenerator
operator|)
name|codeGenClass
operator|.
name|newInstance
argument_list|()
expr_stmt|;
name|codeGen
operator|.
name|setBehavior
argument_list|(
name|behavior
argument_list|)
expr_stmt|;
name|codeGen
operator|.
name|setAnalyzer
argument_list|(
name|analyzer
argument_list|)
expr_stmt|;
name|codeGen
operator|.
name|setTool
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|codeGen
operator|.
name|gen
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cnfe
parameter_list|)
block|{
name|panic
argument_list|(
literal|"Cannot instantiate code-generator: "
operator|+
name|codeGenClassName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|ie
parameter_list|)
block|{
name|panic
argument_list|(
literal|"Cannot instantiate code-generator: "
operator|+
name|codeGenClassName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ie
parameter_list|)
block|{
name|panic
argument_list|(
literal|"Cannot instantiate code-generator: "
operator|+
name|codeGenClassName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|iae
parameter_list|)
block|{
name|panic
argument_list|(
literal|"code-generator class '"
operator|+
name|codeGenClassName
operator|+
literal|"' is not accessible"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RecognitionException
name|pe
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Unhandled parser error: "
operator|+
name|pe
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TokenStreamException
name|io
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"TokenStreamException: "
operator|+
name|io
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/** Issue an error      * @param s The message      */
DECL|method|error (String s)
specifier|public
name|void
name|error
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|hasError
operator|=
literal|true
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"error: "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
comment|/** Issue an error with line number information      * @param s The message      * @param file The file that has the error      * @param line The grammar file line number on which the error occured      */
DECL|method|error (String s, String file, int line)
specifier|public
name|void
name|error
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|hasError
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|FileLineFormatter
operator|.
name|getFormatter
argument_list|()
operator|.
name|getFormatString
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"line "
operator|+
name|line
operator|+
literal|": "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** When we are 1.1 compatible... public static Object factory2 (String p, Object[] initargs) {   Class c;   Object o = null;   try { 	int argslen = initargs.length; 	Class cl[] = new Class[argslen]; 	for (int i=0;i&lt;argslen;i++) { 	  cl[i] = Class.forName(initargs[i].getClass().getName()); 	} 	c = Class.forName (p); 	Constructor con = c.getConstructor (cl); 	o = con.newInstance (initargs);   } catch (Exception e) { 	System.err.println ("Can't make a " + p);   }   return o; } */
DECL|method|factory (String p)
specifier|public
specifier|static
name|Object
name|factory
parameter_list|(
name|String
name|p
parameter_list|)
block|{
name|Class
name|c
decl_stmt|;
name|Object
name|o
init|=
literal|null
decl_stmt|;
try|try
block|{
name|c
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// get class def
name|o
operator|=
name|c
operator|.
name|newInstance
argument_list|()
expr_stmt|;
comment|// make a new one
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// either class not found,
comment|// class is interface/abstract, or
comment|// class or initializer is not accessible.
name|warning
argument_list|(
literal|"Can't create an object of type "
operator|+
name|p
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|o
return|;
block|}
DECL|method|fileMinusPath (String f)
specifier|public
specifier|static
name|String
name|fileMinusPath
parameter_list|(
name|String
name|f
parameter_list|)
block|{
name|String
name|separator
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
decl_stmt|;
name|int
name|endOfPath
init|=
name|f
operator|.
name|lastIndexOf
argument_list|(
name|separator
argument_list|)
decl_stmt|;
if|if
condition|(
name|endOfPath
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|f
return|;
comment|// no path found
block|}
return|return
name|f
operator|.
name|substring
argument_list|(
name|endOfPath
operator|+
literal|1
argument_list|)
return|;
block|}
comment|/** Determine the language used for this run of ANTLR      *  This was made a method so the subclass can override it      */
DECL|method|getLanguage (MakeGrammar behavior)
specifier|public
name|String
name|getLanguage
parameter_list|(
name|MakeGrammar
name|behavior
parameter_list|)
block|{
if|if
condition|(
name|genDiagnostics
condition|)
block|{
return|return
literal|"Diagnostic"
return|;
block|}
if|if
condition|(
name|genHTML
condition|)
block|{
return|return
literal|"HTML"
return|;
block|}
return|return
name|behavior
operator|.
name|language
return|;
block|}
DECL|method|getOutputDirectory ()
specifier|public
specifier|static
name|String
name|getOutputDirectory
parameter_list|()
block|{
return|return
name|outputDir
return|;
block|}
DECL|method|help ()
specifier|private
specifier|static
name|void
name|help
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"usage: java antlr.Tool [args] file.g"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -o outputDir       specify output directory where all output generated."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -glib superGrammar specify location of supergrammar file."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -debug             launch the ParseView debugger upon parser invocation."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -html              generate an html file from your grammar (minus actions)."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -diagnostic        generate a textfile with diagnostics."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -trace             have all rules call traceIn/traceOut."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -traceParser       have parser rules call traceIn/traceOut."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -traceLexer        have lexer rules call traceIn/traceOut."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -traceTreeParser   have tree parser rules call traceIn/traceOut."
argument_list|)
expr_stmt|;
block|}
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"ANTLR Parser Generator   Version "
operator|+
name|Tool
operator|.
name|version
operator|+
literal|"   1989-2000 jGuru.com"
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|help
argument_list|()
expr_stmt|;
block|}
name|Tool
name|theTool
init|=
operator|new
name|Tool
argument_list|()
decl_stmt|;
name|theTool
operator|.
name|doEverything
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|theTool
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"#$%%*&@# internal error: "
operator|+
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"[complain to nearest government official"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" or send hate-mail to parrt@jguru.com;"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" please send stack trace with report.]"
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|openOutputFile (String f)
specifier|public
specifier|static
name|PrintWriter
name|openOutputFile
parameter_list|(
name|String
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|PrintWriter
argument_list|(
operator|new
name|FileWriter
argument_list|(
name|outputDir
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
operator|+
name|f
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getGrammarReader ()
specifier|public
name|Reader
name|getGrammarReader
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|grammarFile
operator|!=
literal|null
condition|)
block|{
name|f
operator|=
operator|new
name|FileReader
argument_list|(
name|grammarFile
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|panic
argument_list|(
literal|"Error: cannot open grammar file "
operator|+
name|grammarFile
argument_list|)
expr_stmt|;
name|help
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
comment|/** Issue an unknown fatal error */
DECL|method|panic ()
specifier|public
specifier|static
name|void
name|panic
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"panic"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/** Issue a fatal error message      * @param s The message      */
DECL|method|panic (String s)
specifier|public
specifier|static
name|void
name|panic
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"panic: "
operator|+
name|s
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// File.getParent() can return null when the file is specified without
comment|// a directory or is in the root directory.
comment|// This method handles those cases.
DECL|method|parent (File f)
specifier|public
specifier|static
name|File
name|parent
parameter_list|(
name|File
name|f
parameter_list|)
block|{
name|String
name|dirname
init|=
name|f
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|dirname
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|f
operator|.
name|isAbsolute
argument_list|()
condition|)
return|return
operator|new
name|File
argument_list|(
name|File
operator|.
name|separator
argument_list|)
return|;
else|else
return|return
operator|new
name|File
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.dir"
argument_list|)
argument_list|)
return|;
block|}
return|return
operator|new
name|File
argument_list|(
name|dirname
argument_list|)
return|;
block|}
comment|/** Parse a list such as "f1.g;f2.g;..." and return a Vector      *  of the elements.      */
DECL|method|parseSeparatedList (String list, char separator)
specifier|public
specifier|static
name|Vector
name|parseSeparatedList
parameter_list|(
name|String
name|list
parameter_list|,
name|char
name|separator
parameter_list|)
block|{
name|Vector
name|v
init|=
operator|new
name|Vector
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|list
operator|.
name|length
argument_list|()
condition|)
block|{
while|while
condition|(
name|i
operator|<
name|list
operator|.
name|length
argument_list|()
operator|&&
name|list
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|!=
name|separator
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|list
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|// add element to vector
name|v
operator|.
name|appendElement
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// must be a separator or finished.
if|if
condition|(
name|i
operator|<
name|list
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// not done?
name|i
operator|++
expr_stmt|;
comment|// skip separator
block|}
block|}
if|if
condition|(
name|v
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
return|return
name|v
return|;
block|}
comment|/** given a filename, strip off the directory prefix (if any)      *  and return it.  Return "./" if f has no dir prefix.      */
DECL|method|pathToFile (String f)
specifier|public
specifier|static
name|String
name|pathToFile
parameter_list|(
name|String
name|f
parameter_list|)
block|{
name|String
name|separator
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
decl_stmt|;
name|int
name|endOfPath
init|=
name|f
operator|.
name|lastIndexOf
argument_list|(
name|separator
argument_list|)
decl_stmt|;
if|if
condition|(
name|endOfPath
operator|==
operator|-
literal|1
condition|)
block|{
comment|// no path, use current directory
return|return
literal|"."
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
return|;
block|}
return|return
name|f
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|endOfPath
operator|+
literal|1
argument_list|)
return|;
block|}
comment|/** Process the command-line arguments.  Can only be called by Tool.      * @param args The command-line arguments passed to main()      */
DECL|method|processArguments (String[] args)
specifier|private
name|void
name|processArguments
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-diagnostic"
argument_list|)
condition|)
block|{
name|genDiagnostics
operator|=
literal|true
expr_stmt|;
name|genHTML
operator|=
literal|false
expr_stmt|;
name|Tool
operator|.
name|setArgOK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-o"
argument_list|)
condition|)
block|{
name|Tool
operator|.
name|setArgOK
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|args
operator|.
name|length
condition|)
block|{
name|error
argument_list|(
literal|"missing output directory with -o option; ignoring"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|++
expr_stmt|;
name|setOutputDirectory
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Tool
operator|.
name|setArgOK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-html"
argument_list|)
condition|)
block|{
name|genHTML
operator|=
literal|true
expr_stmt|;
name|genDiagnostics
operator|=
literal|false
expr_stmt|;
name|Tool
operator|.
name|setArgOK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'-'
condition|)
block|{
comment|// Must be the grammar file
name|grammarFile
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
name|Tool
operator|.
name|setArgOK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|method|setArgOK (int i)
specifier|public
specifier|static
name|void
name|setArgOK
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|cmdLineArgValid
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
DECL|method|setOutputDirectory (String o)
specifier|public
specifier|static
name|void
name|setOutputDirectory
parameter_list|(
name|String
name|o
parameter_list|)
block|{
name|outputDir
operator|=
name|o
expr_stmt|;
block|}
comment|/** General-purpose utility function for removing      * characters from back of string      * @param s The string to process      * @param c The character to remove      * @return The resulting string      */
DECL|method|stripBack (String s, char c)
specifier|static
specifier|public
name|String
name|stripBack
parameter_list|(
name|String
name|s
parameter_list|,
name|char
name|c
parameter_list|)
block|{
while|while
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|s
operator|.
name|charAt
argument_list|(
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
name|c
condition|)
block|{
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/** General-purpose utility function for removing      * characters from back of string      * @param s The string to process      * @param remove A string containing the set of characters to remove      * @return The resulting string      */
DECL|method|stripBack (String s, String remove)
specifier|static
specifier|public
name|String
name|stripBack
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|remove
parameter_list|)
block|{
name|boolean
name|changed
decl_stmt|;
do|do
block|{
name|changed
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|remove
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|remove
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
while|while
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|s
operator|.
name|charAt
argument_list|(
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
name|c
condition|)
block|{
name|changed
operator|=
literal|true
expr_stmt|;
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|changed
condition|)
do|;
return|return
name|s
return|;
block|}
comment|/** General-purpose utility function for removing      * characters from front of string      * @param s The string to process      * @param c The character to remove      * @return The resulting string      */
DECL|method|stripFront (String s, char c)
specifier|static
specifier|public
name|String
name|stripFront
parameter_list|(
name|String
name|s
parameter_list|,
name|char
name|c
parameter_list|)
block|{
while|while
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|s
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|c
condition|)
block|{
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/** General-purpose utility function for removing      * characters from front of string      * @param s The string to process      * @param remove A string containing the set of characters to remove      * @return The resulting string      */
DECL|method|stripFront (String s, String remove)
specifier|static
specifier|public
name|String
name|stripFront
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|remove
parameter_list|)
block|{
name|boolean
name|changed
decl_stmt|;
do|do
block|{
name|changed
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|remove
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|remove
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
while|while
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|s
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|c
condition|)
block|{
name|changed
operator|=
literal|true
expr_stmt|;
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|changed
condition|)
do|;
return|return
name|s
return|;
block|}
comment|/** General-purpose utility function for removing      * characters from the front and back of string      * @param s The string to process      * @param head exact string to strip from head      * @param tail exact string to strip from tail      * @return The resulting string      */
DECL|method|stripFrontBack (String src, String head, String tail)
specifier|public
specifier|static
name|String
name|stripFrontBack
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|head
parameter_list|,
name|String
name|tail
parameter_list|)
block|{
name|int
name|h
init|=
name|src
operator|.
name|indexOf
argument_list|(
name|head
argument_list|)
decl_stmt|;
name|int
name|t
init|=
name|src
operator|.
name|lastIndexOf
argument_list|(
name|tail
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|==
operator|-
literal|1
operator|||
name|t
operator|==
operator|-
literal|1
condition|)
return|return
name|src
return|;
return|return
name|src
operator|.
name|substring
argument_list|(
name|h
operator|+
literal|1
argument_list|,
name|t
argument_list|)
return|;
block|}
comment|/** Issue an error; used for general tool errors not for grammar stuff      * @param s The message      */
DECL|method|toolError (String s)
specifier|public
specifier|static
name|void
name|toolError
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"error: "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
comment|/** Issue a warning      * @param s the message      */
DECL|method|warning (String s)
specifier|public
specifier|static
name|void
name|warning
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
comment|/** Issue a warning with line number information      * @param s The message      * @param file The file that has the warning      * @param line The grammar file line number on which the warning occured      */
DECL|method|warning (String s, String file, int line)
specifier|public
specifier|static
name|void
name|warning
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|FileLineFormatter
operator|.
name|getFormatter
argument_list|()
operator|.
name|getFormatString
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
operator|+
literal|"warning:"
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning; line "
operator|+
name|line
operator|+
literal|": "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Issue a warning with line number information      * @param s The lines of the message      * @param file The file that has the warning      * @param line The grammar file line number on which the warning occured      */
DECL|method|warning (String[] s, String file, int line)
specifier|public
specifier|static
name|void
name|warning
parameter_list|(
name|String
index|[]
name|s
parameter_list|,
name|String
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
literal|null
operator|||
name|s
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"bad multi-line message to Tool.warning"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|FileLineFormatter
operator|.
name|getFormatter
argument_list|()
operator|.
name|getFormatString
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
operator|+
literal|"warning:"
operator|+
name|s
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|s
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|FileLineFormatter
operator|.
name|getFormatter
argument_list|()
operator|.
name|getFormatString
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
operator|+
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: line "
operator|+
name|line
operator|+
literal|": "
operator|+
name|s
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|s
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: line "
operator|+
name|line
operator|+
literal|": "
operator|+
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Support C++ namespaces (for now).  Add a nested namespace name to the      * current namespace.      * DAW: David Wagner      */
DECL|method|setNameSpace (String name)
specifier|public
name|void
name|setNameSpace
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|nameSpace
condition|)
name|nameSpace
operator|=
operator|new
name|NameSpace
argument_list|(
name|stripFrontBack
argument_list|(
name|name
argument_list|,
literal|"\""
argument_list|,
literal|"\""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

