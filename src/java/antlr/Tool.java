begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/license.html  *  * $Id$  */
end_comment

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|PreservingFileWriter
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|Version
import|;
end_import

begin_class
DECL|class|Tool
specifier|public
class|class
name|Tool
block|{
DECL|field|version
specifier|public
specifier|static
name|String
name|version
init|=
literal|""
decl_stmt|;
comment|/** Object that handles analysis errors */
DECL|field|errorHandler
name|ToolErrorHandler
name|errorHandler
decl_stmt|;
comment|/** Was there an error during parsing or analysis? */
DECL|field|hasError
specifier|protected
name|boolean
name|hasError
init|=
literal|false
decl_stmt|;
comment|/** Generate diagnostics? (vs code) */
DECL|field|genDiagnostics
name|boolean
name|genDiagnostics
init|=
literal|false
decl_stmt|;
comment|/** Generate DocBook vs code? */
DECL|field|genDocBook
name|boolean
name|genDocBook
init|=
literal|false
decl_stmt|;
comment|/** Generate HTML vs code? */
DECL|field|genHTML
name|boolean
name|genHTML
init|=
literal|false
decl_stmt|;
comment|/** Current output directory for generated files */
DECL|field|outputDir
specifier|protected
specifier|static
name|String
name|outputDir
init|=
literal|"."
decl_stmt|;
comment|// Grammar input
DECL|field|grammarFile
specifier|protected
name|String
name|grammarFile
decl_stmt|;
DECL|field|f
specifier|transient
name|Reader
name|f
init|=
operator|new
name|InputStreamReader
argument_list|(
name|System
operator|.
name|in
argument_list|)
decl_stmt|;
comment|// SAS: changed for proper text io
comment|//  transient DataInputStream in = null;
DECL|field|literalsPrefix
specifier|protected
specifier|static
name|String
name|literalsPrefix
init|=
literal|"LITERAL_"
decl_stmt|;
DECL|field|upperCaseMangledLiterals
specifier|protected
specifier|static
name|boolean
name|upperCaseMangledLiterals
init|=
literal|false
decl_stmt|;
comment|/** C++ file level options */
DECL|field|nameSpace
specifier|protected
name|NameSpace
name|nameSpace
init|=
literal|null
decl_stmt|;
DECL|field|namespaceAntlr
specifier|protected
name|String
name|namespaceAntlr
init|=
literal|null
decl_stmt|;
DECL|field|namespaceStd
specifier|protected
name|String
name|namespaceStd
init|=
literal|null
decl_stmt|;
DECL|field|genHashLines
specifier|protected
name|boolean
name|genHashLines
init|=
literal|true
decl_stmt|;
DECL|field|noConstructors
specifier|protected
name|boolean
name|noConstructors
init|=
literal|false
decl_stmt|;
DECL|field|cmdLineArgValid
specifier|private
name|BitSet
name|cmdLineArgValid
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
comment|/** Construct a new Tool. */
DECL|method|Tool ()
specifier|public
name|Tool
parameter_list|()
block|{
name|errorHandler
operator|=
operator|new
name|DefaultToolErrorHandler
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|getGrammarFile ()
specifier|public
name|String
name|getGrammarFile
parameter_list|()
block|{
return|return
name|grammarFile
return|;
block|}
DECL|method|hasError ()
specifier|public
name|boolean
name|hasError
parameter_list|()
block|{
return|return
name|hasError
return|;
block|}
DECL|method|getNameSpace ()
specifier|public
name|NameSpace
name|getNameSpace
parameter_list|()
block|{
return|return
name|nameSpace
return|;
block|}
DECL|method|getNamespaceStd ()
specifier|public
name|String
name|getNamespaceStd
parameter_list|()
block|{
return|return
name|namespaceStd
return|;
block|}
DECL|method|getNamespaceAntlr ()
specifier|public
name|String
name|getNamespaceAntlr
parameter_list|()
block|{
return|return
name|namespaceAntlr
return|;
block|}
DECL|method|getGenHashLines ()
specifier|public
name|boolean
name|getGenHashLines
parameter_list|()
block|{
return|return
name|genHashLines
return|;
block|}
DECL|method|getLiteralsPrefix ()
specifier|public
name|String
name|getLiteralsPrefix
parameter_list|()
block|{
return|return
name|literalsPrefix
return|;
block|}
DECL|method|getUpperCaseMangledLiterals ()
specifier|public
name|boolean
name|getUpperCaseMangledLiterals
parameter_list|()
block|{
return|return
name|upperCaseMangledLiterals
return|;
block|}
DECL|method|setFileLineFormatter (FileLineFormatter formatter)
specifier|public
name|void
name|setFileLineFormatter
parameter_list|(
name|FileLineFormatter
name|formatter
parameter_list|)
block|{
name|FileLineFormatter
operator|.
name|setFormatter
argument_list|(
name|formatter
argument_list|)
expr_stmt|;
block|}
DECL|method|checkForInvalidArguments (String[] args, BitSet cmdLineArgValid)
specifier|protected
name|void
name|checkForInvalidArguments
parameter_list|(
name|String
index|[]
name|args
parameter_list|,
name|BitSet
name|cmdLineArgValid
parameter_list|)
block|{
comment|// check for invalid command line args
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|args
operator|.
name|length
condition|;
name|a
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|cmdLineArgValid
operator|.
name|member
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"invalid command-line argument: "
operator|+
name|args
index|[
name|a
index|]
operator|+
literal|"; ignored"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** This example is from the book _Java in a Nutshell_ by David      * Flanagan.  Written by David Flanagan.  Copyright (c) 1996      * O'Reilly& Associates.  You may study, use, modify, and      * distribute this example for any purpose.  This example is      * provided WITHOUT WARRANTY either expressed or implied.  */
DECL|method|copyFile (String source_name, String dest_name)
specifier|public
name|void
name|copyFile
parameter_list|(
name|String
name|source_name
parameter_list|,
name|String
name|dest_name
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|source_file
init|=
operator|new
name|File
argument_list|(
name|source_name
argument_list|)
decl_stmt|;
name|File
name|destination_file
init|=
operator|new
name|File
argument_list|(
name|dest_name
argument_list|)
decl_stmt|;
name|Reader
name|source
init|=
literal|null
decl_stmt|;
name|Writer
name|destination
init|=
literal|null
decl_stmt|;
name|char
index|[]
name|buffer
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
try|try
block|{
comment|// First make sure the specified source file
comment|// exists, is a file, and is readable.
if|if
condition|(
operator|!
name|source_file
operator|.
name|exists
argument_list|()
operator|||
operator|!
name|source_file
operator|.
name|isFile
argument_list|()
condition|)
throw|throw
operator|new
name|FileCopyException
argument_list|(
literal|"FileCopy: no such source file: "
operator|+
name|source_name
argument_list|)
throw|;
if|if
condition|(
operator|!
name|source_file
operator|.
name|canRead
argument_list|()
condition|)
throw|throw
operator|new
name|FileCopyException
argument_list|(
literal|"FileCopy: source file "
operator|+
literal|"is unreadable: "
operator|+
name|source_name
argument_list|)
throw|;
comment|// If the destination exists, make sure it is a writeable file
comment|// and ask before overwriting it.  If the destination doesn't
comment|// exist, make sure the directory exists and is writeable.
if|if
condition|(
name|destination_file
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|destination_file
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
name|System
operator|.
name|in
argument_list|)
decl_stmt|;
name|String
name|response
decl_stmt|;
if|if
condition|(
operator|!
name|destination_file
operator|.
name|canWrite
argument_list|()
condition|)
throw|throw
operator|new
name|FileCopyException
argument_list|(
literal|"FileCopy: destination "
operator|+
literal|"file is unwriteable: "
operator|+
name|dest_name
argument_list|)
throw|;
comment|/*                       System.out.print("File " + dest_name +                       " already exists.  Overwrite? (Y/N): ");                       System.out.flush();                       response = in.readLine();                       if (!response.equals("Y")&& !response.equals("y"))                       throw new FileCopyException("FileCopy: copy cancelled.");                     */
block|}
else|else
block|{
throw|throw
operator|new
name|FileCopyException
argument_list|(
literal|"FileCopy: destination "
operator|+
literal|"is not a file: "
operator|+
name|dest_name
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|File
name|parentdir
init|=
name|parent
argument_list|(
name|destination_file
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parentdir
operator|.
name|exists
argument_list|()
condition|)
throw|throw
operator|new
name|FileCopyException
argument_list|(
literal|"FileCopy: destination "
operator|+
literal|"directory doesn't exist: "
operator|+
name|dest_name
argument_list|)
throw|;
if|if
condition|(
operator|!
name|parentdir
operator|.
name|canWrite
argument_list|()
condition|)
throw|throw
operator|new
name|FileCopyException
argument_list|(
literal|"FileCopy: destination "
operator|+
literal|"directory is unwriteable: "
operator|+
name|dest_name
argument_list|)
throw|;
block|}
comment|// If we've gotten this far, then everything is okay; we can
comment|// copy the file.
name|source
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|FileReader
argument_list|(
name|source_file
argument_list|)
argument_list|)
expr_stmt|;
name|destination
operator|=
operator|new
name|BufferedWriter
argument_list|(
operator|new
name|FileWriter
argument_list|(
name|destination_file
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|new
name|char
index|[
literal|1024
index|]
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|bytes_read
operator|=
name|source
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|==
operator|-
literal|1
condition|)
break|break;
name|destination
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
block|}
block|}
comment|// No matter what happens, always close any streams we've opened.
finally|finally
block|{
if|if
condition|(
name|source
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|source
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
empty_stmt|;
block|}
block|}
if|if
condition|(
name|destination
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|destination
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
empty_stmt|;
block|}
block|}
block|}
block|}
comment|/** Perform processing on the grammar file.  Can only be called      * from main() @param args The command-line arguments passed to      * main().  This wrapper does the System.exit for use with command-line.      */
DECL|method|doEverythingWrapper (String[] args)
specifier|public
name|void
name|doEverythingWrapper
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|int
name|exitCode
init|=
name|doEverything
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|System
operator|.
name|exit
argument_list|(
name|exitCode
argument_list|)
expr_stmt|;
block|}
comment|/** Process args and have ANTLR do it's stuff without calling System.exit.      *  Just return the result code.  Makes it easy for ANT build tool.      */
DECL|method|doEverything (String[] args)
specifier|public
name|int
name|doEverything
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
comment|// run the preprocessor to handle inheritance first.
comment|// Start preprocessor. This strips generates an argument list
comment|// without -glib options (inside preTool)
name|antlr
operator|.
name|preprocessor
operator|.
name|Tool
name|preTool
init|=
operator|new
name|antlr
operator|.
name|preprocessor
operator|.
name|Tool
argument_list|(
name|this
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|boolean
name|preprocess_ok
init|=
name|preTool
operator|.
name|preprocess
argument_list|()
decl_stmt|;
name|String
index|[]
name|modifiedArgs
init|=
name|preTool
operator|.
name|preprocessedArgList
argument_list|()
decl_stmt|;
comment|// process arguments for the Tool
name|processArguments
argument_list|(
name|modifiedArgs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|preprocess_ok
condition|)
block|{
return|return
literal|1
return|;
block|}
name|f
operator|=
name|getGrammarReader
argument_list|()
expr_stmt|;
name|ANTLRLexer
name|lexer
init|=
operator|new
name|ANTLRLexer
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|TokenBuffer
name|tokenBuf
init|=
operator|new
name|TokenBuffer
argument_list|(
name|lexer
argument_list|)
decl_stmt|;
name|LLkAnalyzer
name|analyzer
init|=
operator|new
name|LLkAnalyzer
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|MakeGrammar
name|behavior
init|=
operator|new
name|MakeGrammar
argument_list|(
name|this
argument_list|,
name|args
argument_list|,
name|analyzer
argument_list|)
decl_stmt|;
try|try
block|{
name|ANTLRParser
name|p
init|=
operator|new
name|ANTLRParser
argument_list|(
name|tokenBuf
argument_list|,
name|behavior
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|p
operator|.
name|setFilename
argument_list|(
name|grammarFile
argument_list|)
expr_stmt|;
name|p
operator|.
name|grammar
argument_list|()
expr_stmt|;
if|if
condition|(
name|hasError
argument_list|()
condition|)
block|{
name|fatalError
argument_list|(
literal|"Exiting due to errors."
argument_list|)
expr_stmt|;
block|}
name|checkForInvalidArguments
argument_list|(
name|modifiedArgs
argument_list|,
name|cmdLineArgValid
argument_list|)
expr_stmt|;
comment|// Create the right code generator according to the "language" option
name|CodeGenerator
name|codeGen
decl_stmt|;
comment|// SAS: created getLanguage() method so subclass can override
comment|//      (necessary for VAJ interface)
name|String
name|codeGenClassName
init|=
literal|"antlr."
operator|+
name|getLanguage
argument_list|(
name|behavior
argument_list|)
operator|+
literal|"CodeGenerator"
decl_stmt|;
try|try
block|{
name|Class
name|codeGenClass
init|=
name|Class
operator|.
name|forName
argument_list|(
name|codeGenClassName
argument_list|)
decl_stmt|;
name|codeGen
operator|=
operator|(
name|CodeGenerator
operator|)
name|codeGenClass
operator|.
name|newInstance
argument_list|()
expr_stmt|;
name|codeGen
operator|.
name|setBehavior
argument_list|(
name|behavior
argument_list|)
expr_stmt|;
name|codeGen
operator|.
name|setAnalyzer
argument_list|(
name|analyzer
argument_list|)
expr_stmt|;
name|codeGen
operator|.
name|setTool
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|codeGen
operator|.
name|gen
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cnfe
parameter_list|)
block|{
name|panic
argument_list|(
literal|"Cannot instantiate code-generator: "
operator|+
name|codeGenClassName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|ie
parameter_list|)
block|{
name|panic
argument_list|(
literal|"Cannot instantiate code-generator: "
operator|+
name|codeGenClassName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ie
parameter_list|)
block|{
name|panic
argument_list|(
literal|"Cannot instantiate code-generator: "
operator|+
name|codeGenClassName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|iae
parameter_list|)
block|{
name|panic
argument_list|(
literal|"code-generator class '"
operator|+
name|codeGenClassName
operator|+
literal|"' is not accessible"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RecognitionException
name|pe
parameter_list|)
block|{
name|fatalError
argument_list|(
literal|"Unhandled parser error: "
operator|+
name|pe
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TokenStreamException
name|io
parameter_list|)
block|{
name|fatalError
argument_list|(
literal|"TokenStreamException: "
operator|+
name|io
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/** Issue an error      * @param s The message      */
DECL|method|error (String s)
specifier|public
name|void
name|error
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|hasError
operator|=
literal|true
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"error: "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
comment|/** Issue an error with line number information      * @param s The message      * @param file The file that has the error (or null)      * @param line The grammar file line number on which the error occured (or -1)      * @param column The grammar file column number on which the error occured (or -1)      */
DECL|method|error (String s, String file, int line, int column)
specifier|public
name|void
name|error
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|column
parameter_list|)
block|{
name|hasError
operator|=
literal|true
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|FileLineFormatter
operator|.
name|getFormatter
argument_list|()
operator|.
name|getFormatString
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
comment|/** When we are 1.1 compatible... public static Object factory2 (String p, Object[] initargs) {      Class c;      Object o = null;      try {      int argslen = initargs.length;      Class cl[] = new Class[argslen];      for (int i=0;i&lt;argslen;i++) {      cl[i] = Class.forName(initargs[i].getClass().getName());      }      c = Class.forName (p);      Constructor con = c.getConstructor (cl);      o = con.newInstance (initargs);      } catch (Exception e) {      System.err.println ("Can't make a " + p);      }      return o;      }      */
DECL|method|factory (String p)
specifier|public
name|Object
name|factory
parameter_list|(
name|String
name|p
parameter_list|)
block|{
name|Class
name|c
decl_stmt|;
name|Object
name|o
init|=
literal|null
decl_stmt|;
try|try
block|{
name|c
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// get class def
name|o
operator|=
name|c
operator|.
name|newInstance
argument_list|()
expr_stmt|;
comment|// make a new one
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// either class not found,
comment|// class is interface/abstract, or
comment|// class or initializer is not accessible.
name|warning
argument_list|(
literal|"Can't create an object of type "
operator|+
name|p
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|o
return|;
block|}
DECL|method|fileMinusPath (String f)
specifier|public
name|String
name|fileMinusPath
parameter_list|(
name|String
name|f
parameter_list|)
block|{
name|String
name|separator
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
decl_stmt|;
name|int
name|endOfPath
init|=
name|f
operator|.
name|lastIndexOf
argument_list|(
name|separator
argument_list|)
decl_stmt|;
if|if
condition|(
name|endOfPath
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|f
return|;
comment|// no path found
block|}
return|return
name|f
operator|.
name|substring
argument_list|(
name|endOfPath
operator|+
literal|1
argument_list|)
return|;
block|}
comment|/** Determine the language used for this run of ANTLR      *  This was made a method so the subclass can override it      */
DECL|method|getLanguage (MakeGrammar behavior)
specifier|public
name|String
name|getLanguage
parameter_list|(
name|MakeGrammar
name|behavior
parameter_list|)
block|{
if|if
condition|(
name|genDiagnostics
condition|)
block|{
return|return
literal|"Diagnostic"
return|;
block|}
if|if
condition|(
name|genHTML
condition|)
block|{
return|return
literal|"HTML"
return|;
block|}
if|if
condition|(
name|genDocBook
condition|)
block|{
return|return
literal|"DocBook"
return|;
block|}
return|return
name|behavior
operator|.
name|language
return|;
block|}
DECL|method|getOutputDirectory ()
specifier|public
name|String
name|getOutputDirectory
parameter_list|()
block|{
return|return
name|outputDir
return|;
block|}
DECL|method|help ()
specifier|private
specifier|static
name|void
name|help
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"usage: java antlr.Tool [args] file.g"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -o outputDir       specify output directory where all output generated."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -glib superGrammar specify location of supergrammar file."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -debug             launch the ParseView debugger upon parser invocation."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -html              generate a html file from your grammar."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -docbook           generate a docbook sgml file from your grammar."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -diagnostic        generate a textfile with diagnostics."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -trace             have all rules call traceIn/traceOut."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -traceLexer        have lexer rules call traceIn/traceOut."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -traceParser       have parser rules call traceIn/traceOut."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -traceTreeParser   have tree parser rules call traceIn/traceOut."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  -h|-help|--help    this message"
argument_list|)
expr_stmt|;
block|}
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"ANTLR Parser Generator   Version "
operator|+
name|Version
operator|.
name|project_version
operator|+
literal|"   1989-2004 jGuru.com"
argument_list|)
expr_stmt|;
name|version
operator|=
name|Version
operator|.
name|project_version
expr_stmt|;
try|try
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|help
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-h"
argument_list|)
operator|||
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-help"
argument_list|)
operator|||
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"--help"
argument_list|)
condition|)
block|{
name|help
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|Tool
name|theTool
init|=
operator|new
name|Tool
argument_list|()
decl_stmt|;
name|theTool
operator|.
name|doEverything
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|theTool
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"#$%%*&@# internal error: "
operator|+
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"[complain to nearest government official"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" or send hate-mail to parrt@jguru.com;"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" please send stack trace with report.]"
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/** This method is used by all code generators to create new output 	 * files. If the outputDir set by -o is not present it will be created here. 	 */
DECL|method|openOutputFile (String f)
specifier|public
name|PrintWriter
name|openOutputFile
parameter_list|(
name|String
name|f
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|outputDir
operator|!=
literal|"."
condition|)
block|{
name|File
name|out_dir
init|=
operator|new
name|File
argument_list|(
name|outputDir
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|out_dir
operator|.
name|exists
argument_list|()
condition|)
name|out_dir
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|PrintWriter
argument_list|(
operator|new
name|PreservingFileWriter
argument_list|(
name|outputDir
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
operator|+
name|f
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getGrammarReader ()
specifier|public
name|Reader
name|getGrammarReader
parameter_list|()
block|{
name|Reader
name|f
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|grammarFile
operator|!=
literal|null
condition|)
block|{
name|f
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|FileReader
argument_list|(
name|grammarFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|fatalError
argument_list|(
literal|"cannot open grammar file "
operator|+
name|grammarFile
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
comment|/** @since 2.7.2      */
DECL|method|reportException (Exception e, String message)
specifier|public
name|void
name|reportException
parameter_list|(
name|Exception
name|e
parameter_list|,
name|String
name|message
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|message
operator|==
literal|null
condition|?
name|e
operator|.
name|getMessage
argument_list|()
else|:
name|message
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** @since 2.7.2      */
DECL|method|reportProgress (String message)
specifier|public
name|void
name|reportProgress
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
comment|/** An error occured that should stop the Tool from doing any work.      *  The default implementation currently exits (via      *  {@link java.lang.System.exit(int)} after printing an error message to      *<var>stderr</var>. However, the tools should expect that a subclass      *  will override this to throw an unchecked exception such as      *  {@link java.lang.IllegalStateException} or another subclass of      *  {@link java.lang.RuntimeException}.<em>If this method is overriden,      *<strong>it must never return normally</strong>; i.e. it must always      *  throw an exception or call System.exit</em>.      *  @since 2.7.2      *  @param s The message      */
DECL|method|fatalError (String message)
specifier|public
name|void
name|fatalError
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/** Issue an unknown fatal error.<em>If this method is overriden,      *<strong>it must never return normally</strong>; i.e. it must always      *  throw an exception or call System.exit</em>.      *  @deprecated as of 2.7.2 use {@link #fatalError(String)}. By default      *              this method executes<code>fatalError("panic");</code>.      */
DECL|method|panic ()
specifier|public
name|void
name|panic
parameter_list|()
block|{
name|fatalError
argument_list|(
literal|"panic"
argument_list|)
expr_stmt|;
block|}
comment|/** Issue a fatal error message.<em>If this method is overriden,      *<strong>it must never return normally</strong>; i.e. it must always      *  throw an exception or call System.exit</em>.      *  @deprecated as of 2.7.2 use {@link #fatalError(String)}. By defaykt      *              this method executes<code>fatalError("panic: " + s);</code>.      * @param s The message      */
DECL|method|panic (String s)
specifier|public
name|void
name|panic
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|fatalError
argument_list|(
literal|"panic: "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
comment|// File.getParent() can return null when the file is specified without
comment|// a directory or is in the root directory.
comment|// This method handles those cases.
DECL|method|parent (File f)
specifier|public
name|File
name|parent
parameter_list|(
name|File
name|f
parameter_list|)
block|{
name|String
name|dirname
init|=
name|f
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|dirname
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|f
operator|.
name|isAbsolute
argument_list|()
condition|)
return|return
operator|new
name|File
argument_list|(
name|File
operator|.
name|separator
argument_list|)
return|;
else|else
return|return
operator|new
name|File
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.dir"
argument_list|)
argument_list|)
return|;
block|}
return|return
operator|new
name|File
argument_list|(
name|dirname
argument_list|)
return|;
block|}
comment|/** Parse a list such as "f1.g;f2.g;..." and return a Vector      *  of the elements.      */
DECL|method|parseSeparatedList (String list, char separator)
specifier|public
specifier|static
name|Vector
name|parseSeparatedList
parameter_list|(
name|String
name|list
parameter_list|,
name|char
name|separator
parameter_list|)
block|{
name|java
operator|.
name|util
operator|.
name|StringTokenizer
name|st
init|=
operator|new
name|java
operator|.
name|util
operator|.
name|StringTokenizer
argument_list|(
name|list
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|separator
argument_list|)
argument_list|)
decl_stmt|;
name|Vector
name|v
init|=
operator|new
name|Vector
argument_list|(
literal|10
argument_list|)
decl_stmt|;
while|while
condition|(
name|st
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|v
operator|.
name|appendElement
argument_list|(
name|st
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
return|return
name|v
return|;
block|}
comment|/** given a filename, strip off the directory prefix (if any)      *  and return it.  Return "./" if f has no dir prefix.      */
DECL|method|pathToFile (String f)
specifier|public
name|String
name|pathToFile
parameter_list|(
name|String
name|f
parameter_list|)
block|{
name|String
name|separator
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
decl_stmt|;
name|int
name|endOfPath
init|=
name|f
operator|.
name|lastIndexOf
argument_list|(
name|separator
argument_list|)
decl_stmt|;
if|if
condition|(
name|endOfPath
operator|==
operator|-
literal|1
condition|)
block|{
comment|// no path, use current directory
return|return
literal|"."
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
return|;
block|}
return|return
name|f
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|endOfPath
operator|+
literal|1
argument_list|)
return|;
block|}
comment|/**<p>Process the command-line arguments.  Can only be called by Tool.      * A bitset is collected of all correct arguments via setArgOk.</p>      * @param args The command-line arguments passed to main()      *      */
DECL|method|processArguments (String[] args)
specifier|protected
name|void
name|processArguments
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-diagnostic"
argument_list|)
condition|)
block|{
name|genDiagnostics
operator|=
literal|true
expr_stmt|;
name|genHTML
operator|=
literal|false
expr_stmt|;
name|setArgOK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-o"
argument_list|)
condition|)
block|{
name|setArgOK
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|args
operator|.
name|length
condition|)
block|{
name|error
argument_list|(
literal|"missing output directory with -o option; ignoring"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|++
expr_stmt|;
name|setOutputDirectory
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|setArgOK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-html"
argument_list|)
condition|)
block|{
name|genHTML
operator|=
literal|true
expr_stmt|;
name|genDiagnostics
operator|=
literal|false
expr_stmt|;
name|setArgOK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-docbook"
argument_list|)
condition|)
block|{
name|genDocBook
operator|=
literal|true
expr_stmt|;
name|genDiagnostics
operator|=
literal|false
expr_stmt|;
name|setArgOK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'-'
condition|)
block|{
comment|// Must be the grammar file
name|grammarFile
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
name|setArgOK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|setArgOK (int i)
specifier|public
name|void
name|setArgOK
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|cmdLineArgValid
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
DECL|method|setOutputDirectory (String o)
specifier|public
name|void
name|setOutputDirectory
parameter_list|(
name|String
name|o
parameter_list|)
block|{
name|outputDir
operator|=
name|o
expr_stmt|;
block|}
comment|/** Issue an error; used for general tool errors not for grammar stuff      * @param s The message      */
DECL|method|toolError (String s)
specifier|public
name|void
name|toolError
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"error: "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
comment|/** Issue a warning      * @param s the message      */
DECL|method|warning (String s)
specifier|public
name|void
name|warning
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
comment|/** Issue a warning with line number information      * @param s The message      * @param file The file that has the warning (or null)      * @param line The grammar file line number on which the warning occured (or -1)      * @param column The grammar file line number on which the warning occured (or -1)      */
DECL|method|warning (String s, String file, int line, int column)
specifier|public
name|void
name|warning
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|column
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|FileLineFormatter
operator|.
name|getFormatter
argument_list|()
operator|.
name|getFormatString
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
operator|+
literal|"warning:"
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
comment|/** Issue a warning with line number information      * @param s The lines of the message      * @param file The file that has the warning      * @param line The grammar file line number on which the warning occured      */
DECL|method|warning (String[] s, String file, int line, int column)
specifier|public
name|void
name|warning
parameter_list|(
name|String
index|[]
name|s
parameter_list|,
name|String
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|column
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
literal|null
operator|||
name|s
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"bad multi-line message to Tool.warning"
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|FileLineFormatter
operator|.
name|getFormatter
argument_list|()
operator|.
name|getFormatString
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
operator|+
literal|"warning:"
operator|+
name|s
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|s
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|FileLineFormatter
operator|.
name|getFormatter
argument_list|()
operator|.
name|getFormatString
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
operator|+
literal|"    "
operator|+
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Support C++& C# namespaces (for now).      * C++: Add a nested namespace name to the current namespace.      * C# : Specify an enclosing namespace for the generated code.      * DAW: David Wagner -- C# support by kunle odutola      */
DECL|method|setNameSpace (String name)
specifier|public
name|void
name|setNameSpace
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|nameSpace
condition|)
name|nameSpace
operator|=
operator|new
name|NameSpace
argument_list|(
name|StringUtils
operator|.
name|stripFrontBack
argument_list|(
name|name
argument_list|,
literal|"\""
argument_list|,
literal|"\""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

