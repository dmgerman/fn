begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/RIGHTS.html  *  * $Id$  */
end_comment

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|Vector
import|;
end_import

begin_comment
comment|/**A linear-approximate LL(k) grammar analzyer.  *  * All lookahead elements are sets of token types.  *  * @author  Terence Parr, John Lilley  * @see     antlr.Grammar  * @see     antlr.Lookahead  */
end_comment

begin_class
DECL|class|LLkAnalyzer
specifier|public
class|class
name|LLkAnalyzer
implements|implements
name|LLkGrammarAnalyzer
block|{
comment|// Set "analyzerDebug" to true
DECL|field|DEBUG_ANALYZER
specifier|public
name|boolean
name|DEBUG_ANALYZER
init|=
literal|false
decl_stmt|;
DECL|field|currentBlock
specifier|private
name|AlternativeBlock
name|currentBlock
decl_stmt|;
DECL|field|tool
specifier|protected
name|Tool
name|tool
init|=
literal|null
decl_stmt|;
DECL|field|grammar
specifier|protected
name|Grammar
name|grammar
init|=
literal|null
decl_stmt|;
comment|// True if analyzing a lexical grammar
DECL|field|lexicalAnalysis
specifier|protected
name|boolean
name|lexicalAnalysis
init|=
literal|false
decl_stmt|;
comment|// Used for formatting bit sets in default (Java) format
DECL|field|charFormatter
name|CharFormatter
name|charFormatter
init|=
operator|new
name|JavaCharFormatter
argument_list|()
decl_stmt|;
comment|/** Create an LLk analyzer */
DECL|method|LLkAnalyzer (Tool tool_)
specifier|public
name|LLkAnalyzer
parameter_list|(
name|Tool
name|tool_
parameter_list|)
block|{
name|tool
operator|=
name|tool_
expr_stmt|;
block|}
comment|/** Return true if someone used the '.' wildcard default idiom. 	 *  Either #(. children) or '.' as an alt by itself. 	 */
DECL|method|altUsesWildcardDefault (Alternative alt)
specifier|protected
name|boolean
name|altUsesWildcardDefault
parameter_list|(
name|Alternative
name|alt
parameter_list|)
block|{
name|AlternativeElement
name|head
init|=
name|alt
operator|.
name|head
decl_stmt|;
comment|// if element is #(. blah) then check to see if el is root
if|if
condition|(
name|head
operator|instanceof
name|TreeElement
operator|&&
operator|(
operator|(
name|TreeElement
operator|)
name|head
operator|)
operator|.
name|root
operator|instanceof
name|WildcardElement
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|head
operator|instanceof
name|WildcardElement
operator|&&
name|head
operator|.
name|next
operator|instanceof
name|BlockEndElement
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**Is this block of alternatives LL(k)?  Fill in alternative cache for this block. 	 * @return true if the block is deterministic 	 */
DECL|method|deterministic (AlternativeBlock blk)
specifier|public
name|boolean
name|deterministic
parameter_list|(
name|AlternativeBlock
name|blk
parameter_list|)
block|{
comment|/** The lookahead depth for this decision */
name|int
name|k
init|=
literal|1
decl_stmt|;
comment|// start at k=1
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"deterministic("
operator|+
name|blk
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|boolean
name|det
init|=
literal|true
decl_stmt|;
name|int
name|nalts
init|=
name|blk
operator|.
name|alternatives
operator|.
name|size
argument_list|()
decl_stmt|;
name|AlternativeBlock
name|saveCurrentBlock
init|=
name|currentBlock
decl_stmt|;
name|Alternative
name|wildcardAlt
init|=
literal|null
decl_stmt|;
name|currentBlock
operator|=
name|blk
expr_stmt|;
comment|/* don't allow nongreedy (...) blocks */
if|if
condition|(
name|blk
operator|.
name|greedy
operator|==
literal|false
operator|&&
operator|!
operator|(
name|blk
operator|instanceof
name|OneOrMoreBlock
operator|)
operator|&&
operator|!
operator|(
name|blk
operator|instanceof
name|ZeroOrMoreBlock
operator|)
condition|)
block|{
name|tool
operator|.
name|warning
argument_list|(
literal|"Being nongreedy only makes sense for (...)+ and (...)*"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|blk
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// SPECIAL CASE: only one alternative.  We don't need to check the
comment|// determinism, but other code expects the lookahead cache to be
comment|// set for the single alt.
if|if
condition|(
name|nalts
operator|==
literal|1
condition|)
block|{
name|AlternativeElement
name|e
init|=
name|blk
operator|.
name|getAlternativeAt
argument_list|(
literal|0
argument_list|)
operator|.
name|head
decl_stmt|;
name|currentBlock
operator|.
name|alti
operator|=
literal|0
expr_stmt|;
name|blk
operator|.
name|getAlternativeAt
argument_list|(
literal|0
argument_list|)
operator|.
name|cache
index|[
literal|1
index|]
operator|=
name|e
operator|.
name|look
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|blk
operator|.
name|getAlternativeAt
argument_list|(
literal|0
argument_list|)
operator|.
name|lookaheadDepth
operator|=
literal|1
expr_stmt|;
comment|// set lookahead to LL(1)
name|currentBlock
operator|=
name|saveCurrentBlock
expr_stmt|;
return|return
literal|true
return|;
comment|// always deterministic for one alt
block|}
name|outer
label|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nalts
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|currentBlock
operator|.
name|alti
operator|=
name|i
expr_stmt|;
name|currentBlock
operator|.
name|analysisAlt
operator|=
name|i
expr_stmt|;
comment|// which alt are we analyzing?
name|currentBlock
operator|.
name|altj
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|// reset this alt.  Haven't computed yet,
comment|// but we need the alt number.
name|inner
label|:
comment|// compare against other alternatives with lookahead depth k
for|for
control|(
name|int
name|j
init|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|nalts
condition|;
name|j
operator|++
control|)
block|{
name|currentBlock
operator|.
name|altj
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"comparing "
operator|+
name|i
operator|+
literal|" against alt "
operator|+
name|j
argument_list|)
expr_stmt|;
name|currentBlock
operator|.
name|analysisAlt
operator|=
name|j
expr_stmt|;
comment|// which alt are we analyzing?
name|k
operator|=
literal|1
expr_stmt|;
comment|// always attempt minimum lookahead possible.
comment|// check to see if there is a lookahead depth that distinguishes
comment|// between alternatives i and j.
name|Lookahead
index|[]
name|r
init|=
operator|new
name|Lookahead
index|[
name|grammar
operator|.
name|maxk
operator|+
literal|1
index|]
decl_stmt|;
name|boolean
name|haveAmbiguity
decl_stmt|;
do|do
block|{
name|haveAmbiguity
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"checking depth "
operator|+
name|k
operator|+
literal|"<="
operator|+
name|grammar
operator|.
name|maxk
argument_list|)
expr_stmt|;
name|Lookahead
name|p
decl_stmt|,
name|q
decl_stmt|;
name|p
operator|=
name|getAltLookahead
argument_list|(
name|blk
argument_list|,
name|i
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|q
operator|=
name|getAltLookahead
argument_list|(
name|blk
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
comment|// compare LOOK(alt i) with LOOK(alt j).  Is there an intersection?
comment|// Lookahead must be disjoint.
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"p is "
operator|+
name|p
operator|.
name|toString
argument_list|(
literal|","
argument_list|,
name|charFormatter
argument_list|,
name|grammar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"q is "
operator|+
name|q
operator|.
name|toString
argument_list|(
literal|","
argument_list|,
name|charFormatter
argument_list|,
name|grammar
argument_list|)
argument_list|)
expr_stmt|;
comment|// r[i] = p.fset.and(q.fset);
name|r
index|[
name|k
index|]
operator|=
name|p
operator|.
name|intersection
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"intersection at depth "
operator|+
name|k
operator|+
literal|" is "
operator|+
name|r
index|[
name|k
index|]
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
index|[
name|k
index|]
operator|.
name|nil
argument_list|()
condition|)
block|{
name|haveAmbiguity
operator|=
literal|true
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
comment|// go until no more lookahead to use or no intersection
block|}
do|while
condition|(
name|haveAmbiguity
operator|&&
name|k
operator|<=
name|grammar
operator|.
name|maxk
condition|)
do|;
name|Alternative
name|ai
init|=
name|blk
operator|.
name|getAlternativeAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Alternative
name|aj
init|=
name|blk
operator|.
name|getAlternativeAt
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|haveAmbiguity
condition|)
block|{
name|det
operator|=
literal|false
expr_stmt|;
name|ai
operator|.
name|lookaheadDepth
operator|=
name|NONDETERMINISTIC
expr_stmt|;
name|aj
operator|.
name|lookaheadDepth
operator|=
name|NONDETERMINISTIC
expr_stmt|;
comment|/* if ith alt starts with a syntactic predicate, computing the 					 * lookahead is still done for code generation, but messages 					 * should not be generated when comparing against alt j. 					 * Alternatives with syn preds that are unnecessary do 					 * not result in syn pred try-blocks. 					 */
if|if
condition|(
name|ai
operator|.
name|synPred
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"alt "
operator|+
name|i
operator|+
literal|" has a syn pred"
argument_list|)
expr_stmt|;
block|}
comment|// The alt with the (...)=> block is nondeterministic for sure.
comment|// If the (...)=> conflicts with alt j, j is nondeterministic.
comment|// This prevents alt j from being in any switch statements.
comment|// move on to next alternative=>no possible ambiguity!
comment|//						continue inner;
block|}
comment|/* if ith alt starts with a semantic predicate, computing the 					 * lookahead is still done for code generation, but messages 					 * should not be generated when comparing against alt j. 					 */
elseif|else
if|if
condition|(
name|ai
operator|.
name|semPred
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"alt "
operator|+
name|i
operator|+
literal|" has a sem pred"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if jth alt is exactly the wildcard or wildcard root of tree, 					 * then remove elements from alt i lookahead from alt j's lookahead. 					 * Don't do an ambiguity warning. 					 */
elseif|else
if|if
condition|(
name|altUsesWildcardDefault
argument_list|(
name|aj
argument_list|)
condition|)
block|{
comment|// System.out.println("removing pred sets");
comment|// removeCompetingPredictionSetsFromWildcard(aj.cache, aj.head, grammar.maxk);
name|wildcardAlt
operator|=
name|aj
expr_stmt|;
block|}
comment|/* If the user specified warnWhenFollowAmbig=false, then we 					 * can turn off this warning IFF one of the alts is empty; 					 * that is, it points immediately at the end block. 					 */
elseif|else
if|if
condition|(
operator|!
name|blk
operator|.
name|warnWhenFollowAmbig
operator|&&
operator|(
name|ai
operator|.
name|head
operator|instanceof
name|BlockEndElement
operator|||
name|aj
operator|.
name|head
operator|instanceof
name|BlockEndElement
operator|)
condition|)
block|{
comment|// System.out.println("ai.head pts to "+ai.head.getClass());
comment|// System.out.println("aj.head pts to "+aj.head.getClass());
block|}
comment|/* If they have the generateAmbigWarnings option off for the block 					 * then don't generate a warning. 					 */
elseif|else
if|if
condition|(
operator|!
name|blk
operator|.
name|generateAmbigWarnings
condition|)
block|{ 					}
comment|/* If greedy=true and *one* empty alt shut off warning. */
elseif|else
if|if
condition|(
name|blk
operator|.
name|greedySet
operator|&&
name|blk
operator|.
name|greedy
operator|&&
operator|(
operator|(
name|ai
operator|.
name|head
operator|instanceof
name|BlockEndElement
operator|&&
operator|!
operator|(
name|aj
operator|.
name|head
operator|instanceof
name|BlockEndElement
operator|)
operator|)
operator|||
operator|(
name|aj
operator|.
name|head
operator|instanceof
name|BlockEndElement
operator|&&
operator|!
operator|(
name|ai
operator|.
name|head
operator|instanceof
name|BlockEndElement
operator|)
operator|)
operator|)
condition|)
block|{
comment|// System.out.println("greedy set to true; one alt empty");
block|}
comment|/* We have no choice, but to report a nondetermism */
else|else
block|{
name|tool
operator|.
name|errorHandler
operator|.
name|warnAltAmbiguity
argument_list|(
name|grammar
argument_list|,
name|blk
argument_list|,
comment|// the block
name|lexicalAnalysis
argument_list|,
comment|// true if lexical
name|grammar
operator|.
name|maxk
argument_list|,
comment|// depth of ambiguity
name|r
argument_list|,
comment|// set of linear ambiguities
name|i
argument_list|,
comment|// first ambiguous alternative
name|j
comment|// second ambiguous alternative
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// a lookahead depth, k, was found where i and j do not conflict
name|ai
operator|.
name|lookaheadDepth
operator|=
name|Math
operator|.
name|max
argument_list|(
name|ai
operator|.
name|lookaheadDepth
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|aj
operator|.
name|lookaheadDepth
operator|=
name|Math
operator|.
name|max
argument_list|(
name|aj
operator|.
name|lookaheadDepth
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// finished with block.
comment|// If had wildcard default clause idiom, remove competing lookahead
comment|/* 		  if ( wildcardAlt!=null ) { 		  removeCompetingPredictionSetsFromWildcard(wildcardAlt.cache, wildcardAlt.head, grammar.maxk); 		  } 		*/
name|currentBlock
operator|=
name|saveCurrentBlock
expr_stmt|;
return|return
name|det
return|;
block|}
comment|/**Is (...)+ block LL(1)?  Fill in alternative cache for this block. 	 * @return true if the block is deterministic 	 */
DECL|method|deterministic (OneOrMoreBlock blk)
specifier|public
name|boolean
name|deterministic
parameter_list|(
name|OneOrMoreBlock
name|blk
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"deterministic(...)+("
operator|+
name|blk
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|AlternativeBlock
name|saveCurrentBlock
init|=
name|currentBlock
decl_stmt|;
name|currentBlock
operator|=
name|blk
expr_stmt|;
name|boolean
name|blkOk
init|=
name|deterministic
argument_list|(
operator|(
name|AlternativeBlock
operator|)
name|blk
argument_list|)
decl_stmt|;
comment|// block has been checked, now check that what follows does not conflict
comment|// with the lookahead of the (...)+ block.
name|boolean
name|det
init|=
name|deterministicImpliedPath
argument_list|(
name|blk
argument_list|)
decl_stmt|;
name|currentBlock
operator|=
name|saveCurrentBlock
expr_stmt|;
return|return
name|det
operator|&&
name|blkOk
return|;
block|}
comment|/**Is (...)* block LL(1)?  Fill in alternative cache for this block. 	 * @return true if the block is deterministic 	 */
DECL|method|deterministic (ZeroOrMoreBlock blk)
specifier|public
name|boolean
name|deterministic
parameter_list|(
name|ZeroOrMoreBlock
name|blk
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"deterministic(...)*("
operator|+
name|blk
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|AlternativeBlock
name|saveCurrentBlock
init|=
name|currentBlock
decl_stmt|;
name|currentBlock
operator|=
name|blk
expr_stmt|;
name|boolean
name|blkOk
init|=
name|deterministic
argument_list|(
operator|(
name|AlternativeBlock
operator|)
name|blk
argument_list|)
decl_stmt|;
comment|// block has been checked, now check that what follows does not conflict
comment|// with the lookahead of the (...)* block.
name|boolean
name|det
init|=
name|deterministicImpliedPath
argument_list|(
name|blk
argument_list|)
decl_stmt|;
name|currentBlock
operator|=
name|saveCurrentBlock
expr_stmt|;
return|return
name|det
operator|&&
name|blkOk
return|;
block|}
comment|/**Is this (...)* or (...)+ block LL(k)?      * @return true if the block is deterministic      */
DECL|method|deterministicImpliedPath (BlockWithImpliedExitPath blk)
specifier|public
name|boolean
name|deterministicImpliedPath
parameter_list|(
name|BlockWithImpliedExitPath
name|blk
parameter_list|)
block|{
comment|/** The lookahead depth for this decision considering implied exit path */
name|int
name|k
decl_stmt|;
name|boolean
name|det
init|=
literal|true
decl_stmt|;
name|Vector
name|alts
init|=
name|blk
operator|.
name|getAlternatives
argument_list|()
decl_stmt|;
name|int
name|nalts
init|=
name|alts
operator|.
name|size
argument_list|()
decl_stmt|;
name|currentBlock
operator|.
name|altj
operator|=
operator|-
literal|1
expr_stmt|;
comment|// comparing against implicit optional/exit alt
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"deterministicImpliedPath"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nalts
condition|;
name|i
operator|++
control|)
block|{
comment|// check follow against all alts
name|Alternative
name|alt
init|=
name|blk
operator|.
name|getAlternativeAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|alt
operator|.
name|head
operator|instanceof
name|BlockEndElement
condition|)
block|{
name|tool
operator|.
name|warning
argument_list|(
literal|"empty alternative makes no sense in (...)* or (...)+"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|blk
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|k
operator|=
literal|1
expr_stmt|;
comment|// assume eac alt is LL(1) with exit branch
comment|// check to see if there is a lookahead depth that distinguishes
comment|// between alternative i and the exit branch.
name|Lookahead
index|[]
name|r
init|=
operator|new
name|Lookahead
index|[
name|grammar
operator|.
name|maxk
operator|+
literal|1
index|]
decl_stmt|;
name|boolean
name|haveAmbiguity
decl_stmt|;
do|do
block|{
name|haveAmbiguity
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"checking depth "
operator|+
name|k
operator|+
literal|"<="
operator|+
name|grammar
operator|.
name|maxk
argument_list|)
expr_stmt|;
name|Lookahead
name|p
decl_stmt|;
name|Lookahead
name|follow
init|=
name|blk
operator|.
name|next
operator|.
name|look
argument_list|(
name|k
argument_list|)
decl_stmt|;
name|blk
operator|.
name|exitCache
index|[
name|k
index|]
operator|=
name|follow
expr_stmt|;
name|currentBlock
operator|.
name|alti
operator|=
name|i
expr_stmt|;
name|p
operator|=
name|getAltLookahead
argument_list|(
name|blk
argument_list|,
name|i
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"follow is "
operator|+
name|follow
operator|.
name|toString
argument_list|(
literal|","
argument_list|,
name|charFormatter
argument_list|,
name|grammar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"p is "
operator|+
name|p
operator|.
name|toString
argument_list|(
literal|","
argument_list|,
name|charFormatter
argument_list|,
name|grammar
argument_list|)
argument_list|)
expr_stmt|;
comment|//r[k] = follow.fset.and(p.fset);
name|r
index|[
name|k
index|]
operator|=
name|follow
operator|.
name|intersection
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"intersection at depth "
operator|+
name|k
operator|+
literal|" is "
operator|+
name|r
index|[
name|k
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
index|[
name|k
index|]
operator|.
name|nil
argument_list|()
condition|)
block|{
name|haveAmbiguity
operator|=
literal|true
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
comment|// go until no more lookahead to use or no intersection
block|}
do|while
condition|(
name|haveAmbiguity
operator|&&
name|k
operator|<=
name|grammar
operator|.
name|maxk
condition|)
do|;
if|if
condition|(
name|haveAmbiguity
condition|)
block|{
name|det
operator|=
literal|false
expr_stmt|;
name|alt
operator|.
name|lookaheadDepth
operator|=
name|NONDETERMINISTIC
expr_stmt|;
name|blk
operator|.
name|exitLookaheadDepth
operator|=
name|NONDETERMINISTIC
expr_stmt|;
name|Alternative
name|ambigAlt
init|=
name|blk
operator|.
name|getAlternativeAt
argument_list|(
name|currentBlock
operator|.
name|alti
argument_list|)
decl_stmt|;
comment|/* If the user specified warnWhenFollowAmbig=false, then we 					 * can turn off this warning. 					 */
if|if
condition|(
operator|!
name|blk
operator|.
name|warnWhenFollowAmbig
condition|)
block|{ 					}
comment|/* If they have the generateAmbigWarnings option off for the block 					 * then don't generate a warning. 					 */
elseif|else
if|if
condition|(
operator|!
name|blk
operator|.
name|generateAmbigWarnings
condition|)
block|{ 					}
comment|/* If greedy=true and alt not empty, shut off warning */
elseif|else
if|if
condition|(
name|blk
operator|.
name|greedy
operator|==
literal|true
operator|&&
name|blk
operator|.
name|greedySet
operator|&&
operator|!
operator|(
name|ambigAlt
operator|.
name|head
operator|instanceof
name|BlockEndElement
operator|)
condition|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"greedy loop"
argument_list|)
expr_stmt|;
block|}
comment|/* If greedy=false then shut off warning...will have 					 * to add "if FOLLOW break" 					 * block during code gen to compensate for removal of warning. 					 */
elseif|else
if|if
condition|(
name|blk
operator|.
name|greedy
operator|==
literal|false
operator|&&
operator|!
operator|(
name|ambigAlt
operator|.
name|head
operator|instanceof
name|BlockEndElement
operator|)
condition|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"nongreedy loop"
argument_list|)
expr_stmt|;
comment|// if FOLLOW not single k-string (|set[k]| can
comment|// be> 1 actually) then must warn them that
comment|// loop may terminate incorrectly.
comment|// For example, ('a'..'d')+ ("ad"|"cb")
if|if
condition|(
operator|!
name|lookaheadEquivForApproxAndFullAnalysis
argument_list|(
name|blk
operator|.
name|exitCache
argument_list|,
name|grammar
operator|.
name|maxk
argument_list|)
condition|)
block|{
name|tool
operator|.
name|warning
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"nongreedy block may exit incorrectly due"
block|,
literal|"\tto limitations of linear approximate lookahead (first k-1 sets"
block|,
literal|"\tin lookahead not singleton)."
block|}
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|blk
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// no choice but to generate a warning
else|else
block|{
name|tool
operator|.
name|errorHandler
operator|.
name|warnAltExitAmbiguity
argument_list|(
name|grammar
argument_list|,
name|blk
argument_list|,
comment|// the block
name|lexicalAnalysis
argument_list|,
comment|// true if lexical
name|grammar
operator|.
name|maxk
argument_list|,
comment|// depth of ambiguity
name|r
argument_list|,
comment|// set of linear ambiguities
name|i
comment|// ambiguous alternative
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|alt
operator|.
name|lookaheadDepth
operator|=
name|Math
operator|.
name|max
argument_list|(
name|alt
operator|.
name|lookaheadDepth
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|blk
operator|.
name|exitLookaheadDepth
operator|=
name|Math
operator|.
name|max
argument_list|(
name|blk
operator|.
name|exitLookaheadDepth
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|det
return|;
block|}
comment|/**Compute the lookahead set of whatever follows references to 	 * the rule associated witht the FOLLOW block. 	 */
DECL|method|FOLLOW (int k, RuleEndElement end)
specifier|public
name|Lookahead
name|FOLLOW
parameter_list|(
name|int
name|k
parameter_list|,
name|RuleEndElement
name|end
parameter_list|)
block|{
comment|// what rule are we trying to compute FOLLOW of?
name|RuleBlock
name|rb
init|=
operator|(
name|RuleBlock
operator|)
name|end
operator|.
name|block
decl_stmt|;
comment|// rule name is different in lexer
name|String
name|rule
decl_stmt|;
if|if
condition|(
name|lexicalAnalysis
condition|)
block|{
name|rule
operator|=
name|CodeGenerator
operator|.
name|lexerRuleName
argument_list|(
name|rb
operator|.
name|getRuleName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rule
operator|=
name|rb
operator|.
name|getRuleName
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FOLLOW("
operator|+
name|k
operator|+
literal|","
operator|+
name|rule
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// are we in the midst of computing this FOLLOW already?
if|if
condition|(
name|end
operator|.
name|lock
index|[
name|k
index|]
condition|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FOLLOW cycle to "
operator|+
name|rule
argument_list|)
expr_stmt|;
return|return
operator|new
name|Lookahead
argument_list|(
name|rule
argument_list|)
return|;
block|}
comment|// Check to see if there is cached value
if|if
condition|(
name|end
operator|.
name|cache
index|[
name|k
index|]
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"cache entry FOLLOW("
operator|+
name|k
operator|+
literal|") for "
operator|+
name|rule
operator|+
literal|": "
operator|+
name|end
operator|.
name|cache
index|[
name|k
index|]
operator|.
name|toString
argument_list|(
literal|","
argument_list|,
name|charFormatter
argument_list|,
name|grammar
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// if the cache is a complete computation then simply return entry
if|if
condition|(
name|end
operator|.
name|cache
index|[
name|k
index|]
operator|.
name|cycle
operator|==
literal|null
condition|)
block|{
return|return
operator|(
name|Lookahead
operator|)
name|end
operator|.
name|cache
index|[
name|k
index|]
operator|.
name|clone
argument_list|()
return|;
block|}
comment|// A cache entry exists, but it is a reference to a cyclic computation.
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|grammar
operator|.
name|getSymbol
argument_list|(
name|end
operator|.
name|cache
index|[
name|k
index|]
operator|.
name|cycle
argument_list|)
decl_stmt|;
name|RuleEndElement
name|re
init|=
name|rs
operator|.
name|getBlock
argument_list|()
operator|.
name|endNode
decl_stmt|;
comment|// The other entry may not exist because it is still being
comment|// computed when this cycle cache entry was found here.
if|if
condition|(
name|re
operator|.
name|cache
index|[
name|k
index|]
operator|==
literal|null
condition|)
block|{
comment|// return the cycle...that's all we can do at the moment.
return|return
operator|(
name|Lookahead
operator|)
name|end
operator|.
name|cache
index|[
name|k
index|]
operator|.
name|clone
argument_list|()
return|;
block|}
else|else
block|{
comment|// replace this cache entry with the entry from the referenced computation.
comment|// Eventually, this percolates a complete (no cycle reference) cache entry
comment|// to this node (or at least gets it closer and closer).  This is not
comment|// crucial, but makes cache lookup faster as we might have to look up
comment|// lots of cycle references before finding a complete reference.
name|end
operator|.
name|cache
index|[
name|k
index|]
operator|=
name|re
operator|.
name|cache
index|[
name|k
index|]
expr_stmt|;
comment|// Return the cache entry associated with the cycle reference.
return|return
operator|(
name|Lookahead
operator|)
name|re
operator|.
name|cache
index|[
name|k
index|]
operator|.
name|clone
argument_list|()
return|;
block|}
block|}
name|end
operator|.
name|lock
index|[
name|k
index|]
operator|=
literal|true
expr_stmt|;
comment|// prevent FOLLOW computation cycles
name|Lookahead
name|p
init|=
operator|new
name|Lookahead
argument_list|()
decl_stmt|;
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|grammar
operator|.
name|getSymbol
argument_list|(
name|rule
argument_list|)
decl_stmt|;
comment|// Walk list of references to this rule to compute FOLLOW
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rs
operator|.
name|numReferences
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RuleRefElement
name|rr
init|=
name|rs
operator|.
name|getReference
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"next["
operator|+
name|rule
operator|+
literal|"] is "
operator|+
name|rr
operator|.
name|next
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Lookahead
name|q
init|=
name|rr
operator|.
name|next
operator|.
name|look
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FIRST of next["
operator|+
name|rule
operator|+
literal|"] ptr is "
operator|+
name|q
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If there is a cycle then if the cycle is to the rule for 			 * this end block, you have a cycle to yourself.  Remove the 			 * cycle indication--the lookahead is complete. 			 */
if|if
condition|(
name|q
operator|.
name|cycle
operator|!=
literal|null
operator|&&
name|q
operator|.
name|cycle
operator|.
name|equals
argument_list|(
name|rule
argument_list|)
condition|)
block|{
name|q
operator|.
name|cycle
operator|=
literal|null
expr_stmt|;
comment|// don't want cycle to yourself!
block|}
comment|// add the lookahead into the current FOLLOW computation set
name|p
operator|.
name|combineWith
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"combined FOLLOW["
operator|+
name|rule
operator|+
literal|"] is "
operator|+
name|p
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|end
operator|.
name|lock
index|[
name|k
index|]
operator|=
literal|false
expr_stmt|;
comment|// we're not doing FOLLOW anymore
comment|// if no rules follow this, it can be a start symbol or called by a start sym.
comment|// set the follow to be end of file.
if|if
condition|(
name|p
operator|.
name|fset
operator|.
name|nil
argument_list|()
operator|&&
name|p
operator|.
name|cycle
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
comment|// Tree grammars don't see EOF, they see end of sibling list or
comment|// "NULL TREE LOOKAHEAD".
name|p
operator|.
name|fset
operator|.
name|add
argument_list|(
name|Token
operator|.
name|NULL_TREE_LOOKAHEAD
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
block|{
comment|// Lexical grammars use Epsilon to indicate that the end of rule has been hit
comment|// EOF would be misleading; any character can follow a token rule not just EOF
comment|// as in a grammar (where a start symbol is followed by EOF).  There is no
comment|// sequence info in a lexer between tokens to indicate what is the last token
comment|// to be seen.
comment|// p.fset.add(EPSILON_TYPE);
name|p
operator|.
name|setEpsilon
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|p
operator|.
name|fset
operator|.
name|add
argument_list|(
name|Token
operator|.
name|EOF_TYPE
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Cache the result of the FOLLOW computation
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"saving FOLLOW("
operator|+
name|k
operator|+
literal|") for "
operator|+
name|rule
operator|+
literal|": "
operator|+
name|p
operator|.
name|toString
argument_list|(
literal|","
argument_list|,
name|charFormatter
argument_list|,
name|grammar
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|end
operator|.
name|cache
index|[
name|k
index|]
operator|=
operator|(
name|Lookahead
operator|)
name|p
operator|.
name|clone
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
DECL|method|getAltLookahead (AlternativeBlock blk, int alt, int k)
specifier|private
name|Lookahead
name|getAltLookahead
parameter_list|(
name|AlternativeBlock
name|blk
parameter_list|,
name|int
name|alt
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|Lookahead
name|p
decl_stmt|;
name|Alternative
name|a
init|=
name|blk
operator|.
name|getAlternativeAt
argument_list|(
name|alt
argument_list|)
decl_stmt|;
name|AlternativeElement
name|e
init|=
name|a
operator|.
name|head
decl_stmt|;
comment|//System.out.println("getAltLookahead("+k+","+e+"), cache size is "+a.cache.length);
if|if
condition|(
name|a
operator|.
name|cache
index|[
name|k
index|]
operator|==
literal|null
condition|)
block|{
name|p
operator|=
name|e
operator|.
name|look
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|a
operator|.
name|cache
index|[
name|k
index|]
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|a
operator|.
name|cache
index|[
name|k
index|]
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
comment|/**Actions are ignored */
DECL|method|look (int k, ActionElement action)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|,
name|ActionElement
name|action
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"lookAction("
operator|+
name|k
operator|+
literal|","
operator|+
name|action
operator|+
literal|")"
argument_list|)
expr_stmt|;
return|return
name|action
operator|.
name|next
operator|.
name|look
argument_list|(
name|k
argument_list|)
return|;
block|}
comment|/**Combine the lookahead computed for each alternative */
DECL|method|look (int k, AlternativeBlock blk)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|,
name|AlternativeBlock
name|blk
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"lookAltBlk("
operator|+
name|k
operator|+
literal|","
operator|+
name|blk
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|AlternativeBlock
name|saveCurrentBlock
init|=
name|currentBlock
decl_stmt|;
name|currentBlock
operator|=
name|blk
expr_stmt|;
name|Lookahead
name|p
init|=
operator|new
name|Lookahead
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blk
operator|.
name|alternatives
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"alt "
operator|+
name|i
operator|+
literal|" of "
operator|+
name|blk
argument_list|)
expr_stmt|;
comment|// must set analysis alt
name|currentBlock
operator|.
name|analysisAlt
operator|=
name|i
expr_stmt|;
name|Alternative
name|alt
init|=
name|blk
operator|.
name|getAlternativeAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|AlternativeElement
name|elem
init|=
name|alt
operator|.
name|head
decl_stmt|;
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
block|{
if|if
condition|(
name|alt
operator|.
name|head
operator|==
name|alt
operator|.
name|tail
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"alt "
operator|+
name|i
operator|+
literal|" is empty"
argument_list|)
expr_stmt|;
block|}
block|}
name|Lookahead
name|q
init|=
name|elem
operator|.
name|look
argument_list|(
name|k
argument_list|)
decl_stmt|;
name|p
operator|.
name|combineWith
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|==
literal|1
operator|&&
name|blk
operator|.
name|not
operator|&&
name|subruleCanBeInverted
argument_list|(
name|blk
argument_list|,
name|lexicalAnalysis
argument_list|)
condition|)
block|{
comment|// Invert the lookahead set
if|if
condition|(
name|lexicalAnalysis
condition|)
block|{
name|BitSet
name|b
init|=
call|(
name|BitSet
call|)
argument_list|(
operator|(
name|LexerGrammar
operator|)
name|grammar
argument_list|)
operator|.
name|charVocabulary
operator|.
name|clone
argument_list|()
decl_stmt|;
name|int
index|[]
name|elems
init|=
name|p
operator|.
name|fset
operator|.
name|toArray
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|elems
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|b
operator|.
name|remove
argument_list|(
name|elems
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|p
operator|.
name|fset
operator|=
name|b
expr_stmt|;
block|}
else|else
block|{
name|p
operator|.
name|fset
operator|.
name|notInPlace
argument_list|(
name|Token
operator|.
name|MIN_USER_TYPE
argument_list|,
name|grammar
operator|.
name|tokenManager
operator|.
name|maxTokenType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|currentBlock
operator|=
name|saveCurrentBlock
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/**Compute what follows this place-holder node and possibly 	 * what begins the associated loop unless the 	 * node is locked. 	 *<p> 	 * if we hit the end of a loop, we have to include 	 * what tokens can begin the loop as well.  If the start 	 * node is locked, then we simply found an empty path 	 * through this subrule while analyzing it.  If the 	 * start node is not locked, then this node was hit 	 * during a FOLLOW operation and the FIRST of this 	 * block must be included in that lookahead computation. 	 */
DECL|method|look (int k, BlockEndElement end)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|,
name|BlockEndElement
name|end
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"lookBlockEnd("
operator|+
name|k
operator|+
literal|", "
operator|+
name|end
operator|.
name|block
operator|+
literal|"); lock is "
operator|+
name|end
operator|.
name|lock
index|[
name|k
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|.
name|lock
index|[
name|k
index|]
condition|)
block|{
comment|// computation in progress => the tokens we would have
comment|// computed (had we not been locked) will be included
comment|// in the set by that computation with the lock on this
comment|// node.
return|return
operator|new
name|Lookahead
argument_list|()
return|;
block|}
name|Lookahead
name|p
decl_stmt|;
comment|/* Hitting the end of a loop means you can see what begins the loop */
if|if
condition|(
name|end
operator|.
name|block
operator|instanceof
name|ZeroOrMoreBlock
operator|||
name|end
operator|.
name|block
operator|instanceof
name|OneOrMoreBlock
condition|)
block|{
comment|// compute what can start the block,
comment|// but lock end node so we don't do it twice in same
comment|// computation.
name|end
operator|.
name|lock
index|[
name|k
index|]
operator|=
literal|true
expr_stmt|;
name|p
operator|=
name|look
argument_list|(
name|k
argument_list|,
name|end
operator|.
name|block
argument_list|)
expr_stmt|;
name|end
operator|.
name|lock
index|[
name|k
index|]
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
operator|new
name|Lookahead
argument_list|()
expr_stmt|;
block|}
comment|/* Tree blocks do not have any follow because they are children 		 * of what surrounds them.  For example, A #(B C) D results in 		 * a look() for the TreeElement end of NULL_TREE_LOOKAHEAD, which 		 * indicates that nothing can follow the last node of tree #(B C) 		 */
if|if
condition|(
name|end
operator|.
name|block
operator|instanceof
name|TreeElement
condition|)
block|{
name|p
operator|.
name|combineWith
argument_list|(
name|Lookahead
operator|.
name|of
argument_list|(
name|Token
operator|.
name|NULL_TREE_LOOKAHEAD
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Syntactic predicates such as ( (A)? )=> have no follow per se. 		 * We cannot accurately say what would be matched following a 		 * syntactic predicate (you MIGHT be ok if you said it was whatever 		 * followed the alternative predicted by the predicate).  Hence, 		 * (like end-of-token) we return Epsilon to indicate "unknown 		 * lookahead." 		 */
elseif|else
if|if
condition|(
name|end
operator|.
name|block
operator|instanceof
name|SynPredBlock
condition|)
block|{
name|p
operator|.
name|setEpsilon
argument_list|()
expr_stmt|;
block|}
comment|// compute what can follow the block
else|else
block|{
name|Lookahead
name|q
init|=
name|end
operator|.
name|block
operator|.
name|next
operator|.
name|look
argument_list|(
name|k
argument_list|)
decl_stmt|;
name|p
operator|.
name|combineWith
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
comment|/**Return this char as the lookahead if k=1. 	 *<p>### Doesn't work for ( 'a' 'b' | 'a' ~'b' ) yet!!! 	 *<p> 	 * If the atom has the<tt>not</tt> flag on, then 	 * create the set complement of the tokenType 	 * which is the set of all characters referenced 	 * in the grammar with this char turned off. 	 * Also remove characters from the set that 	 * are currently allocated for predicting 	 * previous alternatives.  This avoids ambiguity 	 * messages and is more properly what is meant. 	 * ( 'a' | ~'a' ) implies that the ~'a' is the 	 * "else" clause. 	 *<p> 	 * NOTE: we do<b>NOT</b> include exit path in 	 * the exclusion set. E.g., 	 * ( 'a' | ~'a' )* 'b' 	 * should exit upon seeing a 'b' during the loop. 	 */
DECL|method|look (int k, CharLiteralElement atom)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|,
name|CharLiteralElement
name|atom
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"lookCharLiteral("
operator|+
name|k
operator|+
literal|","
operator|+
name|atom
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// Skip until analysis hits k==1
if|if
condition|(
name|k
operator|>
literal|1
condition|)
block|{
return|return
name|atom
operator|.
name|next
operator|.
name|look
argument_list|(
name|k
operator|-
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|lexicalAnalysis
condition|)
block|{
if|if
condition|(
name|atom
operator|.
name|not
condition|)
block|{
name|BitSet
name|b
init|=
call|(
name|BitSet
call|)
argument_list|(
operator|(
name|LexerGrammar
operator|)
name|grammar
argument_list|)
operator|.
name|charVocabulary
operator|.
name|clone
argument_list|()
decl_stmt|;
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"charVocab is "
operator|+
name|b
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// remove stuff predicted by preceding alts and follow of block
name|removeCompetingPredictionSets
argument_list|(
name|b
argument_list|,
name|atom
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"charVocab after removal of prior alt lookahead "
operator|+
name|b
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// now remove element that is stated not to be in the set
name|b
operator|.
name|clear
argument_list|(
name|atom
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|Lookahead
argument_list|(
name|b
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Lookahead
operator|.
name|of
argument_list|(
name|atom
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|// Should have been avoided by MakeGrammar
name|tool
operator|.
name|panic
argument_list|(
literal|"Character literal reference found in parser"
argument_list|)
expr_stmt|;
comment|// ... so we make the compiler happy
return|return
name|Lookahead
operator|.
name|of
argument_list|(
name|atom
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
DECL|method|look (int k, CharRangeElement r)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|,
name|CharRangeElement
name|r
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"lookCharRange("
operator|+
name|k
operator|+
literal|","
operator|+
name|r
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// Skip until analysis hits k==1
if|if
condition|(
name|k
operator|>
literal|1
condition|)
block|{
return|return
name|r
operator|.
name|next
operator|.
name|look
argument_list|(
name|k
operator|-
literal|1
argument_list|)
return|;
block|}
name|BitSet
name|p
init|=
name|BitSet
operator|.
name|of
argument_list|(
name|r
operator|.
name|begin
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|r
operator|.
name|begin
operator|+
literal|1
init|;
name|i
operator|<=
name|r
operator|.
name|end
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Lookahead
argument_list|(
name|p
argument_list|)
return|;
block|}
DECL|method|look (int k, GrammarAtom atom)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|,
name|GrammarAtom
name|atom
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"look("
operator|+
name|k
operator|+
literal|","
operator|+
name|atom
operator|+
literal|"["
operator|+
name|atom
operator|.
name|getType
argument_list|()
operator|+
literal|"])"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lexicalAnalysis
condition|)
block|{
comment|// MakeGrammar should have created a rule reference instead
name|tool
operator|.
name|panic
argument_list|(
literal|"token reference found in lexer"
argument_list|)
expr_stmt|;
block|}
comment|// Skip until analysis hits k==1
if|if
condition|(
name|k
operator|>
literal|1
condition|)
block|{
return|return
name|atom
operator|.
name|next
operator|.
name|look
argument_list|(
name|k
operator|-
literal|1
argument_list|)
return|;
block|}
name|Lookahead
name|l
init|=
name|Lookahead
operator|.
name|of
argument_list|(
name|atom
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|atom
operator|.
name|not
condition|)
block|{
comment|// Invert the lookahead set against the token vocabulary
name|int
name|maxToken
init|=
name|grammar
operator|.
name|tokenManager
operator|.
name|maxTokenType
argument_list|()
decl_stmt|;
name|l
operator|.
name|fset
operator|.
name|notInPlace
argument_list|(
name|Token
operator|.
name|MIN_USER_TYPE
argument_list|,
name|maxToken
argument_list|)
expr_stmt|;
comment|// remove stuff predicted by preceding alts and follow of block
name|removeCompetingPredictionSets
argument_list|(
name|l
operator|.
name|fset
argument_list|,
name|atom
argument_list|)
expr_stmt|;
block|}
return|return
name|l
return|;
block|}
comment|/**The lookahead of a (...)+ block is the combined lookahead of 	 * all alternatives and, if an empty path is found, the lookahead 	 * of what follows the block. 	 */
DECL|method|look (int k, OneOrMoreBlock blk)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|,
name|OneOrMoreBlock
name|blk
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"look+"
operator|+
name|k
operator|+
literal|","
operator|+
name|blk
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|Lookahead
name|p
init|=
name|look
argument_list|(
name|k
argument_list|,
operator|(
name|AlternativeBlock
operator|)
name|blk
argument_list|)
decl_stmt|;
return|return
name|p
return|;
block|}
comment|/**Combine the lookahead computed for each alternative. 	 * Lock the node so that no other computation may come back 	 * on itself--infinite loop.  This also implies infinite left-recursion 	 * in the grammar (or an error in this algorithm ;)). 	 */
DECL|method|look (int k, RuleBlock blk)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|,
name|RuleBlock
name|blk
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"lookRuleBlk("
operator|+
name|k
operator|+
literal|","
operator|+
name|blk
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|Lookahead
name|p
init|=
name|look
argument_list|(
name|k
argument_list|,
operator|(
name|AlternativeBlock
operator|)
name|blk
argument_list|)
decl_stmt|;
return|return
name|p
return|;
block|}
comment|/**If not locked or noFOLLOW set, compute FOLLOW of a rule. 	 *<p> 	 * TJP says 8/12/99: not true anymore: 	 * Lexical rules never compute follow.  They set epsilon and 	 * the code generator gens code to check for any character. 	 * The code generator must remove the tokens used to predict 	 * any previous alts in the same block. 	 *<p> 	 * When the last node of a rule is reached and noFOLLOW, 	 * it implies that a "local" FOLLOW will be computed 	 * after this call.  I.e., 	 *<pre> 	 *		a : b A; 	 *		b : B | ; 	 *		c : b C; 	 *</pre> 	 * Here, when computing the look of rule b from rule a, 	 * we want only {B,EPSILON_TYPE} so that look(b A) will 	 * be {B,A} not {B,A,C}. 	 *<p> 	 * if the end block is not locked and the FOLLOW is 	 * wanted, the algorithm must compute the lookahead 	 * of what follows references to this rule.  If 	 * end block is locked, FOLLOW will return an empty set 	 * with a cycle to the rule associated with this end block. 	 */
DECL|method|look (int k, RuleEndElement end)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|,
name|RuleEndElement
name|end
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"lookRuleBlockEnd("
operator|+
name|k
operator|+
literal|"); noFOLLOW="
operator|+
name|end
operator|.
name|noFOLLOW
operator|+
literal|"; lock is "
operator|+
name|end
operator|.
name|lock
index|[
name|k
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
comment|/*lexicalAnalysis ||*/
name|end
operator|.
name|noFOLLOW
condition|)
block|{
name|Lookahead
name|p
init|=
operator|new
name|Lookahead
argument_list|()
decl_stmt|;
name|p
operator|.
name|setEpsilon
argument_list|()
expr_stmt|;
name|p
operator|.
name|epsilonDepth
operator|=
name|BitSet
operator|.
name|of
argument_list|(
name|k
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
name|Lookahead
name|p
init|=
name|FOLLOW
argument_list|(
name|k
argument_list|,
name|end
argument_list|)
decl_stmt|;
return|return
name|p
return|;
block|}
comment|/**Compute the lookahead contributed by a rule reference. 	 * 	 *<p> 	 * When computing ruleref lookahead, we don't want the FOLLOW 	 * computation done if an empty path exists for the rule. 	 * The FOLLOW is too loose of a set...we want only to 	 * include the "local" FOLLOW or what can follow this 	 * particular ref to the node.  In other words, we use 	 * context information to reduce the complexity of the 	 * analysis and strengthen the parser. 	 * 	 * The noFOLLOW flag is used as a means of restricting 	 * the FOLLOW to a "local" FOLLOW.  This variable is 	 * orthogonal to the<tt>lock</tt> variable that prevents 	 * infinite recursion.  noFOLLOW does not care about what k is. 	 */
DECL|method|look (int k, RuleRefElement rr)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|,
name|RuleRefElement
name|rr
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"lookRuleRef("
operator|+
name|k
operator|+
literal|","
operator|+
name|rr
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|grammar
operator|.
name|getSymbol
argument_list|(
name|rr
operator|.
name|targetRule
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|==
literal|null
operator|||
operator|!
name|rs
operator|.
name|defined
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"no definition of rule "
operator|+
name|rr
operator|.
name|targetRule
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|rr
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|Lookahead
argument_list|()
return|;
block|}
name|RuleBlock
name|rb
init|=
name|rs
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|RuleEndElement
name|end
init|=
name|rb
operator|.
name|endNode
decl_stmt|;
name|boolean
name|saveEnd
init|=
name|end
operator|.
name|noFOLLOW
decl_stmt|;
name|end
operator|.
name|noFOLLOW
operator|=
literal|true
expr_stmt|;
comment|// go off to the rule and get the lookahead (w/o FOLLOW)
name|Lookahead
name|p
init|=
name|look
argument_list|(
name|k
argument_list|,
name|rr
operator|.
name|targetRule
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"back from rule ref to "
operator|+
name|rr
operator|.
name|targetRule
argument_list|)
expr_stmt|;
comment|// restore state of end block
name|end
operator|.
name|noFOLLOW
operator|=
name|saveEnd
expr_stmt|;
comment|// check for infinite recursion.  If a cycle is returned: trouble!
if|if
condition|(
name|p
operator|.
name|cycle
operator|!=
literal|null
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"infinite recursion to rule "
operator|+
name|p
operator|.
name|cycle
operator|+
literal|" from rule "
operator|+
name|rr
operator|.
name|enclosingRuleName
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|rr
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// is the local FOLLOW required?
if|if
condition|(
name|p
operator|.
name|containsEpsilon
argument_list|()
condition|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"rule ref to "
operator|+
name|rr
operator|.
name|targetRule
operator|+
literal|" has eps, depth: "
operator|+
name|p
operator|.
name|epsilonDepth
argument_list|)
expr_stmt|;
comment|// remove epsilon
name|p
operator|.
name|resetEpsilon
argument_list|()
expr_stmt|;
comment|// fset.clear(EPSILON_TYPE);
comment|// for each lookahead depth that saw epsilon
name|int
index|[]
name|depths
init|=
name|p
operator|.
name|epsilonDepth
operator|.
name|toArray
argument_list|()
decl_stmt|;
name|p
operator|.
name|epsilonDepth
operator|=
literal|null
expr_stmt|;
comment|// clear all epsilon stuff
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|depths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|rk
init|=
name|k
operator|-
operator|(
name|k
operator|-
name|depths
index|[
name|i
index|]
operator|)
decl_stmt|;
name|Lookahead
name|q
init|=
name|rr
operator|.
name|next
operator|.
name|look
argument_list|(
name|rk
argument_list|)
decl_stmt|;
comment|// see comments in Lookahead
name|p
operator|.
name|combineWith
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
comment|// note: any of these look() computations for local follow can
comment|// set EPSILON in the set again if the end of this rule is found.
block|}
return|return
name|p
return|;
block|}
DECL|method|look (int k, StringLiteralElement atom)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|,
name|StringLiteralElement
name|atom
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"lookStringLiteral("
operator|+
name|k
operator|+
literal|","
operator|+
name|atom
operator|+
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lexicalAnalysis
condition|)
block|{
comment|// need more lookahead than string can provide?
if|if
condition|(
name|k
operator|>
name|atom
operator|.
name|processedAtomText
operator|.
name|length
argument_list|()
condition|)
block|{
return|return
name|atom
operator|.
name|next
operator|.
name|look
argument_list|(
name|k
operator|-
name|atom
operator|.
name|processedAtomText
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// get char at lookahead depth k, from the processed literal text
return|return
name|Lookahead
operator|.
name|of
argument_list|(
name|atom
operator|.
name|processedAtomText
operator|.
name|charAt
argument_list|(
name|k
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|// Skip until analysis hits k==1
if|if
condition|(
name|k
operator|>
literal|1
condition|)
block|{
return|return
name|atom
operator|.
name|next
operator|.
name|look
argument_list|(
name|k
operator|-
literal|1
argument_list|)
return|;
block|}
name|Lookahead
name|l
init|=
name|Lookahead
operator|.
name|of
argument_list|(
name|atom
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|atom
operator|.
name|not
condition|)
block|{
comment|// Invert the lookahead set against the token vocabulary
name|int
name|maxToken
init|=
name|grammar
operator|.
name|tokenManager
operator|.
name|maxTokenType
argument_list|()
decl_stmt|;
name|l
operator|.
name|fset
operator|.
name|notInPlace
argument_list|(
name|Token
operator|.
name|MIN_USER_TYPE
argument_list|,
name|maxToken
argument_list|)
expr_stmt|;
block|}
return|return
name|l
return|;
block|}
block|}
comment|/**The lookahead of a (...)=> block is the lookahead of 	 * what follows the block.  By definition, the syntactic 	 * predicate block defies static analysis (you want to try it 	 * out at run-time).  The LOOK of (a)=>A B is A for LL(1) 	 * ### is this even called? 	 */
DECL|method|look (int k, SynPredBlock blk)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|,
name|SynPredBlock
name|blk
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"look=>("
operator|+
name|k
operator|+
literal|","
operator|+
name|blk
operator|+
literal|")"
argument_list|)
expr_stmt|;
return|return
name|blk
operator|.
name|next
operator|.
name|look
argument_list|(
name|k
argument_list|)
return|;
block|}
DECL|method|look (int k, TokenRangeElement r)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|,
name|TokenRangeElement
name|r
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"lookTokenRange("
operator|+
name|k
operator|+
literal|","
operator|+
name|r
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// Skip until analysis hits k==1
if|if
condition|(
name|k
operator|>
literal|1
condition|)
block|{
return|return
name|r
operator|.
name|next
operator|.
name|look
argument_list|(
name|k
operator|-
literal|1
argument_list|)
return|;
block|}
name|BitSet
name|p
init|=
name|BitSet
operator|.
name|of
argument_list|(
name|r
operator|.
name|begin
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|r
operator|.
name|begin
operator|+
literal|1
init|;
name|i
operator|<=
name|r
operator|.
name|end
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Lookahead
argument_list|(
name|p
argument_list|)
return|;
block|}
DECL|method|look (int k, TreeElement t)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|,
name|TreeElement
name|t
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"look("
operator|+
name|k
operator|+
literal|","
operator|+
name|t
operator|.
name|root
operator|+
literal|"["
operator|+
name|t
operator|.
name|root
operator|.
name|getType
argument_list|()
operator|+
literal|"])"
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|1
condition|)
block|{
return|return
name|t
operator|.
name|next
operator|.
name|look
argument_list|(
name|k
operator|-
literal|1
argument_list|)
return|;
block|}
name|Lookahead
name|l
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|root
operator|instanceof
name|WildcardElement
condition|)
block|{
name|l
operator|=
name|t
operator|.
name|root
operator|.
name|look
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// compute FIRST set minus previous rows
block|}
else|else
block|{
name|l
operator|=
name|Lookahead
operator|.
name|of
argument_list|(
name|t
operator|.
name|root
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|root
operator|.
name|not
condition|)
block|{
comment|// Invert the lookahead set against the token vocabulary
name|int
name|maxToken
init|=
name|grammar
operator|.
name|tokenManager
operator|.
name|maxTokenType
argument_list|()
decl_stmt|;
name|l
operator|.
name|fset
operator|.
name|notInPlace
argument_list|(
name|Token
operator|.
name|MIN_USER_TYPE
argument_list|,
name|maxToken
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|l
return|;
block|}
DECL|method|look (int k, WildcardElement wc)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|,
name|WildcardElement
name|wc
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"look("
operator|+
name|k
operator|+
literal|","
operator|+
name|wc
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// Skip until analysis hits k==1
if|if
condition|(
name|k
operator|>
literal|1
condition|)
block|{
return|return
name|wc
operator|.
name|next
operator|.
name|look
argument_list|(
name|k
operator|-
literal|1
argument_list|)
return|;
block|}
name|BitSet
name|b
decl_stmt|;
if|if
condition|(
name|lexicalAnalysis
condition|)
block|{
comment|// Copy the character vocabulary
name|b
operator|=
call|(
name|BitSet
call|)
argument_list|(
operator|(
name|LexerGrammar
operator|)
name|grammar
argument_list|)
operator|.
name|charVocabulary
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
operator|new
name|BitSet
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Invert the lookahead set against the token vocabulary
name|int
name|maxToken
init|=
name|grammar
operator|.
name|tokenManager
operator|.
name|maxTokenType
argument_list|()
decl_stmt|;
name|b
operator|.
name|notInPlace
argument_list|(
name|Token
operator|.
name|MIN_USER_TYPE
argument_list|,
name|maxToken
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"look("
operator|+
name|k
operator|+
literal|","
operator|+
name|wc
operator|+
literal|") after not: "
operator|+
name|b
argument_list|)
expr_stmt|;
block|}
comment|// Remove prediction sets from competing alternatives
comment|// removeCompetingPredictionSets(b, wc);
return|return
operator|new
name|Lookahead
argument_list|(
name|b
argument_list|)
return|;
block|}
comment|/** The (...)* element is the combined lookahead of the alternatives and what can 	 *  follow the loop. 	 */
DECL|method|look (int k, ZeroOrMoreBlock blk)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|,
name|ZeroOrMoreBlock
name|blk
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"look*("
operator|+
name|k
operator|+
literal|","
operator|+
name|blk
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|Lookahead
name|p
init|=
name|look
argument_list|(
name|k
argument_list|,
operator|(
name|AlternativeBlock
operator|)
name|blk
argument_list|)
decl_stmt|;
name|Lookahead
name|q
init|=
name|blk
operator|.
name|next
operator|.
name|look
argument_list|(
name|k
argument_list|)
decl_stmt|;
name|p
operator|.
name|combineWith
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/**Compute the combined lookahead for all productions of a rule. 	 * If the lookahead returns with epsilon, at least one epsilon 	 * path exists (one that consumes no tokens).  The noFOLLOW 	 * flag being set for this endruleblk, indicates that the 	 * a rule ref invoked this rule. 	 * 	 * Currently only look(RuleRef) calls this.  There is no need 	 * for the code generator to call this. 	 */
DECL|method|look (int k, String rule)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|,
name|String
name|rule
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"lookRuleName("
operator|+
name|k
operator|+
literal|","
operator|+
name|rule
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|grammar
operator|.
name|getSymbol
argument_list|(
name|rule
argument_list|)
decl_stmt|;
name|RuleBlock
name|rb
init|=
name|rs
operator|.
name|getBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|rb
operator|.
name|lock
index|[
name|k
index|]
condition|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"infinite recursion to rule "
operator|+
name|rb
operator|.
name|getRuleName
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|Lookahead
argument_list|(
name|rule
argument_list|)
return|;
block|}
comment|// have we computed it before?
if|if
condition|(
name|rb
operator|.
name|cache
index|[
name|k
index|]
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"found depth "
operator|+
name|k
operator|+
literal|" result in FIRST "
operator|+
name|rule
operator|+
literal|" cache: "
operator|+
name|rb
operator|.
name|cache
index|[
name|k
index|]
operator|.
name|toString
argument_list|(
literal|","
argument_list|,
name|charFormatter
argument_list|,
name|grammar
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|Lookahead
operator|)
name|rb
operator|.
name|cache
index|[
name|k
index|]
operator|.
name|clone
argument_list|()
return|;
block|}
name|rb
operator|.
name|lock
index|[
name|k
index|]
operator|=
literal|true
expr_stmt|;
name|Lookahead
name|p
init|=
name|look
argument_list|(
name|k
argument_list|,
operator|(
name|RuleBlock
operator|)
name|rb
argument_list|)
decl_stmt|;
name|rb
operator|.
name|lock
index|[
name|k
index|]
operator|=
literal|false
expr_stmt|;
comment|// cache results
name|rb
operator|.
name|cache
index|[
name|k
index|]
operator|=
operator|(
name|Lookahead
operator|)
name|p
operator|.
name|clone
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG_ANALYZER
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"saving depth "
operator|+
name|k
operator|+
literal|" result in FIRST "
operator|+
name|rule
operator|+
literal|" cache: "
operator|+
name|rb
operator|.
name|cache
index|[
name|k
index|]
operator|.
name|toString
argument_list|(
literal|","
argument_list|,
name|charFormatter
argument_list|,
name|grammar
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
comment|/** If the first k-1 sets are singleton sets, the appoximate 	 *  lookahead analysis is equivalent to full lookahead analysis. 	 */
DECL|method|lookaheadEquivForApproxAndFullAnalysis (Lookahead[] bset, int k)
specifier|public
specifier|static
name|boolean
name|lookaheadEquivForApproxAndFullAnalysis
parameter_list|(
name|Lookahead
index|[]
name|bset
parameter_list|,
name|int
name|k
parameter_list|)
block|{
comment|// first k-1 sets degree 1?
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|k
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|BitSet
name|look
init|=
name|bset
index|[
name|i
index|]
operator|.
name|fset
decl_stmt|;
if|if
condition|(
name|look
operator|.
name|degree
argument_list|()
operator|>
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/** Remove the prediction sets from preceding alternatives 	 * and follow set, but *only* if this element is the first element  	 * of the alternative.  The class members currenBlock and 	 * currentBlock.analysisAlt must be set correctly. 	 * @param b The prediction bitset to be modified 	 * @el The element of interest 	 */
DECL|method|removeCompetingPredictionSets (BitSet b, AlternativeElement el)
specifier|private
name|void
name|removeCompetingPredictionSets
parameter_list|(
name|BitSet
name|b
parameter_list|,
name|AlternativeElement
name|el
parameter_list|)
block|{
comment|// Only do this if the element is the first element of the alt,
comment|// because we are making an implicit assumption that k==1.
name|GrammarElement
name|head
init|=
name|currentBlock
operator|.
name|getAlternativeAt
argument_list|(
name|currentBlock
operator|.
name|analysisAlt
argument_list|)
operator|.
name|head
decl_stmt|;
comment|// if element is #(. blah) then check to see if el is root
if|if
condition|(
name|head
operator|instanceof
name|TreeElement
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|TreeElement
operator|)
name|head
operator|)
operator|.
name|root
operator|!=
name|el
condition|)
block|{
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|el
operator|!=
name|head
condition|)
block|{
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|currentBlock
operator|.
name|analysisAlt
condition|;
name|i
operator|++
control|)
block|{
name|AlternativeElement
name|e
init|=
name|currentBlock
operator|.
name|getAlternativeAt
argument_list|(
name|i
argument_list|)
operator|.
name|head
decl_stmt|;
name|b
operator|.
name|subtractInPlace
argument_list|(
name|e
operator|.
name|look
argument_list|(
literal|1
argument_list|)
operator|.
name|fset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Remove the prediction sets from preceding alternatives 	 * The class members currenBlock must be set correctly. 	 * Remove prediction sets from 1..k. 	 * @param look The prediction lookahead to be modified 	 * @el The element of interest 	 * @k  How deep into lookahead to modify 	 */
DECL|method|removeCompetingPredictionSetsFromWildcard (Lookahead[] look, AlternativeElement el, int k)
specifier|private
name|void
name|removeCompetingPredictionSetsFromWildcard
parameter_list|(
name|Lookahead
index|[]
name|look
parameter_list|,
name|AlternativeElement
name|el
parameter_list|,
name|int
name|k
parameter_list|)
block|{
for|for
control|(
name|int
name|d
init|=
literal|1
init|;
name|d
operator|<=
name|k
condition|;
name|d
operator|++
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|currentBlock
operator|.
name|analysisAlt
condition|;
name|i
operator|++
control|)
block|{
name|AlternativeElement
name|e
init|=
name|currentBlock
operator|.
name|getAlternativeAt
argument_list|(
name|i
argument_list|)
operator|.
name|head
decl_stmt|;
name|look
index|[
name|d
index|]
operator|.
name|fset
operator|.
name|subtractInPlace
argument_list|(
name|e
operator|.
name|look
argument_list|(
name|d
argument_list|)
operator|.
name|fset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** reset the analyzer so it looks like a new one */
DECL|method|reset ()
specifier|private
name|void
name|reset
parameter_list|()
block|{
name|grammar
operator|=
literal|null
expr_stmt|;
name|DEBUG_ANALYZER
operator|=
literal|false
expr_stmt|;
name|currentBlock
operator|=
literal|null
expr_stmt|;
name|lexicalAnalysis
operator|=
literal|false
expr_stmt|;
block|}
comment|/** Set the grammar for the analyzer */
DECL|method|setGrammar (Grammar g)
specifier|public
name|void
name|setGrammar
parameter_list|(
name|Grammar
name|g
parameter_list|)
block|{
if|if
condition|(
name|grammar
operator|!=
literal|null
condition|)
block|{
name|reset
argument_list|()
expr_stmt|;
block|}
name|grammar
operator|=
name|g
expr_stmt|;
comment|// Is this lexical?
name|lexicalAnalysis
operator|=
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
expr_stmt|;
name|DEBUG_ANALYZER
operator|=
name|grammar
operator|.
name|analyzerDebug
expr_stmt|;
block|}
DECL|method|subruleCanBeInverted (AlternativeBlock blk, boolean forLexer)
specifier|public
name|boolean
name|subruleCanBeInverted
parameter_list|(
name|AlternativeBlock
name|blk
parameter_list|,
name|boolean
name|forLexer
parameter_list|)
block|{
if|if
condition|(
name|blk
operator|instanceof
name|ZeroOrMoreBlock
operator|||
name|blk
operator|instanceof
name|OneOrMoreBlock
operator|||
name|blk
operator|instanceof
name|SynPredBlock
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Cannot invert an empty subrule
if|if
condition|(
name|blk
operator|.
name|alternatives
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// The block must only contain alternatives with a single element,
comment|// where each element is a char, token, char range, or token range.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blk
operator|.
name|alternatives
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Alternative
name|alt
init|=
name|blk
operator|.
name|getAlternativeAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Cannot have anything interesting in the alternative ...
if|if
condition|(
name|alt
operator|.
name|synPred
operator|!=
literal|null
operator|||
name|alt
operator|.
name|semPred
operator|!=
literal|null
operator|||
name|alt
operator|.
name|exceptionSpec
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// ... and there must be one simple element
name|AlternativeElement
name|elt
init|=
name|alt
operator|.
name|head
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|elt
operator|instanceof
name|CharLiteralElement
operator|||
name|elt
operator|instanceof
name|TokenRefElement
operator|||
name|elt
operator|instanceof
name|CharRangeElement
operator|||
name|elt
operator|instanceof
name|TokenRangeElement
operator|||
operator|(
name|elt
operator|instanceof
name|StringLiteralElement
operator|&&
operator|!
name|forLexer
operator|)
operator|)
operator|||
operator|!
operator|(
name|elt
operator|.
name|next
operator|instanceof
name|BlockEndElement
operator|)
operator|||
name|elt
operator|.
name|getAutoGenType
argument_list|()
operator|!=
name|GrammarElement
operator|.
name|AUTO_GEN_NONE
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
end_class

end_unit

