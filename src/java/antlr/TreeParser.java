begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/RIGHTS.html  *  * $Id$  */
end_comment

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|AST
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|BitSet
import|;
end_import

begin_class
DECL|class|TreeParser
specifier|public
class|class
name|TreeParser
block|{
comment|/** The AST Null object; the parsing cursor is set to this when 	 *  it is found to be null.  This way, we can test the 	 *  token type of a node without having to have tests for null 	 *  everywhere. 	 */
DECL|field|ASTNULL
specifier|public
specifier|static
name|ASTNULLType
name|ASTNULL
init|=
operator|new
name|ASTNULLType
argument_list|()
decl_stmt|;
comment|/** Where did this rule leave off parsing; avoids a return parameter */
DECL|field|_retTree
specifier|protected
name|AST
name|_retTree
decl_stmt|;
comment|/** guessing nesting level; guessing==0 implies not guessing */
comment|// protected int guessing = 0;
comment|/** Nesting level of registered handlers */
comment|// protected int exceptionLevel = 0;
DECL|field|inputState
specifier|protected
name|TreeParserSharedInputState
name|inputState
decl_stmt|;
comment|/** Table of token type to token names */
DECL|field|tokenNames
specifier|protected
name|String
index|[]
name|tokenNames
decl_stmt|;
comment|/** AST return value for a rule is squirreled away here */
DECL|field|returnAST
specifier|protected
name|AST
name|returnAST
decl_stmt|;
comment|/** AST support code; parser and treeparser delegate to this object */
DECL|field|astFactory
specifier|protected
name|ASTFactory
name|astFactory
init|=
operator|new
name|ASTFactory
argument_list|()
decl_stmt|;
comment|/** Used to keep track of indentdepth for traceIn/Out */
DECL|field|traceDepth
specifier|protected
name|int
name|traceDepth
init|=
literal|0
decl_stmt|;
DECL|method|TreeParser ()
specifier|public
name|TreeParser
parameter_list|()
block|{
name|inputState
operator|=
operator|new
name|TreeParserSharedInputState
argument_list|()
expr_stmt|;
block|}
comment|/** Get the AST return value squirreled away in the parser */
DECL|method|getAST ()
specifier|public
name|AST
name|getAST
parameter_list|()
block|{
return|return
name|returnAST
return|;
block|}
DECL|method|getASTFactory ()
specifier|public
name|ASTFactory
name|getASTFactory
parameter_list|()
block|{
return|return
name|astFactory
return|;
block|}
DECL|method|getTokenName (int num)
specifier|public
name|String
name|getTokenName
parameter_list|(
name|int
name|num
parameter_list|)
block|{
return|return
name|tokenNames
index|[
name|num
index|]
return|;
block|}
DECL|method|getTokenNames ()
specifier|public
name|String
index|[]
name|getTokenNames
parameter_list|()
block|{
return|return
name|tokenNames
return|;
block|}
DECL|method|match (AST t, int ttype)
specifier|protected
name|void
name|match
parameter_list|(
name|AST
name|t
parameter_list|,
name|int
name|ttype
parameter_list|)
throws|throws
name|MismatchedTokenException
block|{
comment|//System.out.println("match("+ttype+"); cursor is "+t);
if|if
condition|(
name|t
operator|==
literal|null
operator|||
name|t
operator|==
name|ASTNULL
operator|||
name|t
operator|.
name|getType
argument_list|()
operator|!=
name|ttype
condition|)
block|{
throw|throw
operator|new
name|MismatchedTokenException
argument_list|(
name|getTokenNames
argument_list|()
argument_list|,
name|t
argument_list|,
name|ttype
argument_list|,
literal|false
argument_list|)
throw|;
block|}
block|}
comment|/**Make sure current lookahead symbol matches the given set 	 * Throw an exception upon mismatch, which is catch by either the 	 * error handler or by the syntactic predicate. 	 */
DECL|method|match (AST t, BitSet b)
specifier|public
name|void
name|match
parameter_list|(
name|AST
name|t
parameter_list|,
name|BitSet
name|b
parameter_list|)
throws|throws
name|MismatchedTokenException
block|{
if|if
condition|(
name|t
operator|==
literal|null
operator|||
name|t
operator|==
name|ASTNULL
operator|||
operator|!
name|b
operator|.
name|member
argument_list|(
name|t
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|MismatchedTokenException
argument_list|(
name|getTokenNames
argument_list|()
argument_list|,
name|t
argument_list|,
name|b
argument_list|,
literal|false
argument_list|)
throw|;
block|}
block|}
DECL|method|matchNot (AST t, int ttype)
specifier|protected
name|void
name|matchNot
parameter_list|(
name|AST
name|t
parameter_list|,
name|int
name|ttype
parameter_list|)
throws|throws
name|MismatchedTokenException
block|{
comment|//System.out.println("match("+ttype+"); cursor is "+t);
if|if
condition|(
name|t
operator|==
literal|null
operator|||
name|t
operator|==
name|ASTNULL
operator|||
name|t
operator|.
name|getType
argument_list|()
operator|==
name|ttype
condition|)
block|{
throw|throw
operator|new
name|MismatchedTokenException
argument_list|(
name|getTokenNames
argument_list|()
argument_list|,
name|t
argument_list|,
name|ttype
argument_list|,
literal|true
argument_list|)
throw|;
block|}
block|}
DECL|method|panic ()
specifier|public
specifier|static
name|void
name|panic
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"TreeWalker: panic"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/** Parser error-reporting function can be overridden in subclass */
DECL|method|reportError (RecognitionException ex)
specifier|public
name|void
name|reportError
parameter_list|(
name|RecognitionException
name|ex
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|ex
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Parser error-reporting function can be overridden in subclass */
DECL|method|reportError (String s)
specifier|public
name|void
name|reportError
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"error: "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
comment|/** Parser warning-reporting function can be overridden in subclass */
DECL|method|reportWarning (String s)
specifier|public
name|void
name|reportWarning
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
comment|/** Specify an object with support code (shared by 	 *  Parser and TreeParser.  Normally, the programmer 	 *  does not play with this, using setASTNodeType instead. 	 */
DECL|method|setASTFactory (ASTFactory f)
specifier|public
name|void
name|setASTFactory
parameter_list|(
name|ASTFactory
name|f
parameter_list|)
block|{
name|astFactory
operator|=
name|f
expr_stmt|;
block|}
comment|/** Specify the type of node to create during tree building */
DECL|method|setASTNodeType (String nodeType)
specifier|public
name|void
name|setASTNodeType
parameter_list|(
name|String
name|nodeType
parameter_list|)
block|{
name|setASTNodeClass
argument_list|(
name|nodeType
argument_list|)
expr_stmt|;
block|}
comment|/** Specify the type of node to create during tree building */
DECL|method|setASTNodeClass (String nodeType)
specifier|public
name|void
name|setASTNodeClass
parameter_list|(
name|String
name|nodeType
parameter_list|)
block|{
name|astFactory
operator|.
name|setASTNodeType
argument_list|(
name|nodeType
argument_list|)
expr_stmt|;
block|}
DECL|method|traceIndent ()
specifier|public
name|void
name|traceIndent
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|traceDepth
condition|;
name|i
operator|++
control|)
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
DECL|method|traceIn (String rname, AST t)
specifier|public
name|void
name|traceIn
parameter_list|(
name|String
name|rname
parameter_list|,
name|AST
name|t
parameter_list|)
block|{
name|traceDepth
operator|+=
literal|1
expr_stmt|;
name|traceIndent
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"> "
operator|+
name|rname
operator|+
literal|"("
operator|+
operator|(
name|t
operator|!=
literal|null
condition|?
name|t
operator|.
name|toString
argument_list|()
else|:
literal|"null"
operator|)
operator|+
literal|")"
operator|+
operator|(
operator|(
name|inputState
operator|.
name|guessing
operator|>
literal|0
operator|)
condition|?
literal|" [guessing]"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
DECL|method|traceOut (String rname, AST t)
specifier|public
name|void
name|traceOut
parameter_list|(
name|String
name|rname
parameter_list|,
name|AST
name|t
parameter_list|)
block|{
name|traceIndent
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"< "
operator|+
name|rname
operator|+
literal|"("
operator|+
operator|(
name|t
operator|!=
literal|null
condition|?
name|t
operator|.
name|toString
argument_list|()
else|:
literal|"null"
operator|)
operator|+
literal|")"
operator|+
operator|(
operator|(
name|inputState
operator|.
name|guessing
operator|>
literal|0
operator|)
condition|?
literal|" [guessing]"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|traceDepth
operator|--
expr_stmt|;
block|}
block|}
end_class

end_unit

