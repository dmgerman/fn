begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/RIGHTS.html  *  * $Id$  */
end_comment

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_comment
comment|//SAS: changed for proper text file io
end_comment

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileWriter
import|;
end_import

begin_comment
comment|/**Generate MyParser.txt, MyLexer.txt and MyParserTokenTypes.txt */
end_comment

begin_class
DECL|class|DiagnosticCodeGenerator
specifier|public
class|class
name|DiagnosticCodeGenerator
extends|extends
name|CodeGenerator
block|{
comment|/** non-zero if inside syntactic predicate generation */
DECL|field|syntacticPredLevel
specifier|protected
name|int
name|syntacticPredLevel
init|=
literal|0
decl_stmt|;
comment|/** true during lexer generation, false during parser generation */
DECL|field|doingLexRules
specifier|protected
name|boolean
name|doingLexRules
init|=
literal|false
decl_stmt|;
comment|/** Create a Diagnostic code-generator using the given Grammar 	 * The caller must still call setTool, setBehavior, and setAnalyzer 	 * before generating code. 	 */
DECL|method|DiagnosticCodeGenerator ()
specifier|public
name|DiagnosticCodeGenerator
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
name|charFormatter
operator|=
operator|new
name|JavaCharFormatter
argument_list|()
expr_stmt|;
block|}
comment|/**Generate the parser, lexer, and token types documentation */
DECL|method|gen ()
specifier|public
name|void
name|gen
parameter_list|()
block|{
comment|// Do the code generation
try|try
block|{
comment|// Loop over all grammars
name|Enumeration
name|grammarIter
init|=
name|behavior
operator|.
name|grammars
operator|.
name|elements
argument_list|()
decl_stmt|;
while|while
condition|(
name|grammarIter
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|Grammar
name|g
init|=
operator|(
name|Grammar
operator|)
name|grammarIter
operator|.
name|nextElement
argument_list|()
decl_stmt|;
comment|// Connect all the components to each other
name|g
operator|.
name|setGrammarAnalyzer
argument_list|(
name|analyzer
argument_list|)
expr_stmt|;
name|g
operator|.
name|setCodeGenerator
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|setGrammar
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|// To get right overloading behavior across hetrogeneous grammars
name|g
operator|.
name|generate
argument_list|()
expr_stmt|;
if|if
condition|(
name|tool
operator|.
name|hasError
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Exiting due to errors."
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Loop over all token managers (some of which are lexers)
name|Enumeration
name|tmIter
init|=
name|behavior
operator|.
name|tokenManagers
operator|.
name|elements
argument_list|()
decl_stmt|;
while|while
condition|(
name|tmIter
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|TokenManager
name|tm
init|=
operator|(
name|TokenManager
operator|)
name|tmIter
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|tm
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
comment|// Write the token manager tokens as Java
name|genTokenTypes
argument_list|(
name|tm
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The {...} action to generate 	 */
DECL|method|gen (ActionElement action)
specifier|public
name|void
name|gen
parameter_list|(
name|ActionElement
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|.
name|isSemPred
condition|)
block|{
comment|// handled elsewhere
block|}
else|else
block|{
name|print
argument_list|(
literal|"ACTION: "
argument_list|)
expr_stmt|;
name|_printAction
argument_list|(
name|action
operator|.
name|actionText
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The "x|y|z|..." block to generate 	 */
DECL|method|gen (AlternativeBlock blk)
specifier|public
name|void
name|gen
parameter_list|(
name|AlternativeBlock
name|blk
parameter_list|)
block|{
name|println
argument_list|(
literal|"Start of alternative block."
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|genBlockPreamble
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|boolean
name|ok
init|=
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|deterministic
argument_list|(
name|blk
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|println
argument_list|(
literal|"Warning: This alternative block is non-deterministic"
argument_list|)
expr_stmt|;
block|}
name|genCommonBlock
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The block-end element to generate.  Block-end 	 * elements are synthesized by the grammar parser to represent 	 * the end of a block. 	 */
DECL|method|gen (BlockEndElement end)
specifier|public
name|void
name|gen
parameter_list|(
name|BlockEndElement
name|end
parameter_list|)
block|{
comment|// no-op
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The character literal reference to generate 	 */
DECL|method|gen (CharLiteralElement atom)
specifier|public
name|void
name|gen
parameter_list|(
name|CharLiteralElement
name|atom
parameter_list|)
block|{
name|print
argument_list|(
literal|"Match character "
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|.
name|not
condition|)
block|{
name|_print
argument_list|(
literal|"NOT "
argument_list|)
expr_stmt|;
block|}
name|_print
argument_list|(
name|atom
operator|.
name|atomText
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|.
name|label
operator|!=
literal|null
condition|)
block|{
name|_print
argument_list|(
literal|", label="
operator|+
name|atom
operator|.
name|label
argument_list|)
expr_stmt|;
block|}
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The character-range reference to generate 	 */
DECL|method|gen (CharRangeElement r)
specifier|public
name|void
name|gen
parameter_list|(
name|CharRangeElement
name|r
parameter_list|)
block|{
name|print
argument_list|(
literal|"Match character range: "
operator|+
name|r
operator|.
name|beginText
operator|+
literal|".."
operator|+
name|r
operator|.
name|endText
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|label
operator|!=
literal|null
condition|)
block|{
name|_print
argument_list|(
literal|", label = "
operator|+
name|r
operator|.
name|label
argument_list|)
expr_stmt|;
block|}
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/** Generate the lexer TXT file */
DECL|method|gen (LexerGrammar g)
specifier|public
name|void
name|gen
parameter_list|(
name|LexerGrammar
name|g
parameter_list|)
throws|throws
name|IOException
block|{
name|setGrammar
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Generating "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
name|TokenTypesFileExt
argument_list|)
expr_stmt|;
name|currentOutput
operator|=
name|antlr
operator|.
name|Tool
operator|.
name|openOutputFile
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
name|TokenTypesFileExt
argument_list|)
expr_stmt|;
comment|//SAS: changed for proper text file io
name|tabs
operator|=
literal|0
expr_stmt|;
name|doingLexRules
operator|=
literal|true
expr_stmt|;
comment|// Generate header common to all TXT output files
name|genHeader
argument_list|()
expr_stmt|;
comment|// Output the user-defined lexer premamble
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** Lexer Preamble Action."
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"This action will appear before the declaration of your lexer class:"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
name|grammar
operator|.
name|preambleAction
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"*** End of Lexer Preamble Action"
argument_list|)
expr_stmt|;
comment|// Generate lexer class definition
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** Your lexer class is called '"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"' and is a subclass of '"
operator|+
name|grammar
operator|.
name|getSuperClass
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
comment|// Generate user-defined parser class members
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** User-defined lexer  class members:"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"These are the member declarations that you defined for your class:"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|printAction
argument_list|(
name|grammar
operator|.
name|classMemberAction
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"*** End of user-defined lexer class members"
argument_list|)
expr_stmt|;
comment|// Generate string literals
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** String literals used in the parser"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"The following string literals were used in the parser."
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"An actual code generator would arrange to place these literals"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"into a table in the generated lexer, so that actions in the"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"generated lexer could match token text against the literals."
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"String literals used in the lexer are not listed here, as they"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"are incorporated into the mainstream lexer processing."
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// Enumerate all of the symbols and look for string literal symbols
name|Enumeration
name|ids
init|=
name|grammar
operator|.
name|getSymbols
argument_list|()
decl_stmt|;
while|while
condition|(
name|ids
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|GrammarSymbol
name|sym
init|=
operator|(
name|GrammarSymbol
operator|)
name|ids
operator|.
name|nextElement
argument_list|()
decl_stmt|;
comment|// Only processing string literals -- reject other symbol entries
if|if
condition|(
name|sym
operator|instanceof
name|StringLiteralSymbol
condition|)
block|{
name|StringLiteralSymbol
name|s
init|=
operator|(
name|StringLiteralSymbol
operator|)
name|sym
decl_stmt|;
name|println
argument_list|(
name|s
operator|.
name|getId
argument_list|()
operator|+
literal|" = "
operator|+
name|s
operator|.
name|getTokenType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"*** End of string literals used by the parser"
argument_list|)
expr_stmt|;
comment|// Generate nextToken() rule.
comment|// nextToken() is a synthetic lexer rule that is the implicit OR of all
comment|// user-defined lexer rules.
name|genNextToken
argument_list|()
expr_stmt|;
comment|// Generate code for each rule in the lexer
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** User-defined Lexer rules:"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|ids
operator|=
name|grammar
operator|.
name|rules
operator|.
name|elements
argument_list|()
expr_stmt|;
while|while
condition|(
name|ids
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|ids
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|id
operator|.
name|equals
argument_list|(
literal|"mnextToken"
argument_list|)
condition|)
block|{
name|genRule
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
block|}
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** End User-defined Lexer rules:"
argument_list|)
expr_stmt|;
comment|// Close the lexer output file
name|currentOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentOutput
operator|=
literal|null
expr_stmt|;
name|doingLexRules
operator|=
literal|false
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The (...)+ block to generate 	 */
DECL|method|gen (OneOrMoreBlock blk)
specifier|public
name|void
name|gen
parameter_list|(
name|OneOrMoreBlock
name|blk
parameter_list|)
block|{
name|println
argument_list|(
literal|"Start ONE-OR-MORE (...)+ block:"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|genBlockPreamble
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|boolean
name|ok
init|=
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|deterministic
argument_list|(
name|blk
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|println
argument_list|(
literal|"Warning: This one-or-more block is non-deterministic"
argument_list|)
expr_stmt|;
block|}
name|genCommonBlock
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"End ONE-OR-MORE block."
argument_list|)
expr_stmt|;
block|}
comment|/** Generate the parser TXT file */
DECL|method|gen (ParserGrammar g)
specifier|public
name|void
name|gen
parameter_list|(
name|ParserGrammar
name|g
parameter_list|)
throws|throws
name|IOException
block|{
name|setGrammar
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|// Open the output stream for the parser and set the currentOutput
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Generating "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
name|TokenTypesFileExt
argument_list|)
expr_stmt|;
name|currentOutput
operator|=
name|antlr
operator|.
name|Tool
operator|.
name|openOutputFile
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
name|TokenTypesFileExt
argument_list|)
expr_stmt|;
comment|//SAS: changed for proper text file io
name|tabs
operator|=
literal|0
expr_stmt|;
comment|// Generate the header common to all output files.
name|genHeader
argument_list|()
expr_stmt|;
comment|// Output the user-defined parser premamble
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** Parser Preamble Action."
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"This action will appear before the declaration of your parser class:"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
name|grammar
operator|.
name|preambleAction
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"*** End of Parser Preamble Action"
argument_list|)
expr_stmt|;
comment|// Generate parser class definition
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** Your parser class is called '"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"' and is a subclass of '"
operator|+
name|grammar
operator|.
name|getSuperClass
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
comment|// Generate user-defined parser class members
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** User-defined parser class members:"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"These are the member declarations that you defined for your class:"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|printAction
argument_list|(
name|grammar
operator|.
name|classMemberAction
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"*** End of user-defined parser class members"
argument_list|)
expr_stmt|;
comment|// Generate code for each rule in the grammar
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** Parser rules:"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// Enumerate the parser rules
name|Enumeration
name|rules
init|=
name|grammar
operator|.
name|rules
operator|.
name|elements
argument_list|()
decl_stmt|;
while|while
condition|(
name|rules
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// Get the rules from the list and downcast it to proper type
name|GrammarSymbol
name|sym
init|=
operator|(
name|GrammarSymbol
operator|)
name|rules
operator|.
name|nextElement
argument_list|()
decl_stmt|;
comment|// Only process parser rules
if|if
condition|(
name|sym
operator|instanceof
name|RuleSymbol
condition|)
block|{
name|genRule
argument_list|(
operator|(
name|RuleSymbol
operator|)
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** End of parser rules"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** End of parser"
argument_list|)
expr_stmt|;
comment|// Close the parser output stream
name|currentOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentOutput
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The rule-reference to generate 	 */
DECL|method|gen (RuleRefElement rr)
specifier|public
name|void
name|gen
parameter_list|(
name|RuleRefElement
name|rr
parameter_list|)
block|{
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|grammar
operator|.
name|getSymbol
argument_list|(
name|rr
operator|.
name|targetRule
argument_list|)
decl_stmt|;
comment|// Generate the actual rule description
name|print
argument_list|(
literal|"Rule Reference: "
operator|+
name|rr
operator|.
name|targetRule
argument_list|)
expr_stmt|;
if|if
condition|(
name|rr
operator|.
name|idAssign
operator|!=
literal|null
condition|)
block|{
name|_print
argument_list|(
literal|", assigned to '"
operator|+
name|rr
operator|.
name|idAssign
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rr
operator|.
name|args
operator|!=
literal|null
condition|)
block|{
name|_print
argument_list|(
literal|", arguments = "
operator|+
name|rr
operator|.
name|args
argument_list|)
expr_stmt|;
block|}
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// Perform diagnostics
if|if
condition|(
name|rs
operator|==
literal|null
operator|||
operator|!
name|rs
operator|.
name|isDefined
argument_list|()
condition|)
block|{
name|println
argument_list|(
literal|"Rule '"
operator|+
name|rr
operator|.
name|targetRule
operator|+
literal|"' is referenced, but that rule is not defined."
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"\tPerhaps the rule is misspelled, or you forgot to define it."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|rs
operator|instanceof
name|RuleSymbol
operator|)
condition|)
block|{
comment|// Should this ever happen??
name|println
argument_list|(
literal|"Rule '"
operator|+
name|rr
operator|.
name|targetRule
operator|+
literal|"' is referenced, but that is not a grammar rule."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rr
operator|.
name|idAssign
operator|!=
literal|null
condition|)
block|{
comment|// Warn if the rule has no return type
if|if
condition|(
name|rs
operator|.
name|block
operator|.
name|returnAction
operator|==
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"Error: You assigned from Rule '"
operator|+
name|rr
operator|.
name|targetRule
operator|+
literal|"', but that rule has no return type."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Warn about return value if any, but not inside syntactic predicate
if|if
condition|(
operator|!
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
operator|&&
name|syntacticPredLevel
operator|==
literal|0
operator|&&
name|rs
operator|.
name|block
operator|.
name|returnAction
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"Warning: Rule '"
operator|+
name|rr
operator|.
name|targetRule
operator|+
literal|"' returns a value"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rr
operator|.
name|args
operator|!=
literal|null
operator|&&
name|rs
operator|.
name|block
operator|.
name|argAction
operator|==
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"Error: Rule '"
operator|+
name|rr
operator|.
name|targetRule
operator|+
literal|"' accepts no arguments."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The string-literal reference to generate 	 */
DECL|method|gen (StringLiteralElement atom)
specifier|public
name|void
name|gen
parameter_list|(
name|StringLiteralElement
name|atom
parameter_list|)
block|{
name|print
argument_list|(
literal|"Match string literal "
argument_list|)
expr_stmt|;
name|_print
argument_list|(
name|atom
operator|.
name|atomText
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|.
name|label
operator|!=
literal|null
condition|)
block|{
name|_print
argument_list|(
literal|", label="
operator|+
name|atom
operator|.
name|label
argument_list|)
expr_stmt|;
block|}
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The token-range reference to generate 	 */
DECL|method|gen (TokenRangeElement r)
specifier|public
name|void
name|gen
parameter_list|(
name|TokenRangeElement
name|r
parameter_list|)
block|{
name|print
argument_list|(
literal|"Match token range: "
operator|+
name|r
operator|.
name|beginText
operator|+
literal|".."
operator|+
name|r
operator|.
name|endText
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|label
operator|!=
literal|null
condition|)
block|{
name|_print
argument_list|(
literal|", label = "
operator|+
name|r
operator|.
name|label
argument_list|)
expr_stmt|;
block|}
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The token-reference to generate 	 */
DECL|method|gen (TokenRefElement atom)
specifier|public
name|void
name|gen
parameter_list|(
name|TokenRefElement
name|atom
parameter_list|)
block|{
name|print
argument_list|(
literal|"Match token "
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|.
name|not
condition|)
block|{
name|_print
argument_list|(
literal|"NOT "
argument_list|)
expr_stmt|;
block|}
name|_print
argument_list|(
name|atom
operator|.
name|atomText
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|.
name|label
operator|!=
literal|null
condition|)
block|{
name|_print
argument_list|(
literal|", label="
operator|+
name|atom
operator|.
name|label
argument_list|)
expr_stmt|;
block|}
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
DECL|method|gen (TreeElement t)
specifier|public
name|void
name|gen
parameter_list|(
name|TreeElement
name|t
parameter_list|)
block|{
name|print
argument_list|(
literal|"Tree reference: "
operator|+
name|t
argument_list|)
expr_stmt|;
block|}
comment|/** Generate the tree-walker TXT file */
DECL|method|gen (TreeWalkerGrammar g)
specifier|public
name|void
name|gen
parameter_list|(
name|TreeWalkerGrammar
name|g
parameter_list|)
throws|throws
name|IOException
block|{
name|setGrammar
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|// Open the output stream for the parser and set the currentOutput
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Generating "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
name|TokenTypesFileExt
argument_list|)
expr_stmt|;
name|currentOutput
operator|=
name|antlr
operator|.
name|Tool
operator|.
name|openOutputFile
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
name|TokenTypesFileExt
argument_list|)
expr_stmt|;
comment|//SAS: changed for proper text file io
name|tabs
operator|=
literal|0
expr_stmt|;
comment|// Generate the header common to all output files.
name|genHeader
argument_list|()
expr_stmt|;
comment|// Output the user-defined parser premamble
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** Tree-walker Preamble Action."
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"This action will appear before the declaration of your tree-walker class:"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
name|grammar
operator|.
name|preambleAction
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"*** End of tree-walker Preamble Action"
argument_list|)
expr_stmt|;
comment|// Generate tree-walker class definition
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** Your tree-walker class is called '"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"' and is a subclass of '"
operator|+
name|grammar
operator|.
name|getSuperClass
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
comment|// Generate user-defined tree-walker class members
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** User-defined tree-walker class members:"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"These are the member declarations that you defined for your class:"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|printAction
argument_list|(
name|grammar
operator|.
name|classMemberAction
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"*** End of user-defined tree-walker class members"
argument_list|)
expr_stmt|;
comment|// Generate code for each rule in the grammar
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** tree-walker rules:"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// Enumerate the tree-walker rules
name|Enumeration
name|rules
init|=
name|grammar
operator|.
name|rules
operator|.
name|elements
argument_list|()
decl_stmt|;
while|while
condition|(
name|rules
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// Get the rules from the list and downcast it to proper type
name|GrammarSymbol
name|sym
init|=
operator|(
name|GrammarSymbol
operator|)
name|rules
operator|.
name|nextElement
argument_list|()
decl_stmt|;
comment|// Only process tree-walker rules
if|if
condition|(
name|sym
operator|instanceof
name|RuleSymbol
condition|)
block|{
name|genRule
argument_list|(
operator|(
name|RuleSymbol
operator|)
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** End of tree-walker rules"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** End of tree-walker"
argument_list|)
expr_stmt|;
comment|// Close the tree-walker output stream
name|currentOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentOutput
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Generate a wildcard element */
DECL|method|gen (WildcardElement wc)
specifier|public
name|void
name|gen
parameter_list|(
name|WildcardElement
name|wc
parameter_list|)
block|{
name|print
argument_list|(
literal|"Match wildcard"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|_print
argument_list|(
literal|", label = "
operator|+
name|wc
operator|.
name|getLabel
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The (...)* block to generate 	 */
DECL|method|gen (ZeroOrMoreBlock blk)
specifier|public
name|void
name|gen
parameter_list|(
name|ZeroOrMoreBlock
name|blk
parameter_list|)
block|{
name|println
argument_list|(
literal|"Start ZERO-OR-MORE (...)+ block:"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|genBlockPreamble
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|boolean
name|ok
init|=
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|deterministic
argument_list|(
name|blk
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|println
argument_list|(
literal|"Warning: This zero-or-more block is non-deterministic"
argument_list|)
expr_stmt|;
block|}
name|genCommonBlock
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"End ZERO-OR-MORE block."
argument_list|)
expr_stmt|;
block|}
DECL|method|genAlt (Alternative alt)
specifier|protected
name|void
name|genAlt
parameter_list|(
name|Alternative
name|alt
parameter_list|)
block|{
for|for
control|(
name|AlternativeElement
name|elem
init|=
name|alt
operator|.
name|head
init|;
operator|!
operator|(
name|elem
operator|instanceof
name|BlockEndElement
operator|)
condition|;
name|elem
operator|=
name|elem
operator|.
name|next
control|)
block|{
name|elem
operator|.
name|generate
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|alt
operator|.
name|getTreeSpecifier
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"AST will be built as: "
operator|+
name|alt
operator|.
name|getTreeSpecifier
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate the header for a block, which may be a RuleBlock or a 	 * plain AlternativeBLock.  This generates any variable declarations, 	 * init-actions, and syntactic-predicate-testing variables. 	 * @blk The block for which the preamble is to be generated. 	 */
DECL|method|genBlockPreamble (AlternativeBlock blk)
specifier|protected
name|void
name|genBlockPreamble
parameter_list|(
name|AlternativeBlock
name|blk
parameter_list|)
block|{
comment|// dump out init action
if|if
condition|(
name|blk
operator|.
name|initAction
operator|!=
literal|null
condition|)
block|{
name|printAction
argument_list|(
literal|"Init action: "
operator|+
name|blk
operator|.
name|initAction
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**Generate common code for a block of alternatives; return a postscript 	 * that needs to be generated at the end of the block.  Other routines 	 * may append else-clauses and such for error checking before the postfix 	 * is generated. 	 */
DECL|method|genCommonBlock (AlternativeBlock blk)
specifier|public
name|void
name|genCommonBlock
parameter_list|(
name|AlternativeBlock
name|blk
parameter_list|)
block|{
name|boolean
name|singleAlt
init|=
operator|(
name|blk
operator|.
name|alternatives
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
decl_stmt|;
name|println
argument_list|(
literal|"Start of an alternative block."
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"The lookahead set for this block is:"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|genLookaheadSetForBlock
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
if|if
condition|(
name|singleAlt
condition|)
block|{
name|println
argument_list|(
literal|"This block has a single alternative"
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|.
name|getAlternativeAt
argument_list|(
literal|0
argument_list|)
operator|.
name|synPred
operator|!=
literal|null
condition|)
block|{
comment|// Generate a warning if there is one alt and it has a synPred
name|println
argument_list|(
literal|"Warning: you specified a syntactic predicate for this alternative,"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"and it is the only alternative of a block and will be ignored."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|println
argument_list|(
literal|"This block has multiple alternatives:"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blk
operator|.
name|alternatives
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Alternative
name|alt
init|=
name|blk
operator|.
name|getAlternativeAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|AlternativeElement
name|elem
init|=
name|alt
operator|.
name|head
decl_stmt|;
comment|// Print lookahead set for alternate
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|print
argument_list|(
literal|"Otherwise, "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|_println
argument_list|(
literal|"Alternate("
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|") will be taken IF:"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"The lookahead set: "
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|genLookaheadSetForAlt
argument_list|(
name|alt
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
if|if
condition|(
name|alt
operator|.
name|semPred
operator|!=
literal|null
operator|||
name|alt
operator|.
name|synPred
operator|!=
literal|null
condition|)
block|{
name|print
argument_list|(
literal|"is matched, AND "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
literal|"is matched."
argument_list|)
expr_stmt|;
block|}
comment|// Dump semantic predicates
if|if
condition|(
name|alt
operator|.
name|semPred
operator|!=
literal|null
condition|)
block|{
name|_println
argument_list|(
literal|"the semantic predicate:"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
name|alt
operator|.
name|semPred
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt
operator|.
name|synPred
operator|!=
literal|null
condition|)
block|{
name|print
argument_list|(
literal|"is true, AND "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
literal|"is true."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Dump syntactic predicate
if|if
condition|(
name|alt
operator|.
name|synPred
operator|!=
literal|null
condition|)
block|{
name|_println
argument_list|(
literal|"the syntactic predicate:"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|genSynPred
argument_list|(
name|alt
operator|.
name|synPred
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"is matched."
argument_list|)
expr_stmt|;
block|}
comment|// Dump the alternative
name|genAlt
argument_list|(
name|alt
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"OTHERWISE, a NoViableAlt exception will be thrown"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|singleAlt
condition|)
block|{
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"End of alternatives"
argument_list|)
expr_stmt|;
block|}
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"End of alternative block."
argument_list|)
expr_stmt|;
block|}
comment|/** Generate a textual representation of the follow set 	 * for a block. 	 * @param blk  The rule block of interest 	 */
DECL|method|genFollowSetForRuleBlock (RuleBlock blk)
specifier|public
name|void
name|genFollowSetForRuleBlock
parameter_list|(
name|RuleBlock
name|blk
parameter_list|)
block|{
name|Lookahead
name|follow
init|=
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|FOLLOW
argument_list|(
literal|1
argument_list|,
name|blk
operator|.
name|endNode
argument_list|)
decl_stmt|;
name|printSet
argument_list|(
name|grammar
operator|.
name|maxk
argument_list|,
literal|1
argument_list|,
name|follow
argument_list|)
expr_stmt|;
block|}
comment|/** Generate a header that is common to all TXT files */
DECL|method|genHeader ()
specifier|protected
name|void
name|genHeader
parameter_list|()
block|{
name|println
argument_list|(
literal|"ANTLR-generated file resulting from grammar "
operator|+
name|tool
operator|.
name|grammarFile
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"Diagnostic output"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"Terence Parr, MageLang Institute"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"with John Lilley, Empathy Software"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"ANTLR Version "
operator|+
name|Tool
operator|.
name|version
operator|+
literal|"; 1996,1997"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** Header Action."
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"This action will appear at the top of all generated files."
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|printAction
argument_list|(
name|behavior
operator|.
name|getHeaderAction
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"*** End of Header Action"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/**Generate the lookahead set for an alternate. */
DECL|method|genLookaheadSetForAlt (Alternative alt)
specifier|protected
name|void
name|genLookaheadSetForAlt
parameter_list|(
name|Alternative
name|alt
parameter_list|)
block|{
if|if
condition|(
name|doingLexRules
operator|&&
name|alt
operator|.
name|cache
index|[
literal|1
index|]
operator|.
name|containsEpsilon
argument_list|()
condition|)
block|{
name|println
argument_list|(
literal|"MATCHES ALL"
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|depth
init|=
name|alt
operator|.
name|lookaheadDepth
decl_stmt|;
if|if
condition|(
name|depth
operator|==
name|GrammarAnalyzer
operator|.
name|NONDETERMINISTIC
condition|)
block|{
comment|// if the decision is nondeterministic, do the best we can: LL(k)
comment|// any predicates that are around will be generated later.
name|depth
operator|=
name|grammar
operator|.
name|maxk
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|depth
condition|;
name|i
operator|++
control|)
block|{
name|Lookahead
name|lookahead
init|=
name|alt
operator|.
name|cache
index|[
name|i
index|]
decl_stmt|;
name|printSet
argument_list|(
name|depth
argument_list|,
name|i
argument_list|,
name|lookahead
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate a textual representation of the lookahead set 	 * for a block. 	 * @param blk  The block of interest 	 */
DECL|method|genLookaheadSetForBlock (AlternativeBlock blk)
specifier|public
name|void
name|genLookaheadSetForBlock
parameter_list|(
name|AlternativeBlock
name|blk
parameter_list|)
block|{
comment|// Find the maximal lookahead depth over all alternatives
name|int
name|depth
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blk
operator|.
name|alternatives
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Alternative
name|alt
init|=
name|blk
operator|.
name|getAlternativeAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|alt
operator|.
name|lookaheadDepth
operator|==
name|GrammarAnalyzer
operator|.
name|NONDETERMINISTIC
condition|)
block|{
name|depth
operator|=
name|grammar
operator|.
name|maxk
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|depth
operator|<
name|alt
operator|.
name|lookaheadDepth
condition|)
block|{
name|depth
operator|=
name|alt
operator|.
name|lookaheadDepth
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|depth
condition|;
name|i
operator|++
control|)
block|{
name|Lookahead
name|lookahead
init|=
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|look
argument_list|(
name|i
argument_list|,
name|blk
argument_list|)
decl_stmt|;
name|printSet
argument_list|(
name|depth
argument_list|,
name|i
argument_list|,
name|lookahead
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate the nextToken rule. 	 * nextToken is a synthetic lexer rule that is the implicit OR of all 	 * user-defined lexer rules. 	 */
DECL|method|genNextToken ()
specifier|public
name|void
name|genNextToken
parameter_list|()
block|{
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** Lexer nextToken rule:"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"The lexer nextToken rule is synthesized from all of the user-defined"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"lexer rules.  It logically consists of one big alternative block with"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"each user-defined rule being an alternative."
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// Create the synthesized rule block for nextToken consisting
comment|// of an alternate block containing all the user-defined lexer rules.
name|RuleBlock
name|blk
init|=
name|MakeGrammar
operator|.
name|createNextTokenRule
argument_list|(
name|grammar
argument_list|,
name|grammar
operator|.
name|rules
argument_list|,
literal|"nextToken"
argument_list|)
decl_stmt|;
comment|// Define the nextToken rule symbol
name|RuleSymbol
name|nextTokenRs
init|=
operator|new
name|RuleSymbol
argument_list|(
literal|"mnextToken"
argument_list|)
decl_stmt|;
name|nextTokenRs
operator|.
name|setDefined
argument_list|()
expr_stmt|;
name|nextTokenRs
operator|.
name|setBlock
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|nextTokenRs
operator|.
name|access
operator|=
literal|"private"
expr_stmt|;
name|grammar
operator|.
name|define
argument_list|(
name|nextTokenRs
argument_list|)
expr_stmt|;
comment|// Analyze the synthesized block
if|if
condition|(
operator|!
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|deterministic
argument_list|(
name|blk
argument_list|)
condition|)
block|{
name|println
argument_list|(
literal|"The grammar analyzer has determined that the synthesized"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"nextToken rule is non-deterministic (i.e., it has ambiguities)"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"This means that there is some overlap of the character"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"lookahead for two or more of your lexer rules."
argument_list|)
expr_stmt|;
block|}
name|genCommonBlock
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** End of nextToken lexer rule."
argument_list|)
expr_stmt|;
block|}
comment|/** Generate code for a named rule block 	 * @param s The RuleSymbol describing the rule to generate 	*/
DECL|method|genRule (RuleSymbol s)
specifier|public
name|void
name|genRule
parameter_list|(
name|RuleSymbol
name|s
parameter_list|)
block|{
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|String
name|ruleType
init|=
operator|(
name|doingLexRules
condition|?
literal|"Lexer"
else|:
literal|"Parser"
operator|)
decl_stmt|;
name|println
argument_list|(
literal|"*** "
operator|+
name|ruleType
operator|+
literal|" Rule: "
operator|+
name|s
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|isDefined
argument_list|()
condition|)
block|{
name|println
argument_list|(
literal|"This rule is undefined."
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"This means that the rule was referenced somewhere in the grammar,"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"but a definition for the rule was not encountered."
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"It is also possible that syntax errors during the parse of"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"your grammar file prevented correct processing of the rule."
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** End "
operator|+
name|ruleType
operator|+
literal|" Rule: "
operator|+
name|s
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|tabs
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|access
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|println
argument_list|(
literal|"Access: "
operator|+
name|s
operator|.
name|access
argument_list|)
expr_stmt|;
block|}
comment|// Get rule return type and arguments
name|RuleBlock
name|rblk
init|=
name|s
operator|.
name|getBlock
argument_list|()
decl_stmt|;
comment|// Gen method return value(s)
if|if
condition|(
name|rblk
operator|.
name|returnAction
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"Return value(s): "
operator|+
name|rblk
operator|.
name|returnAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|doingLexRules
condition|)
block|{
name|println
argument_list|(
literal|"Error: you specified return value(s) for a lexical rule."
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"\tLexical rules have an implicit return type of 'int'."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|doingLexRules
condition|)
block|{
name|println
argument_list|(
literal|"Return value: lexical rule returns an implicit token type"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
literal|"Return value: none"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Gen arguments
if|if
condition|(
name|rblk
operator|.
name|argAction
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"Arguments: "
operator|+
name|rblk
operator|.
name|argAction
argument_list|)
expr_stmt|;
block|}
comment|// Dump any init-action
name|genBlockPreamble
argument_list|(
name|rblk
argument_list|)
expr_stmt|;
comment|// Analyze the rule
name|boolean
name|ok
init|=
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|deterministic
argument_list|(
name|rblk
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|println
argument_list|(
literal|"Error: This rule is non-deterministic"
argument_list|)
expr_stmt|;
block|}
comment|// Dump the alternates of the rule
name|genCommonBlock
argument_list|(
name|rblk
argument_list|)
expr_stmt|;
comment|// Search for an unlabeled exception specification attached to the rule
name|ExceptionSpec
name|unlabeledUserSpec
init|=
name|rblk
operator|.
name|findExceptionSpec
argument_list|(
literal|""
argument_list|)
decl_stmt|;
comment|// Generate user-defined or default catch phrases
if|if
condition|(
name|unlabeledUserSpec
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"You specified error-handler(s) for this rule:"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|unlabeledUserSpec
operator|.
name|handlers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|ExceptionHandler
name|handler
init|=
operator|(
name|ExceptionHandler
operator|)
name|unlabeledUserSpec
operator|.
name|handlers
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|println
argument_list|(
literal|"Error-handler("
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|") catches ["
operator|+
name|handler
operator|.
name|exceptionTypeAndName
operator|.
name|getText
argument_list|()
operator|+
literal|"] and executes:"
argument_list|)
expr_stmt|;
name|printAction
argument_list|(
name|handler
operator|.
name|action
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"End error-handlers."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|doingLexRules
condition|)
block|{
name|println
argument_list|(
literal|"Default error-handling will be generated, which catches all"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"parser exceptions and consumes tokens until the follow-set is seen."
argument_list|)
expr_stmt|;
block|}
comment|// Dump the follow set
comment|// Doesn't seem to work for lexical rules...
if|if
condition|(
operator|!
name|doingLexRules
condition|)
block|{
name|println
argument_list|(
literal|"The follow set for this rule is:"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|genFollowSetForRuleBlock
argument_list|(
name|rblk
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
block|}
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"*** End "
operator|+
name|ruleType
operator|+
literal|" Rule: "
operator|+
name|s
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Generate the syntactic predicate.  This basically generates 	 * the alternative block, buts tracks if we are inside a synPred 	 * @param blk  The syntactic predicate block 	 */
DECL|method|genSynPred (SynPredBlock blk)
specifier|protected
name|void
name|genSynPred
parameter_list|(
name|SynPredBlock
name|blk
parameter_list|)
block|{
name|syntacticPredLevel
operator|++
expr_stmt|;
name|gen
argument_list|(
operator|(
name|AlternativeBlock
operator|)
name|blk
argument_list|)
expr_stmt|;
name|syntacticPredLevel
operator|--
expr_stmt|;
block|}
comment|/** Generate the token types TXT file */
DECL|method|genTokenTypes (TokenManager tm)
specifier|protected
name|void
name|genTokenTypes
parameter_list|(
name|TokenManager
name|tm
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Open the token output TXT file and set the currentOutput stream
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Generating "
operator|+
name|tm
operator|.
name|getName
argument_list|()
operator|+
name|TokenTypesFileSuffix
operator|+
name|TokenTypesFileExt
argument_list|)
expr_stmt|;
name|currentOutput
operator|=
name|antlr
operator|.
name|Tool
operator|.
name|openOutputFile
argument_list|(
name|tm
operator|.
name|getName
argument_list|()
operator|+
name|TokenTypesFileSuffix
operator|+
name|TokenTypesFileExt
argument_list|)
expr_stmt|;
comment|//SAS: changed for proper text file io
name|tabs
operator|=
literal|0
expr_stmt|;
comment|// Generate the header common to all diagnostic files
name|genHeader
argument_list|()
expr_stmt|;
comment|// Generate a string for each token.  This creates a static
comment|// array of Strings indexed by token type.
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** Tokens used by the parser"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"This is a list of the token numeric values and the corresponding"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"token identifiers.  Some tokens are literals, and because of that"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"they have no identifiers.  Literals are double-quoted."
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// Enumerate all the valid token types
name|Vector
name|v
init|=
name|tm
operator|.
name|getVocabulary
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|Token
operator|.
name|MIN_USER_TYPE
init|;
name|i
operator|<
name|v
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|s
init|=
operator|(
name|String
operator|)
name|v
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
name|s
operator|+
literal|" = "
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Close the interface
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"*** End of tokens used by the parser"
argument_list|)
expr_stmt|;
comment|// Close the tokens output file
name|currentOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentOutput
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Get a string for an expression to generate creation of an AST subtree. 	  * @param v A Vector of String, where each element is an expression in the target language yielding an AST node. 	  */
DECL|method|getASTCreateString (Vector v)
specifier|public
name|String
name|getASTCreateString
parameter_list|(
name|Vector
name|v
parameter_list|)
block|{
return|return
literal|"***Create an AST from a vector here***"
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
return|;
block|}
comment|/** Get a string for an expression to generate creating of an AST node 	  * @param str The arguments to the AST constructor 	  */
DECL|method|getASTCreateString (GrammarAtom atom, String str)
specifier|public
name|String
name|getASTCreateString
parameter_list|(
name|GrammarAtom
name|atom
parameter_list|,
name|String
name|str
parameter_list|)
block|{
return|return
literal|"["
operator|+
name|str
operator|+
literal|"]"
return|;
block|}
comment|/** Map an identifier to it's corresponding tree-node variable. 	  * This is context-sensitive, depending on the rule and alternative 	  * being generated 	  * @param id The identifier name to map 	  * @param forInput true if the input tree node variable is to be returned, otherwise the output variable is returned. 	  */
DECL|method|mapTreeId (String id, ActionTransInfo tInfo)
specifier|public
name|String
name|mapTreeId
parameter_list|(
name|String
name|id
parameter_list|,
name|ActionTransInfo
name|tInfo
parameter_list|)
block|{
return|return
name|id
return|;
block|}
comment|/** Format a lookahead or follow set. 	 * @param depth The depth of the entire lookahead/follow 	 * @param k The lookahead level to print 	 * @param lookahead  The lookahead/follow set to print 	 */
DECL|method|printSet (int depth, int k, Lookahead lookahead)
specifier|public
name|void
name|printSet
parameter_list|(
name|int
name|depth
parameter_list|,
name|int
name|k
parameter_list|,
name|Lookahead
name|lookahead
parameter_list|)
block|{
name|int
name|numCols
init|=
literal|5
decl_stmt|;
name|int
index|[]
name|elems
init|=
name|lookahead
operator|.
name|fset
operator|.
name|toArray
argument_list|()
decl_stmt|;
if|if
condition|(
name|depth
operator|!=
literal|1
condition|)
block|{
name|print
argument_list|(
literal|"k=="
operator|+
name|k
operator|+
literal|": {"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print
argument_list|(
literal|"{ "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elems
operator|.
name|length
operator|>
name|numCols
condition|)
block|{
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|print
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|int
name|column
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|elems
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|column
operator|++
expr_stmt|;
if|if
condition|(
name|column
operator|>
name|numCols
condition|)
block|{
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|print
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|doingLexRules
condition|)
block|{
name|_print
argument_list|(
name|charFormatter
operator|.
name|literalChar
argument_list|(
name|elems
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_print
argument_list|(
operator|(
name|String
operator|)
name|grammar
operator|.
name|tokenManager
operator|.
name|getVocabulary
argument_list|()
operator|.
name|elementAt
argument_list|(
name|elems
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|elems
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|_print
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|elems
operator|.
name|length
operator|>
name|numCols
condition|)
block|{
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|print
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|_println
argument_list|(
literal|" }"
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

