begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/license.html  *  * $Id$  */
end_comment

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|Vector
import|;
end_import

begin_comment
comment|/**This object holds all information needed to represent  * the lookahead for any particular lookahead computation  * for a<b>single</b> lookahead depth.  Final lookahead  * information is a simple bit set, but intermediate  * stages need computation cycle and FOLLOW information.  *  *<p>  * Concerning the<tt>cycle</tt> variable.  * If lookahead is computed for a RuleEnd node, then  * computation is part of a FOLLOW cycle for this rule.  * If lookahead is computed for a RuleBlock node, the  * computation is part of a FIRST cycle to this rule.  *  *<p>  * Concerning the<tt>epsilonDepth</tt> variable.  * This is not the depth relative to the rule reference  * that epsilon was encountered.  That value is  *<pre>  * 		initial_k - epsilonDepth + 1  *</pre>  * Also, lookahead depths past rule ref for local follow are:  *<pre>  * 		initial_k - (initial_k - epsilonDepth)  *</pre>  * Used for rule references.  If we try  * to compute look(k, ruleref) and there are fewer  * than k lookahead terminals before the end of the  * the rule, epsilon will be returned (don't want to  * pass the end of the rule).  We must track when the  * the lookahead got stuck.  For example,  *<pre>  * 		a : b A B E F G;  * 		b : C ;  *</pre>  * LOOK(5, ref-to(b)) is {<EPSILON>} with depth = 4, which  * indicates that at 2 (5-4+1) tokens ahead, end of rule was reached.  * Therefore, the token at 4=5-(5-4) past rule ref b must be  * included in the set == F.  * The situation is complicated by the fact that a computation  * may hit the end of a rule at many different depths.  For example,  *<pre>  * 		a : b A B C ;  * 		b : E F		// epsilon depth of 1 relative to initial k=3  * 		  | G		// epsilon depth of 2  * 		  ;  *</pre>  * Here, LOOK(3,ref-to(b)) returns epsilon, but the depths are  * {1, 2}; i.e., 3-(3-1) and 3-(3-2).  Those are the lookahead depths  * past the rule ref needed for the local follow.  *  *<p>  * This is null unless an epsilon is created.  *  * @see antlr.Lookahead#combineWith(Lookahead)  */
end_comment

begin_class
DECL|class|Lookahead
specifier|public
class|class
name|Lookahead
implements|implements
name|Cloneable
block|{
comment|/** actual bitset of the lookahead */
DECL|field|fset
name|BitSet
name|fset
decl_stmt|;
comment|/** is this computation part of a computation cycle? */
DECL|field|cycle
name|String
name|cycle
decl_stmt|;
comment|/** What k values were being computed when end of rule hit? */
DECL|field|epsilonDepth
name|BitSet
name|epsilonDepth
decl_stmt|;
comment|/** Does this lookahead depth include Epsilon token type? This      *  is used to avoid having a bit in the set for Epsilon as it      *  conflicts with parsing binary files.      */
DECL|field|hasEpsilon
name|boolean
name|hasEpsilon
init|=
literal|false
decl_stmt|;
DECL|method|Lookahead ()
specifier|public
name|Lookahead
parameter_list|()
block|{
name|fset
operator|=
operator|new
name|BitSet
argument_list|()
expr_stmt|;
block|}
comment|/** create a new lookahead set with the LL(1) set to the parameter */
DECL|method|Lookahead (BitSet p)
specifier|public
name|Lookahead
parameter_list|(
name|BitSet
name|p
parameter_list|)
block|{
name|fset
operator|=
name|p
expr_stmt|;
block|}
comment|/** create an empty lookahead set, but with cycle */
DECL|method|Lookahead (String c)
specifier|public
name|Lookahead
parameter_list|(
name|String
name|c
parameter_list|)
block|{
name|this
argument_list|()
expr_stmt|;
name|cycle
operator|=
name|c
expr_stmt|;
block|}
comment|/** Make a deep copy of everything in this object */
DECL|method|clone ()
specifier|public
name|Object
name|clone
parameter_list|()
block|{
name|Lookahead
name|p
init|=
literal|null
decl_stmt|;
try|try
block|{
name|p
operator|=
operator|(
name|Lookahead
operator|)
name|super
operator|.
name|clone
argument_list|()
expr_stmt|;
name|p
operator|.
name|fset
operator|=
operator|(
name|BitSet
operator|)
name|fset
operator|.
name|clone
argument_list|()
expr_stmt|;
name|p
operator|.
name|cycle
operator|=
name|cycle
expr_stmt|;
comment|// strings are immutable
if|if
condition|(
name|epsilonDepth
operator|!=
literal|null
condition|)
block|{
name|p
operator|.
name|epsilonDepth
operator|=
operator|(
name|BitSet
operator|)
name|epsilonDepth
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InternalError
argument_list|()
throw|;
block|}
return|return
name|p
return|;
block|}
DECL|method|combineWith (Lookahead q)
specifier|public
name|void
name|combineWith
parameter_list|(
name|Lookahead
name|q
parameter_list|)
block|{
if|if
condition|(
name|cycle
operator|==
literal|null
condition|)
block|{
comment|// track at least one cycle
name|cycle
operator|=
name|q
operator|.
name|cycle
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|.
name|containsEpsilon
argument_list|()
condition|)
block|{
name|hasEpsilon
operator|=
literal|true
expr_stmt|;
block|}
comment|// combine epsilon depths
if|if
condition|(
name|epsilonDepth
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|q
operator|.
name|epsilonDepth
operator|!=
literal|null
condition|)
block|{
name|epsilonDepth
operator|.
name|orInPlace
argument_list|(
name|q
operator|.
name|epsilonDepth
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|q
operator|.
name|epsilonDepth
operator|!=
literal|null
condition|)
block|{
name|epsilonDepth
operator|=
operator|(
name|BitSet
operator|)
name|q
operator|.
name|epsilonDepth
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
name|fset
operator|.
name|orInPlace
argument_list|(
name|q
operator|.
name|fset
argument_list|)
expr_stmt|;
block|}
DECL|method|containsEpsilon ()
specifier|public
name|boolean
name|containsEpsilon
parameter_list|()
block|{
return|return
name|hasEpsilon
return|;
block|}
comment|/** What is the intersection of two lookahead depths?      *  Only the Epsilon "bit" and bitset are considered.      */
DECL|method|intersection (Lookahead q)
specifier|public
name|Lookahead
name|intersection
parameter_list|(
name|Lookahead
name|q
parameter_list|)
block|{
name|Lookahead
name|p
init|=
operator|new
name|Lookahead
argument_list|(
name|fset
operator|.
name|and
argument_list|(
name|q
operator|.
name|fset
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|hasEpsilon
operator|&&
name|q
operator|.
name|hasEpsilon
condition|)
block|{
name|p
operator|.
name|setEpsilon
argument_list|()
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
DECL|method|nil ()
specifier|public
name|boolean
name|nil
parameter_list|()
block|{
return|return
name|fset
operator|.
name|nil
argument_list|()
operator|&&
operator|!
name|hasEpsilon
return|;
block|}
DECL|method|of (int el)
specifier|public
specifier|static
name|Lookahead
name|of
parameter_list|(
name|int
name|el
parameter_list|)
block|{
name|Lookahead
name|look
init|=
operator|new
name|Lookahead
argument_list|()
decl_stmt|;
name|look
operator|.
name|fset
operator|.
name|add
argument_list|(
name|el
argument_list|)
expr_stmt|;
return|return
name|look
return|;
block|}
DECL|method|resetEpsilon ()
specifier|public
name|void
name|resetEpsilon
parameter_list|()
block|{
name|hasEpsilon
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|setEpsilon ()
specifier|public
name|void
name|setEpsilon
parameter_list|()
block|{
name|hasEpsilon
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|e
init|=
literal|""
decl_stmt|,
name|b
decl_stmt|,
name|f
init|=
literal|""
decl_stmt|,
name|d
init|=
literal|""
decl_stmt|;
name|b
operator|=
name|fset
operator|.
name|toString
argument_list|(
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|containsEpsilon
argument_list|()
condition|)
block|{
name|e
operator|=
literal|"+<epsilon>"
expr_stmt|;
block|}
if|if
condition|(
name|cycle
operator|!=
literal|null
condition|)
block|{
name|f
operator|=
literal|"; FOLLOW("
operator|+
name|cycle
operator|+
literal|")"
expr_stmt|;
block|}
if|if
condition|(
name|epsilonDepth
operator|!=
literal|null
condition|)
block|{
name|d
operator|=
literal|"; depths="
operator|+
name|epsilonDepth
operator|.
name|toString
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|+
name|e
operator|+
name|f
operator|+
name|d
return|;
block|}
DECL|method|toString (String separator, CharFormatter formatter)
specifier|public
name|String
name|toString
parameter_list|(
name|String
name|separator
parameter_list|,
name|CharFormatter
name|formatter
parameter_list|)
block|{
name|String
name|e
init|=
literal|""
decl_stmt|,
name|b
decl_stmt|,
name|f
init|=
literal|""
decl_stmt|,
name|d
init|=
literal|""
decl_stmt|;
name|b
operator|=
name|fset
operator|.
name|toString
argument_list|(
name|separator
argument_list|,
name|formatter
argument_list|)
expr_stmt|;
if|if
condition|(
name|containsEpsilon
argument_list|()
condition|)
block|{
name|e
operator|=
literal|"+<epsilon>"
expr_stmt|;
block|}
if|if
condition|(
name|cycle
operator|!=
literal|null
condition|)
block|{
name|f
operator|=
literal|"; FOLLOW("
operator|+
name|cycle
operator|+
literal|")"
expr_stmt|;
block|}
if|if
condition|(
name|epsilonDepth
operator|!=
literal|null
condition|)
block|{
name|d
operator|=
literal|"; depths="
operator|+
name|epsilonDepth
operator|.
name|toString
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|+
name|e
operator|+
name|f
operator|+
name|d
return|;
block|}
DECL|method|toString (String separator, CharFormatter formatter, Grammar g)
specifier|public
name|String
name|toString
parameter_list|(
name|String
name|separator
parameter_list|,
name|CharFormatter
name|formatter
parameter_list|,
name|Grammar
name|g
parameter_list|)
block|{
if|if
condition|(
name|g
operator|instanceof
name|LexerGrammar
condition|)
block|{
return|return
name|toString
argument_list|(
name|separator
argument_list|,
name|formatter
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|toString
argument_list|(
name|separator
argument_list|,
name|g
operator|.
name|tokenManager
operator|.
name|getVocabulary
argument_list|()
argument_list|)
return|;
block|}
block|}
DECL|method|toString (String separator, Vector vocab)
specifier|public
name|String
name|toString
parameter_list|(
name|String
name|separator
parameter_list|,
name|Vector
name|vocab
parameter_list|)
block|{
name|String
name|b
decl_stmt|,
name|f
init|=
literal|""
decl_stmt|,
name|d
init|=
literal|""
decl_stmt|;
name|b
operator|=
name|fset
operator|.
name|toString
argument_list|(
name|separator
argument_list|,
name|vocab
argument_list|)
expr_stmt|;
if|if
condition|(
name|cycle
operator|!=
literal|null
condition|)
block|{
name|f
operator|=
literal|"; FOLLOW("
operator|+
name|cycle
operator|+
literal|")"
expr_stmt|;
block|}
if|if
condition|(
name|epsilonDepth
operator|!=
literal|null
condition|)
block|{
name|d
operator|=
literal|"; depths="
operator|+
name|epsilonDepth
operator|.
name|toString
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|+
name|f
operator|+
name|d
return|;
block|}
block|}
end_class

end_unit

