begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/license.html  *  * $Id$  */
end_comment

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|AST
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|ASTArray
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_comment
comment|/** AST Support code shared by TreeParser and Parser.  *  We use delegation to share code (and have only one  *  bit of code to maintain) rather than subclassing  *  or superclassing (forces AST support code to be  *  loaded even when you don't want to do AST stuff).  *  *  Typically, setASTNodeType is used to specify the  *  homogeneous type of node to create, but you can override  *  create to make heterogeneous nodes etc...  */
end_comment

begin_class
DECL|class|ASTFactory
specifier|public
class|class
name|ASTFactory
block|{
comment|/** Name of AST class to create during tree construction.      *  Null implies that the create method should create      *  a default AST type such as CommonAST.  This is for 	 *  homogeneous nodes.      */
DECL|field|theASTNodeType
specifier|protected
name|String
name|theASTNodeType
init|=
literal|null
decl_stmt|;
DECL|field|theASTNodeTypeClass
specifier|protected
name|Class
name|theASTNodeTypeClass
init|=
literal|null
decl_stmt|;
comment|/** How to specify the classname to create for a particular 	 *  token type.  Note that ANTLR allows you to say, for example, 	 * 	    tokens {          PLUS<AST=PLUSNode>;          ...         } 	 * 	 *  and it tracks everything statically.  #[PLUS] will make you 	 *  a PLUSNode w/o use of this table. 	 * 	 *  For tokens that ANTLR cannot track statically like #[i], 	 *  you can use this table to map PLUS (Integer) -> PLUSNode (Class) 	 *  etc... ANTLR sets the class map from the tokens {...} section 	 *  via the ASTFactory(Hashtable) ctor in antlr.Parser. 	 */
DECL|field|tokenTypeToASTClassMap
specifier|protected
name|Hashtable
name|tokenTypeToASTClassMap
init|=
literal|null
decl_stmt|;
DECL|method|ASTFactory ()
specifier|public
name|ASTFactory
parameter_list|()
block|{ 	}
comment|/** Create factory with a specific mapping from token type 	 *  to Java AST node type.  Your subclasses of ASTFactory 	 *  can override and reuse the map stuff. 	 */
DECL|method|ASTFactory (Hashtable tokenTypeToClassMap)
specifier|public
name|ASTFactory
parameter_list|(
name|Hashtable
name|tokenTypeToClassMap
parameter_list|)
block|{
name|setTokenTypeToASTClassMap
argument_list|(
name|tokenTypeToClassMap
argument_list|)
expr_stmt|;
block|}
comment|/** Specify an "override" for the Java AST object created for a 	 *  specific token.  It is provided as a convenience so 	 *  you can specify node types dynamically.  ANTLR sets 	 *  the token type mapping automatically from the tokens{...} 	 *  section, but you can change that mapping with this method. 	 *  ANTLR does it's best to statically determine the node 	 *  type for generating parsers, but it cannot deal with 	 *  dynamic values like #[LT(1)].  In this case, it relies 	 *  on the mapping.  Beware differences in the tokens{...} 	 *  section and what you set via this method.  Make sure 	 *  they are the same. 	 * 	 *  Set className to null to remove the mapping. 	 * 	 *  @since 2.7.2 	 */
DECL|method|setTokenTypeASTNodeType (int tokenType, String className)
specifier|public
name|void
name|setTokenTypeASTNodeType
parameter_list|(
name|int
name|tokenType
parameter_list|,
name|String
name|className
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|tokenTypeToASTClassMap
operator|==
literal|null
condition|)
block|{
name|tokenTypeToASTClassMap
operator|=
operator|new
name|Hashtable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|className
operator|==
literal|null
condition|)
block|{
name|tokenTypeToASTClassMap
operator|.
name|remove
argument_list|(
operator|new
name|Integer
argument_list|(
name|tokenType
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|Class
name|c
init|=
literal|null
decl_stmt|;
try|try
block|{
name|c
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|className
argument_list|)
expr_stmt|;
name|tokenTypeToASTClassMap
operator|.
name|put
argument_list|(
operator|new
name|Integer
argument_list|(
name|tokenType
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid class, "
operator|+
name|className
argument_list|)
throw|;
block|}
block|}
comment|/** For a given token type, what is the AST node object type to create 	 *  for it? 	 *  @since 2.7.2 	 */
DECL|method|getASTNodeType (int tokenType)
specifier|public
name|Class
name|getASTNodeType
parameter_list|(
name|int
name|tokenType
parameter_list|)
block|{
comment|// try node specific class
if|if
condition|(
name|tokenTypeToASTClassMap
operator|!=
literal|null
condition|)
block|{
name|Class
name|c
init|=
operator|(
name|Class
operator|)
name|tokenTypeToASTClassMap
operator|.
name|get
argument_list|(
operator|new
name|Integer
argument_list|(
name|tokenType
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
return|return
name|c
return|;
block|}
block|}
comment|// try a global specified class
if|if
condition|(
name|theASTNodeTypeClass
operator|!=
literal|null
condition|)
block|{
return|return
name|theASTNodeTypeClass
return|;
block|}
comment|// default to the common type
return|return
name|CommonAST
operator|.
name|class
return|;
block|}
comment|/** Add a child to the current AST */
DECL|method|addASTChild (ASTPair currentAST, AST child)
specifier|public
name|void
name|addASTChild
parameter_list|(
name|ASTPair
name|currentAST
parameter_list|,
name|AST
name|child
parameter_list|)
block|{
if|if
condition|(
name|child
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|currentAST
operator|.
name|root
operator|==
literal|null
condition|)
block|{
comment|// Make new child the current root
name|currentAST
operator|.
name|root
operator|=
name|child
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|currentAST
operator|.
name|child
operator|==
literal|null
condition|)
block|{
comment|// Add new child to current root
name|currentAST
operator|.
name|root
operator|.
name|setFirstChild
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|currentAST
operator|.
name|child
operator|.
name|setNextSibling
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Make new child the current child
name|currentAST
operator|.
name|child
operator|=
name|child
expr_stmt|;
name|currentAST
operator|.
name|advanceChildToEnd
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Create a new empty AST node; if the user did not specify      *  an AST node type, then create a default one: CommonAST.      */
DECL|method|create ()
specifier|public
name|AST
name|create
parameter_list|()
block|{
return|return
name|create
argument_list|(
name|Token
operator|.
name|INVALID_TYPE
argument_list|)
return|;
block|}
DECL|method|create (int type)
specifier|public
name|AST
name|create
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|Class
name|c
init|=
name|getASTNodeType
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|AST
name|t
init|=
name|create
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|initialize
argument_list|(
name|type
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
DECL|method|create (int type, String txt)
specifier|public
name|AST
name|create
parameter_list|(
name|int
name|type
parameter_list|,
name|String
name|txt
parameter_list|)
block|{
name|AST
name|t
init|=
name|create
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|initialize
argument_list|(
name|type
argument_list|,
name|txt
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
comment|/** Create an AST node with the token type and text passed in, but 	 *  with a specific Java object type. Typically called when you 	 *  say @[PLUS,"+",PLUSNode] in an antlr action. 	 *  @since 2.7.2 	 */
DECL|method|create (int type, String txt, String className)
specifier|public
name|AST
name|create
parameter_list|(
name|int
name|type
parameter_list|,
name|String
name|txt
parameter_list|,
name|String
name|className
parameter_list|)
block|{
name|AST
name|t
init|=
name|create
argument_list|(
name|className
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|initialize
argument_list|(
name|type
argument_list|,
name|txt
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
comment|/** Create a new empty AST node; if the user did not specify      *  an AST node type, then create a default one: CommonAST.      */
DECL|method|create (AST tr)
specifier|public
name|AST
name|create
parameter_list|(
name|AST
name|tr
parameter_list|)
block|{
if|if
condition|(
name|tr
operator|==
literal|null
condition|)
return|return
literal|null
return|;
comment|// create(null) == null
name|AST
name|t
init|=
name|create
argument_list|(
name|tr
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|initialize
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
DECL|method|create (Token tok)
specifier|public
name|AST
name|create
parameter_list|(
name|Token
name|tok
parameter_list|)
block|{
name|AST
name|t
init|=
name|create
argument_list|(
name|tok
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|initialize
argument_list|(
name|tok
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
comment|/** ANTLR generates reference to this when you reference a token 	 *  that has a specified heterogeneous AST node type.  This is 	 *  also a special case node creation routine for backward 	 *  compatibility.  Before, ANTLR generated "new T(tokenObject)" 	 *  and so I must call the appropriate constructor not T(). 	 * 	 * @since 2.7.2 	 */
DECL|method|create (Token tok, String className)
specifier|public
name|AST
name|create
parameter_list|(
name|Token
name|tok
parameter_list|,
name|String
name|className
parameter_list|)
block|{
name|AST
name|t
init|=
name|createUsingCtor
argument_list|(
name|tok
argument_list|,
name|className
argument_list|)
decl_stmt|;
return|return
name|t
return|;
block|}
comment|/** 	 * @since 2.7.2 	 */
DECL|method|create (String className)
specifier|public
name|AST
name|create
parameter_list|(
name|String
name|className
parameter_list|)
block|{
name|Class
name|c
init|=
literal|null
decl_stmt|;
try|try
block|{
name|c
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|className
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid class, "
operator|+
name|className
argument_list|)
throw|;
block|}
return|return
name|create
argument_list|(
name|c
argument_list|)
return|;
block|}
comment|/** 	 * @since 2.7.2 	 */
DECL|method|createUsingCtor (Token token, String className)
specifier|protected
name|AST
name|createUsingCtor
parameter_list|(
name|Token
name|token
parameter_list|,
name|String
name|className
parameter_list|)
block|{
name|Class
name|c
init|=
literal|null
decl_stmt|;
name|AST
name|t
init|=
literal|null
decl_stmt|;
try|try
block|{
name|c
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|className
argument_list|)
expr_stmt|;
name|Class
index|[]
name|tokenArgType
init|=
operator|new
name|Class
index|[]
block|{
name|antlr
operator|.
name|Token
operator|.
name|class
block|}
decl_stmt|;
try|try
block|{
name|Constructor
name|ctor
init|=
name|c
operator|.
name|getConstructor
argument_list|(
name|tokenArgType
argument_list|)
decl_stmt|;
name|t
operator|=
operator|(
name|AST
operator|)
name|ctor
operator|.
name|newInstance
argument_list|(
operator|new
name|Object
index|[]
block|{
name|token
block|}
argument_list|)
expr_stmt|;
comment|// make a new one
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
comment|// just do the regular thing if you can't find the ctor
comment|// Your AST must have default ctor to use this.
name|t
operator|=
name|create
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|initialize
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid class or can't make instance, "
operator|+
name|className
argument_list|)
throw|;
block|}
return|return
name|t
return|;
block|}
comment|/** 	 * @since 2.7.2 	 */
DECL|method|create (Class c)
specifier|protected
name|AST
name|create
parameter_list|(
name|Class
name|c
parameter_list|)
block|{
name|AST
name|t
init|=
literal|null
decl_stmt|;
try|try
block|{
name|t
operator|=
operator|(
name|AST
operator|)
name|c
operator|.
name|newInstance
argument_list|()
expr_stmt|;
comment|// make a new one
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|error
argument_list|(
literal|"Can't create AST Node "
operator|+
name|c
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|t
return|;
block|}
comment|/** Copy a single node with same Java AST objec type. 	 *  Ignore the tokenType->Class mapping since you know 	 *  the type of the node, t.getClass(), and doing a dup. 	 * 	 *  clone() is not used because we want all AST creation 	 *  to go thru the factory so creation can be      *  tracked.  Returns null if t is null.      */
DECL|method|dup (AST t)
specifier|public
name|AST
name|dup
parameter_list|(
name|AST
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|AST
name|dup_t
init|=
name|create
argument_list|(
name|t
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
name|dup_t
operator|.
name|initialize
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|dup_t
return|;
block|}
comment|/** Duplicate tree including siblings of root. */
DECL|method|dupList (AST t)
specifier|public
name|AST
name|dupList
parameter_list|(
name|AST
name|t
parameter_list|)
block|{
name|AST
name|result
init|=
name|dupTree
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|// if t == null, then result==null
name|AST
name|nt
init|=
name|result
decl_stmt|;
while|while
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
comment|// for each sibling of the root
name|t
operator|=
name|t
operator|.
name|getNextSibling
argument_list|()
expr_stmt|;
name|nt
operator|.
name|setNextSibling
argument_list|(
name|dupTree
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|// dup each subtree, building new tree
name|nt
operator|=
name|nt
operator|.
name|getNextSibling
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**Duplicate a tree, assuming this is a root node of a tree--      * duplicate that node and what's below; ignore siblings of root node.      */
DECL|method|dupTree (AST t)
specifier|public
name|AST
name|dupTree
parameter_list|(
name|AST
name|t
parameter_list|)
block|{
name|AST
name|result
init|=
name|dup
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|// make copy of root
comment|// copy all children of root.
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|setFirstChild
argument_list|(
name|dupList
argument_list|(
name|t
operator|.
name|getFirstChild
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/** Make a tree from a list of nodes.  The first element in the      *  array is the root.  If the root is null, then the tree is      *  a simple list not a tree.  Handles null children nodes correctly.      *  For example, build(a, b, null, c) yields tree (a b c).  build(null,a,b)      *  yields tree (nil a b).      */
DECL|method|make (AST[] nodes)
specifier|public
name|AST
name|make
parameter_list|(
name|AST
index|[]
name|nodes
parameter_list|)
block|{
if|if
condition|(
name|nodes
operator|==
literal|null
operator|||
name|nodes
operator|.
name|length
operator|==
literal|0
condition|)
return|return
literal|null
return|;
name|AST
name|root
init|=
name|nodes
index|[
literal|0
index|]
decl_stmt|;
name|AST
name|tail
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|root
operator|!=
literal|null
condition|)
block|{
name|root
operator|.
name|setFirstChild
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// don't leave any old pointers set
block|}
comment|// link in children;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|nodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nodes
index|[
name|i
index|]
operator|==
literal|null
condition|)
continue|continue;
comment|// ignore null nodes
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
comment|// Set the root and set it up for a flat list
name|root
operator|=
name|tail
operator|=
name|nodes
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tail
operator|==
literal|null
condition|)
block|{
name|root
operator|.
name|setFirstChild
argument_list|(
name|nodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tail
operator|=
name|root
operator|.
name|getFirstChild
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tail
operator|.
name|setNextSibling
argument_list|(
name|nodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tail
operator|=
name|tail
operator|.
name|getNextSibling
argument_list|()
expr_stmt|;
block|}
comment|// Chase tail to last sibling
while|while
condition|(
name|tail
operator|.
name|getNextSibling
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|tail
operator|=
name|tail
operator|.
name|getNextSibling
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|root
return|;
block|}
comment|/** Make a tree from a list of nodes, where the nodes are contained      * in an ASTArray object      */
DECL|method|make (ASTArray nodes)
specifier|public
name|AST
name|make
parameter_list|(
name|ASTArray
name|nodes
parameter_list|)
block|{
return|return
name|make
argument_list|(
name|nodes
operator|.
name|array
argument_list|)
return|;
block|}
comment|/** Make an AST the root of current AST */
DECL|method|makeASTRoot (ASTPair currentAST, AST root)
specifier|public
name|void
name|makeASTRoot
parameter_list|(
name|ASTPair
name|currentAST
parameter_list|,
name|AST
name|root
parameter_list|)
block|{
if|if
condition|(
name|root
operator|!=
literal|null
condition|)
block|{
comment|// Add the current root as a child of new root
name|root
operator|.
name|addChild
argument_list|(
name|currentAST
operator|.
name|root
argument_list|)
expr_stmt|;
comment|// The new current child is the last sibling of the old root
name|currentAST
operator|.
name|child
operator|=
name|currentAST
operator|.
name|root
expr_stmt|;
name|currentAST
operator|.
name|advanceChildToEnd
argument_list|()
expr_stmt|;
comment|// Set the new root
name|currentAST
operator|.
name|root
operator|=
name|root
expr_stmt|;
block|}
block|}
DECL|method|setASTNodeClass (String t)
specifier|public
name|void
name|setASTNodeClass
parameter_list|(
name|String
name|t
parameter_list|)
block|{
name|theASTNodeType
operator|=
name|t
expr_stmt|;
try|try
block|{
name|theASTNodeTypeClass
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|// get class def
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// either class not found,
comment|// class is interface/abstract, or
comment|// class or initializer is not accessible.
name|error
argument_list|(
literal|"Can't find/access AST Node type"
operator|+
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Specify the type of node to create during tree building.      * 	@deprecated since 2.7.1      */
DECL|method|setASTNodeType (String t)
specifier|public
name|void
name|setASTNodeType
parameter_list|(
name|String
name|t
parameter_list|)
block|{
name|setASTNodeClass
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
DECL|method|getTokenTypeToASTClassMap ()
specifier|public
name|Hashtable
name|getTokenTypeToASTClassMap
parameter_list|()
block|{
return|return
name|tokenTypeToASTClassMap
return|;
block|}
DECL|method|setTokenTypeToASTClassMap (Hashtable tokenTypeToClassMap)
specifier|public
name|void
name|setTokenTypeToASTClassMap
parameter_list|(
name|Hashtable
name|tokenTypeToClassMap
parameter_list|)
block|{
name|this
operator|.
name|tokenTypeToASTClassMap
operator|=
name|tokenTypeToClassMap
expr_stmt|;
block|}
comment|/** To change where error messages go, can subclass/override this method      *  and then setASTFactory in Parser and TreeParser.  This method removes      *  a prior dependency on class antlr.Tool.      */
DECL|method|error (String e)
specifier|public
name|void
name|error
parameter_list|(
name|String
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

