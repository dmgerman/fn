begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/RIGHTS.html  *  * $Id$  */
end_comment

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|AST
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|ASTArray
import|;
end_import

begin_comment
comment|/** AST Support code shared by TreeParser and Parser.  *  We use delegation to share code (and have only one  *  bit of code to maintain) rather than subclassing  *  or superclassing (forces AST support code to be  *  loaded even when you don't want to do AST stuff).  *  *  Typically, setASTNodeType is used to specify the  *  type of node to create, but you can override  *  create to make heterogeneous nodes etc...  */
end_comment

begin_class
DECL|class|ASTFactory
specifier|public
class|class
name|ASTFactory
block|{
comment|/** Name of AST class to create during tree construction.      *  Null implies that the create method should create      *  a default AST type such as CommonAST.      */
DECL|field|theASTNodeType
specifier|protected
name|String
name|theASTNodeType
init|=
literal|null
decl_stmt|;
DECL|field|theASTNodeTypeClass
specifier|protected
name|Class
name|theASTNodeTypeClass
init|=
literal|null
decl_stmt|;
comment|/** Add a child to the current AST */
DECL|method|addASTChild (ASTPair currentAST, AST child)
specifier|public
name|void
name|addASTChild
parameter_list|(
name|ASTPair
name|currentAST
parameter_list|,
name|AST
name|child
parameter_list|)
block|{
if|if
condition|(
name|child
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|currentAST
operator|.
name|root
operator|==
literal|null
condition|)
block|{
comment|// Make new child the current root
name|currentAST
operator|.
name|root
operator|=
name|child
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|currentAST
operator|.
name|child
operator|==
literal|null
condition|)
block|{
comment|// Add new child to current root
name|currentAST
operator|.
name|root
operator|.
name|setFirstChild
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|currentAST
operator|.
name|child
operator|.
name|setNextSibling
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Make new child the current child
name|currentAST
operator|.
name|child
operator|=
name|child
expr_stmt|;
name|currentAST
operator|.
name|advanceChildToEnd
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Create a new empty AST node; if the user did not specify      *  an AST node type, then create a default one: CommonAST.      */
DECL|method|create ()
specifier|public
name|AST
name|create
parameter_list|()
block|{
name|AST
name|t
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|theASTNodeTypeClass
operator|==
literal|null
condition|)
block|{
name|t
operator|=
operator|new
name|CommonAST
argument_list|()
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|t
operator|=
operator|(
name|AST
operator|)
name|theASTNodeTypeClass
operator|.
name|newInstance
argument_list|()
expr_stmt|;
comment|// make a new one
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|antlr
operator|.
name|Tool
operator|.
name|warning
argument_list|(
literal|"Can't create AST Node "
operator|+
name|theASTNodeType
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
return|return
name|t
return|;
block|}
DECL|method|create (int type)
specifier|public
name|AST
name|create
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|AST
name|t
init|=
name|create
argument_list|()
decl_stmt|;
name|t
operator|.
name|initialize
argument_list|(
name|type
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
DECL|method|create (int type, String txt)
specifier|public
name|AST
name|create
parameter_list|(
name|int
name|type
parameter_list|,
name|String
name|txt
parameter_list|)
block|{
name|AST
name|t
init|=
name|create
argument_list|()
decl_stmt|;
name|t
operator|.
name|initialize
argument_list|(
name|type
argument_list|,
name|txt
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/** Create a new empty AST node; if the user did not specify      *  an AST node type, then create a default one: CommonAST.      */
DECL|method|create (AST tr)
specifier|public
name|AST
name|create
parameter_list|(
name|AST
name|tr
parameter_list|)
block|{
if|if
condition|(
name|tr
operator|==
literal|null
condition|)
return|return
literal|null
return|;
comment|// create(null) == null
name|AST
name|t
init|=
name|create
argument_list|()
decl_stmt|;
name|t
operator|.
name|initialize
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
DECL|method|create (Token tok)
specifier|public
name|AST
name|create
parameter_list|(
name|Token
name|tok
parameter_list|)
block|{
name|AST
name|t
init|=
name|create
argument_list|()
decl_stmt|;
name|t
operator|.
name|initialize
argument_list|(
name|tok
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/** Copy a single node.  clone() is not used because      *  we want to return an AST not a plain object...a type      *  safety issue.  Further, we want to have all AST node      *  creation go through the factory so creation can be      *  tracked.  Returns null if t is null.      */
DECL|method|dup (AST t)
specifier|public
name|AST
name|dup
parameter_list|(
name|AST
name|t
parameter_list|)
block|{
return|return
name|create
argument_list|(
name|t
argument_list|)
return|;
comment|// if t==null, create returns null
block|}
comment|/** Duplicate tree including siblings of root. */
DECL|method|dupList (AST t)
specifier|public
name|AST
name|dupList
parameter_list|(
name|AST
name|t
parameter_list|)
block|{
name|AST
name|result
init|=
name|dupTree
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|// if t == null, then result==null
name|AST
name|nt
init|=
name|result
decl_stmt|;
while|while
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
comment|// for each sibling of the root
name|t
operator|=
name|t
operator|.
name|getNextSibling
argument_list|()
expr_stmt|;
name|nt
operator|.
name|setNextSibling
argument_list|(
name|dupTree
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|// dup each subtree, building new tree
name|nt
operator|=
name|nt
operator|.
name|getNextSibling
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**Duplicate a tree, assuming this is a root node of a tree--      * duplicate that node and what's below; ignore siblings of root node.      */
DECL|method|dupTree (AST t)
specifier|public
name|AST
name|dupTree
parameter_list|(
name|AST
name|t
parameter_list|)
block|{
name|AST
name|result
init|=
name|dup
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|// make copy of root
comment|// copy all children of root.
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|setFirstChild
argument_list|(
name|dupList
argument_list|(
name|t
operator|.
name|getFirstChild
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/** Make a tree from a list of nodes.  The first element in the      *  array is the root.  If the root is null, then the tree is      *  a simple list not a tree.  Handles null children nodes correctly.      *  For example, build(a, b, null, c) yields tree (a b c).  build(null,a,b)      *  yields tree (nil a b).      */
DECL|method|make (AST[] nodes)
specifier|public
name|AST
name|make
parameter_list|(
name|AST
index|[]
name|nodes
parameter_list|)
block|{
if|if
condition|(
name|nodes
operator|==
literal|null
operator|||
name|nodes
operator|.
name|length
operator|==
literal|0
condition|)
return|return
literal|null
return|;
name|AST
name|root
init|=
name|nodes
index|[
literal|0
index|]
decl_stmt|;
name|AST
name|tail
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|root
operator|!=
literal|null
condition|)
block|{
name|root
operator|.
name|setFirstChild
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// don't leave any old pointers set
block|}
comment|// link in children;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|nodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nodes
index|[
name|i
index|]
operator|==
literal|null
condition|)
continue|continue;
comment|// ignore null nodes
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
comment|// Set the root and set it up for a flat list
name|root
operator|=
name|tail
operator|=
name|nodes
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tail
operator|==
literal|null
condition|)
block|{
name|root
operator|.
name|setFirstChild
argument_list|(
name|nodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tail
operator|=
name|root
operator|.
name|getFirstChild
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tail
operator|.
name|setNextSibling
argument_list|(
name|nodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tail
operator|=
name|tail
operator|.
name|getNextSibling
argument_list|()
expr_stmt|;
block|}
comment|// Chase tail to last sibling
while|while
condition|(
name|tail
operator|.
name|getNextSibling
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|tail
operator|=
name|tail
operator|.
name|getNextSibling
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|root
return|;
block|}
comment|/** Make a tree from a list of nodes, where the nodes are contained      * in an ASTArray object      */
DECL|method|make (ASTArray nodes)
specifier|public
name|AST
name|make
parameter_list|(
name|ASTArray
name|nodes
parameter_list|)
block|{
return|return
name|make
argument_list|(
name|nodes
operator|.
name|array
argument_list|)
return|;
block|}
comment|/** Make an AST the root of current AST */
DECL|method|makeASTRoot (ASTPair currentAST, AST root)
specifier|public
name|void
name|makeASTRoot
parameter_list|(
name|ASTPair
name|currentAST
parameter_list|,
name|AST
name|root
parameter_list|)
block|{
if|if
condition|(
name|root
operator|!=
literal|null
condition|)
block|{
comment|// Add the current root as a child of new root
name|root
operator|.
name|addChild
argument_list|(
name|currentAST
operator|.
name|root
argument_list|)
expr_stmt|;
comment|// The new current child is the last sibling of the old root
name|currentAST
operator|.
name|child
operator|=
name|currentAST
operator|.
name|root
expr_stmt|;
name|currentAST
operator|.
name|advanceChildToEnd
argument_list|()
expr_stmt|;
comment|// Set the new root
name|currentAST
operator|.
name|root
operator|=
name|root
expr_stmt|;
block|}
block|}
DECL|method|setASTNodeType (String t)
specifier|public
name|void
name|setASTNodeType
parameter_list|(
name|String
name|t
parameter_list|)
block|{
name|theASTNodeType
operator|=
name|t
expr_stmt|;
try|try
block|{
name|theASTNodeTypeClass
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|// get class def
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// either class not found,
comment|// class is interface/abstract, or
comment|// class or initializer is not accessible.
name|antlr
operator|.
name|Tool
operator|.
name|warning
argument_list|(
literal|"Can't find/access AST Node type"
operator|+
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

