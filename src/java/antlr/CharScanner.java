begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/RIGHTS.html  *  * $Id$  */
end_comment

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_class
DECL|class|CharScanner
specifier|public
specifier|abstract
class|class
name|CharScanner
implements|implements
name|TokenStream
block|{
DECL|field|NO_CHAR
specifier|static
specifier|final
name|char
name|NO_CHAR
init|=
literal|0
decl_stmt|;
DECL|field|EOF_CHAR
specifier|public
specifier|static
specifier|final
name|char
name|EOF_CHAR
init|=
operator|(
name|char
operator|)
operator|-
literal|1
decl_stmt|;
DECL|field|text
specifier|protected
name|ANTLRStringBuffer
name|text
decl_stmt|;
comment|// text of current token
DECL|field|saveConsumedInput
specifier|protected
name|boolean
name|saveConsumedInput
init|=
literal|true
decl_stmt|;
comment|// does consume() save characters?
DECL|field|tokenObjectClass
specifier|protected
name|Class
name|tokenObjectClass
decl_stmt|;
comment|// what kind of tokens to create?
DECL|field|caseSensitive
specifier|protected
name|boolean
name|caseSensitive
init|=
literal|true
decl_stmt|;
DECL|field|caseSensitiveLiterals
specifier|protected
name|boolean
name|caseSensitiveLiterals
init|=
literal|true
decl_stmt|;
DECL|field|literals
specifier|protected
name|Hashtable
name|literals
decl_stmt|;
comment|// set by subclass
DECL|field|_returnToken
specifier|protected
name|Token
name|_returnToken
init|=
literal|null
decl_stmt|;
comment|// used to return tokens w/o using return val.
comment|// Hash string used so we don't new one every time to check literals table
DECL|field|hashString
specifier|protected
name|ANTLRHashString
name|hashString
decl_stmt|;
DECL|field|inputState
specifier|protected
name|LexerSharedInputState
name|inputState
decl_stmt|;
comment|/** Used during filter mode to indicate that path is desired.      *  A subsequent scan error will report an error as usual if      *  acceptPath=true;      */
DECL|field|commitToPath
specifier|protected
name|boolean
name|commitToPath
init|=
literal|false
decl_stmt|;
comment|/** Used to keep track of indentdepth for traceIn/Out */
DECL|field|traceDepth
specifier|protected
name|int
name|traceDepth
init|=
literal|0
decl_stmt|;
DECL|method|CharScanner ()
specifier|public
name|CharScanner
parameter_list|()
block|{
name|text
operator|=
operator|new
name|ANTLRStringBuffer
argument_list|()
expr_stmt|;
name|hashString
operator|=
operator|new
name|ANTLRHashString
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// JZ: conflict with obfuscator: setTokenObjectClass("antlr.CommonToken");
name|setTokenObjectClass
argument_list|(
operator|(
operator|new
name|antlr
operator|.
name|CommonToken
argument_list|()
operator|)
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// JZ: solution
block|}
DECL|method|CharScanner (InputBuffer cb)
specifier|public
name|CharScanner
parameter_list|(
name|InputBuffer
name|cb
parameter_list|)
block|{
comment|// SAS: use generic buffer
name|this
argument_list|()
expr_stmt|;
name|inputState
operator|=
operator|new
name|LexerSharedInputState
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
DECL|method|CharScanner (LexerSharedInputState sharedState)
specifier|public
name|CharScanner
parameter_list|(
name|LexerSharedInputState
name|sharedState
parameter_list|)
block|{
name|this
argument_list|()
expr_stmt|;
name|inputState
operator|=
name|sharedState
expr_stmt|;
block|}
DECL|method|append (char c)
specifier|public
name|void
name|append
parameter_list|(
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|saveConsumedInput
condition|)
block|{
name|text
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|append (String s)
specifier|public
name|void
name|append
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|saveConsumedInput
condition|)
block|{
name|text
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|commit ()
specifier|public
name|void
name|commit
parameter_list|()
block|{
name|inputState
operator|.
name|input
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
DECL|method|consume ()
specifier|public
name|void
name|consume
parameter_list|()
throws|throws
name|CharStreamException
block|{
if|if
condition|(
name|inputState
operator|.
name|guessing
operator|==
literal|0
condition|)
block|{
name|char
name|c
init|=
name|LA
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|caseSensitive
condition|)
block|{
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// use input.LA(), not LA(), to get original case
comment|// CharScanner.LA() would toLower it.
name|append
argument_list|(
name|inputState
operator|.
name|input
operator|.
name|LA
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|tab
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|inputState
operator|.
name|column
operator|++
expr_stmt|;
block|}
block|}
name|inputState
operator|.
name|input
operator|.
name|consume
argument_list|()
expr_stmt|;
block|}
comment|/** Consume chars until one matches the given char */
DECL|method|consumeUntil (int c)
specifier|public
name|void
name|consumeUntil
parameter_list|(
name|int
name|c
parameter_list|)
throws|throws
name|CharStreamException
block|{
while|while
condition|(
name|LA
argument_list|(
literal|1
argument_list|)
operator|!=
name|EOF_CHAR
operator|&&
name|LA
argument_list|(
literal|1
argument_list|)
operator|!=
name|c
condition|)
block|{
name|consume
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Consume chars until one matches the given set */
DECL|method|consumeUntil (BitSet set)
specifier|public
name|void
name|consumeUntil
parameter_list|(
name|BitSet
name|set
parameter_list|)
throws|throws
name|CharStreamException
block|{
while|while
condition|(
name|LA
argument_list|(
literal|1
argument_list|)
operator|!=
name|EOF_CHAR
operator|&&
operator|!
name|set
operator|.
name|member
argument_list|(
name|LA
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|consume
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getCaseSensitive ()
specifier|public
name|boolean
name|getCaseSensitive
parameter_list|()
block|{
return|return
name|caseSensitive
return|;
block|}
DECL|method|getCaseSensitiveLiterals ()
specifier|public
specifier|final
name|boolean
name|getCaseSensitiveLiterals
parameter_list|()
block|{
return|return
name|caseSensitiveLiterals
return|;
block|}
DECL|method|getColumn ()
specifier|public
name|int
name|getColumn
parameter_list|()
block|{
return|return
name|inputState
operator|.
name|column
return|;
block|}
DECL|method|setColumn (int c)
specifier|public
name|void
name|setColumn
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|inputState
operator|.
name|column
operator|=
name|c
expr_stmt|;
block|}
DECL|method|getCommitToPath ()
specifier|public
name|boolean
name|getCommitToPath
parameter_list|()
block|{
return|return
name|commitToPath
return|;
block|}
DECL|method|getFilename ()
specifier|public
name|String
name|getFilename
parameter_list|()
block|{
return|return
name|inputState
operator|.
name|filename
return|;
block|}
DECL|method|getInputBuffer ()
specifier|public
name|InputBuffer
name|getInputBuffer
parameter_list|()
block|{
return|return
name|inputState
operator|.
name|input
return|;
block|}
DECL|method|getInputState ()
specifier|public
name|LexerSharedInputState
name|getInputState
parameter_list|()
block|{
return|return
name|inputState
return|;
block|}
DECL|method|setInputState (LexerSharedInputState state)
specifier|public
name|void
name|setInputState
parameter_list|(
name|LexerSharedInputState
name|state
parameter_list|)
block|{
name|inputState
operator|=
name|state
expr_stmt|;
block|}
DECL|method|getLine ()
specifier|public
name|int
name|getLine
parameter_list|()
block|{
return|return
name|inputState
operator|.
name|line
return|;
block|}
comment|/** return a copy of the current text buffer */
DECL|method|getText ()
specifier|public
name|String
name|getText
parameter_list|()
block|{
return|return
name|text
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|getTokenObject ()
specifier|public
name|Token
name|getTokenObject
parameter_list|()
block|{
return|return
name|_returnToken
return|;
block|}
DECL|method|LA (int i)
specifier|public
name|char
name|LA
parameter_list|(
name|int
name|i
parameter_list|)
throws|throws
name|CharStreamException
block|{
if|if
condition|(
name|caseSensitive
condition|)
block|{
return|return
name|inputState
operator|.
name|input
operator|.
name|LA
argument_list|(
name|i
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|toLower
argument_list|(
name|inputState
operator|.
name|input
operator|.
name|LA
argument_list|(
name|i
argument_list|)
argument_list|)
return|;
block|}
block|}
DECL|method|makeToken (int t)
specifier|protected
name|Token
name|makeToken
parameter_list|(
name|int
name|t
parameter_list|)
block|{
try|try
block|{
name|Token
name|tok
init|=
operator|(
name|Token
operator|)
name|tokenObjectClass
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|tok
operator|.
name|setType
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tok
operator|.
name|setColumn
argument_list|(
name|inputState
operator|.
name|tokenStartColumn
argument_list|)
expr_stmt|;
name|tok
operator|.
name|setLine
argument_list|(
name|inputState
operator|.
name|tokenStartLine
argument_list|)
expr_stmt|;
comment|// tracking real start line now: tok.setLine(inputState.line);
return|return
name|tok
return|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|ie
parameter_list|)
block|{
name|panic
argument_list|(
literal|"can't instantiate token: "
operator|+
name|tokenObjectClass
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|iae
parameter_list|)
block|{
name|panic
argument_list|(
literal|"Token class is not accessible"
operator|+
name|tokenObjectClass
argument_list|)
expr_stmt|;
block|}
return|return
name|Token
operator|.
name|badToken
return|;
block|}
DECL|method|mark ()
specifier|public
name|int
name|mark
parameter_list|()
block|{
return|return
name|inputState
operator|.
name|input
operator|.
name|mark
argument_list|()
return|;
block|}
DECL|method|match (char c)
specifier|public
name|void
name|match
parameter_list|(
name|char
name|c
parameter_list|)
throws|throws
name|MismatchedCharException
throws|,
name|CharStreamException
block|{
if|if
condition|(
name|LA
argument_list|(
literal|1
argument_list|)
operator|!=
name|c
condition|)
block|{
throw|throw
operator|new
name|MismatchedCharException
argument_list|(
name|LA
argument_list|(
literal|1
argument_list|)
argument_list|,
name|c
argument_list|,
literal|false
argument_list|,
name|this
argument_list|)
throw|;
block|}
name|consume
argument_list|()
expr_stmt|;
block|}
DECL|method|match (BitSet b)
specifier|public
name|void
name|match
parameter_list|(
name|BitSet
name|b
parameter_list|)
throws|throws
name|MismatchedCharException
throws|,
name|CharStreamException
block|{
if|if
condition|(
operator|!
name|b
operator|.
name|member
argument_list|(
name|LA
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|MismatchedCharException
argument_list|(
name|LA
argument_list|(
literal|1
argument_list|)
argument_list|,
name|b
argument_list|,
literal|false
argument_list|,
name|this
argument_list|)
throw|;
block|}
else|else
block|{
name|consume
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|match (String s)
specifier|public
name|void
name|match
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|MismatchedCharException
throws|,
name|CharStreamException
block|{
name|int
name|len
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|LA
argument_list|(
literal|1
argument_list|)
operator|!=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|MismatchedCharException
argument_list|(
name|LA
argument_list|(
literal|1
argument_list|)
argument_list|,
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|,
literal|false
argument_list|,
name|this
argument_list|)
throw|;
block|}
name|consume
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|matchNot (char c)
specifier|public
name|void
name|matchNot
parameter_list|(
name|char
name|c
parameter_list|)
throws|throws
name|MismatchedCharException
throws|,
name|CharStreamException
block|{
if|if
condition|(
name|LA
argument_list|(
literal|1
argument_list|)
operator|==
name|c
condition|)
block|{
throw|throw
operator|new
name|MismatchedCharException
argument_list|(
name|LA
argument_list|(
literal|1
argument_list|)
argument_list|,
name|c
argument_list|,
literal|true
argument_list|,
name|this
argument_list|)
throw|;
block|}
name|consume
argument_list|()
expr_stmt|;
block|}
DECL|method|matchRange (char c1, char c2)
specifier|public
name|void
name|matchRange
parameter_list|(
name|char
name|c1
parameter_list|,
name|char
name|c2
parameter_list|)
throws|throws
name|MismatchedCharException
throws|,
name|CharStreamException
block|{
if|if
condition|(
name|LA
argument_list|(
literal|1
argument_list|)
operator|<
name|c1
operator|||
name|LA
argument_list|(
literal|1
argument_list|)
operator|>
name|c2
condition|)
throw|throw
operator|new
name|MismatchedCharException
argument_list|(
name|LA
argument_list|(
literal|1
argument_list|)
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|,
literal|false
argument_list|,
name|this
argument_list|)
throw|;
name|consume
argument_list|()
expr_stmt|;
block|}
DECL|method|newline ()
specifier|public
name|void
name|newline
parameter_list|()
block|{
name|inputState
operator|.
name|line
operator|++
expr_stmt|;
name|inputState
operator|.
name|column
operator|=
literal|1
expr_stmt|;
block|}
comment|/** advance the current column number by an appropriate amount.      *  If you do not override this to specify how much to jump for      *  a tab, then tabs are counted as one char.  This method is      *  called from consume().      */
DECL|method|tab ()
specifier|public
name|void
name|tab
parameter_list|()
block|{
comment|// update inputState.column as function of
comment|// inputState.column and tab stops.
comment|// For example, if tab stops are columns 1 and 5 etc...
comment|// and column is 3, then add 2 to column.
name|inputState
operator|.
name|column
operator|++
expr_stmt|;
block|}
DECL|method|panic ()
specifier|public
name|void
name|panic
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"CharScanner: panic"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|panic (String s)
specifier|public
name|void
name|panic
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"CharScanner; panic: "
operator|+
name|s
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/** Parser error-reporting function can be overridden in subclass */
DECL|method|reportError (RecognitionException ex)
specifier|public
name|void
name|reportError
parameter_list|(
name|RecognitionException
name|ex
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
comment|/** Parser error-reporting function can be overridden in subclass */
DECL|method|reportError (String s)
specifier|public
name|void
name|reportError
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|getFilename
argument_list|()
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"error: "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|getFilename
argument_list|()
operator|+
literal|": error: "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Parser warning-reporting function can be overridden in subclass */
DECL|method|reportWarning (String s)
specifier|public
name|void
name|reportWarning
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|getFilename
argument_list|()
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|getFilename
argument_list|()
operator|+
literal|": warning: "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|resetText ()
specifier|public
name|void
name|resetText
parameter_list|()
block|{
name|text
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|inputState
operator|.
name|tokenStartColumn
operator|=
name|inputState
operator|.
name|column
expr_stmt|;
name|inputState
operator|.
name|tokenStartLine
operator|=
name|inputState
operator|.
name|line
expr_stmt|;
block|}
DECL|method|rewind (int pos)
specifier|public
name|void
name|rewind
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|inputState
operator|.
name|input
operator|.
name|rewind
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
DECL|method|setCaseSensitive (boolean t)
specifier|public
name|void
name|setCaseSensitive
parameter_list|(
name|boolean
name|t
parameter_list|)
block|{
name|caseSensitive
operator|=
name|t
expr_stmt|;
block|}
DECL|method|setCommitToPath (boolean commit)
specifier|public
name|void
name|setCommitToPath
parameter_list|(
name|boolean
name|commit
parameter_list|)
block|{
name|commitToPath
operator|=
name|commit
expr_stmt|;
block|}
DECL|method|setFilename (String f)
specifier|public
name|void
name|setFilename
parameter_list|(
name|String
name|f
parameter_list|)
block|{
name|inputState
operator|.
name|filename
operator|=
name|f
expr_stmt|;
block|}
DECL|method|setLine (int line)
specifier|public
name|void
name|setLine
parameter_list|(
name|int
name|line
parameter_list|)
block|{
name|inputState
operator|.
name|line
operator|=
name|line
expr_stmt|;
block|}
DECL|method|setText (String s)
specifier|public
name|void
name|setText
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|resetText
argument_list|()
expr_stmt|;
name|text
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
DECL|method|setTokenObjectClass (String cl)
specifier|public
name|void
name|setTokenObjectClass
parameter_list|(
name|String
name|cl
parameter_list|)
block|{
try|try
block|{
name|tokenObjectClass
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|ce
parameter_list|)
block|{
name|panic
argument_list|(
literal|"ClassNotFoundException: "
operator|+
name|cl
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Test the token text against the literals table
comment|// Override this method to perform a different literals test
DECL|method|testLiteralsTable (int ttype)
specifier|public
name|int
name|testLiteralsTable
parameter_list|(
name|int
name|ttype
parameter_list|)
block|{
name|hashString
operator|.
name|setBuffer
argument_list|(
name|text
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|text
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|Integer
name|literalsIndex
init|=
operator|(
name|Integer
operator|)
name|literals
operator|.
name|get
argument_list|(
name|hashString
argument_list|)
decl_stmt|;
if|if
condition|(
name|literalsIndex
operator|!=
literal|null
condition|)
block|{
name|ttype
operator|=
name|literalsIndex
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
return|return
name|ttype
return|;
block|}
comment|/** Test the text passed in against the literals table      * Override this method to perform a different literals test      * This is used primarily when you want to test a portion of      * a token.      */
DECL|method|testLiteralsTable (String text, int ttype)
specifier|public
name|int
name|testLiteralsTable
parameter_list|(
name|String
name|text
parameter_list|,
name|int
name|ttype
parameter_list|)
block|{
name|ANTLRHashString
name|s
init|=
operator|new
name|ANTLRHashString
argument_list|(
name|text
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|Integer
name|literalsIndex
init|=
operator|(
name|Integer
operator|)
name|literals
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|literalsIndex
operator|!=
literal|null
condition|)
block|{
name|ttype
operator|=
name|literalsIndex
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
return|return
name|ttype
return|;
block|}
comment|// Override this method to get more specific case handling
DECL|method|toLower (char c)
specifier|public
name|char
name|toLower
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Character
operator|.
name|toLowerCase
argument_list|(
name|c
argument_list|)
return|;
block|}
DECL|method|traceIndent ()
specifier|public
name|void
name|traceIndent
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|traceDepth
condition|;
name|i
operator|++
control|)
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
DECL|method|traceIn (String rname)
specifier|public
name|void
name|traceIn
parameter_list|(
name|String
name|rname
parameter_list|)
throws|throws
name|CharStreamException
block|{
name|traceDepth
operator|+=
literal|1
expr_stmt|;
name|traceIndent
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"> lexer "
operator|+
name|rname
operator|+
literal|"; c=="
operator|+
name|LA
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|traceOut (String rname)
specifier|public
name|void
name|traceOut
parameter_list|(
name|String
name|rname
parameter_list|)
throws|throws
name|CharStreamException
block|{
name|traceIndent
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"< lexer "
operator|+
name|rname
operator|+
literal|"; c=="
operator|+
name|LA
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|traceDepth
operator|-=
literal|1
expr_stmt|;
block|}
comment|/** This method is called by YourLexer.nextToken() when the lexer has      *  hit EOF condition.  EOF is NOT a character.      *  This method is not called if EOF is reached during      *  syntactic predicate evaluation or during evaluation      *  of normal lexical rules, which presumably would be      *  an IOException.  This traps the "normal" EOF condition.      *      *  uponEOF() is called after the complete evaluation of      *  the previous token and only if your parser asks      *  for another token beyond that last non-EOF token.      *      *  You might want to throw token or char stream exceptions      *  like: "Heh, premature eof" or a retry stream exception      *  ("I found the end of this file, go back to referencing file").      */
DECL|method|uponEOF ()
specifier|public
name|void
name|uponEOF
parameter_list|()
throws|throws
name|TokenStreamException
throws|,
name|CharStreamException
block|{     }
block|}
end_class

end_unit

