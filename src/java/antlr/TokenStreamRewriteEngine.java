begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/license.html  */
end_comment

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/** This token stream tracks the *entire* token stream coming from  *  a lexer, but does not pass on the whitespace (or whatever else  *  you want to discard) to the parser.  *  *  This class can then be asked for the ith token in the input stream.  *  Useful for dumping out the input stream exactly after doing some  *  augmentation or other manipulations.  Tokens are index from 0..n-1  *  *  You can insert stuff, replace, and delete chunks.  Note that the  *  operations are done lazily--only if you convert the buffer to a  *  String.  This is very efficient because you are not moving data around  *  all the time.  As the buffer of tokens is converted to strings, the  *  toString() method(s) check to see if there is an operation at the  *  current index.  If so, the operation is done and then normal String  *  rendering continues on the buffer.  This is like having multiple Turing  *  machine instruction streams (programs) operating on a single input tape. :)  *  *  Since the operations are done lazily at toString-time, operations do not  *  screw up the token index values.  That is, an insert operation at token  *  index i does not change the index values for tokens i+1..n-1.  *  *  Because operations never actually alter the buffer, you may always get  *  the original token stream back without undoing anything.  Since  *  the instructions are queued up, you can easily simulate transactions and  *  roll back any changes if there is an error just by removing instructions.  *  For example,  *  * 		TokenStreamRewriteEngine rewriteEngine =  * 			new TokenStreamRewriteEngine(lexer);  *      JavaRecognizer parser = new JavaRecognizer(rewriteEngine);  *      ...  *      rewriteEngine.insertAfter("pass1", t, "foobar");}  * 		rewriteEngine.insertAfter("pass2", u, "start");}  * 		System.out.println(rewriteEngine.toString("pass1"));  * 		System.out.println(rewriteEngine.toString("pass2"));  *  *  You can also have multiple "instruction streams" and get multiple  *  rewrites from a single pass over the input.  Just name the instruction  *  streams and use that name again when printing the buffer.  This could be  *  useful for generating a C file and also its header file--all from the  *  same buffer.  *  *  If you don't use named rewrite streams, a "default" stream is used.  *  *  Terence Parr, parrt@cs.usfca.edu  *  University of San Francisco  *  February 2004  */
end_comment

begin_class
DECL|class|TokenStreamRewriteEngine
specifier|public
class|class
name|TokenStreamRewriteEngine
implements|implements
name|TokenStream
block|{
DECL|field|MIN_TOKEN_INDEX
specifier|public
specifier|static
specifier|final
name|int
name|MIN_TOKEN_INDEX
init|=
literal|0
decl_stmt|;
DECL|class|RewriteOperation
specifier|static
class|class
name|RewriteOperation
block|{
DECL|field|index
specifier|protected
name|int
name|index
decl_stmt|;
DECL|field|text
specifier|protected
name|String
name|text
decl_stmt|;
DECL|method|RewriteOperation (int index, String text)
specifier|protected
name|RewriteOperation
parameter_list|(
name|int
name|index
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|this
operator|.
name|text
operator|=
name|text
expr_stmt|;
block|}
comment|/** Execute the rewrite operation by possibly adding to the buffer. 		 *  Return the index of the next token to operate on. 		 */
DECL|method|execute (StringBuffer buf)
specifier|public
name|int
name|execute
parameter_list|(
name|StringBuffer
name|buf
parameter_list|)
block|{
return|return
name|index
return|;
block|}
block|}
DECL|class|InsertBeforeOp
specifier|static
class|class
name|InsertBeforeOp
extends|extends
name|RewriteOperation
block|{
DECL|method|InsertBeforeOp (int index, String text)
specifier|public
name|InsertBeforeOp
parameter_list|(
name|int
name|index
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|super
argument_list|(
name|index
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
DECL|method|execute (StringBuffer buf)
specifier|public
name|int
name|execute
parameter_list|(
name|StringBuffer
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|text
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
block|}
DECL|class|ReplaceOp
specifier|static
class|class
name|ReplaceOp
extends|extends
name|RewriteOperation
block|{
DECL|field|lastIndex
specifier|protected
name|int
name|lastIndex
decl_stmt|;
DECL|method|ReplaceOp (int from, int to, String text)
specifier|public
name|ReplaceOp
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|super
argument_list|(
name|from
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|lastIndex
operator|=
name|to
expr_stmt|;
block|}
DECL|method|execute (StringBuffer buf)
specifier|public
name|int
name|execute
parameter_list|(
name|StringBuffer
name|buf
parameter_list|)
block|{
if|if
condition|(
name|text
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
return|return
name|lastIndex
operator|+
literal|1
return|;
block|}
block|}
DECL|class|DeleteOp
specifier|static
class|class
name|DeleteOp
extends|extends
name|ReplaceOp
block|{
DECL|method|DeleteOp (int from, int to)
specifier|public
name|DeleteOp
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|super
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|DEFAULT_PROGRAM_NAME
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_PROGRAM_NAME
init|=
literal|"default"
decl_stmt|;
DECL|field|PROGRAM_INIT_SIZE
specifier|public
specifier|static
specifier|final
name|int
name|PROGRAM_INIT_SIZE
init|=
literal|100
decl_stmt|;
comment|/** Track the incoming list of tokens */
DECL|field|tokens
specifier|protected
name|List
name|tokens
decl_stmt|;
comment|/** You may have multiple, named streams of rewrite operations. 	 *  I'm calling these things "programs." 	 *  Maps String (name) -> rewrite (List) 	 */
DECL|field|programs
specifier|protected
name|Map
name|programs
init|=
literal|null
decl_stmt|;
comment|/** Map String (program name) -> Integer index */
DECL|field|lastRewriteTokenIndexes
specifier|protected
name|Map
name|lastRewriteTokenIndexes
init|=
literal|null
decl_stmt|;
comment|/** track index of tokens */
DECL|field|index
specifier|protected
name|int
name|index
init|=
name|MIN_TOKEN_INDEX
decl_stmt|;
comment|/** Who do we suck tokens from? */
DECL|field|stream
specifier|protected
name|TokenStream
name|stream
decl_stmt|;
comment|/** Which (whitespace) token(s) to throw out */
DECL|field|discardMask
specifier|protected
name|BitSet
name|discardMask
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
DECL|method|TokenStreamRewriteEngine (TokenStream upstream)
specifier|public
name|TokenStreamRewriteEngine
parameter_list|(
name|TokenStream
name|upstream
parameter_list|)
block|{
name|this
argument_list|(
name|upstream
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
block|}
DECL|method|TokenStreamRewriteEngine (TokenStream upstream, int initialSize)
specifier|public
name|TokenStreamRewriteEngine
parameter_list|(
name|TokenStream
name|upstream
parameter_list|,
name|int
name|initialSize
parameter_list|)
block|{
name|stream
operator|=
name|upstream
expr_stmt|;
name|tokens
operator|=
operator|new
name|ArrayList
argument_list|(
name|initialSize
argument_list|)
expr_stmt|;
name|programs
operator|=
operator|new
name|HashMap
argument_list|()
expr_stmt|;
name|programs
operator|.
name|put
argument_list|(
name|DEFAULT_PROGRAM_NAME
argument_list|,
operator|new
name|ArrayList
argument_list|(
name|PROGRAM_INIT_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|lastRewriteTokenIndexes
operator|=
operator|new
name|HashMap
argument_list|()
expr_stmt|;
block|}
DECL|method|nextToken ()
specifier|public
name|Token
name|nextToken
parameter_list|()
throws|throws
name|TokenStreamException
block|{
name|TokenWithIndex
name|t
decl_stmt|;
comment|// suck tokens until end of stream or we find a non-discarded token
do|do
block|{
name|t
operator|=
operator|(
name|TokenWithIndex
operator|)
name|stream
operator|.
name|nextToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|setIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
comment|// what is t's index in list?
if|if
condition|(
name|t
operator|.
name|getType
argument_list|()
operator|!=
name|Token
operator|.
name|EOF_TYPE
condition|)
block|{
name|tokens
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|// track all tokens except EOF
block|}
name|index
operator|++
expr_stmt|;
comment|// move to next position
block|}
block|}
do|while
condition|(
name|t
operator|!=
literal|null
operator|&&
name|discardMask
operator|.
name|member
argument_list|(
name|t
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
do|;
return|return
name|t
return|;
block|}
DECL|method|rollback (int instructionIndex)
specifier|public
name|void
name|rollback
parameter_list|(
name|int
name|instructionIndex
parameter_list|)
block|{
name|rollback
argument_list|(
name|DEFAULT_PROGRAM_NAME
argument_list|,
name|instructionIndex
argument_list|)
expr_stmt|;
block|}
comment|/** Rollback the instruction stream for a program so that 	 *  the indicated instruction (via instructionIndex) is no 	 *  longer in the stream.  UNTESTED! 	 */
DECL|method|rollback (String programName, int instructionIndex)
specifier|public
name|void
name|rollback
parameter_list|(
name|String
name|programName
parameter_list|,
name|int
name|instructionIndex
parameter_list|)
block|{
name|List
name|is
init|=
operator|(
name|List
operator|)
name|programs
operator|.
name|get
argument_list|(
name|programName
argument_list|)
decl_stmt|;
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
name|programs
operator|.
name|put
argument_list|(
name|programName
argument_list|,
name|is
operator|.
name|subList
argument_list|(
name|MIN_TOKEN_INDEX
argument_list|,
name|instructionIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|deleteProgram ()
specifier|public
name|void
name|deleteProgram
parameter_list|()
block|{
name|deleteProgram
argument_list|(
name|DEFAULT_PROGRAM_NAME
argument_list|)
expr_stmt|;
block|}
comment|/** Reset the program so that no instructions exist */
DECL|method|deleteProgram (String programName)
specifier|public
name|void
name|deleteProgram
parameter_list|(
name|String
name|programName
parameter_list|)
block|{
name|rollback
argument_list|(
name|programName
argument_list|,
name|MIN_TOKEN_INDEX
argument_list|)
expr_stmt|;
block|}
comment|/** If op.index> lastRewriteTokenIndexes, just add to the end. 	 *  Otherwise, do linear */
DECL|method|addToSortedRewriteList (RewriteOperation op)
specifier|protected
name|void
name|addToSortedRewriteList
parameter_list|(
name|RewriteOperation
name|op
parameter_list|)
block|{
name|addToSortedRewriteList
argument_list|(
name|DEFAULT_PROGRAM_NAME
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
DECL|method|addToSortedRewriteList (String programName, RewriteOperation op)
specifier|protected
name|void
name|addToSortedRewriteList
parameter_list|(
name|String
name|programName
parameter_list|,
name|RewriteOperation
name|op
parameter_list|)
block|{
name|List
name|rewrites
init|=
name|getProgram
argument_list|(
name|programName
argument_list|)
decl_stmt|;
comment|// if at or beyond last op's index, just append
if|if
condition|(
name|op
operator|.
name|index
operator|>=
name|getLastRewriteTokenIndex
argument_list|(
name|programName
argument_list|)
condition|)
block|{
name|rewrites
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|// append to list of operations
comment|// record the index of this operation for next time through
name|setLastRewriteTokenIndex
argument_list|(
name|programName
argument_list|,
name|op
operator|.
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// not after the last one, so must insert to ordered list
name|Comparator
name|comparator
init|=
operator|new
name|Comparator
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Object
name|o
parameter_list|,
name|Object
name|o1
parameter_list|)
block|{
name|RewriteOperation
name|a
init|=
operator|(
name|RewriteOperation
operator|)
name|o
decl_stmt|;
name|RewriteOperation
name|b
init|=
operator|(
name|RewriteOperation
operator|)
name|o1
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|index
operator|<
name|b
operator|.
name|index
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|.
name|index
operator|>
name|b
operator|.
name|index
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
block|}
decl_stmt|;
name|int
name|pos
init|=
name|Collections
operator|.
name|binarySearch
argument_list|(
name|rewrites
argument_list|,
name|op
argument_list|,
name|comparator
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|rewrites
operator|.
name|add
argument_list|(
operator|-
name|pos
operator|-
literal|1
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|insertAfter (Token t, String text)
specifier|public
name|void
name|insertAfter
parameter_list|(
name|Token
name|t
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|insertAfter
argument_list|(
name|DEFAULT_PROGRAM_NAME
argument_list|,
name|t
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
DECL|method|insertAfter (int index, String text)
specifier|public
name|void
name|insertAfter
parameter_list|(
name|int
name|index
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|insertAfter
argument_list|(
name|DEFAULT_PROGRAM_NAME
argument_list|,
name|index
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
DECL|method|insertAfter (String programName, Token t, String text)
specifier|public
name|void
name|insertAfter
parameter_list|(
name|String
name|programName
parameter_list|,
name|Token
name|t
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|insertAfter
argument_list|(
name|programName
argument_list|,
operator|(
operator|(
name|TokenWithIndex
operator|)
name|t
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
DECL|method|insertAfter (String programName, int index, String text)
specifier|public
name|void
name|insertAfter
parameter_list|(
name|String
name|programName
parameter_list|,
name|int
name|index
parameter_list|,
name|String
name|text
parameter_list|)
block|{
comment|// to insert after, just insert before next index (even if past end)
name|insertBefore
argument_list|(
name|programName
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
DECL|method|insertBefore (Token t, String text)
specifier|public
name|void
name|insertBefore
parameter_list|(
name|Token
name|t
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|insertBefore
argument_list|(
name|DEFAULT_PROGRAM_NAME
argument_list|,
name|t
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
DECL|method|insertBefore (int index, String text)
specifier|public
name|void
name|insertBefore
parameter_list|(
name|int
name|index
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|insertBefore
argument_list|(
name|DEFAULT_PROGRAM_NAME
argument_list|,
name|index
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
DECL|method|insertBefore (String programName, Token t, String text)
specifier|public
name|void
name|insertBefore
parameter_list|(
name|String
name|programName
parameter_list|,
name|Token
name|t
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|insertBefore
argument_list|(
name|programName
argument_list|,
operator|(
operator|(
name|TokenWithIndex
operator|)
name|t
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
DECL|method|insertBefore (String programName, int index, String text)
specifier|public
name|void
name|insertBefore
parameter_list|(
name|String
name|programName
parameter_list|,
name|int
name|index
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|addToSortedRewriteList
argument_list|(
name|programName
argument_list|,
operator|new
name|InsertBeforeOp
argument_list|(
name|index
argument_list|,
name|text
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|replace (int index, String text)
specifier|public
name|void
name|replace
parameter_list|(
name|int
name|index
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|replace
argument_list|(
name|DEFAULT_PROGRAM_NAME
argument_list|,
name|index
argument_list|,
name|index
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
DECL|method|replace (int from, int to, String text)
specifier|public
name|void
name|replace
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|replace
argument_list|(
name|DEFAULT_PROGRAM_NAME
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
DECL|method|replace (Token indexT, String text)
specifier|public
name|void
name|replace
parameter_list|(
name|Token
name|indexT
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|replace
argument_list|(
name|DEFAULT_PROGRAM_NAME
argument_list|,
name|indexT
argument_list|,
name|indexT
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
DECL|method|replace (Token from, Token to, String text)
specifier|public
name|void
name|replace
parameter_list|(
name|Token
name|from
parameter_list|,
name|Token
name|to
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|replace
argument_list|(
name|DEFAULT_PROGRAM_NAME
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
DECL|method|replace (String programName, int from, int to, String text)
specifier|public
name|void
name|replace
parameter_list|(
name|String
name|programName
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|addToSortedRewriteList
argument_list|(
operator|new
name|ReplaceOp
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|text
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|replace (String programName, Token from, Token to, String text)
specifier|public
name|void
name|replace
parameter_list|(
name|String
name|programName
parameter_list|,
name|Token
name|from
parameter_list|,
name|Token
name|to
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|replace
argument_list|(
name|programName
argument_list|,
operator|(
operator|(
name|TokenWithIndex
operator|)
name|from
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|,
operator|(
operator|(
name|TokenWithIndex
operator|)
name|to
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
DECL|method|delete (int index)
specifier|public
name|void
name|delete
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|delete
argument_list|(
name|DEFAULT_PROGRAM_NAME
argument_list|,
name|index
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
DECL|method|delete (int from, int to)
specifier|public
name|void
name|delete
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|delete
argument_list|(
name|DEFAULT_PROGRAM_NAME
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
DECL|method|delete (Token indexT)
specifier|public
name|void
name|delete
parameter_list|(
name|Token
name|indexT
parameter_list|)
block|{
name|delete
argument_list|(
name|DEFAULT_PROGRAM_NAME
argument_list|,
name|indexT
argument_list|,
name|indexT
argument_list|)
expr_stmt|;
block|}
DECL|method|delete (Token from, Token to)
specifier|public
name|void
name|delete
parameter_list|(
name|Token
name|from
parameter_list|,
name|Token
name|to
parameter_list|)
block|{
name|delete
argument_list|(
name|DEFAULT_PROGRAM_NAME
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
DECL|method|delete (String programName, int from, int to)
specifier|public
name|void
name|delete
parameter_list|(
name|String
name|programName
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|replace
argument_list|(
name|programName
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|delete (String programName, Token from, Token to)
specifier|public
name|void
name|delete
parameter_list|(
name|String
name|programName
parameter_list|,
name|Token
name|from
parameter_list|,
name|Token
name|to
parameter_list|)
block|{
name|replace
argument_list|(
name|programName
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|discard (int ttype)
specifier|public
name|void
name|discard
parameter_list|(
name|int
name|ttype
parameter_list|)
block|{
name|discardMask
operator|.
name|add
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
block|}
DECL|method|getToken (int i)
specifier|public
name|TokenWithIndex
name|getToken
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
operator|(
name|TokenWithIndex
operator|)
name|tokens
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
DECL|method|getTokenStreamSize ()
specifier|public
name|int
name|getTokenStreamSize
parameter_list|()
block|{
return|return
name|tokens
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|toOriginalString ()
specifier|public
name|String
name|toOriginalString
parameter_list|()
block|{
return|return
name|toOriginalString
argument_list|(
name|MIN_TOKEN_INDEX
argument_list|,
name|getTokenStreamSize
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
DECL|method|toOriginalString (int start, int end)
specifier|public
name|String
name|toOriginalString
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|>=
name|MIN_TOKEN_INDEX
operator|&&
name|i
operator|<=
name|end
operator|&&
name|i
operator|<
name|tokens
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|getToken
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|toString
argument_list|(
name|MIN_TOKEN_INDEX
argument_list|,
name|getTokenStreamSize
argument_list|()
argument_list|)
return|;
block|}
DECL|method|toString (String programName)
specifier|public
name|String
name|toString
parameter_list|(
name|String
name|programName
parameter_list|)
block|{
return|return
name|toString
argument_list|(
name|programName
argument_list|,
name|MIN_TOKEN_INDEX
argument_list|,
name|getTokenStreamSize
argument_list|()
argument_list|)
return|;
block|}
DECL|method|toString (int start, int end)
specifier|public
name|String
name|toString
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
return|return
name|toString
argument_list|(
name|DEFAULT_PROGRAM_NAME
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
return|;
block|}
DECL|method|toString (String programName, int start, int end)
specifier|public
name|String
name|toString
parameter_list|(
name|String
name|programName
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|List
name|rewrites
init|=
operator|(
name|List
operator|)
name|programs
operator|.
name|get
argument_list|(
name|programName
argument_list|)
decl_stmt|;
if|if
condition|(
name|rewrites
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
comment|// invalid program
block|}
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
comment|/** Index of first rewrite we have not done */
name|int
name|rewriteOpIndex
init|=
literal|0
decl_stmt|;
name|int
name|tokenCursor
init|=
name|start
decl_stmt|;
while|while
condition|(
name|tokenCursor
operator|>=
name|MIN_TOKEN_INDEX
operator|&&
name|tokenCursor
operator|<=
name|end
operator|&&
name|tokenCursor
operator|<
name|tokens
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|rewriteOpIndex
operator|<
name|rewrites
operator|.
name|size
argument_list|()
condition|)
block|{
name|RewriteOperation
name|op
init|=
operator|(
name|RewriteOperation
operator|)
name|rewrites
operator|.
name|get
argument_list|(
name|rewriteOpIndex
argument_list|)
decl_stmt|;
while|while
condition|(
name|tokenCursor
operator|==
name|op
operator|.
name|index
operator|&&
name|rewriteOpIndex
operator|<
name|rewrites
operator|.
name|size
argument_list|()
condition|)
block|{
comment|/* 					System.out.println("execute op "+rewriteOpIndex+ 									   " (type "+op.getClass().getName()+")" 									   +" at index "+op.index); 					*/
name|tokenCursor
operator|=
name|op
operator|.
name|execute
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|rewriteOpIndex
operator|++
expr_stmt|;
if|if
condition|(
name|rewriteOpIndex
operator|<
name|rewrites
operator|.
name|size
argument_list|()
condition|)
block|{
name|op
operator|=
operator|(
name|RewriteOperation
operator|)
name|rewrites
operator|.
name|get
argument_list|(
name|rewriteOpIndex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tokenCursor
operator|<
name|end
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|getToken
argument_list|(
name|tokenCursor
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|tokenCursor
operator|++
expr_stmt|;
block|}
block|}
comment|// now see if there are operations (append) beyond last token index
for|for
control|(
name|int
name|opi
init|=
name|rewriteOpIndex
init|;
name|opi
operator|<
name|rewrites
operator|.
name|size
argument_list|()
condition|;
name|opi
operator|++
control|)
block|{
name|RewriteOperation
name|op
init|=
operator|(
name|RewriteOperation
operator|)
name|rewrites
operator|.
name|get
argument_list|(
name|opi
argument_list|)
decl_stmt|;
name|op
operator|.
name|execute
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|// must be insertions if after last token
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|toDebugString ()
specifier|public
name|String
name|toDebugString
parameter_list|()
block|{
return|return
name|toDebugString
argument_list|(
name|MIN_TOKEN_INDEX
argument_list|,
name|getTokenStreamSize
argument_list|()
argument_list|)
return|;
block|}
DECL|method|toDebugString (int start, int end)
specifier|public
name|String
name|toDebugString
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|>=
name|MIN_TOKEN_INDEX
operator|&&
name|i
operator|<=
name|end
operator|&&
name|i
operator|<
name|tokens
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|getToken
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|getLastRewriteTokenIndex ()
specifier|public
name|int
name|getLastRewriteTokenIndex
parameter_list|()
block|{
return|return
name|getLastRewriteTokenIndex
argument_list|(
name|DEFAULT_PROGRAM_NAME
argument_list|)
return|;
block|}
DECL|method|getLastRewriteTokenIndex (String programName)
specifier|protected
name|int
name|getLastRewriteTokenIndex
parameter_list|(
name|String
name|programName
parameter_list|)
block|{
name|Integer
name|I
init|=
operator|(
name|Integer
operator|)
name|lastRewriteTokenIndexes
operator|.
name|get
argument_list|(
name|programName
argument_list|)
decl_stmt|;
if|if
condition|(
name|I
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|I
operator|.
name|intValue
argument_list|()
return|;
block|}
DECL|method|setLastRewriteTokenIndex (String programName, int i)
specifier|protected
name|void
name|setLastRewriteTokenIndex
parameter_list|(
name|String
name|programName
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|lastRewriteTokenIndexes
operator|.
name|put
argument_list|(
name|programName
argument_list|,
operator|new
name|Integer
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getProgram (String name)
specifier|protected
name|List
name|getProgram
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|List
name|is
init|=
operator|(
name|List
operator|)
name|programs
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|is
operator|==
literal|null
condition|)
block|{
name|is
operator|=
name|initializeProgram
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|is
return|;
block|}
DECL|method|initializeProgram (String name)
specifier|private
name|List
name|initializeProgram
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|List
name|is
init|=
operator|new
name|ArrayList
argument_list|(
name|PROGRAM_INIT_SIZE
argument_list|)
decl_stmt|;
name|programs
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|is
argument_list|)
expr_stmt|;
return|return
name|is
return|;
block|}
block|}
end_class

end_unit

