begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/RIGHTS.html  *  * $Id$  */
end_comment

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|Vector
import|;
end_import

begin_comment
comment|/** Static implementation of the TokenManager, used for importVocab option  */
end_comment

begin_class
DECL|class|ImportVocabTokenManager
class|class
name|ImportVocabTokenManager
extends|extends
name|SimpleTokenManager
implements|implements
name|Cloneable
block|{
DECL|field|filename
specifier|private
name|String
name|filename
decl_stmt|;
DECL|field|grammar
specifier|protected
name|Grammar
name|grammar
decl_stmt|;
DECL|method|ImportVocabTokenManager (Grammar grammar, String filename_, String name_, Tool tool_)
name|ImportVocabTokenManager
parameter_list|(
name|Grammar
name|grammar
parameter_list|,
name|String
name|filename_
parameter_list|,
name|String
name|name_
parameter_list|,
name|Tool
name|tool_
parameter_list|)
block|{
comment|// initialize
name|super
argument_list|(
name|name_
argument_list|,
name|tool_
argument_list|)
expr_stmt|;
name|this
operator|.
name|grammar
operator|=
name|grammar
expr_stmt|;
comment|// Figure out exactly where the file lives.  Check $PWD first,
comment|// and then search in -o<output_dir>.
name|File
name|grammarFile
init|=
operator|new
name|File
argument_list|(
name|filename_
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|grammarFile
operator|.
name|exists
argument_list|()
condition|)
block|{
name|grammarFile
operator|=
operator|new
name|File
argument_list|(
name|Tool
operator|.
name|getOutputDirectory
argument_list|()
argument_list|,
name|filename_
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|grammarFile
operator|.
name|exists
argument_list|()
condition|)
block|{
name|tool
operator|.
name|panic
argument_list|(
literal|"Cannot find importVocab file '"
operator|+
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
name|filename
operator|=
name|filename_
expr_stmt|;
name|setReadOnly
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Read a file with lines of the form ID=number
try|try
block|{
comment|// SAS: changed the following for proper text io
name|FileReader
name|fileIn
init|=
operator|new
name|FileReader
argument_list|(
name|grammarFile
argument_list|)
decl_stmt|;
name|ANTLRTokdefLexer
name|tokdefLexer
init|=
operator|new
name|ANTLRTokdefLexer
argument_list|(
name|fileIn
argument_list|)
decl_stmt|;
name|ANTLRTokdefParser
name|tokdefParser
init|=
operator|new
name|ANTLRTokdefParser
argument_list|(
name|tokdefLexer
argument_list|)
decl_stmt|;
name|tokdefParser
operator|.
name|setFilename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|tokdefParser
operator|.
name|file
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnf
parameter_list|)
block|{
name|tool
operator|.
name|panic
argument_list|(
literal|"Cannot find importVocab file '"
operator|+
name|filename
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RecognitionException
name|ex
parameter_list|)
block|{
name|tool
operator|.
name|panic
argument_list|(
literal|"Error parsing importVocab file '"
operator|+
name|filename
operator|+
literal|"': "
operator|+
name|ex
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TokenStreamException
name|ex
parameter_list|)
block|{
name|tool
operator|.
name|panic
argument_list|(
literal|"Error reading importVocab file '"
operator|+
name|filename
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|clone ()
specifier|public
name|Object
name|clone
parameter_list|()
block|{
name|ImportVocabTokenManager
name|tm
decl_stmt|;
name|tm
operator|=
operator|(
name|ImportVocabTokenManager
operator|)
name|super
operator|.
name|clone
argument_list|()
expr_stmt|;
name|tm
operator|.
name|filename
operator|=
name|this
operator|.
name|filename
expr_stmt|;
name|tm
operator|.
name|grammar
operator|=
name|this
operator|.
name|grammar
expr_stmt|;
return|return
name|tm
return|;
block|}
comment|/** define a token. */
DECL|method|define (TokenSymbol ts)
specifier|public
name|void
name|define
parameter_list|(
name|TokenSymbol
name|ts
parameter_list|)
block|{
name|super
operator|.
name|define
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
comment|/** define a token.  Intended for use only when reading the importVocab file. */
DECL|method|define (String s, int ttype)
specifier|public
name|void
name|define
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|ttype
parameter_list|)
block|{
name|TokenSymbol
name|ts
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
literal|"\""
argument_list|)
condition|)
block|{
name|ts
operator|=
operator|new
name|StringLiteralSymbol
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ts
operator|=
operator|new
name|TokenSymbol
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|ts
operator|.
name|setTokenType
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
name|super
operator|.
name|define
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|maxToken
operator|=
operator|(
name|ttype
operator|+
literal|1
operator|)
operator|>
name|maxToken
condition|?
operator|(
name|ttype
operator|+
literal|1
operator|)
else|:
name|maxToken
expr_stmt|;
comment|// record maximum token type
block|}
comment|/** importVocab token manager is read-only if output would be same as input */
DECL|method|isReadOnly ()
specifier|public
name|boolean
name|isReadOnly
parameter_list|()
block|{
return|return
name|readOnly
return|;
block|}
comment|/** Get the next unused token type. */
DECL|method|nextTokenType ()
specifier|public
name|int
name|nextTokenType
parameter_list|()
block|{
return|return
name|super
operator|.
name|nextTokenType
argument_list|()
return|;
block|}
block|}
end_class

end_unit

