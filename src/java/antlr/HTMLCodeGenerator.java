begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/license.html  *  * $Id$  */
end_comment

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_comment
comment|//SAS: changed for proper text file io
end_comment

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileWriter
import|;
end_import

begin_comment
comment|/**Generate P.html, a cross-linked representation of P with or without actions */
end_comment

begin_class
DECL|class|HTMLCodeGenerator
specifier|public
class|class
name|HTMLCodeGenerator
extends|extends
name|CodeGenerator
block|{
comment|/** non-zero if inside syntactic predicate generation */
DECL|field|syntacticPredLevel
specifier|protected
name|int
name|syntacticPredLevel
init|=
literal|0
decl_stmt|;
comment|/** true during lexer generation, false during parser generation */
DECL|field|doingLexRules
specifier|protected
name|boolean
name|doingLexRules
init|=
literal|false
decl_stmt|;
DECL|field|firstElementInAlt
specifier|protected
name|boolean
name|firstElementInAlt
decl_stmt|;
DECL|field|prevAltElem
specifier|protected
name|AlternativeElement
name|prevAltElem
init|=
literal|null
decl_stmt|;
comment|// what was generated last?
comment|/** Create a Diagnostic code-generator using the given Grammar      * The caller must still call setTool, setBehavior, and setAnalyzer      * before generating code.      */
DECL|method|HTMLCodeGenerator ()
specifier|public
name|HTMLCodeGenerator
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
name|charFormatter
operator|=
operator|new
name|JavaCharFormatter
argument_list|()
expr_stmt|;
block|}
comment|/** Encode a string for printing in a HTML document..      * e.g. encode '<' '>' and similar stuff      * @param s the string to encode      */
DECL|method|HTMLEncode (String s)
specifier|static
name|String
name|HTMLEncode
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|s
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'&'
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|"&amp;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\"'
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|"&quot;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|"&#039;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|"&lt;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|"&gt;"
argument_list|)
expr_stmt|;
else|else
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|gen ()
specifier|public
name|void
name|gen
parameter_list|()
block|{
comment|// Do the code generation
try|try
block|{
comment|// Loop over all grammars
name|Enumeration
name|grammarIter
init|=
name|behavior
operator|.
name|grammars
operator|.
name|elements
argument_list|()
decl_stmt|;
while|while
condition|(
name|grammarIter
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|Grammar
name|g
init|=
operator|(
name|Grammar
operator|)
name|grammarIter
operator|.
name|nextElement
argument_list|()
decl_stmt|;
comment|// Connect all the components to each other
comment|/* 				g.setGrammarAnalyzer(analyzer); 				analyzer.setGrammar(g); 				*/
name|g
operator|.
name|setCodeGenerator
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// To get right overloading behavior across hetrogeneous grammars
name|g
operator|.
name|generate
argument_list|()
expr_stmt|;
if|if
condition|(
name|antlrTool
operator|.
name|hasError
argument_list|()
condition|)
block|{
name|antlrTool
operator|.
name|fatalError
argument_list|(
literal|"Exiting due to errors."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|antlrTool
operator|.
name|reportException
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate code for the given grammar element.      * @param blk The {...} action to generate      */
DECL|method|gen (ActionElement action)
specifier|public
name|void
name|gen
parameter_list|(
name|ActionElement
name|action
parameter_list|)
block|{
comment|// no-op
block|}
comment|/** Generate code for the given grammar element.      * @param blk The "x|y|z|..." block to generate      */
DECL|method|gen (AlternativeBlock blk)
specifier|public
name|void
name|gen
parameter_list|(
name|AlternativeBlock
name|blk
parameter_list|)
block|{
name|genGenericBlock
argument_list|(
name|blk
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element.      * @param blk The block-end element to generate.  Block-end      * elements are synthesized by the grammar parser to represent      * the end of a block.      */
DECL|method|gen (BlockEndElement end)
specifier|public
name|void
name|gen
parameter_list|(
name|BlockEndElement
name|end
parameter_list|)
block|{
comment|// no-op
block|}
comment|/** Generate code for the given grammar element.      * @param blk The character literal reference to generate      */
DECL|method|gen (CharLiteralElement atom)
specifier|public
name|void
name|gen
parameter_list|(
name|CharLiteralElement
name|atom
parameter_list|)
block|{
if|if
condition|(
name|atom
operator|.
name|not
condition|)
block|{
name|_print
argument_list|(
literal|"~"
argument_list|)
expr_stmt|;
block|}
name|_print
argument_list|(
name|HTMLEncode
argument_list|(
name|atom
operator|.
name|atomText
argument_list|)
operator|+
literal|" "
argument_list|)
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element.      * @param blk The character-range reference to generate      */
DECL|method|gen (CharRangeElement r)
specifier|public
name|void
name|gen
parameter_list|(
name|CharRangeElement
name|r
parameter_list|)
block|{
name|print
argument_list|(
name|r
operator|.
name|beginText
operator|+
literal|".."
operator|+
name|r
operator|.
name|endText
operator|+
literal|" "
argument_list|)
expr_stmt|;
block|}
comment|/** Generate the lexer HTML file */
DECL|method|gen (LexerGrammar g)
specifier|public
name|void
name|gen
parameter_list|(
name|LexerGrammar
name|g
parameter_list|)
throws|throws
name|IOException
block|{
name|setGrammar
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|antlrTool
operator|.
name|reportProgress
argument_list|(
literal|"Generating "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
name|TokenTypesFileExt
argument_list|)
expr_stmt|;
name|currentOutput
operator|=
name|antlrTool
operator|.
name|openOutputFile
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
name|TokenTypesFileExt
argument_list|)
expr_stmt|;
comment|//SAS: changed for proper text file io
name|tabs
operator|=
literal|0
expr_stmt|;
name|doingLexRules
operator|=
literal|true
expr_stmt|;
comment|// Generate header common to all TXT output files
name|genHeader
argument_list|()
expr_stmt|;
comment|// Output the user-defined lexer premamble
comment|// RK: guess not..
comment|// println(grammar.preambleAction.getText());
comment|// Generate lexer class definition
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// print javadoc comment if any
if|if
condition|(
name|grammar
operator|.
name|comment
operator|!=
literal|null
condition|)
block|{
name|_println
argument_list|(
name|HTMLEncode
argument_list|(
name|grammar
operator|.
name|comment
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
literal|"Definition of lexer "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|", which is a subclass of "
operator|+
name|grammar
operator|.
name|getSuperClass
argument_list|()
operator|+
literal|"."
argument_list|)
expr_stmt|;
comment|// Generate user-defined parser class members
comment|// printAction(grammar.classMemberAction.getText());
comment|/* 		// Generate string literals 		println(""); 		println("*** String literals used in the parser"); 		println("The following string literals were used in the parser."); 		println("An actual code generator would arrange to place these literals"); 		println("into a table in the generated lexer, so that actions in the"); 		println("generated lexer could match token text against the literals."); 		println("String literals used in the lexer are not listed here, as they"); 		println("are incorporated into the mainstream lexer processing."); 		tabs++; 		// Enumerate all of the symbols and look for string literal symbols 		Enumeration ids = grammar.getSymbols(); 		while ( ids.hasMoreElements() ) { 			GrammarSymbol sym = (GrammarSymbol)ids.nextElement(); 			// Only processing string literals -- reject other symbol entries 			if ( sym instanceof StringLiteralSymbol ) { 				StringLiteralSymbol s = (StringLiteralSymbol)sym; 				println(s.getId() + " = " + s.getTokenType()); 			} 		} 		tabs--; 		println("*** End of string literals used by the parser"); 		*/
comment|// Generate nextToken() rule.
comment|// nextToken() is a synthetic lexer rule that is the implicit OR of all
comment|// user-defined lexer rules.
name|genNextToken
argument_list|()
expr_stmt|;
comment|// Generate code for each rule in the lexer
name|Enumeration
name|ids
init|=
name|grammar
operator|.
name|rules
operator|.
name|elements
argument_list|()
decl_stmt|;
while|while
condition|(
name|ids
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|ids
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|id
operator|.
name|equals
argument_list|(
literal|"mnextToken"
argument_list|)
condition|)
block|{
name|genRule
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Close the lexer output file
name|currentOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentOutput
operator|=
literal|null
expr_stmt|;
name|doingLexRules
operator|=
literal|false
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element.      * @param blk The (...)+ block to generate      */
DECL|method|gen (OneOrMoreBlock blk)
specifier|public
name|void
name|gen
parameter_list|(
name|OneOrMoreBlock
name|blk
parameter_list|)
block|{
name|genGenericBlock
argument_list|(
name|blk
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
block|}
comment|/** Generate the parser HTML file */
DECL|method|gen (ParserGrammar g)
specifier|public
name|void
name|gen
parameter_list|(
name|ParserGrammar
name|g
parameter_list|)
throws|throws
name|IOException
block|{
name|setGrammar
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|// Open the output stream for the parser and set the currentOutput
name|antlrTool
operator|.
name|reportProgress
argument_list|(
literal|"Generating "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
name|currentOutput
operator|=
name|antlrTool
operator|.
name|openOutputFile
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|0
expr_stmt|;
comment|// Generate the header common to all output files.
name|genHeader
argument_list|()
expr_stmt|;
comment|// Generate parser class definition
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// print javadoc comment if any
if|if
condition|(
name|grammar
operator|.
name|comment
operator|!=
literal|null
condition|)
block|{
name|_println
argument_list|(
name|HTMLEncode
argument_list|(
name|grammar
operator|.
name|comment
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
literal|"Definition of parser "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|", which is a subclass of "
operator|+
name|grammar
operator|.
name|getSuperClass
argument_list|()
operator|+
literal|"."
argument_list|)
expr_stmt|;
comment|// Enumerate the parser rules
name|Enumeration
name|rules
init|=
name|grammar
operator|.
name|rules
operator|.
name|elements
argument_list|()
decl_stmt|;
while|while
condition|(
name|rules
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// Get the rules from the list and downcast it to proper type
name|GrammarSymbol
name|sym
init|=
operator|(
name|GrammarSymbol
operator|)
name|rules
operator|.
name|nextElement
argument_list|()
decl_stmt|;
comment|// Only process parser rules
if|if
condition|(
name|sym
operator|instanceof
name|RuleSymbol
condition|)
block|{
name|genRule
argument_list|(
operator|(
name|RuleSymbol
operator|)
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|genTail
argument_list|()
expr_stmt|;
comment|// Close the parser output stream
name|currentOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentOutput
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element.      * @param blk The rule-reference to generate      */
DECL|method|gen (RuleRefElement rr)
specifier|public
name|void
name|gen
parameter_list|(
name|RuleRefElement
name|rr
parameter_list|)
block|{
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|grammar
operator|.
name|getSymbol
argument_list|(
name|rr
operator|.
name|targetRule
argument_list|)
decl_stmt|;
comment|// Generate the actual rule description
name|_print
argument_list|(
literal|"<a href=\""
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|".html#"
operator|+
name|rr
operator|.
name|targetRule
operator|+
literal|"\">"
argument_list|)
expr_stmt|;
name|_print
argument_list|(
name|rr
operator|.
name|targetRule
argument_list|)
expr_stmt|;
name|_print
argument_list|(
literal|"</a>"
argument_list|)
expr_stmt|;
comment|// RK: Leave out args..
comment|//	if (rr.args != null) {
comment|//		_print("["+rr.args+"]");
comment|//	}
name|_print
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element.      * @param blk The string-literal reference to generate      */
DECL|method|gen (StringLiteralElement atom)
specifier|public
name|void
name|gen
parameter_list|(
name|StringLiteralElement
name|atom
parameter_list|)
block|{
if|if
condition|(
name|atom
operator|.
name|not
condition|)
block|{
name|_print
argument_list|(
literal|"~"
argument_list|)
expr_stmt|;
block|}
name|_print
argument_list|(
name|HTMLEncode
argument_list|(
name|atom
operator|.
name|atomText
argument_list|)
argument_list|)
expr_stmt|;
name|_print
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element.      * @param blk The token-range reference to generate      */
DECL|method|gen (TokenRangeElement r)
specifier|public
name|void
name|gen
parameter_list|(
name|TokenRangeElement
name|r
parameter_list|)
block|{
name|print
argument_list|(
name|r
operator|.
name|beginText
operator|+
literal|".."
operator|+
name|r
operator|.
name|endText
operator|+
literal|" "
argument_list|)
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element.      * @param blk The token-reference to generate      */
DECL|method|gen (TokenRefElement atom)
specifier|public
name|void
name|gen
parameter_list|(
name|TokenRefElement
name|atom
parameter_list|)
block|{
if|if
condition|(
name|atom
operator|.
name|not
condition|)
block|{
name|_print
argument_list|(
literal|"~"
argument_list|)
expr_stmt|;
block|}
name|_print
argument_list|(
name|atom
operator|.
name|atomText
argument_list|)
expr_stmt|;
name|_print
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
DECL|method|gen (TreeElement t)
specifier|public
name|void
name|gen
parameter_list|(
name|TreeElement
name|t
parameter_list|)
block|{
name|print
argument_list|(
name|t
operator|+
literal|" "
argument_list|)
expr_stmt|;
block|}
comment|/** Generate the tree-walker TXT file */
DECL|method|gen (TreeWalkerGrammar g)
specifier|public
name|void
name|gen
parameter_list|(
name|TreeWalkerGrammar
name|g
parameter_list|)
throws|throws
name|IOException
block|{
name|setGrammar
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|// Open the output stream for the parser and set the currentOutput
name|antlrTool
operator|.
name|reportProgress
argument_list|(
literal|"Generating "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
name|currentOutput
operator|=
name|antlrTool
operator|.
name|openOutputFile
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
comment|//SAS: changed for proper text file io
name|tabs
operator|=
literal|0
expr_stmt|;
comment|// Generate the header common to all output files.
name|genHeader
argument_list|()
expr_stmt|;
comment|// Output the user-defined parser premamble
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|//		println("*** Tree-walker Preamble Action.");
comment|//		println("This action will appear before the declaration of your tree-walker class:");
comment|//		tabs++;
comment|//		println(grammar.preambleAction.getText());
comment|//		tabs--;
comment|//		println("*** End of tree-walker Preamble Action");
comment|// Generate tree-walker class definition
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// print javadoc comment if any
if|if
condition|(
name|grammar
operator|.
name|comment
operator|!=
literal|null
condition|)
block|{
name|_println
argument_list|(
name|HTMLEncode
argument_list|(
name|grammar
operator|.
name|comment
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
literal|"Definition of tree parser "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|", which is a subclass of "
operator|+
name|grammar
operator|.
name|getSuperClass
argument_list|()
operator|+
literal|"."
argument_list|)
expr_stmt|;
comment|// Generate user-defined tree-walker class members
comment|//		println("");
comment|//		println("*** User-defined tree-walker class members:");
comment|//		println("These are the member declarations that you defined for your class:");
comment|//		tabs++;
comment|//		printAction(grammar.classMemberAction.getText());
comment|//		tabs--;
comment|//		println("*** End of user-defined tree-walker class members");
comment|// Generate code for each rule in the grammar
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|//		println("*** tree-walker rules:");
name|tabs
operator|++
expr_stmt|;
comment|// Enumerate the tree-walker rules
name|Enumeration
name|rules
init|=
name|grammar
operator|.
name|rules
operator|.
name|elements
argument_list|()
decl_stmt|;
while|while
condition|(
name|rules
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// Get the rules from the list and downcast it to proper type
name|GrammarSymbol
name|sym
init|=
operator|(
name|GrammarSymbol
operator|)
name|rules
operator|.
name|nextElement
argument_list|()
decl_stmt|;
comment|// Only process tree-walker rules
if|if
condition|(
name|sym
operator|instanceof
name|RuleSymbol
condition|)
block|{
name|genRule
argument_list|(
operator|(
name|RuleSymbol
operator|)
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|//		println("*** End of tree-walker rules");
comment|//		println("");
comment|//		println("*** End of tree-walker");
comment|// Close the tree-walker output stream
name|currentOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentOutput
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Generate a wildcard element */
DECL|method|gen (WildcardElement wc)
specifier|public
name|void
name|gen
parameter_list|(
name|WildcardElement
name|wc
parameter_list|)
block|{
comment|/* 		if ( wc.getLabel()!=null ) { 			_print(wc.getLabel()+"="); 		} 		*/
name|_print
argument_list|(
literal|". "
argument_list|)
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element.      * @param blk The (...)* block to generate      */
DECL|method|gen (ZeroOrMoreBlock blk)
specifier|public
name|void
name|gen
parameter_list|(
name|ZeroOrMoreBlock
name|blk
parameter_list|)
block|{
name|genGenericBlock
argument_list|(
name|blk
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
block|}
DECL|method|genAlt (Alternative alt)
specifier|protected
name|void
name|genAlt
parameter_list|(
name|Alternative
name|alt
parameter_list|)
block|{
if|if
condition|(
name|alt
operator|.
name|getTreeSpecifier
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|_print
argument_list|(
name|alt
operator|.
name|getTreeSpecifier
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|prevAltElem
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|AlternativeElement
name|elem
init|=
name|alt
operator|.
name|head
init|;
operator|!
operator|(
name|elem
operator|instanceof
name|BlockEndElement
operator|)
condition|;
name|elem
operator|=
name|elem
operator|.
name|next
control|)
block|{
name|elem
operator|.
name|generate
argument_list|()
expr_stmt|;
name|firstElementInAlt
operator|=
literal|false
expr_stmt|;
name|prevAltElem
operator|=
name|elem
expr_stmt|;
block|}
block|}
comment|/** Generate the header for a block, which may be a RuleBlock or a      * plain AlternativeBLock.  This generates any variable declarations,      * init-actions, and syntactic-predicate-testing variables.      * @blk The block for which the preamble is to be generated.      */
comment|//	protected void genBlockPreamble(AlternativeBlock blk) {
comment|// RK: don't dump out init actions
comment|// dump out init action
comment|//		if ( blk.initAction!=null ) {
comment|//			printAction("{" + blk.initAction + "}");
comment|//		}
comment|//	}
comment|/**Generate common code for a block of alternatives; return a postscript      * that needs to be generated at the end of the block.  Other routines      * may append else-clauses and such for error checking before the postfix      * is generated.      */
DECL|method|genCommonBlock (AlternativeBlock blk)
specifier|public
name|void
name|genCommonBlock
parameter_list|(
name|AlternativeBlock
name|blk
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blk
operator|.
name|alternatives
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Alternative
name|alt
init|=
name|blk
operator|.
name|getAlternativeAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|AlternativeElement
name|elem
init|=
name|alt
operator|.
name|head
decl_stmt|;
comment|// dump alt operator |
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|blk
operator|.
name|alternatives
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|print
argument_list|(
literal|"|\t"
argument_list|)
expr_stmt|;
block|}
comment|// Dump the alternative, starting with predicates
comment|//
name|boolean
name|save
init|=
name|firstElementInAlt
decl_stmt|;
name|firstElementInAlt
operator|=
literal|true
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// in case we do a newline in alt, increase the tab indent
comment|// RK: don't dump semantic/syntactic predicates
comment|// only obscures grammar.
comment|//
comment|// Dump semantic predicates
comment|//
comment|//	if (alt.semPred != null) {
comment|//		println("{" + alt.semPred + "}?");
comment|//	}
comment|// Dump syntactic predicate
comment|//	if (alt.synPred != null) {
comment|//		genSynPred(alt.synPred);
comment|//	}
name|genAlt
argument_list|(
name|alt
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|firstElementInAlt
operator|=
name|save
expr_stmt|;
block|}
block|}
comment|/** Generate a textual representation of the follow set      * for a block.      * @param blk  The rule block of interest      */
DECL|method|genFollowSetForRuleBlock (RuleBlock blk)
specifier|public
name|void
name|genFollowSetForRuleBlock
parameter_list|(
name|RuleBlock
name|blk
parameter_list|)
block|{
name|Lookahead
name|follow
init|=
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|FOLLOW
argument_list|(
literal|1
argument_list|,
name|blk
operator|.
name|endNode
argument_list|)
decl_stmt|;
name|printSet
argument_list|(
name|grammar
operator|.
name|maxk
argument_list|,
literal|1
argument_list|,
name|follow
argument_list|)
expr_stmt|;
block|}
DECL|method|genGenericBlock (AlternativeBlock blk, String blkOp)
specifier|protected
name|void
name|genGenericBlock
parameter_list|(
name|AlternativeBlock
name|blk
parameter_list|,
name|String
name|blkOp
parameter_list|)
block|{
if|if
condition|(
name|blk
operator|.
name|alternatives
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// make sure we start on a new line
if|if
condition|(
operator|!
name|firstElementInAlt
condition|)
block|{
comment|// only do newline if the last element wasn't a multi-line block
if|if
condition|(
name|prevAltElem
operator|==
literal|null
operator|||
operator|!
operator|(
name|prevAltElem
operator|instanceof
name|AlternativeBlock
operator|)
operator|||
operator|(
operator|(
name|AlternativeBlock
operator|)
name|prevAltElem
operator|)
operator|.
name|alternatives
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|print
argument_list|(
literal|"(\t"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_print
argument_list|(
literal|"(\t"
argument_list|)
expr_stmt|;
block|}
comment|// _println("");
comment|// print("(\t");
block|}
else|else
block|{
name|_print
argument_list|(
literal|"(\t"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|_print
argument_list|(
literal|"( "
argument_list|)
expr_stmt|;
block|}
comment|// RK: don't dump init actions
comment|//	genBlockPreamble(blk);
name|genCommonBlock
argument_list|(
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|.
name|alternatives
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|print
argument_list|(
literal|")"
operator|+
name|blkOp
operator|+
literal|" "
argument_list|)
expr_stmt|;
comment|// if not last element of alt, need newline& to indent
if|if
condition|(
operator|!
operator|(
name|blk
operator|.
name|next
operator|instanceof
name|BlockEndElement
operator|)
condition|)
block|{
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|print
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|_print
argument_list|(
literal|")"
operator|+
name|blkOp
operator|+
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate a header that is common to all TXT files */
DECL|method|genHeader ()
specifier|protected
name|void
name|genHeader
parameter_list|()
block|{
name|println
argument_list|(
literal|"<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"<HTML>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"<HEAD>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"<TITLE>Grammar "
operator|+
name|antlrTool
operator|.
name|grammarFile
operator|+
literal|"</TITLE>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"</HEAD>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"<BODY>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"<table summary=\"\" border=\"1\" cellpadding=\"5\">"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"<tr>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"<td>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"<font size=\"+2\">Grammar "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"</font><br>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"<a href=\"http://www.ANTLR.org\">ANTLR</a>-generated HTML file from "
operator|+
name|antlrTool
operator|.
name|grammarFile
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"<p>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"Terence Parr,<a href=\"http://www.magelang.com\">MageLang Institute</a>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"<br>ANTLR Version "
operator|+
name|antlrTool
operator|.
name|version
operator|+
literal|"; 1989-1999"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"</td>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"</tr>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"</table>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"<PRE>"
argument_list|)
expr_stmt|;
comment|// RK: see no reason for printing include files and stuff...
comment|//		tabs++;
comment|//		printAction(behavior.getHeaderAction(""));
comment|//		tabs--;
block|}
comment|/**Generate the lookahead set for an alternate. */
DECL|method|genLookaheadSetForAlt (Alternative alt)
specifier|protected
name|void
name|genLookaheadSetForAlt
parameter_list|(
name|Alternative
name|alt
parameter_list|)
block|{
if|if
condition|(
name|doingLexRules
operator|&&
name|alt
operator|.
name|cache
index|[
literal|1
index|]
operator|.
name|containsEpsilon
argument_list|()
condition|)
block|{
name|println
argument_list|(
literal|"MATCHES ALL"
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|depth
init|=
name|alt
operator|.
name|lookaheadDepth
decl_stmt|;
if|if
condition|(
name|depth
operator|==
name|GrammarAnalyzer
operator|.
name|NONDETERMINISTIC
condition|)
block|{
comment|// if the decision is nondeterministic, do the best we can: LL(k)
comment|// any predicates that are around will be generated later.
name|depth
operator|=
name|grammar
operator|.
name|maxk
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|depth
condition|;
name|i
operator|++
control|)
block|{
name|Lookahead
name|lookahead
init|=
name|alt
operator|.
name|cache
index|[
name|i
index|]
decl_stmt|;
name|printSet
argument_list|(
name|depth
argument_list|,
name|i
argument_list|,
name|lookahead
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate a textual representation of the lookahead set      * for a block.      * @param blk  The block of interest      */
DECL|method|genLookaheadSetForBlock (AlternativeBlock blk)
specifier|public
name|void
name|genLookaheadSetForBlock
parameter_list|(
name|AlternativeBlock
name|blk
parameter_list|)
block|{
comment|// Find the maximal lookahead depth over all alternatives
name|int
name|depth
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blk
operator|.
name|alternatives
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Alternative
name|alt
init|=
name|blk
operator|.
name|getAlternativeAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|alt
operator|.
name|lookaheadDepth
operator|==
name|GrammarAnalyzer
operator|.
name|NONDETERMINISTIC
condition|)
block|{
name|depth
operator|=
name|grammar
operator|.
name|maxk
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|depth
operator|<
name|alt
operator|.
name|lookaheadDepth
condition|)
block|{
name|depth
operator|=
name|alt
operator|.
name|lookaheadDepth
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|depth
condition|;
name|i
operator|++
control|)
block|{
name|Lookahead
name|lookahead
init|=
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|look
argument_list|(
name|i
argument_list|,
name|blk
argument_list|)
decl_stmt|;
name|printSet
argument_list|(
name|depth
argument_list|,
name|i
argument_list|,
name|lookahead
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate the nextToken rule.      * nextToken is a synthetic lexer rule that is the implicit OR of all      * user-defined lexer rules.      */
DECL|method|genNextToken ()
specifier|public
name|void
name|genNextToken
parameter_list|()
block|{
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"/** Lexer nextToken rule:"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|" *  The lexer nextToken rule is synthesized from all of the user-defined"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|" *  lexer rules.  It logically consists of one big alternative block with"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|" *  each user-defined rule being an alternative."
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|" */"
argument_list|)
expr_stmt|;
comment|// Create the synthesized rule block for nextToken consisting
comment|// of an alternate block containing all the user-defined lexer rules.
name|RuleBlock
name|blk
init|=
name|MakeGrammar
operator|.
name|createNextTokenRule
argument_list|(
name|grammar
argument_list|,
name|grammar
operator|.
name|rules
argument_list|,
literal|"nextToken"
argument_list|)
decl_stmt|;
comment|// Define the nextToken rule symbol
name|RuleSymbol
name|nextTokenRs
init|=
operator|new
name|RuleSymbol
argument_list|(
literal|"mnextToken"
argument_list|)
decl_stmt|;
name|nextTokenRs
operator|.
name|setDefined
argument_list|()
expr_stmt|;
name|nextTokenRs
operator|.
name|setBlock
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|nextTokenRs
operator|.
name|access
operator|=
literal|"private"
expr_stmt|;
name|grammar
operator|.
name|define
argument_list|(
name|nextTokenRs
argument_list|)
expr_stmt|;
comment|/* 		// Analyze the synthesized block 		if (!grammar.theLLkAnalyzer.deterministic(blk)) 		{ 			println("The grammar analyzer has determined that the synthesized"); 			println("nextToken rule is non-deterministic (i.e., it has ambiguities)"); 			println("This means that there is some overlap of the character"); 			println("lookahead for two or more of your lexer rules."); 		} 		*/
name|genCommonBlock
argument_list|(
name|blk
argument_list|)
expr_stmt|;
block|}
comment|/** Generate code for a named rule block      * @param s The RuleSymbol describing the rule to generate      */
DECL|method|genRule (RuleSymbol s)
specifier|public
name|void
name|genRule
parameter_list|(
name|RuleSymbol
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
literal|null
operator|||
operator|!
name|s
operator|.
name|isDefined
argument_list|()
condition|)
return|return;
comment|// undefined rule
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|comment
operator|!=
literal|null
condition|)
block|{
name|_println
argument_list|(
name|HTMLEncode
argument_list|(
name|s
operator|.
name|comment
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|.
name|access
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|s
operator|.
name|access
operator|.
name|equals
argument_list|(
literal|"public"
argument_list|)
condition|)
block|{
name|_print
argument_list|(
name|s
operator|.
name|access
operator|+
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
name|_print
argument_list|(
literal|"<a name=\""
operator|+
name|s
operator|.
name|getId
argument_list|()
operator|+
literal|"\">"
argument_list|)
expr_stmt|;
name|_print
argument_list|(
name|s
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|_print
argument_list|(
literal|"</a>"
argument_list|)
expr_stmt|;
comment|// Get rule return type and arguments
name|RuleBlock
name|rblk
init|=
name|s
operator|.
name|getBlock
argument_list|()
decl_stmt|;
comment|// RK: for HTML output not of much value...
comment|// Gen method return value(s)
comment|//		if (rblk.returnAction != null) {
comment|//			_print("["+rblk.returnAction+"]");
comment|//		}
comment|// Gen arguments
comment|//		if (rblk.argAction != null)
comment|//		{
comment|//				_print(" returns [" + rblk.argAction+"]");
comment|//		}
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|print
argument_list|(
literal|":\t"
argument_list|)
expr_stmt|;
comment|// Dump any init-action
comment|// genBlockPreamble(rblk);
comment|// Dump the alternates of the rule
name|genCommonBlock
argument_list|(
name|rblk
argument_list|)
expr_stmt|;
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
block|}
comment|/** Generate the syntactic predicate.  This basically generates      * the alternative block, buts tracks if we are inside a synPred      * @param blk  The syntactic predicate block      */
DECL|method|genSynPred (SynPredBlock blk)
specifier|protected
name|void
name|genSynPred
parameter_list|(
name|SynPredBlock
name|blk
parameter_list|)
block|{
name|syntacticPredLevel
operator|++
expr_stmt|;
name|genGenericBlock
argument_list|(
name|blk
argument_list|,
literal|" =>"
argument_list|)
expr_stmt|;
name|syntacticPredLevel
operator|--
expr_stmt|;
block|}
DECL|method|genTail ()
specifier|public
name|void
name|genTail
parameter_list|()
block|{
name|println
argument_list|(
literal|"</PRE>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"</BODY>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"</HTML>"
argument_list|)
expr_stmt|;
block|}
comment|/** Generate the token types TXT file */
DECL|method|genTokenTypes (TokenManager tm)
specifier|protected
name|void
name|genTokenTypes
parameter_list|(
name|TokenManager
name|tm
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Open the token output TXT file and set the currentOutput stream
name|antlrTool
operator|.
name|reportProgress
argument_list|(
literal|"Generating "
operator|+
name|tm
operator|.
name|getName
argument_list|()
operator|+
name|TokenTypesFileSuffix
operator|+
name|TokenTypesFileExt
argument_list|)
expr_stmt|;
name|currentOutput
operator|=
name|antlrTool
operator|.
name|openOutputFile
argument_list|(
name|tm
operator|.
name|getName
argument_list|()
operator|+
name|TokenTypesFileSuffix
operator|+
name|TokenTypesFileExt
argument_list|)
expr_stmt|;
comment|//SAS: changed for proper text file io
name|tabs
operator|=
literal|0
expr_stmt|;
comment|// Generate the header common to all diagnostic files
name|genHeader
argument_list|()
expr_stmt|;
comment|// Generate a string for each token.  This creates a static
comment|// array of Strings indexed by token type.
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"*** Tokens used by the parser"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"This is a list of the token numeric values and the corresponding"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"token identifiers.  Some tokens are literals, and because of that"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"they have no identifiers.  Literals are double-quoted."
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// Enumerate all the valid token types
name|Vector
name|v
init|=
name|tm
operator|.
name|getVocabulary
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|Token
operator|.
name|MIN_USER_TYPE
init|;
name|i
operator|<
name|v
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|s
init|=
operator|(
name|String
operator|)
name|v
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
name|s
operator|+
literal|" = "
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Close the interface
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"*** End of tokens used by the parser"
argument_list|)
expr_stmt|;
comment|// Close the tokens output file
name|currentOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentOutput
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Get a string for an expression to generate creation of an AST subtree.      * @param v A Vector of String, where each element is an expression in the target language yielding an AST node.      */
DECL|method|getASTCreateString (Vector v)
specifier|public
name|String
name|getASTCreateString
parameter_list|(
name|Vector
name|v
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
comment|/** Get a string for an expression to generate creating of an AST node      * @param str The arguments to the AST constructor      */
DECL|method|getASTCreateString (GrammarAtom atom, String str)
specifier|public
name|String
name|getASTCreateString
parameter_list|(
name|GrammarAtom
name|atom
parameter_list|,
name|String
name|str
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
comment|/** Map an identifier to it's corresponding tree-node variable.      * This is context-sensitive, depending on the rule and alternative      * being generated      * @param id The identifier name to map      * @param forInput true if the input tree node variable is to be returned, otherwise the output variable is returned.      */
DECL|method|mapTreeId (String id, ActionTransInfo tInfo)
specifier|public
name|String
name|mapTreeId
parameter_list|(
name|String
name|id
parameter_list|,
name|ActionTransInfo
name|tInfo
parameter_list|)
block|{
return|return
name|id
return|;
block|}
comment|/// unused.
DECL|method|processActionForSpecialSymbols (String actionStr, int line, RuleBlock currentRule, ActionTransInfo tInfo)
specifier|protected
name|String
name|processActionForSpecialSymbols
parameter_list|(
name|String
name|actionStr
parameter_list|,
name|int
name|line
parameter_list|,
name|RuleBlock
name|currentRule
parameter_list|,
name|ActionTransInfo
name|tInfo
parameter_list|)
block|{
return|return
name|actionStr
return|;
block|}
comment|/** Format a lookahead or follow set.      * @param depth The depth of the entire lookahead/follow      * @param k The lookahead level to print      * @param lookahead  The lookahead/follow set to print      */
DECL|method|printSet (int depth, int k, Lookahead lookahead)
specifier|public
name|void
name|printSet
parameter_list|(
name|int
name|depth
parameter_list|,
name|int
name|k
parameter_list|,
name|Lookahead
name|lookahead
parameter_list|)
block|{
name|int
name|numCols
init|=
literal|5
decl_stmt|;
name|int
index|[]
name|elems
init|=
name|lookahead
operator|.
name|fset
operator|.
name|toArray
argument_list|()
decl_stmt|;
if|if
condition|(
name|depth
operator|!=
literal|1
condition|)
block|{
name|print
argument_list|(
literal|"k=="
operator|+
name|k
operator|+
literal|": {"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print
argument_list|(
literal|"{ "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elems
operator|.
name|length
operator|>
name|numCols
condition|)
block|{
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|print
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|int
name|column
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|elems
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|column
operator|++
expr_stmt|;
if|if
condition|(
name|column
operator|>
name|numCols
condition|)
block|{
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|print
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|doingLexRules
condition|)
block|{
name|_print
argument_list|(
name|charFormatter
operator|.
name|literalChar
argument_list|(
name|elems
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_print
argument_list|(
operator|(
name|String
operator|)
name|grammar
operator|.
name|tokenManager
operator|.
name|getVocabulary
argument_list|()
operator|.
name|elementAt
argument_list|(
name|elems
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|elems
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|_print
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|elems
operator|.
name|length
operator|>
name|numCols
condition|)
block|{
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|print
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|_println
argument_list|(
literal|" }"
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

