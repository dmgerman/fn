begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/RIGHTS.html  *  * $Id$  */
end_comment

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|Vector
import|;
end_import

begin_comment
comment|/**A list of alternatives */
end_comment

begin_class
DECL|class|AlternativeBlock
class|class
name|AlternativeBlock
extends|extends
name|AlternativeElement
block|{
DECL|field|initAction
specifier|protected
name|String
name|initAction
init|=
literal|null
decl_stmt|;
comment|// string for init action {...}
DECL|field|alternatives
specifier|protected
name|Vector
name|alternatives
decl_stmt|;
comment|// Contains Alternatives
DECL|field|label
specifier|protected
name|String
name|label
decl_stmt|;
comment|// can label a looping block to break out of it.
DECL|field|alti
DECL|field|altj
specifier|protected
name|int
name|alti
decl_stmt|,
name|altj
decl_stmt|;
comment|// which alts are being compared at the moment with
comment|// deterministic()?
DECL|field|analysisAlt
specifier|protected
name|int
name|analysisAlt
decl_stmt|;
comment|// which alt are we computing look on?  Must be alti or altj
DECL|field|hasAnAction
specifier|protected
name|boolean
name|hasAnAction
init|=
literal|false
decl_stmt|;
comment|// does any alt have an action?
DECL|field|hasASynPred
specifier|protected
name|boolean
name|hasASynPred
init|=
literal|false
decl_stmt|;
comment|// does any alt have a syntactic predicate?
DECL|field|ID
specifier|protected
name|int
name|ID
init|=
literal|0
decl_stmt|;
comment|// used to generate unique variables
DECL|field|nblks
specifier|protected
specifier|static
name|int
name|nblks
decl_stmt|;
comment|// how many blocks have we allocated?
DECL|field|not
name|boolean
name|not
init|=
literal|false
decl_stmt|;
comment|// true if block is inverted.
DECL|field|greedy
name|boolean
name|greedy
init|=
literal|true
decl_stmt|;
comment|// Blocks are greedy by default
DECL|field|greedySet
name|boolean
name|greedySet
init|=
literal|false
decl_stmt|;
comment|// but, if not explicitly greedy, warning might be generated
DECL|field|doAutoGen
specifier|protected
name|boolean
name|doAutoGen
init|=
literal|true
decl_stmt|;
comment|// false if no AST (or text) to be generated for block
DECL|field|warnWhenFollowAmbig
specifier|protected
name|boolean
name|warnWhenFollowAmbig
init|=
literal|true
decl_stmt|;
comment|// warn when an empty path or exit path
DECL|field|generateAmbigWarnings
specifier|protected
name|boolean
name|generateAmbigWarnings
init|=
literal|true
decl_stmt|;
comment|// the general warning "shut-up" mechanism
comment|// conflicts with alt of subrule.
comment|// Turning this off will suppress stuff
comment|// like the if-then-else ambig.
DECL|method|AlternativeBlock (Grammar g)
specifier|public
name|AlternativeBlock
parameter_list|(
name|Grammar
name|g
parameter_list|)
block|{
name|this
argument_list|(
name|g
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|AlternativeBlock (Grammar g, int line, boolean not)
specifier|public
name|AlternativeBlock
parameter_list|(
name|Grammar
name|g
parameter_list|,
name|int
name|line
parameter_list|,
name|boolean
name|not
parameter_list|)
block|{
name|super
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|alternatives
operator|=
operator|new
name|Vector
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|this
operator|.
name|line
operator|=
name|line
expr_stmt|;
name|this
operator|.
name|not
operator|=
name|not
expr_stmt|;
name|nblks
operator|++
expr_stmt|;
name|ID
operator|=
name|nblks
expr_stmt|;
block|}
DECL|method|addAlternative (Alternative alt)
specifier|public
name|void
name|addAlternative
parameter_list|(
name|Alternative
name|alt
parameter_list|)
block|{
name|alternatives
operator|.
name|appendElement
argument_list|(
name|alt
argument_list|)
expr_stmt|;
block|}
DECL|method|generate ()
specifier|public
name|void
name|generate
parameter_list|()
block|{
name|grammar
operator|.
name|generator
operator|.
name|gen
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|getAlternativeAt (int i)
specifier|public
name|Alternative
name|getAlternativeAt
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
operator|(
name|Alternative
operator|)
name|alternatives
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
return|;
block|}
DECL|method|getAlternatives ()
specifier|public
name|Vector
name|getAlternatives
parameter_list|()
block|{
return|return
name|alternatives
return|;
block|}
DECL|method|getAutoGen ()
specifier|public
name|boolean
name|getAutoGen
parameter_list|()
block|{
return|return
name|doAutoGen
return|;
block|}
DECL|method|getInitAction ()
specifier|public
name|String
name|getInitAction
parameter_list|()
block|{
return|return
name|initAction
return|;
block|}
DECL|method|getLabel ()
specifier|public
name|String
name|getLabel
parameter_list|()
block|{
return|return
name|label
return|;
block|}
DECL|method|look (int k)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|)
block|{
return|return
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|look
argument_list|(
name|k
argument_list|,
name|this
argument_list|)
return|;
block|}
DECL|method|prepareForAnalysis ()
specifier|public
name|void
name|prepareForAnalysis
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alternatives
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// deterministic() uses an alternative cache and sets lookahead depth
name|Alternative
name|a
init|=
operator|(
name|Alternative
operator|)
name|alternatives
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|a
operator|.
name|cache
operator|=
operator|new
name|Lookahead
index|[
name|grammar
operator|.
name|maxk
operator|+
literal|1
index|]
expr_stmt|;
name|a
operator|.
name|lookaheadDepth
operator|=
name|GrammarAnalyzer
operator|.
name|LOOKAHEAD_DEPTH_INIT
expr_stmt|;
block|}
block|}
comment|/**Walk the syntactic predicate and, for a rule ref R, remove 	 * the ref from the list of FOLLOW references for R (stored 	 * in the symbol table. 	 */
DECL|method|removeTrackingOfRuleRefs (Grammar g)
specifier|public
name|void
name|removeTrackingOfRuleRefs
parameter_list|(
name|Grammar
name|g
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alternatives
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Alternative
name|alt
init|=
name|getAlternativeAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|AlternativeElement
name|elem
init|=
name|alt
operator|.
name|head
decl_stmt|;
while|while
condition|(
name|elem
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|elem
operator|instanceof
name|RuleRefElement
condition|)
block|{
name|RuleRefElement
name|rr
init|=
operator|(
name|RuleRefElement
operator|)
name|elem
decl_stmt|;
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|g
operator|.
name|getSymbol
argument_list|(
name|rr
operator|.
name|targetRule
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|==
literal|null
condition|)
block|{
name|grammar
operator|.
name|tool
operator|.
name|error
argument_list|(
literal|"rule "
operator|+
name|rr
operator|.
name|targetRule
operator|+
literal|" referenced in (...)=>, but not defined"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rs
operator|.
name|references
operator|.
name|removeElement
argument_list|(
name|rr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|elem
operator|instanceof
name|AlternativeBlock
condition|)
block|{
comment|// recurse into subrules
operator|(
operator|(
name|AlternativeBlock
operator|)
name|elem
operator|)
operator|.
name|removeTrackingOfRuleRefs
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
name|elem
operator|=
name|elem
operator|.
name|next
expr_stmt|;
block|}
block|}
block|}
DECL|method|setAlternatives (Vector v)
specifier|public
name|void
name|setAlternatives
parameter_list|(
name|Vector
name|v
parameter_list|)
block|{
name|alternatives
operator|=
name|v
expr_stmt|;
block|}
DECL|method|setAutoGen (boolean doAutoGen_)
specifier|public
name|void
name|setAutoGen
parameter_list|(
name|boolean
name|doAutoGen_
parameter_list|)
block|{
name|doAutoGen
operator|=
name|doAutoGen_
expr_stmt|;
block|}
DECL|method|setInitAction (String initAction_)
specifier|public
name|void
name|setInitAction
parameter_list|(
name|String
name|initAction_
parameter_list|)
block|{
name|initAction
operator|=
name|initAction_
expr_stmt|;
block|}
DECL|method|setLabel (String label_)
specifier|public
name|void
name|setLabel
parameter_list|(
name|String
name|label_
parameter_list|)
block|{
name|label
operator|=
name|label_
expr_stmt|;
block|}
DECL|method|setOption (Token key, Token value)
specifier|public
name|void
name|setOption
parameter_list|(
name|Token
name|key
parameter_list|,
name|Token
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"warnWhenFollowAmbig"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|warnWhenFollowAmbig
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|warnWhenFollowAmbig
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|grammar
operator|.
name|tool
operator|.
name|error
argument_list|(
literal|"Value for warnWhenFollowAmbig must be true or false"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|key
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"generateAmbigWarnings"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|generateAmbigWarnings
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|generateAmbigWarnings
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|grammar
operator|.
name|tool
operator|.
name|error
argument_list|(
literal|"Value for generateAmbigWarnings must be true or false"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|key
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"greedy"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|greedy
operator|=
literal|true
expr_stmt|;
name|greedySet
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|greedy
operator|=
literal|false
expr_stmt|;
name|greedySet
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|grammar
operator|.
name|tool
operator|.
name|error
argument_list|(
literal|"Value for greedy must be true or false"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|key
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|grammar
operator|.
name|tool
operator|.
name|error
argument_list|(
literal|"Invalid subrule option: "
operator|+
name|key
operator|.
name|getText
argument_list|()
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|key
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|s
init|=
literal|" ("
decl_stmt|;
if|if
condition|(
name|initAction
operator|!=
literal|null
condition|)
block|{
name|s
operator|+=
name|initAction
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alternatives
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Alternative
name|alt
init|=
name|getAlternativeAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Lookahead
name|cache
index|[]
init|=
name|alt
operator|.
name|cache
decl_stmt|;
name|int
name|k
init|=
name|alt
operator|.
name|lookaheadDepth
decl_stmt|;
comment|// dump lookahead set
if|if
condition|(
name|k
operator|==
name|GrammarAnalyzer
operator|.
name|LOOKAHEAD_DEPTH_INIT
condition|)
block|{ 	    }
elseif|else
if|if
condition|(
name|k
operator|==
name|GrammarAnalyzer
operator|.
name|NONDETERMINISTIC
condition|)
block|{
name|s
operator|+=
literal|"{?}:"
expr_stmt|;
block|}
else|else
block|{
name|s
operator|+=
literal|" {"
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<=
name|k
condition|;
name|j
operator|++
control|)
block|{
name|s
operator|+=
name|cache
index|[
name|j
index|]
operator|.
name|toString
argument_list|(
literal|","
argument_list|,
name|grammar
operator|.
name|tokenManager
operator|.
name|getVocabulary
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|k
operator|&&
name|cache
index|[
name|j
operator|+
literal|1
index|]
operator|!=
literal|null
condition|)
name|s
operator|+=
literal|";"
expr_stmt|;
block|}
name|s
operator|+=
literal|"}:"
expr_stmt|;
block|}
comment|// dump alternative including pred (if any)
name|AlternativeElement
name|p
init|=
name|alt
operator|.
name|head
decl_stmt|;
name|String
name|pred
init|=
name|alt
operator|.
name|semPred
decl_stmt|;
if|if
condition|(
name|pred
operator|!=
literal|null
condition|)
block|{
name|s
operator|+=
name|pred
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|s
operator|+=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|.
name|next
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
operator|(
name|alternatives
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
name|s
operator|+=
literal|" |"
expr_stmt|;
block|}
block|}
name|s
operator|+=
literal|" )"
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
end_class

end_unit

