begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/RIGHTS.html  *  * $Id$  */
end_comment

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|BitSet
import|;
end_import

begin_comment
comment|/**This object filters a token stream coming from a lexer  * or another TokenStream so that only certain token channels  * get transmitted to the parser.  *  * Any of the channels can be filtered off as "hidden" channels whose  * tokens can be accessed from the parser.  */
end_comment

begin_class
DECL|class|TokenStreamHiddenTokenFilter
specifier|public
class|class
name|TokenStreamHiddenTokenFilter
extends|extends
name|TokenStreamBasicFilter
implements|implements
name|TokenStream
block|{
comment|// protected BitSet discardMask;
DECL|field|hideMask
specifier|protected
name|BitSet
name|hideMask
decl_stmt|;
DECL|field|nextMonitoredToken
specifier|private
name|CommonHiddenStreamToken
name|nextMonitoredToken
decl_stmt|;
comment|/** track tail of hidden list emanating from previous 	 *  monitored token 	 */
DECL|field|lastHiddenToken
specifier|protected
name|CommonHiddenStreamToken
name|lastHiddenToken
decl_stmt|;
DECL|field|firstHidden
specifier|protected
name|CommonHiddenStreamToken
name|firstHidden
init|=
literal|null
decl_stmt|;
DECL|method|TokenStreamHiddenTokenFilter (TokenStream input)
specifier|public
name|TokenStreamHiddenTokenFilter
parameter_list|(
name|TokenStream
name|input
parameter_list|)
block|{
name|super
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|hideMask
operator|=
operator|new
name|BitSet
argument_list|()
expr_stmt|;
block|}
DECL|method|consume ()
specifier|protected
name|void
name|consume
parameter_list|()
throws|throws
name|TokenStreamException
block|{
name|nextMonitoredToken
operator|=
operator|(
name|CommonHiddenStreamToken
operator|)
name|input
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
DECL|method|consumeFirst ()
specifier|private
name|void
name|consumeFirst
parameter_list|()
throws|throws
name|TokenStreamException
block|{
name|consume
argument_list|()
expr_stmt|;
comment|// get first token of input stream
comment|// Handle situation where hidden or discarded tokens
comment|// appear first in input stream
name|CommonHiddenStreamToken
name|p
init|=
literal|null
decl_stmt|;
comment|// while hidden or discarded scarf tokens
while|while
condition|(
name|hideMask
operator|.
name|member
argument_list|(
name|LA
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
operator|||
name|discardMask
operator|.
name|member
argument_list|(
name|LA
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|hideMask
operator|.
name|member
argument_list|(
name|LA
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|==
literal|null
condition|)
block|{
name|p
operator|=
name|LA
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|.
name|setHiddenAfter
argument_list|(
name|LA
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|LA
argument_list|(
literal|1
argument_list|)
operator|.
name|setHiddenBefore
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// double-link
name|p
operator|=
name|LA
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|lastHiddenToken
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|firstHidden
operator|==
literal|null
condition|)
block|{
name|firstHidden
operator|=
name|p
expr_stmt|;
comment|// record hidden token if first
block|}
block|}
name|consume
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getDiscardMask ()
specifier|public
name|BitSet
name|getDiscardMask
parameter_list|()
block|{
return|return
name|discardMask
return|;
block|}
comment|/** Return a ptr to the hidden token appearing immediately after 	 *  token t in the input stream. 	 */
DECL|method|getHiddenAfter (CommonHiddenStreamToken t)
specifier|public
name|CommonHiddenStreamToken
name|getHiddenAfter
parameter_list|(
name|CommonHiddenStreamToken
name|t
parameter_list|)
block|{
return|return
name|t
operator|.
name|getHiddenAfter
argument_list|()
return|;
block|}
comment|/** Return a ptr to the hidden token appearing immediately before 	 *  token t in the input stream. 	 */
DECL|method|getHiddenBefore (CommonHiddenStreamToken t)
specifier|public
name|CommonHiddenStreamToken
name|getHiddenBefore
parameter_list|(
name|CommonHiddenStreamToken
name|t
parameter_list|)
block|{
return|return
name|t
operator|.
name|getHiddenBefore
argument_list|()
return|;
block|}
DECL|method|getHideMask ()
specifier|public
name|BitSet
name|getHideMask
parameter_list|()
block|{
return|return
name|hideMask
return|;
block|}
comment|/** Return the first hidden token if one appears 	 *  before any monitored token. 	 */
DECL|method|getInitialHiddenToken ()
specifier|public
name|CommonHiddenStreamToken
name|getInitialHiddenToken
parameter_list|()
block|{
return|return
name|firstHidden
return|;
block|}
DECL|method|hide (int m)
specifier|public
name|void
name|hide
parameter_list|(
name|int
name|m
parameter_list|)
block|{
name|hideMask
operator|.
name|add
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
DECL|method|hide (BitSet mask)
specifier|public
name|void
name|hide
parameter_list|(
name|BitSet
name|mask
parameter_list|)
block|{
name|hideMask
operator|=
name|mask
expr_stmt|;
block|}
DECL|method|LA (int i)
specifier|protected
name|CommonHiddenStreamToken
name|LA
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|nextMonitoredToken
return|;
block|}
comment|/** Return the next monitored token.  *  Test the token following the monitored token.  *  If following is another monitored token, save it  *  for the next invocation of nextToken (like a single  *  lookahead token) and return it then.  *  If following is unmonitored, nondiscarded (hidden)  *  channel token, add it to the monitored token.  *  *  Note: EOF must be a monitored Token.  */
DECL|method|nextToken ()
specifier|public
name|Token
name|nextToken
parameter_list|()
throws|throws
name|TokenStreamException
block|{
comment|// handle an initial condition; don't want to get lookahead
comment|// token of this splitter until first call to nextToken
if|if
condition|(
name|LA
argument_list|(
literal|1
argument_list|)
operator|==
literal|null
condition|)
block|{
name|consumeFirst
argument_list|()
expr_stmt|;
block|}
comment|// we always consume hidden tokens after monitored, thus,
comment|// upon entry LA(1) is a monitored token.
name|CommonHiddenStreamToken
name|monitored
init|=
name|LA
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// point to hidden tokens found during last invocation
name|monitored
operator|.
name|setHiddenBefore
argument_list|(
name|lastHiddenToken
argument_list|)
expr_stmt|;
name|lastHiddenToken
operator|=
literal|null
expr_stmt|;
comment|// Look for hidden tokens, hook them into list emanating
comment|// from the monitored tokens.
name|consume
argument_list|()
expr_stmt|;
name|CommonHiddenStreamToken
name|p
init|=
name|monitored
decl_stmt|;
comment|// while hidden or discarded scarf tokens
while|while
condition|(
name|hideMask
operator|.
name|member
argument_list|(
name|LA
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
operator|||
name|discardMask
operator|.
name|member
argument_list|(
name|LA
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|hideMask
operator|.
name|member
argument_list|(
name|LA
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
comment|// attach the hidden token to the monitored in a chain
comment|// link forwards
name|p
operator|.
name|setHiddenAfter
argument_list|(
name|LA
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// link backwards
if|if
condition|(
name|p
operator|!=
name|monitored
condition|)
block|{
comment|//hidden cannot point to monitored tokens
name|LA
argument_list|(
literal|1
argument_list|)
operator|.
name|setHiddenBefore
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|lastHiddenToken
operator|=
name|LA
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|consume
argument_list|()
expr_stmt|;
block|}
return|return
name|monitored
return|;
block|}
block|}
end_class

end_unit

