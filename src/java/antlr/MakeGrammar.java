begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/license.html  *  * $Id$  */
end_comment

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|LList
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|Vector
import|;
end_import

begin_class
DECL|class|MakeGrammar
specifier|public
class|class
name|MakeGrammar
extends|extends
name|DefineGrammarSymbols
block|{
DECL|field|blocks
specifier|protected
name|Stack
name|blocks
init|=
operator|new
name|LList
argument_list|()
decl_stmt|;
comment|// track subrules--Stack<BlockContext>
DECL|field|lastRuleRef
specifier|protected
name|RuleRefElement
name|lastRuleRef
decl_stmt|;
DECL|field|ruleEnd
specifier|protected
name|RuleEndElement
name|ruleEnd
decl_stmt|;
comment|// used if not nested
DECL|field|ruleBlock
specifier|protected
name|RuleBlock
name|ruleBlock
decl_stmt|;
comment|// points to block of current rule.
DECL|field|nested
specifier|protected
name|int
name|nested
init|=
literal|0
decl_stmt|;
comment|// nesting inside a subrule
DECL|field|grammarError
specifier|protected
name|boolean
name|grammarError
init|=
literal|false
decl_stmt|;
DECL|field|currentExceptionSpec
name|ExceptionSpec
name|currentExceptionSpec
init|=
literal|null
decl_stmt|;
DECL|method|MakeGrammar (Tool tool_, String[] args_, LLkAnalyzer analyzer_)
specifier|public
name|MakeGrammar
parameter_list|(
name|Tool
name|tool_
parameter_list|,
name|String
index|[]
name|args_
parameter_list|,
name|LLkAnalyzer
name|analyzer_
parameter_list|)
block|{
name|super
argument_list|(
name|tool_
argument_list|,
name|args_
argument_list|,
name|analyzer_
argument_list|)
expr_stmt|;
block|}
comment|/** Abort the processing of a grammar (due to syntax errors) */
DECL|method|abortGrammar ()
specifier|public
name|void
name|abortGrammar
parameter_list|()
block|{
name|String
name|s
init|=
literal|"unknown grammar"
decl_stmt|;
if|if
condition|(
name|grammar
operator|!=
literal|null
condition|)
block|{
name|s
operator|=
name|grammar
operator|.
name|getClassName
argument_list|()
expr_stmt|;
block|}
name|tool
operator|.
name|error
argument_list|(
literal|"aborting grammar '"
operator|+
name|s
operator|+
literal|"' due to errors"
argument_list|)
expr_stmt|;
name|super
operator|.
name|abortGrammar
argument_list|()
expr_stmt|;
block|}
DECL|method|addElementToCurrentAlt (AlternativeElement e)
specifier|protected
name|void
name|addElementToCurrentAlt
parameter_list|(
name|AlternativeElement
name|e
parameter_list|)
block|{
name|e
operator|.
name|enclosingRuleName
operator|=
name|ruleBlock
operator|.
name|ruleName
expr_stmt|;
name|context
argument_list|()
operator|.
name|addAlternativeElement
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
DECL|method|beginAlt (boolean doAutoGen_)
specifier|public
name|void
name|beginAlt
parameter_list|(
name|boolean
name|doAutoGen_
parameter_list|)
block|{
name|super
operator|.
name|beginAlt
argument_list|(
name|doAutoGen_
argument_list|)
expr_stmt|;
name|Alternative
name|alt
init|=
operator|new
name|Alternative
argument_list|()
decl_stmt|;
name|alt
operator|.
name|setAutoGen
argument_list|(
name|doAutoGen_
argument_list|)
expr_stmt|;
name|context
argument_list|()
operator|.
name|block
operator|.
name|addAlternative
argument_list|(
name|alt
argument_list|)
expr_stmt|;
block|}
DECL|method|beginChildList ()
specifier|public
name|void
name|beginChildList
parameter_list|()
block|{
name|super
operator|.
name|beginChildList
argument_list|()
expr_stmt|;
name|context
argument_list|()
operator|.
name|block
operator|.
name|addAlternative
argument_list|(
operator|new
name|Alternative
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Add an exception group to a rule (currently a no-op) */
DECL|method|beginExceptionGroup ()
specifier|public
name|void
name|beginExceptionGroup
parameter_list|()
block|{
name|super
operator|.
name|beginExceptionGroup
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|context
argument_list|()
operator|.
name|block
operator|instanceof
name|RuleBlock
operator|)
condition|)
block|{
name|tool
operator|.
name|panic
argument_list|(
literal|"beginExceptionGroup called outside of rule block"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Add an exception spec to an exception group or rule block */
DECL|method|beginExceptionSpec (Token label)
specifier|public
name|void
name|beginExceptionSpec
parameter_list|(
name|Token
name|label
parameter_list|)
block|{
comment|// Hack the label string a bit to remove leading/trailing space.
if|if
condition|(
name|label
operator|!=
literal|null
condition|)
block|{
name|label
operator|.
name|setText
argument_list|(
name|StringUtils
operator|.
name|stripFront
argument_list|(
name|StringUtils
operator|.
name|stripBack
argument_list|(
name|label
operator|.
name|getText
argument_list|()
argument_list|,
literal|" \n\r\t"
argument_list|)
argument_list|,
literal|" \n\r\t"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|beginExceptionSpec
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|// Don't check for currentExceptionSpec!=null because syntax errors
comment|// may leave it set to something.
name|currentExceptionSpec
operator|=
operator|new
name|ExceptionSpec
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
DECL|method|beginSubRule (Token label, Token start, boolean not)
specifier|public
name|void
name|beginSubRule
parameter_list|(
name|Token
name|label
parameter_list|,
name|Token
name|start
parameter_list|,
name|boolean
name|not
parameter_list|)
block|{
name|super
operator|.
name|beginSubRule
argument_list|(
name|label
argument_list|,
name|start
argument_list|,
name|not
argument_list|)
expr_stmt|;
comment|// we don't know what kind of subrule it is yet.
comment|// push a dummy one that will allow us to collect the
comment|// alternatives.  Later, we'll switch to real object.
name|blocks
operator|.
name|push
argument_list|(
operator|new
name|BlockContext
argument_list|()
argument_list|)
expr_stmt|;
name|context
argument_list|()
operator|.
name|block
operator|=
operator|new
name|AlternativeBlock
argument_list|(
name|grammar
argument_list|,
name|start
argument_list|,
name|not
argument_list|)
expr_stmt|;
name|context
argument_list|()
operator|.
name|altNum
operator|=
literal|0
expr_stmt|;
comment|// reset alternative number
name|nested
operator|++
expr_stmt|;
comment|// create a final node to which the last elememt of each
comment|// alternative will point.
name|context
argument_list|()
operator|.
name|blockEnd
operator|=
operator|new
name|BlockEndElement
argument_list|(
name|grammar
argument_list|)
expr_stmt|;
comment|// make sure end node points to start of block
name|context
argument_list|()
operator|.
name|blockEnd
operator|.
name|block
operator|=
name|context
argument_list|()
operator|.
name|block
expr_stmt|;
name|labelElement
argument_list|(
name|context
argument_list|()
operator|.
name|block
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
DECL|method|beginTree (Token tok)
specifier|public
name|void
name|beginTree
parameter_list|(
name|Token
name|tok
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
operator|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
operator|)
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"Trees only allowed in TreeParser"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|tok
operator|.
name|getLine
argument_list|()
argument_list|,
name|tok
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Trees only allowed in TreeParser"
argument_list|)
throw|;
block|}
name|super
operator|.
name|beginTree
argument_list|(
name|tok
argument_list|)
expr_stmt|;
name|blocks
operator|.
name|push
argument_list|(
operator|new
name|TreeBlockContext
argument_list|()
argument_list|)
expr_stmt|;
name|context
argument_list|()
operator|.
name|block
operator|=
operator|new
name|TreeElement
argument_list|(
name|grammar
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|context
argument_list|()
operator|.
name|altNum
operator|=
literal|0
expr_stmt|;
comment|// reset alternative number
block|}
DECL|method|context ()
specifier|public
name|BlockContext
name|context
parameter_list|()
block|{
if|if
condition|(
name|blocks
operator|.
name|height
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
operator|(
name|BlockContext
operator|)
name|blocks
operator|.
name|top
argument_list|()
return|;
block|}
block|}
comment|/**Used to build nextToken() for the lexer.      * This builds a rule which has every "public" rule in the given Vector of      * rules as it's alternate.  Each rule ref generates a Token object.      * @param g  The Grammar that is being processed      * @param lexRules A vector of lexer rules that will be used to create an alternate block.      * @param rname The name of the resulting rule.      */
DECL|method|createNextTokenRule (Grammar g, Vector lexRules, String rname)
specifier|public
specifier|static
name|RuleBlock
name|createNextTokenRule
parameter_list|(
name|Grammar
name|g
parameter_list|,
name|Vector
name|lexRules
parameter_list|,
name|String
name|rname
parameter_list|)
block|{
comment|// create actual rule data structure
name|RuleBlock
name|rb
init|=
operator|new
name|RuleBlock
argument_list|(
name|g
argument_list|,
name|rname
argument_list|)
decl_stmt|;
name|rb
operator|.
name|setDefaultErrorHandler
argument_list|(
name|g
operator|.
name|getDefaultErrorHandler
argument_list|()
argument_list|)
expr_stmt|;
name|RuleEndElement
name|ruleEnd
init|=
operator|new
name|RuleEndElement
argument_list|(
name|g
argument_list|)
decl_stmt|;
name|rb
operator|.
name|setEndElement
argument_list|(
name|ruleEnd
argument_list|)
expr_stmt|;
name|ruleEnd
operator|.
name|block
operator|=
name|rb
expr_stmt|;
comment|// Add an alternative for each element of the rules vector.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lexRules
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RuleSymbol
name|r
init|=
operator|(
name|RuleSymbol
operator|)
name|lexRules
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|isDefined
argument_list|()
condition|)
block|{
name|g
operator|.
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Lexer rule "
operator|+
name|r
operator|.
name|id
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
operator|+
literal|" is not defined"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|r
operator|.
name|access
operator|.
name|equals
argument_list|(
literal|"public"
argument_list|)
condition|)
block|{
name|Alternative
name|alt
init|=
operator|new
name|Alternative
argument_list|()
decl_stmt|;
comment|// create alt we'll add to ref rule
name|RuleBlock
name|targetRuleBlock
init|=
name|r
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|Vector
name|targetRuleAlts
init|=
name|targetRuleBlock
operator|.
name|getAlternatives
argument_list|()
decl_stmt|;
comment|// collect a sem pred if only one alt and it's at the start;
comment|// simple, but faster to implement until real hoisting
if|if
condition|(
name|targetRuleAlts
operator|!=
literal|null
operator|&&
name|targetRuleAlts
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|Alternative
name|onlyAlt
init|=
operator|(
name|Alternative
operator|)
name|targetRuleAlts
operator|.
name|elementAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|onlyAlt
operator|.
name|semPred
operator|!=
literal|null
condition|)
block|{
comment|// ok, has sem pred, make this rule ref alt have a pred
name|alt
operator|.
name|semPred
operator|=
name|onlyAlt
operator|.
name|semPred
expr_stmt|;
comment|// REMOVE predicate from target rule???  NOPE, another
comment|// rule other than nextToken() might invoke it.
block|}
block|}
comment|// create a rule ref to lexer rule
comment|// the Token is a RULE_REF not a TOKEN_REF since the
comment|// conversion to mRulename has already taken place
name|RuleRefElement
name|rr
init|=
operator|new
name|RuleRefElement
argument_list|(
name|g
argument_list|,
operator|new
name|CommonToken
argument_list|(
name|ANTLRTokenTypes
operator|.
name|RULE_REF
argument_list|,
name|r
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|,
name|GrammarElement
operator|.
name|AUTO_GEN_NONE
argument_list|)
decl_stmt|;
name|rr
operator|.
name|setLabel
argument_list|(
literal|"theRetToken"
argument_list|)
expr_stmt|;
name|rr
operator|.
name|enclosingRuleName
operator|=
literal|"nextToken"
expr_stmt|;
name|rr
operator|.
name|next
operator|=
name|ruleEnd
expr_stmt|;
name|alt
operator|.
name|addElement
argument_list|(
name|rr
argument_list|)
expr_stmt|;
comment|// add rule ref to alt
name|alt
operator|.
name|setAutoGen
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// keep text of elements
name|rb
operator|.
name|addAlternative
argument_list|(
name|alt
argument_list|)
expr_stmt|;
comment|// add alt to rule block
name|r
operator|.
name|addReference
argument_list|(
name|rr
argument_list|)
expr_stmt|;
comment|// track ref to this rule in rule blk
block|}
block|}
block|}
name|rb
operator|.
name|setAutoGen
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// keep text of elements
name|rb
operator|.
name|prepareForAnalysis
argument_list|()
expr_stmt|;
comment|//System.out.println(rb);
return|return
name|rb
return|;
block|}
comment|/** Return block as if they had typed: "( rule )?" */
DECL|method|createOptionalRuleRef (String rule, Token start)
specifier|private
name|AlternativeBlock
name|createOptionalRuleRef
parameter_list|(
name|String
name|rule
parameter_list|,
name|Token
name|start
parameter_list|)
block|{
comment|// Make the subrule
name|AlternativeBlock
name|blk
init|=
operator|new
name|AlternativeBlock
argument_list|(
name|grammar
argument_list|,
name|start
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// Make sure rule is defined
name|String
name|mrule
init|=
name|CodeGenerator
operator|.
name|encodeLexerRuleName
argument_list|(
name|rule
argument_list|)
decl_stmt|;
comment|// can only be a lexer rule!
if|if
condition|(
operator|!
name|grammar
operator|.
name|isDefined
argument_list|(
name|mrule
argument_list|)
condition|)
block|{
name|grammar
operator|.
name|define
argument_list|(
operator|new
name|RuleSymbol
argument_list|(
name|mrule
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Make the rule ref element
comment|// RK: fixme probably easier to abuse start token..
name|Token
name|t
init|=
operator|new
name|CommonToken
argument_list|(
name|ANTLRTokenTypes
operator|.
name|TOKEN_REF
argument_list|,
name|rule
argument_list|)
decl_stmt|;
name|t
operator|.
name|setLine
argument_list|(
name|start
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|setLine
argument_list|(
name|start
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
name|RuleRefElement
name|rref
init|=
operator|new
name|RuleRefElement
argument_list|(
name|grammar
argument_list|,
name|t
argument_list|,
name|GrammarElement
operator|.
name|AUTO_GEN_NONE
argument_list|)
decl_stmt|;
name|rref
operator|.
name|enclosingRuleName
operator|=
name|ruleBlock
operator|.
name|ruleName
expr_stmt|;
comment|// Make the end of block element
name|BlockEndElement
name|end
init|=
operator|new
name|BlockEndElement
argument_list|(
name|grammar
argument_list|)
decl_stmt|;
name|end
operator|.
name|block
operator|=
name|blk
expr_stmt|;
comment|// end block points back to start of blk
comment|// Make an alternative, putting the rule ref into it
name|Alternative
name|alt
init|=
operator|new
name|Alternative
argument_list|(
name|rref
argument_list|)
decl_stmt|;
name|alt
operator|.
name|addElement
argument_list|(
name|end
argument_list|)
expr_stmt|;
comment|// last element in alt points to end of block
comment|// Add the alternative to this block
name|blk
operator|.
name|addAlternative
argument_list|(
name|alt
argument_list|)
expr_stmt|;
comment|// create an empty (optional) alt and add to blk
name|Alternative
name|optAlt
init|=
operator|new
name|Alternative
argument_list|()
decl_stmt|;
name|optAlt
operator|.
name|addElement
argument_list|(
name|end
argument_list|)
expr_stmt|;
comment|// points immediately to end of block
name|blk
operator|.
name|addAlternative
argument_list|(
name|optAlt
argument_list|)
expr_stmt|;
name|blk
operator|.
name|prepareForAnalysis
argument_list|()
expr_stmt|;
return|return
name|blk
return|;
block|}
DECL|method|defineRuleName (Token r, String access, boolean ruleAutoGen, String docComment)
specifier|public
name|void
name|defineRuleName
parameter_list|(
name|Token
name|r
parameter_list|,
name|String
name|access
parameter_list|,
name|boolean
name|ruleAutoGen
parameter_list|,
name|String
name|docComment
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|//		if ( Character.isUpperCase(r.getText().charAt(0)) ) {
if|if
condition|(
name|r
operator|.
name|type
operator|==
name|ANTLRTokenTypes
operator|.
name|TOKEN_REF
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"Lexical rule "
operator|+
name|r
operator|.
name|getText
argument_list|()
operator|+
literal|" defined outside of lexer"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|r
operator|.
name|getLine
argument_list|()
argument_list|,
name|r
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
name|r
operator|.
name|setText
argument_list|(
name|r
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"Lexical rule names must be upper case, '"
operator|+
name|r
operator|.
name|getText
argument_list|()
operator|+
literal|"' is not"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|r
operator|.
name|getLine
argument_list|()
argument_list|,
name|r
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
name|r
operator|.
name|setText
argument_list|(
name|r
operator|.
name|getText
argument_list|()
operator|.
name|toUpperCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|super
operator|.
name|defineRuleName
argument_list|(
name|r
argument_list|,
name|access
argument_list|,
name|ruleAutoGen
argument_list|,
name|docComment
argument_list|)
expr_stmt|;
name|String
name|id
init|=
name|r
operator|.
name|getText
argument_list|()
decl_stmt|;
comment|//		if ( Character.isUpperCase(id.charAt(0)) ) { // lexer rule?
if|if
condition|(
name|r
operator|.
name|type
operator|==
name|ANTLRTokenTypes
operator|.
name|TOKEN_REF
condition|)
block|{
comment|// lexer rule?
name|id
operator|=
name|CodeGenerator
operator|.
name|encodeLexerRuleName
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|grammar
operator|.
name|getSymbol
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|RuleBlock
name|rb
init|=
operator|new
name|RuleBlock
argument_list|(
name|grammar
argument_list|,
name|r
operator|.
name|getText
argument_list|()
argument_list|,
name|r
operator|.
name|getLine
argument_list|()
argument_list|,
name|ruleAutoGen
argument_list|)
decl_stmt|;
comment|// Lexer rules do not generate default error handling
name|rb
operator|.
name|setDefaultErrorHandler
argument_list|(
name|grammar
operator|.
name|getDefaultErrorHandler
argument_list|()
argument_list|)
expr_stmt|;
name|ruleBlock
operator|=
name|rb
expr_stmt|;
name|blocks
operator|.
name|push
argument_list|(
operator|new
name|BlockContext
argument_list|()
argument_list|)
expr_stmt|;
comment|// enter new context
name|context
argument_list|()
operator|.
name|block
operator|=
name|rb
expr_stmt|;
name|rs
operator|.
name|setBlock
argument_list|(
name|rb
argument_list|)
expr_stmt|;
name|ruleEnd
operator|=
operator|new
name|RuleEndElement
argument_list|(
name|grammar
argument_list|)
expr_stmt|;
name|rb
operator|.
name|setEndElement
argument_list|(
name|ruleEnd
argument_list|)
expr_stmt|;
name|nested
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|endAlt ()
specifier|public
name|void
name|endAlt
parameter_list|()
block|{
name|super
operator|.
name|endAlt
argument_list|()
expr_stmt|;
if|if
condition|(
name|nested
operator|==
literal|0
condition|)
block|{
comment|// all rule-level alts link to ruleEnd node
name|addElementToCurrentAlt
argument_list|(
name|ruleEnd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addElementToCurrentAlt
argument_list|(
name|context
argument_list|()
operator|.
name|blockEnd
argument_list|)
expr_stmt|;
block|}
name|context
argument_list|()
operator|.
name|altNum
operator|++
expr_stmt|;
block|}
DECL|method|endChildList ()
specifier|public
name|void
name|endChildList
parameter_list|()
block|{
name|super
operator|.
name|endChildList
argument_list|()
expr_stmt|;
comment|// create a final node to which the last elememt of the single
comment|// alternative will point.  Done for compatibility with analyzer.
comment|// Does NOT point to any block like alternative blocks because the
comment|// TreeElement is not a block.  This is used only as a placeholder.
name|BlockEndElement
name|be
init|=
operator|new
name|BlockEndElement
argument_list|(
name|grammar
argument_list|)
decl_stmt|;
name|be
operator|.
name|block
operator|=
name|context
argument_list|()
operator|.
name|block
expr_stmt|;
name|addElementToCurrentAlt
argument_list|(
name|be
argument_list|)
expr_stmt|;
block|}
DECL|method|endExceptionGroup ()
specifier|public
name|void
name|endExceptionGroup
parameter_list|()
block|{
name|super
operator|.
name|endExceptionGroup
argument_list|()
expr_stmt|;
block|}
DECL|method|endExceptionSpec ()
specifier|public
name|void
name|endExceptionSpec
parameter_list|()
block|{
name|super
operator|.
name|endExceptionSpec
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentExceptionSpec
operator|==
literal|null
condition|)
block|{
name|tool
operator|.
name|panic
argument_list|(
literal|"exception processing internal error -- no active exception spec"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|context
argument_list|()
operator|.
name|block
operator|instanceof
name|RuleBlock
condition|)
block|{
comment|// Named rule
operator|(
operator|(
name|RuleBlock
operator|)
name|context
argument_list|()
operator|.
name|block
operator|)
operator|.
name|addExceptionSpec
argument_list|(
name|currentExceptionSpec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// It must be a plain-old alternative block
if|if
condition|(
name|context
argument_list|()
operator|.
name|currentAlt
argument_list|()
operator|.
name|exceptionSpec
operator|!=
literal|null
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"Alternative already has an exception specification"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|context
argument_list|()
operator|.
name|block
operator|.
name|getLine
argument_list|()
argument_list|,
name|context
argument_list|()
operator|.
name|block
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|context
argument_list|()
operator|.
name|currentAlt
argument_list|()
operator|.
name|exceptionSpec
operator|=
name|currentExceptionSpec
expr_stmt|;
block|}
block|}
name|currentExceptionSpec
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Called at the end of processing a grammar */
DECL|method|endGrammar ()
specifier|public
name|void
name|endGrammar
parameter_list|()
block|{
if|if
condition|(
name|grammarError
condition|)
block|{
name|abortGrammar
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|super
operator|.
name|endGrammar
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|endRule (String rule)
specifier|public
name|void
name|endRule
parameter_list|(
name|String
name|rule
parameter_list|)
block|{
name|super
operator|.
name|endRule
argument_list|(
name|rule
argument_list|)
expr_stmt|;
name|BlockContext
name|ctx
init|=
operator|(
name|BlockContext
operator|)
name|blocks
operator|.
name|pop
argument_list|()
decl_stmt|;
comment|// remove scope
comment|// record the start of this block in the ending node
name|ruleEnd
operator|.
name|block
operator|=
name|ctx
operator|.
name|block
expr_stmt|;
name|ruleEnd
operator|.
name|block
operator|.
name|prepareForAnalysis
argument_list|()
expr_stmt|;
comment|//System.out.println(ctx.block);
block|}
DECL|method|endSubRule ()
specifier|public
name|void
name|endSubRule
parameter_list|()
block|{
name|super
operator|.
name|endSubRule
argument_list|()
expr_stmt|;
name|nested
operator|--
expr_stmt|;
comment|// remove subrule context from scope stack
name|BlockContext
name|ctx
init|=
operator|(
name|BlockContext
operator|)
name|blocks
operator|.
name|pop
argument_list|()
decl_stmt|;
name|AlternativeBlock
name|block
init|=
name|ctx
operator|.
name|block
decl_stmt|;
comment|// If the subrule is marked with ~, check that it is
comment|// a valid candidate for analysis
if|if
condition|(
name|block
operator|.
name|not
operator|&&
operator|!
operator|(
name|block
operator|instanceof
name|SynPredBlock
operator|)
operator|&&
operator|!
operator|(
name|block
operator|instanceof
name|ZeroOrMoreBlock
operator|)
operator|&&
operator|!
operator|(
name|block
operator|instanceof
name|OneOrMoreBlock
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|analyzer
operator|.
name|subruleCanBeInverted
argument_list|(
name|block
argument_list|,
name|grammar
operator|instanceof
name|LexerGrammar
argument_list|)
condition|)
block|{
name|String
name|newline
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
name|tool
operator|.
name|error
argument_list|(
literal|"This subrule cannot be inverted.  Only subrules of the form:"
operator|+
name|newline
operator|+
literal|"    (T1|T2|T3...) or"
operator|+
name|newline
operator|+
literal|"    ('c1'|'c2'|'c3'...)"
operator|+
name|newline
operator|+
literal|"may be inverted (ranges are also allowed)."
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|block
operator|.
name|getLine
argument_list|()
argument_list|,
name|block
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// add the subrule as element if not a syn pred
if|if
condition|(
name|block
operator|instanceof
name|SynPredBlock
condition|)
block|{
comment|// record a reference to the recently-recognized syn pred in the
comment|// enclosing block.
name|SynPredBlock
name|synpred
init|=
operator|(
name|SynPredBlock
operator|)
name|block
decl_stmt|;
name|context
argument_list|()
operator|.
name|block
operator|.
name|hasASynPred
operator|=
literal|true
expr_stmt|;
name|context
argument_list|()
operator|.
name|currentAlt
argument_list|()
operator|.
name|synPred
operator|=
name|synpred
expr_stmt|;
name|grammar
operator|.
name|hasSyntacticPredicate
operator|=
literal|true
expr_stmt|;
name|synpred
operator|.
name|removeTrackingOfRuleRefs
argument_list|(
name|grammar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addElementToCurrentAlt
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|.
name|blockEnd
operator|.
name|block
operator|.
name|prepareForAnalysis
argument_list|()
expr_stmt|;
block|}
DECL|method|endTree ()
specifier|public
name|void
name|endTree
parameter_list|()
block|{
name|super
operator|.
name|endTree
argument_list|()
expr_stmt|;
name|BlockContext
name|ctx
init|=
operator|(
name|BlockContext
operator|)
name|blocks
operator|.
name|pop
argument_list|()
decl_stmt|;
name|addElementToCurrentAlt
argument_list|(
name|ctx
operator|.
name|block
argument_list|)
expr_stmt|;
comment|// add new TreeElement to enclosing alt.
block|}
comment|/** Remember that a major error occured in the grammar */
DECL|method|hasError ()
specifier|public
name|void
name|hasError
parameter_list|()
block|{
name|grammarError
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|labelElement (AlternativeElement el, Token label)
specifier|private
name|void
name|labelElement
parameter_list|(
name|AlternativeElement
name|el
parameter_list|,
name|Token
name|label
parameter_list|)
block|{
if|if
condition|(
name|label
operator|!=
literal|null
condition|)
block|{
comment|// Does this label already exist?
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ruleBlock
operator|.
name|labeledElements
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|AlternativeElement
name|altEl
init|=
operator|(
name|AlternativeElement
operator|)
name|ruleBlock
operator|.
name|labeledElements
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|l
init|=
name|altEl
operator|.
name|getLabel
argument_list|()
decl_stmt|;
if|if
condition|(
name|l
operator|!=
literal|null
operator|&&
name|l
operator|.
name|equals
argument_list|(
name|label
operator|.
name|getText
argument_list|()
argument_list|)
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"Label '"
operator|+
name|label
operator|.
name|getText
argument_list|()
operator|+
literal|"' has already been defined"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|label
operator|.
name|getLine
argument_list|()
argument_list|,
name|label
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// add this node to the list of labeled elements
name|el
operator|.
name|setLabel
argument_list|(
name|label
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|ruleBlock
operator|.
name|labeledElements
operator|.
name|appendElement
argument_list|(
name|el
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|noAutoGenSubRule ()
specifier|public
name|void
name|noAutoGenSubRule
parameter_list|()
block|{
name|context
argument_list|()
operator|.
name|block
operator|.
name|setAutoGen
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|oneOrMoreSubRule ()
specifier|public
name|void
name|oneOrMoreSubRule
parameter_list|()
block|{
if|if
condition|(
name|context
argument_list|()
operator|.
name|block
operator|.
name|not
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"'~' cannot be applied to (...)* subrule"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|context
argument_list|()
operator|.
name|block
operator|.
name|getLine
argument_list|()
argument_list|,
name|context
argument_list|()
operator|.
name|block
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// create the right kind of object now that we know what that is
comment|// and switch the list of alternatives.  Adjust the stack of blocks.
comment|// copy any init action also.
name|OneOrMoreBlock
name|b
init|=
operator|new
name|OneOrMoreBlock
argument_list|(
name|grammar
argument_list|)
decl_stmt|;
name|setBlock
argument_list|(
name|b
argument_list|,
name|context
argument_list|()
operator|.
name|block
argument_list|)
expr_stmt|;
name|BlockContext
name|old
init|=
operator|(
name|BlockContext
operator|)
name|blocks
operator|.
name|pop
argument_list|()
decl_stmt|;
comment|// remove old scope; we want new type of subrule
name|blocks
operator|.
name|push
argument_list|(
operator|new
name|BlockContext
argument_list|()
argument_list|)
expr_stmt|;
name|context
argument_list|()
operator|.
name|block
operator|=
name|b
expr_stmt|;
name|context
argument_list|()
operator|.
name|blockEnd
operator|=
name|old
operator|.
name|blockEnd
expr_stmt|;
name|context
argument_list|()
operator|.
name|blockEnd
operator|.
name|block
operator|=
name|b
expr_stmt|;
block|}
DECL|method|optionalSubRule ()
specifier|public
name|void
name|optionalSubRule
parameter_list|()
block|{
if|if
condition|(
name|context
argument_list|()
operator|.
name|block
operator|.
name|not
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"'~' cannot be applied to (...)? subrule"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|context
argument_list|()
operator|.
name|block
operator|.
name|getLine
argument_list|()
argument_list|,
name|context
argument_list|()
operator|.
name|block
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// convert (X)? -> (X|) so that we can ignore optional blocks altogether!
comment|// It already thinks that we have a simple subrule, just add option block.
name|beginAlt
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|endAlt
argument_list|()
expr_stmt|;
block|}
DECL|method|refAction (Token action)
specifier|public
name|void
name|refAction
parameter_list|(
name|Token
name|action
parameter_list|)
block|{
name|super
operator|.
name|refAction
argument_list|(
name|action
argument_list|)
expr_stmt|;
name|context
argument_list|()
operator|.
name|block
operator|.
name|hasAnAction
operator|=
literal|true
expr_stmt|;
name|addElementToCurrentAlt
argument_list|(
operator|new
name|ActionElement
argument_list|(
name|grammar
argument_list|,
name|action
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|setUserExceptions (String thr)
specifier|public
name|void
name|setUserExceptions
parameter_list|(
name|String
name|thr
parameter_list|)
block|{
operator|(
operator|(
name|RuleBlock
operator|)
name|context
argument_list|()
operator|.
name|block
operator|)
operator|.
name|throwsSpec
operator|=
name|thr
expr_stmt|;
block|}
comment|// Only called for rule blocks
DECL|method|refArgAction (Token action)
specifier|public
name|void
name|refArgAction
parameter_list|(
name|Token
name|action
parameter_list|)
block|{
operator|(
operator|(
name|RuleBlock
operator|)
name|context
argument_list|()
operator|.
name|block
operator|)
operator|.
name|argAction
operator|=
name|action
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
DECL|method|refCharLiteral (Token lit, Token label, boolean inverted, int autoGenType, boolean lastInRule)
specifier|public
name|void
name|refCharLiteral
parameter_list|(
name|Token
name|lit
parameter_list|,
name|Token
name|label
parameter_list|,
name|boolean
name|inverted
parameter_list|,
name|int
name|autoGenType
parameter_list|,
name|boolean
name|lastInRule
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"Character literal only valid in lexer"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|lit
operator|.
name|getLine
argument_list|()
argument_list|,
name|lit
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|super
operator|.
name|refCharLiteral
argument_list|(
name|lit
argument_list|,
name|label
argument_list|,
name|inverted
argument_list|,
name|autoGenType
argument_list|,
name|lastInRule
argument_list|)
expr_stmt|;
name|CharLiteralElement
name|cl
init|=
operator|new
name|CharLiteralElement
argument_list|(
operator|(
name|LexerGrammar
operator|)
name|grammar
argument_list|,
name|lit
argument_list|,
name|inverted
argument_list|,
name|autoGenType
argument_list|)
decl_stmt|;
comment|// Generate a warning for non-lowercase ASCII when case-insensitive
if|if
condition|(
operator|!
operator|(
operator|(
name|LexerGrammar
operator|)
name|grammar
operator|)
operator|.
name|caseSensitive
operator|&&
name|cl
operator|.
name|getType
argument_list|()
operator|<
literal|128
operator|&&
name|Character
operator|.
name|toLowerCase
argument_list|(
operator|(
name|char
operator|)
name|cl
operator|.
name|getType
argument_list|()
argument_list|)
operator|!=
operator|(
name|char
operator|)
name|cl
operator|.
name|getType
argument_list|()
condition|)
block|{
name|tool
operator|.
name|warning
argument_list|(
literal|"Character literal must be lowercase when caseSensitive=false"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|lit
operator|.
name|getLine
argument_list|()
argument_list|,
name|lit
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|addElementToCurrentAlt
argument_list|(
name|cl
argument_list|)
expr_stmt|;
name|labelElement
argument_list|(
name|cl
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|// if ignore option is set, must add an optional call to the specified rule.
name|String
name|ignore
init|=
name|ruleBlock
operator|.
name|getIgnoreRule
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|lastInRule
operator|&&
name|ignore
operator|!=
literal|null
condition|)
block|{
name|addElementToCurrentAlt
argument_list|(
name|createOptionalRuleRef
argument_list|(
name|ignore
argument_list|,
name|lit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|refCharRange (Token t1, Token t2, Token label, int autoGenType, boolean lastInRule)
specifier|public
name|void
name|refCharRange
parameter_list|(
name|Token
name|t1
parameter_list|,
name|Token
name|t2
parameter_list|,
name|Token
name|label
parameter_list|,
name|int
name|autoGenType
parameter_list|,
name|boolean
name|lastInRule
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"Character range only valid in lexer"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|t1
operator|.
name|getLine
argument_list|()
argument_list|,
name|t1
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|rangeMin
init|=
name|ANTLRLexer
operator|.
name|tokenTypeForCharLiteral
argument_list|(
name|t1
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|rangeMax
init|=
name|ANTLRLexer
operator|.
name|tokenTypeForCharLiteral
argument_list|(
name|t2
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rangeMax
operator|<
name|rangeMin
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"Malformed range."
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|t1
operator|.
name|getLine
argument_list|()
argument_list|,
name|t1
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Generate a warning for non-lowercase ASCII when case-insensitive
if|if
condition|(
operator|!
operator|(
operator|(
name|LexerGrammar
operator|)
name|grammar
operator|)
operator|.
name|caseSensitive
condition|)
block|{
if|if
condition|(
name|rangeMin
operator|<
literal|128
operator|&&
name|Character
operator|.
name|toLowerCase
argument_list|(
operator|(
name|char
operator|)
name|rangeMin
argument_list|)
operator|!=
operator|(
name|char
operator|)
name|rangeMin
condition|)
block|{
name|tool
operator|.
name|warning
argument_list|(
literal|"Character literal must be lowercase when caseSensitive=false"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|t1
operator|.
name|getLine
argument_list|()
argument_list|,
name|t1
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rangeMax
operator|<
literal|128
operator|&&
name|Character
operator|.
name|toLowerCase
argument_list|(
operator|(
name|char
operator|)
name|rangeMax
argument_list|)
operator|!=
operator|(
name|char
operator|)
name|rangeMax
condition|)
block|{
name|tool
operator|.
name|warning
argument_list|(
literal|"Character literal must be lowercase when caseSensitive=false"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|t2
operator|.
name|getLine
argument_list|()
argument_list|,
name|t2
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|super
operator|.
name|refCharRange
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
name|label
argument_list|,
name|autoGenType
argument_list|,
name|lastInRule
argument_list|)
expr_stmt|;
name|CharRangeElement
name|cr
init|=
operator|new
name|CharRangeElement
argument_list|(
operator|(
name|LexerGrammar
operator|)
name|grammar
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|autoGenType
argument_list|)
decl_stmt|;
name|addElementToCurrentAlt
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|labelElement
argument_list|(
name|cr
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|// if ignore option is set, must add an optional call to the specified rule.
name|String
name|ignore
init|=
name|ruleBlock
operator|.
name|getIgnoreRule
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|lastInRule
operator|&&
name|ignore
operator|!=
literal|null
condition|)
block|{
name|addElementToCurrentAlt
argument_list|(
name|createOptionalRuleRef
argument_list|(
name|ignore
argument_list|,
name|t1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|refTokensSpecElementOption (Token tok, Token option, Token value)
specifier|public
name|void
name|refTokensSpecElementOption
parameter_list|(
name|Token
name|tok
parameter_list|,
name|Token
name|option
parameter_list|,
name|Token
name|value
parameter_list|)
block|{
comment|/* 		System.out.println("setting tokens spec option for "+tok.getText()); 		System.out.println(option.getText()+","+value.getText()); 		*/
name|TokenSymbol
name|ts
init|=
operator|(
name|TokenSymbol
operator|)
name|grammar
operator|.
name|tokenManager
operator|.
name|getTokenSymbol
argument_list|(
name|tok
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|==
literal|null
condition|)
block|{
name|tool
operator|.
name|panic
argument_list|(
literal|"cannot find "
operator|+
name|tok
operator|.
name|getText
argument_list|()
operator|+
literal|"in tokens {...}"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|option
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"AST"
argument_list|)
condition|)
block|{
name|ts
operator|.
name|setASTNodeType
argument_list|(
name|value
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|grammar
operator|.
name|antlrTool
operator|.
name|error
argument_list|(
literal|"invalid tokens {...} element option:"
operator|+
name|option
operator|.
name|getText
argument_list|()
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|option
operator|.
name|getLine
argument_list|()
argument_list|,
name|option
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|refElementOption (Token option, Token value)
specifier|public
name|void
name|refElementOption
parameter_list|(
name|Token
name|option
parameter_list|,
name|Token
name|value
parameter_list|)
block|{
comment|/* 		System.out.println("setting option for "+context().currentElement()); 		System.out.println(option.getText()+","+value.getText()); 		*/
name|AlternativeElement
name|e
init|=
name|context
argument_list|()
operator|.
name|currentElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|StringLiteralElement
operator|||
name|e
operator|instanceof
name|TokenRefElement
operator|||
name|e
operator|instanceof
name|WildcardElement
condition|)
block|{
operator|(
operator|(
name|GrammarAtom
operator|)
name|e
operator|)
operator|.
name|setOption
argument_list|(
name|option
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"cannot use element option ("
operator|+
name|option
operator|.
name|getText
argument_list|()
operator|+
literal|") for this kind of element"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|option
operator|.
name|getLine
argument_list|()
argument_list|,
name|option
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Add an exception handler to an exception spec */
DECL|method|refExceptionHandler (Token exTypeAndName, Token action)
specifier|public
name|void
name|refExceptionHandler
parameter_list|(
name|Token
name|exTypeAndName
parameter_list|,
name|Token
name|action
parameter_list|)
block|{
name|super
operator|.
name|refExceptionHandler
argument_list|(
name|exTypeAndName
argument_list|,
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentExceptionSpec
operator|==
literal|null
condition|)
block|{
name|tool
operator|.
name|panic
argument_list|(
literal|"exception handler processing internal error"
argument_list|)
expr_stmt|;
block|}
name|currentExceptionSpec
operator|.
name|addHandler
argument_list|(
operator|new
name|ExceptionHandler
argument_list|(
name|exTypeAndName
argument_list|,
name|action
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|refInitAction (Token action)
specifier|public
name|void
name|refInitAction
parameter_list|(
name|Token
name|action
parameter_list|)
block|{
name|super
operator|.
name|refAction
argument_list|(
name|action
argument_list|)
expr_stmt|;
name|context
argument_list|()
operator|.
name|block
operator|.
name|setInitAction
argument_list|(
name|action
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|refMemberAction (Token act)
specifier|public
name|void
name|refMemberAction
parameter_list|(
name|Token
name|act
parameter_list|)
block|{
name|grammar
operator|.
name|classMemberAction
operator|=
name|act
expr_stmt|;
block|}
DECL|method|refPreambleAction (Token act)
specifier|public
name|void
name|refPreambleAction
parameter_list|(
name|Token
name|act
parameter_list|)
block|{
name|super
operator|.
name|refPreambleAction
argument_list|(
name|act
argument_list|)
expr_stmt|;
block|}
comment|// Only called for rule blocks
DECL|method|refReturnAction (Token returnAction)
specifier|public
name|void
name|refReturnAction
parameter_list|(
name|Token
name|returnAction
parameter_list|)
block|{
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
block|{
name|String
name|name
init|=
name|CodeGenerator
operator|.
name|encodeLexerRuleName
argument_list|(
operator|(
operator|(
name|RuleBlock
operator|)
name|context
argument_list|()
operator|.
name|block
operator|)
operator|.
name|getRuleName
argument_list|()
argument_list|)
decl_stmt|;
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|grammar
operator|.
name|getSymbol
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|access
operator|.
name|equals
argument_list|(
literal|"public"
argument_list|)
condition|)
block|{
name|tool
operator|.
name|warning
argument_list|(
literal|"public Lexical rules cannot specify return type"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|returnAction
operator|.
name|getLine
argument_list|()
argument_list|,
name|returnAction
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
operator|(
operator|(
name|RuleBlock
operator|)
name|context
argument_list|()
operator|.
name|block
operator|)
operator|.
name|returnAction
operator|=
name|returnAction
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
DECL|method|refRule (Token idAssign, Token r, Token label, Token args, int autoGenType)
specifier|public
name|void
name|refRule
parameter_list|(
name|Token
name|idAssign
parameter_list|,
name|Token
name|r
parameter_list|,
name|Token
name|label
parameter_list|,
name|Token
name|args
parameter_list|,
name|int
name|autoGenType
parameter_list|)
block|{
comment|// Disallow parser rule references in the lexer
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
block|{
comment|//			if (!Character.isUpperCase(r.getText().charAt(0))) {
if|if
condition|(
name|r
operator|.
name|type
operator|!=
name|ANTLRTokenTypes
operator|.
name|TOKEN_REF
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"Parser rule "
operator|+
name|r
operator|.
name|getText
argument_list|()
operator|+
literal|" referenced in lexer"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|autoGenType
operator|==
name|GrammarElement
operator|.
name|AUTO_GEN_CARET
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"AST specification ^ not allowed in lexer"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|r
operator|.
name|getLine
argument_list|()
argument_list|,
name|r
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|super
operator|.
name|refRule
argument_list|(
name|idAssign
argument_list|,
name|r
argument_list|,
name|label
argument_list|,
name|args
argument_list|,
name|autoGenType
argument_list|)
expr_stmt|;
name|lastRuleRef
operator|=
operator|new
name|RuleRefElement
argument_list|(
name|grammar
argument_list|,
name|r
argument_list|,
name|autoGenType
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|!=
literal|null
condition|)
block|{
name|lastRuleRef
operator|.
name|setArgs
argument_list|(
name|args
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idAssign
operator|!=
literal|null
condition|)
block|{
name|lastRuleRef
operator|.
name|setIdAssign
argument_list|(
name|idAssign
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|addElementToCurrentAlt
argument_list|(
name|lastRuleRef
argument_list|)
expr_stmt|;
name|String
name|id
init|=
name|r
operator|.
name|getText
argument_list|()
decl_stmt|;
comment|//		if ( Character.isUpperCase(id.charAt(0)) ) { // lexer rule?
if|if
condition|(
name|r
operator|.
name|type
operator|==
name|ANTLRTokenTypes
operator|.
name|TOKEN_REF
condition|)
block|{
comment|// lexer rule?
name|id
operator|=
name|CodeGenerator
operator|.
name|encodeLexerRuleName
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
comment|// update symbol table so it knows what nodes reference the rule.
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|grammar
operator|.
name|getSymbol
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|rs
operator|.
name|addReference
argument_list|(
name|lastRuleRef
argument_list|)
expr_stmt|;
name|labelElement
argument_list|(
name|lastRuleRef
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
DECL|method|refSemPred (Token pred)
specifier|public
name|void
name|refSemPred
parameter_list|(
name|Token
name|pred
parameter_list|)
block|{
comment|//System.out.println("refSemPred "+pred.getText());
name|super
operator|.
name|refSemPred
argument_list|(
name|pred
argument_list|)
expr_stmt|;
comment|//System.out.println("context().block: "+context().block);
if|if
condition|(
name|context
argument_list|()
operator|.
name|currentAlt
argument_list|()
operator|.
name|atStart
argument_list|()
condition|)
block|{
name|context
argument_list|()
operator|.
name|currentAlt
argument_list|()
operator|.
name|semPred
operator|=
name|pred
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ActionElement
name|a
init|=
operator|new
name|ActionElement
argument_list|(
name|grammar
argument_list|,
name|pred
argument_list|)
decl_stmt|;
name|a
operator|.
name|isSemPred
operator|=
literal|true
expr_stmt|;
name|addElementToCurrentAlt
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
comment|//System.out.println("DONE refSemPred "+pred.getText());
block|}
DECL|method|refStringLiteral (Token lit, Token label, int autoGenType, boolean lastInRule)
specifier|public
name|void
name|refStringLiteral
parameter_list|(
name|Token
name|lit
parameter_list|,
name|Token
name|label
parameter_list|,
name|int
name|autoGenType
parameter_list|,
name|boolean
name|lastInRule
parameter_list|)
block|{
name|super
operator|.
name|refStringLiteral
argument_list|(
name|lit
argument_list|,
name|label
argument_list|,
name|autoGenType
argument_list|,
name|lastInRule
argument_list|)
expr_stmt|;
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
operator|&&
name|autoGenType
operator|==
name|GrammarElement
operator|.
name|AUTO_GEN_CARET
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"^ not allowed in here for tree-walker"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|lit
operator|.
name|getLine
argument_list|()
argument_list|,
name|lit
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|StringLiteralElement
name|sl
init|=
operator|new
name|StringLiteralElement
argument_list|(
name|grammar
argument_list|,
name|lit
argument_list|,
name|autoGenType
argument_list|)
decl_stmt|;
comment|// If case-insensitive, then check each char of the stirng literal
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|&&
operator|!
operator|(
operator|(
name|LexerGrammar
operator|)
name|grammar
operator|)
operator|.
name|caseSensitive
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|lit
operator|.
name|getText
argument_list|()
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|lit
operator|.
name|getText
argument_list|()
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|128
operator|&&
name|Character
operator|.
name|toLowerCase
argument_list|(
name|c
argument_list|)
operator|!=
name|c
condition|)
block|{
name|tool
operator|.
name|warning
argument_list|(
literal|"Characters of string literal must be lowercase when caseSensitive=false"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|lit
operator|.
name|getLine
argument_list|()
argument_list|,
name|lit
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|addElementToCurrentAlt
argument_list|(
name|sl
argument_list|)
expr_stmt|;
name|labelElement
argument_list|(
name|sl
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|// if ignore option is set, must add an optional call to the specified rule.
name|String
name|ignore
init|=
name|ruleBlock
operator|.
name|getIgnoreRule
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|lastInRule
operator|&&
name|ignore
operator|!=
literal|null
condition|)
block|{
name|addElementToCurrentAlt
argument_list|(
name|createOptionalRuleRef
argument_list|(
name|ignore
argument_list|,
name|lit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|refToken (Token idAssign, Token t, Token label, Token args, boolean inverted, int autoGenType, boolean lastInRule)
specifier|public
name|void
name|refToken
parameter_list|(
name|Token
name|idAssign
parameter_list|,
name|Token
name|t
parameter_list|,
name|Token
name|label
parameter_list|,
name|Token
name|args
parameter_list|,
name|boolean
name|inverted
parameter_list|,
name|int
name|autoGenType
parameter_list|,
name|boolean
name|lastInRule
parameter_list|)
block|{
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
block|{
comment|// In lexer, token references are really rule references
if|if
condition|(
name|autoGenType
operator|==
name|GrammarElement
operator|.
name|AUTO_GEN_CARET
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"AST specification ^ not allowed in lexer"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|t
operator|.
name|getLine
argument_list|()
argument_list|,
name|t
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inverted
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"~TOKEN is not allowed in lexer"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|t
operator|.
name|getLine
argument_list|()
argument_list|,
name|t
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|refRule
argument_list|(
name|idAssign
argument_list|,
name|t
argument_list|,
name|label
argument_list|,
name|args
argument_list|,
name|autoGenType
argument_list|)
expr_stmt|;
comment|// if ignore option is set, must add an optional call to the specified token rule.
name|String
name|ignore
init|=
name|ruleBlock
operator|.
name|getIgnoreRule
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|lastInRule
operator|&&
name|ignore
operator|!=
literal|null
condition|)
block|{
name|addElementToCurrentAlt
argument_list|(
name|createOptionalRuleRef
argument_list|(
name|ignore
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Cannot have token ref args or assignment outside of lexer
if|if
condition|(
name|idAssign
operator|!=
literal|null
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"Assignment from token reference only allowed in lexer"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|idAssign
operator|.
name|getLine
argument_list|()
argument_list|,
name|idAssign
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|!=
literal|null
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"Token reference arguments only allowed in lexer"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|args
operator|.
name|getLine
argument_list|()
argument_list|,
name|args
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|refToken
argument_list|(
name|idAssign
argument_list|,
name|t
argument_list|,
name|label
argument_list|,
name|args
argument_list|,
name|inverted
argument_list|,
name|autoGenType
argument_list|,
name|lastInRule
argument_list|)
expr_stmt|;
name|TokenRefElement
name|te
init|=
operator|new
name|TokenRefElement
argument_list|(
name|grammar
argument_list|,
name|t
argument_list|,
name|inverted
argument_list|,
name|autoGenType
argument_list|)
decl_stmt|;
name|addElementToCurrentAlt
argument_list|(
name|te
argument_list|)
expr_stmt|;
name|labelElement
argument_list|(
name|te
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|refTokenRange (Token t1, Token t2, Token label, int autoGenType, boolean lastInRule)
specifier|public
name|void
name|refTokenRange
parameter_list|(
name|Token
name|t1
parameter_list|,
name|Token
name|t2
parameter_list|,
name|Token
name|label
parameter_list|,
name|int
name|autoGenType
parameter_list|,
name|boolean
name|lastInRule
parameter_list|)
block|{
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"Token range not allowed in lexer"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|t1
operator|.
name|getLine
argument_list|()
argument_list|,
name|t1
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|super
operator|.
name|refTokenRange
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
name|label
argument_list|,
name|autoGenType
argument_list|,
name|lastInRule
argument_list|)
expr_stmt|;
name|TokenRangeElement
name|tr
init|=
operator|new
name|TokenRangeElement
argument_list|(
name|grammar
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|autoGenType
argument_list|)
decl_stmt|;
if|if
condition|(
name|tr
operator|.
name|end
operator|<
name|tr
operator|.
name|begin
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"Malformed range."
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|t1
operator|.
name|getLine
argument_list|()
argument_list|,
name|t1
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|addElementToCurrentAlt
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|labelElement
argument_list|(
name|tr
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
DECL|method|refTreeSpecifier (Token treeSpec)
specifier|public
name|void
name|refTreeSpecifier
parameter_list|(
name|Token
name|treeSpec
parameter_list|)
block|{
name|context
argument_list|()
operator|.
name|currentAlt
argument_list|()
operator|.
name|treeSpecifier
operator|=
name|treeSpec
expr_stmt|;
block|}
DECL|method|refWildcard (Token t, Token label, int autoGenType)
specifier|public
name|void
name|refWildcard
parameter_list|(
name|Token
name|t
parameter_list|,
name|Token
name|label
parameter_list|,
name|int
name|autoGenType
parameter_list|)
block|{
name|super
operator|.
name|refWildcard
argument_list|(
name|t
argument_list|,
name|label
argument_list|,
name|autoGenType
argument_list|)
expr_stmt|;
name|WildcardElement
name|wc
init|=
operator|new
name|WildcardElement
argument_list|(
name|grammar
argument_list|,
name|t
argument_list|,
name|autoGenType
argument_list|)
decl_stmt|;
name|addElementToCurrentAlt
argument_list|(
name|wc
argument_list|)
expr_stmt|;
name|labelElement
argument_list|(
name|wc
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
comment|/** Get ready to process a new grammar */
DECL|method|reset ()
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|super
operator|.
name|reset
argument_list|()
expr_stmt|;
name|blocks
operator|=
operator|new
name|LList
argument_list|()
expr_stmt|;
name|lastRuleRef
operator|=
literal|null
expr_stmt|;
name|ruleEnd
operator|=
literal|null
expr_stmt|;
name|ruleBlock
operator|=
literal|null
expr_stmt|;
name|nested
operator|=
literal|0
expr_stmt|;
name|currentExceptionSpec
operator|=
literal|null
expr_stmt|;
name|grammarError
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|setArgOfRuleRef (Token argAction)
specifier|public
name|void
name|setArgOfRuleRef
parameter_list|(
name|Token
name|argAction
parameter_list|)
block|{
name|super
operator|.
name|setArgOfRuleRef
argument_list|(
name|argAction
argument_list|)
expr_stmt|;
name|lastRuleRef
operator|.
name|setArgs
argument_list|(
name|argAction
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|setBlock (AlternativeBlock b, AlternativeBlock src)
specifier|public
specifier|static
name|void
name|setBlock
parameter_list|(
name|AlternativeBlock
name|b
parameter_list|,
name|AlternativeBlock
name|src
parameter_list|)
block|{
name|b
operator|.
name|setAlternatives
argument_list|(
name|src
operator|.
name|getAlternatives
argument_list|()
argument_list|)
expr_stmt|;
name|b
operator|.
name|initAction
operator|=
name|src
operator|.
name|initAction
expr_stmt|;
comment|//b.lookaheadDepth = src.lookaheadDepth;
name|b
operator|.
name|label
operator|=
name|src
operator|.
name|label
expr_stmt|;
name|b
operator|.
name|hasASynPred
operator|=
name|src
operator|.
name|hasASynPred
expr_stmt|;
name|b
operator|.
name|hasAnAction
operator|=
name|src
operator|.
name|hasAnAction
expr_stmt|;
name|b
operator|.
name|warnWhenFollowAmbig
operator|=
name|src
operator|.
name|warnWhenFollowAmbig
expr_stmt|;
name|b
operator|.
name|generateAmbigWarnings
operator|=
name|src
operator|.
name|generateAmbigWarnings
expr_stmt|;
name|b
operator|.
name|line
operator|=
name|src
operator|.
name|line
expr_stmt|;
name|b
operator|.
name|greedy
operator|=
name|src
operator|.
name|greedy
expr_stmt|;
name|b
operator|.
name|greedySet
operator|=
name|src
operator|.
name|greedySet
expr_stmt|;
block|}
DECL|method|setRuleOption (Token key, Token value)
specifier|public
name|void
name|setRuleOption
parameter_list|(
name|Token
name|key
parameter_list|,
name|Token
name|value
parameter_list|)
block|{
comment|//((RuleBlock)context().block).setOption(key, value);
name|ruleBlock
operator|.
name|setOption
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
DECL|method|setSubruleOption (Token key, Token value)
specifier|public
name|void
name|setSubruleOption
parameter_list|(
name|Token
name|key
parameter_list|,
name|Token
name|value
parameter_list|)
block|{
operator|(
operator|(
name|AlternativeBlock
operator|)
name|context
argument_list|()
operator|.
name|block
operator|)
operator|.
name|setOption
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
DECL|method|synPred ()
specifier|public
name|void
name|synPred
parameter_list|()
block|{
if|if
condition|(
name|context
argument_list|()
operator|.
name|block
operator|.
name|not
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"'~' cannot be applied to syntactic predicate"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|context
argument_list|()
operator|.
name|block
operator|.
name|getLine
argument_list|()
argument_list|,
name|context
argument_list|()
operator|.
name|block
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// create the right kind of object now that we know what that is
comment|// and switch the list of alternatives.  Adjust the stack of blocks.
comment|// copy any init action also.
name|SynPredBlock
name|b
init|=
operator|new
name|SynPredBlock
argument_list|(
name|grammar
argument_list|)
decl_stmt|;
name|setBlock
argument_list|(
name|b
argument_list|,
name|context
argument_list|()
operator|.
name|block
argument_list|)
expr_stmt|;
name|BlockContext
name|old
init|=
operator|(
name|BlockContext
operator|)
name|blocks
operator|.
name|pop
argument_list|()
decl_stmt|;
comment|// remove old scope; we want new type of subrule
name|blocks
operator|.
name|push
argument_list|(
operator|new
name|BlockContext
argument_list|()
argument_list|)
expr_stmt|;
name|context
argument_list|()
operator|.
name|block
operator|=
name|b
expr_stmt|;
name|context
argument_list|()
operator|.
name|blockEnd
operator|=
name|old
operator|.
name|blockEnd
expr_stmt|;
name|context
argument_list|()
operator|.
name|blockEnd
operator|.
name|block
operator|=
name|b
expr_stmt|;
block|}
DECL|method|zeroOrMoreSubRule ()
specifier|public
name|void
name|zeroOrMoreSubRule
parameter_list|()
block|{
if|if
condition|(
name|context
argument_list|()
operator|.
name|block
operator|.
name|not
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"'~' cannot be applied to (...)+ subrule"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|context
argument_list|()
operator|.
name|block
operator|.
name|getLine
argument_list|()
argument_list|,
name|context
argument_list|()
operator|.
name|block
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// create the right kind of object now that we know what that is
comment|// and switch the list of alternatives.  Adjust the stack of blocks.
comment|// copy any init action also.
name|ZeroOrMoreBlock
name|b
init|=
operator|new
name|ZeroOrMoreBlock
argument_list|(
name|grammar
argument_list|)
decl_stmt|;
name|setBlock
argument_list|(
name|b
argument_list|,
name|context
argument_list|()
operator|.
name|block
argument_list|)
expr_stmt|;
name|BlockContext
name|old
init|=
operator|(
name|BlockContext
operator|)
name|blocks
operator|.
name|pop
argument_list|()
decl_stmt|;
comment|// remove old scope; we want new type of subrule
name|blocks
operator|.
name|push
argument_list|(
operator|new
name|BlockContext
argument_list|()
argument_list|)
expr_stmt|;
name|context
argument_list|()
operator|.
name|block
operator|=
name|b
expr_stmt|;
name|context
argument_list|()
operator|.
name|blockEnd
operator|=
name|old
operator|.
name|blockEnd
expr_stmt|;
name|context
argument_list|()
operator|.
name|blockEnd
operator|.
name|block
operator|=
name|b
expr_stmt|;
block|}
block|}
end_class

end_unit

