begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/license.html  *  * $Id$  */
end_comment

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileWriter
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|BitSet
import|;
end_import

begin_comment
comment|/**A generic ANTLR code generator.  All code generators  * Derive from this class.  *  *<p>  * A CodeGenerator knows about a Grammar data structure and  * a grammar analyzer.  The Grammar is walked to generate the  * appropriate code for both a parser and lexer (if present).  * This interface may change slightly so that the lexer is  * itself living inside of a Grammar object (in which case,  * this class generates only one recognizer).  The main method  * to call is<tt>gen()</tt>, which initiates all code gen.  *  *<p>  * The interaction of the code generator with the analyzer is  * simple: each subrule block calls deterministic() before generating  * code for the block.  Method deterministic() sets lookahead caches  * in each Alternative object.  Technically, a code generator  * doesn't need the grammar analyzer if all lookahead analysis  * is done at runtime, but this would result in a slower parser.  *  *<p>  * This class provides a set of support utilities to handle argument  * list parsing and so on.  *  * @author  Terence Parr, John Lilley  * @version 2.00a  * @see     antlr.JavaCodeGenerator  * @see     antlr.DiagnosticCodeGenerator  * @see     antlr.LLkAnalyzer  * @see     antlr.Grammar  * @see     antlr.AlternativeElement  * @see     antlr.Lookahead  */
end_comment

begin_class
DECL|class|CodeGenerator
specifier|public
specifier|abstract
class|class
name|CodeGenerator
block|{
DECL|field|antlrTool
specifier|protected
name|antlr
operator|.
name|Tool
name|antlrTool
decl_stmt|;
comment|/** Current tab indentation for code output */
DECL|field|tabs
specifier|protected
name|int
name|tabs
init|=
literal|0
decl_stmt|;
comment|/** Current output Stream */
DECL|field|currentOutput
specifier|transient
specifier|protected
name|PrintWriter
name|currentOutput
decl_stmt|;
comment|// SAS: for proper text i/o
comment|/** The grammar for which we generate code */
DECL|field|grammar
specifier|protected
name|Grammar
name|grammar
init|=
literal|null
decl_stmt|;
comment|/** List of all bitsets that must be dumped.  These are Vectors of BitSet. */
DECL|field|bitsetsUsed
specifier|protected
name|Vector
name|bitsetsUsed
decl_stmt|;
comment|/** The grammar behavior */
DECL|field|behavior
specifier|protected
name|DefineGrammarSymbols
name|behavior
decl_stmt|;
comment|/** The LLk analyzer */
DECL|field|analyzer
specifier|protected
name|LLkGrammarAnalyzer
name|analyzer
decl_stmt|;
comment|/** Object used to format characters in the target language.      * subclass must initialize this to the language-specific formatter      */
DECL|field|charFormatter
specifier|protected
name|CharFormatter
name|charFormatter
decl_stmt|;
comment|/** Use option "codeGenDebug" to generate debugging output */
DECL|field|DEBUG_CODE_GENERATOR
specifier|protected
name|boolean
name|DEBUG_CODE_GENERATOR
init|=
literal|false
decl_stmt|;
comment|/** Default values for code-generation thresholds */
DECL|field|DEFAULT_MAKE_SWITCH_THRESHOLD
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_MAKE_SWITCH_THRESHOLD
init|=
literal|2
decl_stmt|;
DECL|field|DEFAULT_BITSET_TEST_THRESHOLD
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_BITSET_TEST_THRESHOLD
init|=
literal|4
decl_stmt|;
comment|/** If there are more than 8 long words to init in a bitset,      *  try to optimize it; e.g., detect runs of -1L and 0L.      */
DECL|field|BITSET_OPTIMIZE_INIT_THRESHOLD
specifier|protected
specifier|static
specifier|final
name|int
name|BITSET_OPTIMIZE_INIT_THRESHOLD
init|=
literal|8
decl_stmt|;
comment|/** This is a hint for the language-specific code generator.      * A switch() or language-specific equivalent will be generated instead      * of a series of if/else statements for blocks with number of alternates      * greater than or equal to this number of non-predicated LL(1) alternates.      * This is modified by the grammar option "codeGenMakeSwitchThreshold"      */
DECL|field|makeSwitchThreshold
specifier|protected
name|int
name|makeSwitchThreshold
init|=
name|DEFAULT_MAKE_SWITCH_THRESHOLD
decl_stmt|;
comment|/** This is a hint for the language-specific code generator.      * A bitset membership test will be generated instead of an      * ORed series of LA(k) comparisions for lookahead sets with      * degree greater than or equal to this value.      * This is modified by the grammar option "codeGenBitsetTestThreshold"      */
DECL|field|bitsetTestThreshold
specifier|protected
name|int
name|bitsetTestThreshold
init|=
name|DEFAULT_BITSET_TEST_THRESHOLD
decl_stmt|;
DECL|field|OLD_ACTION_TRANSLATOR
specifier|private
specifier|static
name|boolean
name|OLD_ACTION_TRANSLATOR
init|=
literal|true
decl_stmt|;
DECL|field|TokenTypesFileSuffix
specifier|public
specifier|static
name|String
name|TokenTypesFileSuffix
init|=
literal|"TokenTypes"
decl_stmt|;
DECL|field|TokenTypesFileExt
specifier|public
specifier|static
name|String
name|TokenTypesFileExt
init|=
literal|".txt"
decl_stmt|;
comment|/** Construct code generator base class */
DECL|method|CodeGenerator ()
specifier|public
name|CodeGenerator
parameter_list|()
block|{     }
comment|/** Output a String to the currentOutput stream.      * Ignored if string is null.      * @param s The string to output      */
DECL|method|_print (String s)
specifier|protected
name|void
name|_print
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|currentOutput
operator|.
name|print
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Print an action without leading tabs, attempting to      * preserve the current indentation level for multi-line actions      * Ignored if string is null.      * @param s The action string to output      */
DECL|method|_printAction (String s)
specifier|protected
name|void
name|_printAction
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// Skip leading newlines, tabs and spaces
name|int
name|start
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|s
operator|.
name|length
argument_list|()
operator|&&
name|Character
operator|.
name|isSpaceChar
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|start
argument_list|)
argument_list|)
condition|)
block|{
name|start
operator|++
expr_stmt|;
block|}
comment|// Skip leading newlines, tabs and spaces
name|int
name|end
init|=
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|end
operator|>
name|start
operator|&&
name|Character
operator|.
name|isSpaceChar
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|end
argument_list|)
argument_list|)
condition|)
block|{
name|end
operator|--
expr_stmt|;
block|}
name|char
name|c
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<=
name|end
condition|;
control|)
block|{
name|c
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|boolean
name|newline
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|newline
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
if|if
condition|(
name|i
operator|<=
name|end
operator|&&
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'\n'
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
name|newline
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|currentOutput
operator|.
name|print
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|newline
condition|)
block|{
name|currentOutput
operator|.
name|println
argument_list|()
expr_stmt|;
name|printTabs
argument_list|()
expr_stmt|;
comment|// Absorb leading whitespace
while|while
condition|(
name|i
operator|<=
name|end
operator|&&
name|Character
operator|.
name|isSpaceChar
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
name|newline
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|currentOutput
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
comment|/** Output a String followed by newline, to the currentOutput stream.      * Ignored if string is null.      * @param s The string to output      */
DECL|method|_println (String s)
specifier|protected
name|void
name|_println
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|currentOutput
operator|.
name|println
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Test if a set element array represents a contiguous range.      * @param elems The array of elements representing the set, usually from BitSet.toArray().      * @return true if the elements are a contiguous range (with two or more).      */
DECL|method|elementsAreRange (int[] elems)
specifier|public
specifier|static
name|boolean
name|elementsAreRange
parameter_list|(
name|int
index|[]
name|elems
parameter_list|)
block|{
if|if
condition|(
name|elems
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|begin
init|=
name|elems
index|[
literal|0
index|]
decl_stmt|;
name|int
name|end
init|=
name|elems
index|[
name|elems
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|elems
operator|.
name|length
operator|<=
literal|2
condition|)
block|{
comment|// Not enough elements for a range expression
return|return
literal|false
return|;
block|}
if|if
condition|(
name|end
operator|-
name|begin
operator|+
literal|1
operator|>
name|elems
operator|.
name|length
condition|)
block|{
comment|// The set does not represent a contiguous range
return|return
literal|false
return|;
block|}
name|int
name|v
init|=
name|begin
operator|+
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|elems
operator|.
name|length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|!=
name|elems
index|[
name|i
index|]
condition|)
block|{
comment|// The set does not represent a contiguous range
return|return
literal|false
return|;
block|}
name|v
operator|++
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/** Get the identifier portion of an argument-action token.      * The ID of an action is assumed to be a trailing identifier.      * Specific code-generators may want to override this      * if the language has unusual declaration syntax.      * @param t The action token      * @return A string containing the text of the identifier      */
DECL|method|extractIdOfAction (Token t)
specifier|protected
name|String
name|extractIdOfAction
parameter_list|(
name|Token
name|t
parameter_list|)
block|{
return|return
name|extractIdOfAction
argument_list|(
name|t
operator|.
name|getText
argument_list|()
argument_list|,
name|t
operator|.
name|getLine
argument_list|()
argument_list|,
name|t
operator|.
name|getColumn
argument_list|()
argument_list|)
return|;
block|}
comment|/** Get the identifier portion of an argument-action.      * The ID of an action is assumed to be a trailing identifier.      * Specific code-generators may want to override this      * if the language has unusual declaration syntax.      * @param s The action text      * @param line Line used for error reporting.      * @param column Line used for error reporting.      * @return A string containing the text of the identifier      */
DECL|method|extractIdOfAction (String s, int line, int column)
specifier|protected
name|String
name|extractIdOfAction
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|column
parameter_list|)
block|{
name|s
operator|=
name|removeAssignmentFromDeclaration
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|// Search back from the end for a non alphanumeric.  That marks the
comment|// beginning of the identifier
for|for
control|(
name|int
name|i
init|=
name|s
operator|.
name|length
argument_list|()
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|// TODO: make this work for language-independent identifiers?
if|if
condition|(
operator|!
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&&
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|!=
literal|'_'
condition|)
block|{
comment|// Found end of type part
return|return
name|s
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|1
argument_list|)
return|;
block|}
block|}
comment|// Something is bogus, but we cannot parse the language-specific
comment|// actions any better.  The compiler will have to catch the problem.
name|antlrTool
operator|.
name|warning
argument_list|(
literal|"Ill-formed action"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
comment|/** Get the type string out of an argument-action token.      * The type of an action is assumed to precede a trailing identifier      * Specific code-generators may want to override this      * if the language has unusual declaration syntax.      * @param t The action token      * @return A string containing the text of the type      */
DECL|method|extractTypeOfAction (Token t)
specifier|protected
name|String
name|extractTypeOfAction
parameter_list|(
name|Token
name|t
parameter_list|)
block|{
return|return
name|extractTypeOfAction
argument_list|(
name|t
operator|.
name|getText
argument_list|()
argument_list|,
name|t
operator|.
name|getLine
argument_list|()
argument_list|,
name|t
operator|.
name|getColumn
argument_list|()
argument_list|)
return|;
block|}
comment|/** Get the type portion of an argument-action.      * The type of an action is assumed to precede a trailing identifier      * Specific code-generators may want to override this      * if the language has unusual declaration syntax.      * @param s The action text      * @param line Line used for error reporting.      * @return A string containing the text of the type      */
DECL|method|extractTypeOfAction (String s, int line, int column)
specifier|protected
name|String
name|extractTypeOfAction
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|column
parameter_list|)
block|{
name|s
operator|=
name|removeAssignmentFromDeclaration
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|// Search back from the end for a non alphanumeric.  That marks the
comment|// beginning of the identifier
for|for
control|(
name|int
name|i
init|=
name|s
operator|.
name|length
argument_list|()
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|// TODO: make this work for language-independent identifiers?
if|if
condition|(
operator|!
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&&
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|!=
literal|'_'
condition|)
block|{
comment|// Found end of type part
return|return
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
return|;
block|}
block|}
comment|// Something is bogus, but we cannot parse the language-specific
comment|// actions any better.  The compiler will have to catch the problem.
name|antlrTool
operator|.
name|warning
argument_list|(
literal|"Ill-formed action"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
comment|/** Generate the code for all grammars      */
DECL|method|gen ()
specifier|public
specifier|abstract
name|void
name|gen
parameter_list|()
function_decl|;
comment|/** Generate code for the given grammar element.      * @param action The {...} action to generate      */
DECL|method|gen (ActionElement action)
specifier|public
specifier|abstract
name|void
name|gen
parameter_list|(
name|ActionElement
name|action
parameter_list|)
function_decl|;
comment|/** Generate code for the given grammar element.      * @param blk The "x|y|z|..." block to generate      */
DECL|method|gen (AlternativeBlock blk)
specifier|public
specifier|abstract
name|void
name|gen
parameter_list|(
name|AlternativeBlock
name|blk
parameter_list|)
function_decl|;
comment|/** Generate code for the given grammar element.      * @param end The block-end element to generate.  Block-end      * elements are synthesized by the grammar parser to represent      * the end of a block.      */
DECL|method|gen (BlockEndElement end)
specifier|public
specifier|abstract
name|void
name|gen
parameter_list|(
name|BlockEndElement
name|end
parameter_list|)
function_decl|;
comment|/** Generate code for the given grammar element.      * @param atom The character literal reference to generate      */
DECL|method|gen (CharLiteralElement atom)
specifier|public
specifier|abstract
name|void
name|gen
parameter_list|(
name|CharLiteralElement
name|atom
parameter_list|)
function_decl|;
comment|/** Generate code for the given grammar element.      * @param r The character-range reference to generate      */
DECL|method|gen (CharRangeElement r)
specifier|public
specifier|abstract
name|void
name|gen
parameter_list|(
name|CharRangeElement
name|r
parameter_list|)
function_decl|;
comment|/** Generate the code for a parser */
DECL|method|gen (LexerGrammar g)
specifier|public
specifier|abstract
name|void
name|gen
parameter_list|(
name|LexerGrammar
name|g
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Generate code for the given grammar element.      * @param blk The (...)+ block to generate      */
DECL|method|gen (OneOrMoreBlock blk)
specifier|public
specifier|abstract
name|void
name|gen
parameter_list|(
name|OneOrMoreBlock
name|blk
parameter_list|)
function_decl|;
comment|/** Generate the code for a parser */
DECL|method|gen (ParserGrammar g)
specifier|public
specifier|abstract
name|void
name|gen
parameter_list|(
name|ParserGrammar
name|g
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Generate code for the given grammar element.      * @param rr The rule-reference to generate      */
DECL|method|gen (RuleRefElement rr)
specifier|public
specifier|abstract
name|void
name|gen
parameter_list|(
name|RuleRefElement
name|rr
parameter_list|)
function_decl|;
comment|/** Generate code for the given grammar element.      * @param atom The string-literal reference to generate      */
DECL|method|gen (StringLiteralElement atom)
specifier|public
specifier|abstract
name|void
name|gen
parameter_list|(
name|StringLiteralElement
name|atom
parameter_list|)
function_decl|;
comment|/** Generate code for the given grammar element.      * @param r The token-range reference to generate      */
DECL|method|gen (TokenRangeElement r)
specifier|public
specifier|abstract
name|void
name|gen
parameter_list|(
name|TokenRangeElement
name|r
parameter_list|)
function_decl|;
comment|/** Generate code for the given grammar element.      * @param atom The token-reference to generate      */
DECL|method|gen (TokenRefElement atom)
specifier|public
specifier|abstract
name|void
name|gen
parameter_list|(
name|TokenRefElement
name|atom
parameter_list|)
function_decl|;
comment|/** Generate code for the given grammar element.      * @param blk The tree to generate code for.      */
DECL|method|gen (TreeElement t)
specifier|public
specifier|abstract
name|void
name|gen
parameter_list|(
name|TreeElement
name|t
parameter_list|)
function_decl|;
comment|/** Generate the code for a parser */
DECL|method|gen (TreeWalkerGrammar g)
specifier|public
specifier|abstract
name|void
name|gen
parameter_list|(
name|TreeWalkerGrammar
name|g
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Generate code for the given grammar element.      * @param wc The wildcard element to generate      */
DECL|method|gen (WildcardElement wc)
specifier|public
specifier|abstract
name|void
name|gen
parameter_list|(
name|WildcardElement
name|wc
parameter_list|)
function_decl|;
comment|/** Generate code for the given grammar element.      * @param blk The (...)* block to generate      */
DECL|method|gen (ZeroOrMoreBlock blk)
specifier|public
specifier|abstract
name|void
name|gen
parameter_list|(
name|ZeroOrMoreBlock
name|blk
parameter_list|)
function_decl|;
comment|/** Generate the token types as a text file for persistence across shared lexer/parser */
DECL|method|genTokenInterchange (TokenManager tm)
specifier|protected
name|void
name|genTokenInterchange
parameter_list|(
name|TokenManager
name|tm
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Open the token output Java file and set the currentOutput stream
name|String
name|fName
init|=
name|tm
operator|.
name|getName
argument_list|()
operator|+
name|TokenTypesFileSuffix
operator|+
name|TokenTypesFileExt
decl_stmt|;
name|currentOutput
operator|=
name|antlrTool
operator|.
name|openOutputFile
argument_list|(
name|fName
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// $ANTLR "
operator|+
name|antlrTool
operator|.
name|version
operator|+
literal|": "
operator|+
name|antlrTool
operator|.
name|fileMinusPath
argument_list|(
name|antlrTool
operator|.
name|grammarFile
argument_list|)
operator|+
literal|" -> "
operator|+
name|fName
operator|+
literal|"$"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|0
expr_stmt|;
comment|// Header
name|println
argument_list|(
name|tm
operator|.
name|getName
argument_list|()
operator|+
literal|"    // output token vocab name"
argument_list|)
expr_stmt|;
comment|// Generate a definition for each token type
name|Vector
name|v
init|=
name|tm
operator|.
name|getVocabulary
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|Token
operator|.
name|MIN_USER_TYPE
init|;
name|i
operator|<
name|v
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|s
init|=
operator|(
name|String
operator|)
name|v
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEBUG_CODE_GENERATOR
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"gen persistence file entry for: "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|!=
literal|null
operator|&&
operator|!
name|s
operator|.
name|startsWith
argument_list|(
literal|"<"
argument_list|)
condition|)
block|{
comment|// if literal, find label
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
literal|"\""
argument_list|)
condition|)
block|{
name|StringLiteralSymbol
name|sl
init|=
operator|(
name|StringLiteralSymbol
operator|)
name|tm
operator|.
name|getTokenSymbol
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|sl
operator|!=
literal|null
operator|&&
name|sl
operator|.
name|label
operator|!=
literal|null
condition|)
block|{
name|print
argument_list|(
name|sl
operator|.
name|label
operator|+
literal|"="
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
name|s
operator|+
literal|"="
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|// check for a paraphrase
name|TokenSymbol
name|ts
init|=
operator|(
name|TokenSymbol
operator|)
name|tm
operator|.
name|getTokenSymbol
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|==
literal|null
condition|)
block|{
name|antlrTool
operator|.
name|warning
argument_list|(
literal|"undefined token symbol: "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ts
operator|.
name|getParaphrase
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|print
argument_list|(
literal|"("
operator|+
name|ts
operator|.
name|getParaphrase
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
name|println
argument_list|(
literal|"="
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Close the tokens output file
name|currentOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentOutput
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Process a string for an simple expression for use in xx/action.g      * it is used to cast simple tokens/references to the right type for      * the generated language.      * @param str A String.      */
DECL|method|processStringForASTConstructor (String str)
specifier|public
name|String
name|processStringForASTConstructor
parameter_list|(
name|String
name|str
parameter_list|)
block|{
return|return
name|str
return|;
block|}
comment|/** Get a string for an expression to generate creation of an AST subtree.      * @param v A Vector of String, where each element is an expression in the target language yielding an AST node.      */
DECL|method|getASTCreateString (Vector v)
specifier|public
specifier|abstract
name|String
name|getASTCreateString
parameter_list|(
name|Vector
name|v
parameter_list|)
function_decl|;
comment|/** Get a string for an expression to generate creating of an AST node      * @param str The text of the arguments to the AST construction      */
DECL|method|getASTCreateString (GrammarAtom atom, String str)
specifier|public
specifier|abstract
name|String
name|getASTCreateString
parameter_list|(
name|GrammarAtom
name|atom
parameter_list|,
name|String
name|str
parameter_list|)
function_decl|;
comment|/** Given the index of a bitset in the bitset list, generate a unique name.      * Specific code-generators may want to override this      * if the language does not allow '_' or numerals in identifiers.      * @param index  The index of the bitset in the bitset list.      */
DECL|method|getBitsetName (int index)
specifier|protected
name|String
name|getBitsetName
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
literal|"_tokenSet_"
operator|+
name|index
return|;
block|}
DECL|method|encodeLexerRuleName (String id)
specifier|public
specifier|static
name|String
name|encodeLexerRuleName
parameter_list|(
name|String
name|id
parameter_list|)
block|{
return|return
literal|"m"
operator|+
name|id
return|;
block|}
DECL|method|decodeLexerRuleName (String id)
specifier|public
specifier|static
name|String
name|decodeLexerRuleName
parameter_list|(
name|String
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|id
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|id
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
comment|/** Map an identifier to it's corresponding tree-node variable.      * This is context-sensitive, depending on the rule and alternative      * being generated      * @param id The identifier name to map      * @param forInput true if the input tree node variable is to be returned, otherwise the output variable is returned.      * @return The mapped id (which may be the same as the input), or null if the mapping is invalid due to duplicates      */
DECL|method|mapTreeId (String id, ActionTransInfo tInfo)
specifier|public
specifier|abstract
name|String
name|mapTreeId
parameter_list|(
name|String
name|id
parameter_list|,
name|ActionTransInfo
name|tInfo
parameter_list|)
function_decl|;
comment|/** Add a bitset to the list of bitsets to be generated.      * if the bitset is already in the list, ignore the request.      * Always adds the bitset to the end of the list, so the      * caller can rely on the position of bitsets in the list.      * The returned position can be used to format the bitset      * name, since it is invariant.      * @param p Bit set to mark for code generation      * @param forParser true if the bitset is used for the parser, false for the lexer      * @return The position of the bitset in the list.      */
DECL|method|markBitsetForGen (BitSet p)
specifier|protected
name|int
name|markBitsetForGen
parameter_list|(
name|BitSet
name|p
parameter_list|)
block|{
comment|// Is the bitset (or an identical one) already marked for gen?
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bitsetsUsed
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|BitSet
name|set
init|=
operator|(
name|BitSet
operator|)
name|bitsetsUsed
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|equals
argument_list|(
name|set
argument_list|)
condition|)
block|{
comment|// Use the identical one already stored
return|return
name|i
return|;
block|}
block|}
comment|// Add the new bitset
name|bitsetsUsed
operator|.
name|appendElement
argument_list|(
name|p
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|bitsetsUsed
operator|.
name|size
argument_list|()
operator|-
literal|1
return|;
block|}
comment|/** Output tab indent followed by a String, to the currentOutput stream.      * Ignored if string is null.      * @param s The string to output.      */
DECL|method|print (String s)
specifier|protected
name|void
name|print
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|printTabs
argument_list|()
expr_stmt|;
name|currentOutput
operator|.
name|print
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Print an action with leading tabs, attempting to      * preserve the current indentation level for multi-line actions      * Ignored if string is null.      * @param s The action string to output      */
DECL|method|printAction (String s)
specifier|protected
name|void
name|printAction
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|printTabs
argument_list|()
expr_stmt|;
name|_printAction
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Output tab indent followed by a String followed by newline,      * to the currentOutput stream.  Ignored if string is null.      * @param s The string to output      */
DECL|method|println (String s)
specifier|protected
name|void
name|println
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|printTabs
argument_list|()
expr_stmt|;
name|currentOutput
operator|.
name|println
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Output the current tab indentation.  This outputs the number of tabs      * indicated by the "tabs" variable to the currentOutput stream.      */
DECL|method|printTabs ()
specifier|protected
name|void
name|printTabs
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|tabs
condition|;
name|i
operator|++
control|)
block|{
name|currentOutput
operator|.
name|print
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Lexically process $ and # references within the action.      *  This will replace #id and #(...) with the appropriate      *  function calls and/or variables etc...      */
DECL|method|processActionForSpecialSymbols (String actionStr, int line, RuleBlock currentRule, ActionTransInfo tInfo)
specifier|protected
specifier|abstract
name|String
name|processActionForSpecialSymbols
parameter_list|(
name|String
name|actionStr
parameter_list|,
name|int
name|line
parameter_list|,
name|RuleBlock
name|currentRule
parameter_list|,
name|ActionTransInfo
name|tInfo
parameter_list|)
function_decl|;
DECL|method|getFOLLOWBitSet (String ruleName, int k)
specifier|public
name|String
name|getFOLLOWBitSet
parameter_list|(
name|String
name|ruleName
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|GrammarSymbol
name|rs
init|=
name|grammar
operator|.
name|getSymbol
argument_list|(
name|ruleName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|rs
operator|instanceof
name|RuleSymbol
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|RuleBlock
name|blk
init|=
operator|(
operator|(
name|RuleSymbol
operator|)
name|rs
operator|)
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|Lookahead
name|follow
init|=
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|FOLLOW
argument_list|(
name|k
argument_list|,
name|blk
operator|.
name|endNode
argument_list|)
decl_stmt|;
name|String
name|followSetName
init|=
name|getBitsetName
argument_list|(
name|markBitsetForGen
argument_list|(
name|follow
operator|.
name|fset
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|followSetName
return|;
block|}
DECL|method|getFIRSTBitSet (String ruleName, int k)
specifier|public
name|String
name|getFIRSTBitSet
parameter_list|(
name|String
name|ruleName
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|GrammarSymbol
name|rs
init|=
name|grammar
operator|.
name|getSymbol
argument_list|(
name|ruleName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|rs
operator|instanceof
name|RuleSymbol
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|RuleBlock
name|blk
init|=
operator|(
operator|(
name|RuleSymbol
operator|)
name|rs
operator|)
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|Lookahead
name|first
init|=
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|look
argument_list|(
name|k
argument_list|,
name|blk
argument_list|)
decl_stmt|;
name|String
name|firstSetName
init|=
name|getBitsetName
argument_list|(
name|markBitsetForGen
argument_list|(
name|first
operator|.
name|fset
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|firstSetName
return|;
block|}
comment|/**      * Remove the assignment portion of a declaration, if any.      * @param d the declaration      * @return the declaration without any assignment portion      */
DECL|method|removeAssignmentFromDeclaration (String d)
specifier|protected
name|String
name|removeAssignmentFromDeclaration
parameter_list|(
name|String
name|d
parameter_list|)
block|{
comment|// If d contains an equal sign, then it's a declaration
comment|// with an initialization.  Strip off the initialization part.
if|if
condition|(
name|d
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|)
operator|>=
literal|0
condition|)
name|d
operator|=
name|d
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|d
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
return|return
name|d
return|;
block|}
comment|/** Set all fields back like one just created */
DECL|method|reset ()
specifier|private
name|void
name|reset
parameter_list|()
block|{
name|tabs
operator|=
literal|0
expr_stmt|;
comment|// Allocate list of bitsets tagged for code generation
name|bitsetsUsed
operator|=
operator|new
name|Vector
argument_list|()
expr_stmt|;
name|currentOutput
operator|=
literal|null
expr_stmt|;
name|grammar
operator|=
literal|null
expr_stmt|;
name|DEBUG_CODE_GENERATOR
operator|=
literal|false
expr_stmt|;
name|makeSwitchThreshold
operator|=
name|DEFAULT_MAKE_SWITCH_THRESHOLD
expr_stmt|;
name|bitsetTestThreshold
operator|=
name|DEFAULT_BITSET_TEST_THRESHOLD
expr_stmt|;
block|}
DECL|method|reverseLexerRuleName (String id)
specifier|public
specifier|static
name|String
name|reverseLexerRuleName
parameter_list|(
name|String
name|id
parameter_list|)
block|{
return|return
name|id
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|id
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
DECL|method|setAnalyzer (LLkGrammarAnalyzer analyzer_)
specifier|public
name|void
name|setAnalyzer
parameter_list|(
name|LLkGrammarAnalyzer
name|analyzer_
parameter_list|)
block|{
name|analyzer
operator|=
name|analyzer_
expr_stmt|;
block|}
DECL|method|setBehavior (DefineGrammarSymbols behavior_)
specifier|public
name|void
name|setBehavior
parameter_list|(
name|DefineGrammarSymbols
name|behavior_
parameter_list|)
block|{
name|behavior
operator|=
name|behavior_
expr_stmt|;
block|}
comment|/** Set a grammar for the code generator to use */
DECL|method|setGrammar (Grammar g)
specifier|protected
name|void
name|setGrammar
parameter_list|(
name|Grammar
name|g
parameter_list|)
block|{
name|reset
argument_list|()
expr_stmt|;
name|grammar
operator|=
name|g
expr_stmt|;
comment|// Lookup make-switch threshold in the grammar generic options
if|if
condition|(
name|grammar
operator|.
name|hasOption
argument_list|(
literal|"codeGenMakeSwitchThreshold"
argument_list|)
condition|)
block|{
try|try
block|{
name|makeSwitchThreshold
operator|=
name|grammar
operator|.
name|getIntegerOption
argument_list|(
literal|"codeGenMakeSwitchThreshold"
argument_list|)
expr_stmt|;
comment|//System.out.println("setting codeGenMakeSwitchThreshold to " + makeSwitchThreshold);
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|Token
name|tok
init|=
name|grammar
operator|.
name|getOption
argument_list|(
literal|"codeGenMakeSwitchThreshold"
argument_list|)
decl_stmt|;
name|antlrTool
operator|.
name|error
argument_list|(
literal|"option 'codeGenMakeSwitchThreshold' must be an integer"
argument_list|,
name|grammar
operator|.
name|getClassName
argument_list|()
argument_list|,
name|tok
operator|.
name|getLine
argument_list|()
argument_list|,
name|tok
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Lookup bitset-test threshold in the grammar generic options
if|if
condition|(
name|grammar
operator|.
name|hasOption
argument_list|(
literal|"codeGenBitsetTestThreshold"
argument_list|)
condition|)
block|{
try|try
block|{
name|bitsetTestThreshold
operator|=
name|grammar
operator|.
name|getIntegerOption
argument_list|(
literal|"codeGenBitsetTestThreshold"
argument_list|)
expr_stmt|;
comment|//System.out.println("setting codeGenBitsetTestThreshold to " + bitsetTestThreshold);
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|Token
name|tok
init|=
name|grammar
operator|.
name|getOption
argument_list|(
literal|"codeGenBitsetTestThreshold"
argument_list|)
decl_stmt|;
name|antlrTool
operator|.
name|error
argument_list|(
literal|"option 'codeGenBitsetTestThreshold' must be an integer"
argument_list|,
name|grammar
operator|.
name|getClassName
argument_list|()
argument_list|,
name|tok
operator|.
name|getLine
argument_list|()
argument_list|,
name|tok
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Lookup debug code-gen in the grammar generic options
if|if
condition|(
name|grammar
operator|.
name|hasOption
argument_list|(
literal|"codeGenDebug"
argument_list|)
condition|)
block|{
name|Token
name|t
init|=
name|grammar
operator|.
name|getOption
argument_list|(
literal|"codeGenDebug"
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
comment|//System.out.println("setting code-generation debug ON");
name|DEBUG_CODE_GENERATOR
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
comment|//System.out.println("setting code-generation debug OFF");
name|DEBUG_CODE_GENERATOR
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|antlrTool
operator|.
name|error
argument_list|(
literal|"option 'codeGenDebug' must be true or false"
argument_list|,
name|grammar
operator|.
name|getClassName
argument_list|()
argument_list|,
name|t
operator|.
name|getLine
argument_list|()
argument_list|,
name|t
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|setTool (Tool tool)
specifier|public
name|void
name|setTool
parameter_list|(
name|Tool
name|tool
parameter_list|)
block|{
name|antlrTool
operator|=
name|tool
expr_stmt|;
block|}
block|}
end_class

end_unit

