begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/license.html  *  * $Id$  */
end_comment

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_comment
comment|/**A list of alternatives and info contained in  * the rule definition.  */
end_comment

begin_class
DECL|class|RuleBlock
specifier|public
class|class
name|RuleBlock
extends|extends
name|AlternativeBlock
block|{
DECL|field|ruleName
specifier|protected
name|String
name|ruleName
decl_stmt|;
DECL|field|argAction
specifier|protected
name|String
name|argAction
init|=
literal|null
decl_stmt|;
comment|// string for rule arguments [...]
DECL|field|throwsSpec
specifier|protected
name|String
name|throwsSpec
init|=
literal|null
decl_stmt|;
DECL|field|returnAction
specifier|protected
name|String
name|returnAction
init|=
literal|null
decl_stmt|;
comment|// string for rule return type(s)<...>
DECL|field|endNode
specifier|protected
name|RuleEndElement
name|endNode
decl_stmt|;
comment|// which node ends this rule?
comment|// Generate literal-testing code for lexer rule?
DECL|field|testLiterals
specifier|protected
name|boolean
name|testLiterals
init|=
literal|false
decl_stmt|;
DECL|field|labeledElements
name|Vector
name|labeledElements
decl_stmt|;
comment|// List of labeled elements found in this rule
comment|// This is a list of AlternativeElement (or subclass)
DECL|field|lock
specifier|protected
name|boolean
index|[]
name|lock
decl_stmt|;
comment|// for analysis; used to avoid infinite loops
comment|// 1..k
DECL|field|cache
specifier|protected
name|Lookahead
name|cache
index|[]
decl_stmt|;
comment|// Each rule can cache it's lookahead computation.
comment|// This cache contains an epsilon
comment|// imaginary token if the FOLLOW is required.  No
comment|// FOLLOW information is cached here.
comment|// The FIRST(rule) is stored in this cache; 1..k
comment|// This set includes FIRST of all alts.
DECL|field|exceptionSpecs
name|Hashtable
name|exceptionSpecs
decl_stmt|;
comment|// table of String-to-ExceptionSpec.
comment|// grammar-settable options
DECL|field|defaultErrorHandler
specifier|protected
name|boolean
name|defaultErrorHandler
init|=
literal|true
decl_stmt|;
DECL|field|ignoreRule
specifier|protected
name|String
name|ignoreRule
init|=
literal|null
decl_stmt|;
comment|/** Construct a named rule. */
DECL|method|RuleBlock (Grammar g, String r)
specifier|public
name|RuleBlock
parameter_list|(
name|Grammar
name|g
parameter_list|,
name|String
name|r
parameter_list|)
block|{
name|super
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|ruleName
operator|=
name|r
expr_stmt|;
name|labeledElements
operator|=
operator|new
name|Vector
argument_list|()
expr_stmt|;
name|cache
operator|=
operator|new
name|Lookahead
index|[
name|g
operator|.
name|maxk
operator|+
literal|1
index|]
expr_stmt|;
name|exceptionSpecs
operator|=
operator|new
name|Hashtable
argument_list|()
expr_stmt|;
name|setAutoGen
argument_list|(
name|g
operator|instanceof
name|ParserGrammar
argument_list|)
expr_stmt|;
block|}
comment|/** Construct a named rule with line number information */
DECL|method|RuleBlock (Grammar g, String r, int line, boolean doAutoGen_)
specifier|public
name|RuleBlock
parameter_list|(
name|Grammar
name|g
parameter_list|,
name|String
name|r
parameter_list|,
name|int
name|line
parameter_list|,
name|boolean
name|doAutoGen_
parameter_list|)
block|{
name|this
argument_list|(
name|g
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|this
operator|.
name|line
operator|=
name|line
expr_stmt|;
name|setAutoGen
argument_list|(
name|doAutoGen_
argument_list|)
expr_stmt|;
block|}
DECL|method|addExceptionSpec (ExceptionSpec ex)
specifier|public
name|void
name|addExceptionSpec
parameter_list|(
name|ExceptionSpec
name|ex
parameter_list|)
block|{
if|if
condition|(
name|findExceptionSpec
argument_list|(
name|ex
operator|.
name|label
argument_list|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ex
operator|.
name|label
operator|!=
literal|null
condition|)
block|{
name|grammar
operator|.
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Rule '"
operator|+
name|ruleName
operator|+
literal|"' already has an exception handler for label: "
operator|+
name|ex
operator|.
name|label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|grammar
operator|.
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Rule '"
operator|+
name|ruleName
operator|+
literal|"' already has an exception handler"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|exceptionSpecs
operator|.
name|put
argument_list|(
operator|(
name|ex
operator|.
name|label
operator|==
literal|null
condition|?
literal|""
else|:
name|ex
operator|.
name|label
operator|.
name|getText
argument_list|()
operator|)
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|findExceptionSpec (Token label)
specifier|public
name|ExceptionSpec
name|findExceptionSpec
parameter_list|(
name|Token
name|label
parameter_list|)
block|{
return|return
operator|(
name|ExceptionSpec
operator|)
name|exceptionSpecs
operator|.
name|get
argument_list|(
name|label
operator|==
literal|null
condition|?
literal|""
else|:
name|label
operator|.
name|getText
argument_list|()
argument_list|)
return|;
block|}
DECL|method|findExceptionSpec (String label)
specifier|public
name|ExceptionSpec
name|findExceptionSpec
parameter_list|(
name|String
name|label
parameter_list|)
block|{
return|return
operator|(
name|ExceptionSpec
operator|)
name|exceptionSpecs
operator|.
name|get
argument_list|(
name|label
operator|==
literal|null
condition|?
literal|""
else|:
name|label
argument_list|)
return|;
block|}
DECL|method|generate ()
specifier|public
name|void
name|generate
parameter_list|()
block|{
name|grammar
operator|.
name|generator
operator|.
name|gen
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|getDefaultErrorHandler ()
specifier|public
name|boolean
name|getDefaultErrorHandler
parameter_list|()
block|{
return|return
name|defaultErrorHandler
return|;
block|}
DECL|method|getEndElement ()
specifier|public
name|RuleEndElement
name|getEndElement
parameter_list|()
block|{
return|return
name|endNode
return|;
block|}
DECL|method|getIgnoreRule ()
specifier|public
name|String
name|getIgnoreRule
parameter_list|()
block|{
return|return
name|ignoreRule
return|;
block|}
DECL|method|getRuleName ()
specifier|public
name|String
name|getRuleName
parameter_list|()
block|{
return|return
name|ruleName
return|;
block|}
DECL|method|getTestLiterals ()
specifier|public
name|boolean
name|getTestLiterals
parameter_list|()
block|{
return|return
name|testLiterals
return|;
block|}
DECL|method|isLexerAutoGenRule ()
specifier|public
name|boolean
name|isLexerAutoGenRule
parameter_list|()
block|{
return|return
name|ruleName
operator|.
name|equals
argument_list|(
literal|"nextToken"
argument_list|)
return|;
block|}
DECL|method|look (int k)
specifier|public
name|Lookahead
name|look
parameter_list|(
name|int
name|k
parameter_list|)
block|{
return|return
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|look
argument_list|(
name|k
argument_list|,
name|this
argument_list|)
return|;
block|}
DECL|method|prepareForAnalysis ()
specifier|public
name|void
name|prepareForAnalysis
parameter_list|()
block|{
name|super
operator|.
name|prepareForAnalysis
argument_list|()
expr_stmt|;
name|lock
operator|=
operator|new
name|boolean
index|[
name|grammar
operator|.
name|maxk
operator|+
literal|1
index|]
expr_stmt|;
block|}
comment|// rule option values
DECL|method|setDefaultErrorHandler (boolean value)
specifier|public
name|void
name|setDefaultErrorHandler
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|defaultErrorHandler
operator|=
name|value
expr_stmt|;
block|}
DECL|method|setEndElement (RuleEndElement re)
specifier|public
name|void
name|setEndElement
parameter_list|(
name|RuleEndElement
name|re
parameter_list|)
block|{
name|endNode
operator|=
name|re
expr_stmt|;
block|}
DECL|method|setOption (Token key, Token value)
specifier|public
name|void
name|setOption
parameter_list|(
name|Token
name|key
parameter_list|,
name|Token
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"defaultErrorHandler"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|defaultErrorHandler
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|defaultErrorHandler
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|grammar
operator|.
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Value for defaultErrorHandler must be true or false"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|key
operator|.
name|getLine
argument_list|()
argument_list|,
name|key
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"testLiterals"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
condition|)
block|{
name|grammar
operator|.
name|antlrTool
operator|.
name|error
argument_list|(
literal|"testLiterals option only valid for lexer rules"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|key
operator|.
name|getLine
argument_list|()
argument_list|,
name|key
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|testLiterals
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|testLiterals
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|grammar
operator|.
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Value for testLiterals must be true or false"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|key
operator|.
name|getLine
argument_list|()
argument_list|,
name|key
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"ignore"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
condition|)
block|{
name|grammar
operator|.
name|antlrTool
operator|.
name|error
argument_list|(
literal|"ignore option only valid for lexer rules"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|key
operator|.
name|getLine
argument_list|()
argument_list|,
name|key
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ignoreRule
operator|=
name|value
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"paraphrase"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
condition|)
block|{
name|grammar
operator|.
name|antlrTool
operator|.
name|error
argument_list|(
literal|"paraphrase option only valid for lexer rules"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|key
operator|.
name|getLine
argument_list|()
argument_list|,
name|key
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// find token def associated with this rule
name|TokenSymbol
name|ts
init|=
name|grammar
operator|.
name|tokenManager
operator|.
name|getTokenSymbol
argument_list|(
name|ruleName
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|==
literal|null
condition|)
block|{
name|grammar
operator|.
name|antlrTool
operator|.
name|panic
argument_list|(
literal|"cannot find token associated with rule "
operator|+
name|ruleName
argument_list|)
expr_stmt|;
block|}
name|ts
operator|.
name|setParaphrase
argument_list|(
name|value
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"generateAmbigWarnings"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|generateAmbigWarnings
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|generateAmbigWarnings
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|grammar
operator|.
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Value for generateAmbigWarnings must be true or false"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|key
operator|.
name|getLine
argument_list|()
argument_list|,
name|key
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|grammar
operator|.
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Invalid rule option: "
operator|+
name|key
operator|.
name|getText
argument_list|()
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|key
operator|.
name|getLine
argument_list|()
argument_list|,
name|key
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|s
init|=
literal|" FOLLOW={"
decl_stmt|;
name|Lookahead
name|cache
index|[]
init|=
name|endNode
operator|.
name|cache
decl_stmt|;
name|int
name|k
init|=
name|grammar
operator|.
name|maxk
decl_stmt|;
name|boolean
name|allNull
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<=
name|k
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|cache
index|[
name|j
index|]
operator|==
literal|null
condition|)
continue|continue;
name|s
operator|+=
name|cache
index|[
name|j
index|]
operator|.
name|toString
argument_list|(
literal|","
argument_list|,
name|grammar
operator|.
name|tokenManager
operator|.
name|getVocabulary
argument_list|()
argument_list|)
expr_stmt|;
name|allNull
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|k
operator|&&
name|cache
index|[
name|j
operator|+
literal|1
index|]
operator|!=
literal|null
condition|)
name|s
operator|+=
literal|";"
expr_stmt|;
block|}
name|s
operator|+=
literal|"}"
expr_stmt|;
if|if
condition|(
name|allNull
condition|)
name|s
operator|=
literal|""
expr_stmt|;
return|return
name|ruleName
operator|+
literal|": "
operator|+
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|" ;"
operator|+
name|s
return|;
block|}
block|}
end_class

end_unit

