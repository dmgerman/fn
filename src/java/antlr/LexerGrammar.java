begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/RIGHTS.html  *  * $Id$  */
end_comment

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|Vector
import|;
end_import

begin_comment
comment|/** Lexer-specific grammar subclass */
end_comment

begin_class
DECL|class|LexerGrammar
class|class
name|LexerGrammar
extends|extends
name|Grammar
block|{
comment|// character set used by lexer
DECL|field|charVocabulary
specifier|protected
name|BitSet
name|charVocabulary
decl_stmt|;
comment|// true if the lexer generates literal testing code for nextToken
DECL|field|testLiterals
specifier|protected
name|boolean
name|testLiterals
init|=
literal|true
decl_stmt|;
comment|// true if the lexer generates case-sensitive LA(k) testing
DECL|field|caseSensitiveLiterals
specifier|protected
name|boolean
name|caseSensitiveLiterals
init|=
literal|true
decl_stmt|;
comment|/** true if the lexer generates case-sensitive literals testing */
DECL|field|caseSensitive
specifier|protected
name|boolean
name|caseSensitive
init|=
literal|true
decl_stmt|;
comment|/** true if lexer is to ignore all unrecognized tokens */
DECL|field|filterMode
specifier|protected
name|boolean
name|filterMode
init|=
literal|false
decl_stmt|;
comment|/** if filterMode is true, then filterRule can indicate an optional 	 *  rule to use as the scarf language.  If null, programmer used 	 *  plain "filter=true" not "filter=rule". 	 */
DECL|field|filterRule
specifier|protected
name|String
name|filterRule
init|=
literal|null
decl_stmt|;
DECL|method|LexerGrammar (String className_, Tool tool_, String superClass)
name|LexerGrammar
parameter_list|(
name|String
name|className_
parameter_list|,
name|Tool
name|tool_
parameter_list|,
name|String
name|superClass
parameter_list|)
block|{
name|super
argument_list|(
name|className_
argument_list|,
name|tool_
argument_list|,
name|superClass
argument_list|)
expr_stmt|;
name|charVocabulary
operator|=
operator|new
name|BitSet
argument_list|()
expr_stmt|;
comment|// Lexer usually has no default error handling
name|defaultErrorHandler
operator|=
literal|false
expr_stmt|;
block|}
comment|/** Top-level call to generate the code	 */
DECL|method|generate ()
specifier|public
name|void
name|generate
parameter_list|()
throws|throws
name|IOException
block|{
name|generator
operator|.
name|gen
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|getSuperClass ()
specifier|public
name|String
name|getSuperClass
parameter_list|()
block|{
comment|// If debugging, use debugger version of scanner
if|if
condition|(
name|debuggingOutput
condition|)
return|return
literal|"debug.DebuggingCharScanner"
return|;
return|return
literal|"CharScanner"
return|;
block|}
comment|// Get the testLiterals option value
DECL|method|getTestLiterals ()
specifier|public
name|boolean
name|getTestLiterals
parameter_list|()
block|{
return|return
name|testLiterals
return|;
block|}
comment|/**Process command line arguments. 	 * -trace			have all rules call traceIn/traceOut 	 * -traceLexer		have lexical rules call traceIn/traceOut 	 * -debug			generate debugging output for parser debugger 	 */
DECL|method|processArguments (String[] args)
specifier|public
name|void
name|processArguments
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-trace"
argument_list|)
condition|)
block|{
name|traceRules
operator|=
literal|true
expr_stmt|;
name|Tool
operator|.
name|setArgOK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-traceLexer"
argument_list|)
condition|)
block|{
name|traceRules
operator|=
literal|true
expr_stmt|;
name|Tool
operator|.
name|setArgOK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-debug"
argument_list|)
condition|)
block|{
name|debuggingOutput
operator|=
literal|true
expr_stmt|;
name|Tool
operator|.
name|setArgOK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Set the character vocabulary used by the lexer */
DECL|method|setCharVocabulary (BitSet b)
specifier|public
name|void
name|setCharVocabulary
parameter_list|(
name|BitSet
name|b
parameter_list|)
block|{
name|charVocabulary
operator|=
name|b
expr_stmt|;
block|}
comment|/** Set lexer options */
DECL|method|setOption (String key, Token value)
specifier|public
name|boolean
name|setOption
parameter_list|(
name|String
name|key
parameter_list|,
name|Token
name|value
parameter_list|)
block|{
name|String
name|s
init|=
name|value
operator|.
name|getText
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"buildAST"
argument_list|)
condition|)
block|{
name|tool
operator|.
name|warning
argument_list|(
literal|"buildAST option is not valid for lexer"
argument_list|,
name|getFilename
argument_list|()
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"testLiterals"
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|testLiterals
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|testLiterals
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|tool
operator|.
name|warning
argument_list|(
literal|"testLiterals option must be true or false"
argument_list|,
name|getFilename
argument_list|()
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"interactive"
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|interactive
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|interactive
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"interactive option must be true or false"
argument_list|,
name|getFilename
argument_list|()
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"caseSensitive"
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|caseSensitive
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|caseSensitive
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|tool
operator|.
name|warning
argument_list|(
literal|"caseSensitive option must be true or false"
argument_list|,
name|getFilename
argument_list|()
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"caseSensitiveLiterals"
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|caseSensitiveLiterals
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|caseSensitiveLiterals
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|tool
operator|.
name|warning
argument_list|(
literal|"caseSensitiveLiterals option must be true or false"
argument_list|,
name|getFilename
argument_list|()
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"filter"
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|filterMode
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|filterMode
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|getType
argument_list|()
operator|==
name|ANTLRTokenTypes
operator|.
name|TOKEN_REF
condition|)
block|{
name|filterMode
operator|=
literal|true
expr_stmt|;
name|filterRule
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|tool
operator|.
name|warning
argument_list|(
literal|"filter option must be true, false, or a lexer rule name"
argument_list|,
name|getFilename
argument_list|()
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"longestPossible"
argument_list|)
condition|)
block|{
name|tool
operator|.
name|warning
argument_list|(
literal|"longestPossible option has been deprecated; ignoring it..."
argument_list|,
name|getFilename
argument_list|()
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|super
operator|.
name|setOption
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|tool
operator|.
name|error
argument_list|(
literal|"Invalid option: "
operator|+
name|key
argument_list|,
name|getFilename
argument_list|()
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

