begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr.debug
package|package
name|antlr
operator|.
name|debug
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/license.html  */
end_comment

begin_import
import|import
name|antlr
operator|.
name|*
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_comment
comment|/** Override the standard matching and rule entry/exit routines  *  to build parse trees.  This class is useful for 2.7.3 where  *  you can specify a superclass like  *  *   class TinyCParser extends Parser(ParseTreeDebugParser);  */
end_comment

begin_class
DECL|class|ParseTreeDebugParser
specifier|public
class|class
name|ParseTreeDebugParser
extends|extends
name|LLkParser
block|{
comment|/** Each new rule invocation must have it's own subtree.  Tokens 	 *  are added to the current root so we must have a stack of subtree roots. 	 */
DECL|field|currentParseTreeRoot
specifier|protected
name|Stack
name|currentParseTreeRoot
init|=
operator|new
name|Stack
argument_list|()
decl_stmt|;
comment|/** Track most recently created parse subtree so that when parsing 	 *  is finished, we can get to the root. 	 */
DECL|field|mostRecentParseTreeRoot
specifier|protected
name|ParseTreeRule
name|mostRecentParseTreeRoot
init|=
literal|null
decl_stmt|;
comment|/** For every rule replacement with a production, we bump up count. */
DECL|field|numberOfDerivationSteps
specifier|protected
name|int
name|numberOfDerivationSteps
init|=
literal|1
decl_stmt|;
comment|// n replacements plus step 0
DECL|method|ParseTreeDebugParser (int k_)
specifier|public
name|ParseTreeDebugParser
parameter_list|(
name|int
name|k_
parameter_list|)
block|{
name|super
argument_list|(
name|k_
argument_list|)
expr_stmt|;
block|}
DECL|method|ParseTreeDebugParser (ParserSharedInputState state, int k_)
specifier|public
name|ParseTreeDebugParser
parameter_list|(
name|ParserSharedInputState
name|state
parameter_list|,
name|int
name|k_
parameter_list|)
block|{
name|super
argument_list|(
name|state
argument_list|,
name|k_
argument_list|)
expr_stmt|;
block|}
DECL|method|ParseTreeDebugParser (TokenBuffer tokenBuf, int k_)
specifier|public
name|ParseTreeDebugParser
parameter_list|(
name|TokenBuffer
name|tokenBuf
parameter_list|,
name|int
name|k_
parameter_list|)
block|{
name|super
argument_list|(
name|tokenBuf
argument_list|,
name|k_
argument_list|)
expr_stmt|;
block|}
DECL|method|ParseTreeDebugParser (TokenStream lexer, int k_)
specifier|public
name|ParseTreeDebugParser
parameter_list|(
name|TokenStream
name|lexer
parameter_list|,
name|int
name|k_
parameter_list|)
block|{
name|super
argument_list|(
name|lexer
argument_list|,
name|k_
argument_list|)
expr_stmt|;
block|}
DECL|method|getParseTree ()
specifier|public
name|ParseTree
name|getParseTree
parameter_list|()
block|{
return|return
name|mostRecentParseTreeRoot
return|;
block|}
DECL|method|getNumberOfDerivationSteps ()
specifier|public
name|int
name|getNumberOfDerivationSteps
parameter_list|()
block|{
return|return
name|numberOfDerivationSteps
return|;
block|}
DECL|method|match (int i)
specifier|public
name|void
name|match
parameter_list|(
name|int
name|i
parameter_list|)
throws|throws
name|MismatchedTokenException
throws|,
name|TokenStreamException
block|{
name|addCurrentTokenToParseTree
argument_list|()
expr_stmt|;
name|super
operator|.
name|match
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
DECL|method|match (BitSet bitSet)
specifier|public
name|void
name|match
parameter_list|(
name|BitSet
name|bitSet
parameter_list|)
throws|throws
name|MismatchedTokenException
throws|,
name|TokenStreamException
block|{
name|addCurrentTokenToParseTree
argument_list|()
expr_stmt|;
name|super
operator|.
name|match
argument_list|(
name|bitSet
argument_list|)
expr_stmt|;
block|}
DECL|method|matchNot (int i)
specifier|public
name|void
name|matchNot
parameter_list|(
name|int
name|i
parameter_list|)
throws|throws
name|MismatchedTokenException
throws|,
name|TokenStreamException
block|{
name|addCurrentTokenToParseTree
argument_list|()
expr_stmt|;
name|super
operator|.
name|matchNot
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/** This adds LT(1) to the current parse subtree.  Note that the match() 	 *  routines add the node before checking for correct match.  This means 	 *  that, upon mismatched token, there will a token node in the tree 	 *  corresponding to where that token was expected.  For no viable 	 *  alternative errors, no node will be in the tree as nothing was 	 *  matched() (the lookahead failed to predict an alternative). 	 */
DECL|method|addCurrentTokenToParseTree ()
specifier|protected
name|void
name|addCurrentTokenToParseTree
parameter_list|()
throws|throws
name|TokenStreamException
block|{
if|if
condition|(
name|inputState
operator|.
name|guessing
operator|>
literal|0
condition|)
block|{
return|return;
block|}
name|ParseTreeRule
name|root
init|=
operator|(
name|ParseTreeRule
operator|)
name|currentParseTreeRoot
operator|.
name|peek
argument_list|()
decl_stmt|;
name|ParseTreeToken
name|tokenNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|LA
argument_list|(
literal|1
argument_list|)
operator|==
name|Token
operator|.
name|EOF_TYPE
condition|)
block|{
name|tokenNode
operator|=
operator|new
name|ParseTreeToken
argument_list|(
operator|new
name|antlr
operator|.
name|CommonToken
argument_list|(
literal|"EOF"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tokenNode
operator|=
operator|new
name|ParseTreeToken
argument_list|(
name|LT
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|root
operator|.
name|addChild
argument_list|(
name|tokenNode
argument_list|)
expr_stmt|;
block|}
comment|/** Create a rule node, add to current tree, and make it current root */
DECL|method|traceIn (String s)
specifier|public
name|void
name|traceIn
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|TokenStreamException
block|{
if|if
condition|(
name|inputState
operator|.
name|guessing
operator|>
literal|0
condition|)
block|{
return|return;
block|}
name|ParseTreeRule
name|subRoot
init|=
operator|new
name|ParseTreeRule
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentParseTreeRoot
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|ParseTreeRule
name|oldRoot
init|=
operator|(
name|ParseTreeRule
operator|)
name|currentParseTreeRoot
operator|.
name|peek
argument_list|()
decl_stmt|;
name|oldRoot
operator|.
name|addChild
argument_list|(
name|subRoot
argument_list|)
expr_stmt|;
block|}
name|currentParseTreeRoot
operator|.
name|push
argument_list|(
name|subRoot
argument_list|)
expr_stmt|;
name|numberOfDerivationSteps
operator|++
expr_stmt|;
block|}
comment|/** Pop current root; back to adding to old root */
DECL|method|traceOut (String s)
specifier|public
name|void
name|traceOut
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|TokenStreamException
block|{
if|if
condition|(
name|inputState
operator|.
name|guessing
operator|>
literal|0
condition|)
block|{
return|return;
block|}
name|mostRecentParseTreeRoot
operator|=
operator|(
name|ParseTreeRule
operator|)
name|currentParseTreeRoot
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

