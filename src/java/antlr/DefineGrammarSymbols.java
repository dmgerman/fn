begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/license.html  *  * $Id$  */
end_comment

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|BitSet
import|;
end_import

begin_comment
comment|/**DefineGrammarSymbols is a behavior for the ANTLRParser that adds all  * the token and rule symbols to the grammar symbol table.  *  * Token types are assigned to token symbols in this class also.  * The token type for a token is done in the order seen (lexically).  */
end_comment

begin_class
DECL|class|DefineGrammarSymbols
specifier|public
class|class
name|DefineGrammarSymbols
implements|implements
name|ANTLRGrammarParseBehavior
block|{
comment|// Contains all of the defined parser and lexer Grammar's indexed by name
DECL|field|grammars
specifier|protected
name|Hashtable
name|grammars
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
comment|// Contains all the TokenManagers indexed by name
DECL|field|tokenManagers
specifier|protected
name|Hashtable
name|tokenManagers
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
comment|// Current grammar (parser or lexer)
DECL|field|grammar
specifier|protected
name|Grammar
name|grammar
decl_stmt|;
comment|// The tool under which this is invoked
DECL|field|tool
specifier|protected
name|Tool
name|tool
decl_stmt|;
comment|// The grammar analyzer object
DECL|field|analyzer
name|LLkAnalyzer
name|analyzer
decl_stmt|;
comment|// The command-line arguments passed to the tool.
comment|// This allows each grammar to parse the arguments as it is created
DECL|field|args
name|String
index|[]
name|args
decl_stmt|;
comment|// Name for default token manager does not match any valid name
DECL|field|DEFAULT_TOKENMANAGER_NAME
specifier|static
specifier|final
name|String
name|DEFAULT_TOKENMANAGER_NAME
init|=
literal|"*default"
decl_stmt|;
comment|// Header actions apply to all parsers unless redefined
comment|// Contains all of the header actions indexed by name
DECL|field|headerActions
specifier|protected
name|Hashtable
name|headerActions
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
comment|// Place where preamble is stored until a grammar is defined
DECL|field|thePreambleAction
name|Token
name|thePreambleAction
init|=
operator|new
name|CommonToken
argument_list|(
name|Token
operator|.
name|INVALID_TYPE
argument_list|,
literal|""
argument_list|)
decl_stmt|;
comment|// init to empty token
comment|// The target language
DECL|field|language
name|String
name|language
init|=
literal|"Java"
decl_stmt|;
DECL|field|numLexers
specifier|protected
name|int
name|numLexers
init|=
literal|0
decl_stmt|;
DECL|field|numParsers
specifier|protected
name|int
name|numParsers
init|=
literal|0
decl_stmt|;
DECL|field|numTreeParsers
specifier|protected
name|int
name|numTreeParsers
init|=
literal|0
decl_stmt|;
DECL|method|DefineGrammarSymbols (Tool tool_, String[] args_, LLkAnalyzer analyzer_)
specifier|public
name|DefineGrammarSymbols
parameter_list|(
name|Tool
name|tool_
parameter_list|,
name|String
index|[]
name|args_
parameter_list|,
name|LLkAnalyzer
name|analyzer_
parameter_list|)
block|{
name|tool
operator|=
name|tool_
expr_stmt|;
name|args
operator|=
name|args_
expr_stmt|;
name|analyzer
operator|=
name|analyzer_
expr_stmt|;
block|}
DECL|method|_refStringLiteral (Token lit, Token label, int autoGenType, boolean lastInRule)
specifier|public
name|void
name|_refStringLiteral
parameter_list|(
name|Token
name|lit
parameter_list|,
name|Token
name|label
parameter_list|,
name|int
name|autoGenType
parameter_list|,
name|boolean
name|lastInRule
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
condition|)
block|{
comment|// String literals are treated like tokens except by the lexer
name|String
name|str
init|=
name|lit
operator|.
name|getText
argument_list|()
decl_stmt|;
if|if
condition|(
name|grammar
operator|.
name|tokenManager
operator|.
name|getTokenSymbol
argument_list|(
name|str
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// string symbol is already defined
return|return;
block|}
name|StringLiteralSymbol
name|sl
init|=
operator|new
name|StringLiteralSymbol
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|int
name|tt
init|=
name|grammar
operator|.
name|tokenManager
operator|.
name|nextTokenType
argument_list|()
decl_stmt|;
name|sl
operator|.
name|setTokenType
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|grammar
operator|.
name|tokenManager
operator|.
name|define
argument_list|(
name|sl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Reference a token */
DECL|method|_refToken (Token assignId, Token t, Token label, Token args, boolean inverted, int autoGenType, boolean lastInRule)
specifier|public
name|void
name|_refToken
parameter_list|(
name|Token
name|assignId
parameter_list|,
name|Token
name|t
parameter_list|,
name|Token
name|label
parameter_list|,
name|Token
name|args
parameter_list|,
name|boolean
name|inverted
parameter_list|,
name|int
name|autoGenType
parameter_list|,
name|boolean
name|lastInRule
parameter_list|)
block|{
name|String
name|id
init|=
name|t
operator|.
name|getText
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|grammar
operator|.
name|tokenManager
operator|.
name|tokenDefined
argument_list|(
name|id
argument_list|)
condition|)
block|{
comment|/*             // RK: dish out a warning if the token was not defined before.             tool.warning("Token '" + id + "' defined outside tokens section",                          tool.grammarFile, t.getLine(), t.getColumn());             */
name|int
name|tt
init|=
name|grammar
operator|.
name|tokenManager
operator|.
name|nextTokenType
argument_list|()
decl_stmt|;
name|TokenSymbol
name|ts
init|=
operator|new
name|TokenSymbol
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|ts
operator|.
name|setTokenType
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|grammar
operator|.
name|tokenManager
operator|.
name|define
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Abort the processing of a grammar due to syntax errors */
DECL|method|abortGrammar ()
specifier|public
name|void
name|abortGrammar
parameter_list|()
block|{
if|if
condition|(
name|grammar
operator|!=
literal|null
operator|&&
name|grammar
operator|.
name|getClassName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|grammars
operator|.
name|remove
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|grammar
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|beginAlt (boolean doAST_)
specifier|public
name|void
name|beginAlt
parameter_list|(
name|boolean
name|doAST_
parameter_list|)
block|{     }
DECL|method|beginChildList ()
specifier|public
name|void
name|beginChildList
parameter_list|()
block|{     }
comment|// Exception handling
DECL|method|beginExceptionGroup ()
specifier|public
name|void
name|beginExceptionGroup
parameter_list|()
block|{     }
DECL|method|beginExceptionSpec (Token label)
specifier|public
name|void
name|beginExceptionSpec
parameter_list|(
name|Token
name|label
parameter_list|)
block|{     }
DECL|method|beginSubRule (Token label, Token start, boolean not)
specifier|public
name|void
name|beginSubRule
parameter_list|(
name|Token
name|label
parameter_list|,
name|Token
name|start
parameter_list|,
name|boolean
name|not
parameter_list|)
block|{     }
DECL|method|beginTree (Token tok)
specifier|public
name|void
name|beginTree
parameter_list|(
name|Token
name|tok
parameter_list|)
throws|throws
name|SemanticException
block|{     }
comment|/** Define a lexer or parser rule */
DECL|method|defineRuleName (Token r, String access, boolean ruleAutoGen, String docComment)
specifier|public
name|void
name|defineRuleName
parameter_list|(
name|Token
name|r
parameter_list|,
name|String
name|access
parameter_list|,
name|boolean
name|ruleAutoGen
parameter_list|,
name|String
name|docComment
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|id
init|=
name|r
operator|.
name|getText
argument_list|()
decl_stmt|;
comment|//		if ( Character.isUpperCase(id.charAt(0)) ) {
if|if
condition|(
name|r
operator|.
name|type
operator|==
name|ANTLRTokenTypes
operator|.
name|TOKEN_REF
condition|)
block|{
comment|// lexer rule
name|id
operator|=
name|CodeGenerator
operator|.
name|encodeLexerRuleName
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|// make sure we define it as token identifier also
if|if
condition|(
operator|!
name|grammar
operator|.
name|tokenManager
operator|.
name|tokenDefined
argument_list|(
name|r
operator|.
name|getText
argument_list|()
argument_list|)
condition|)
block|{
name|int
name|tt
init|=
name|grammar
operator|.
name|tokenManager
operator|.
name|nextTokenType
argument_list|()
decl_stmt|;
name|TokenSymbol
name|ts
init|=
operator|new
name|TokenSymbol
argument_list|(
name|r
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|ts
operator|.
name|setTokenType
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|grammar
operator|.
name|tokenManager
operator|.
name|define
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
name|RuleSymbol
name|rs
decl_stmt|;
if|if
condition|(
name|grammar
operator|.
name|isDefined
argument_list|(
name|id
argument_list|)
condition|)
block|{
comment|// symbol seen before?
name|rs
operator|=
operator|(
name|RuleSymbol
operator|)
name|grammar
operator|.
name|getSymbol
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|// rule just referenced or has it been defined yet?
if|if
condition|(
name|rs
operator|.
name|isDefined
argument_list|()
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"redefinition of rule "
operator|+
name|id
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|r
operator|.
name|getLine
argument_list|()
argument_list|,
name|r
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rs
operator|=
operator|new
name|RuleSymbol
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|grammar
operator|.
name|define
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
name|rs
operator|.
name|setDefined
argument_list|()
expr_stmt|;
name|rs
operator|.
name|access
operator|=
name|access
expr_stmt|;
name|rs
operator|.
name|comment
operator|=
name|docComment
expr_stmt|;
block|}
comment|/** Define a token from tokens {...}.      *  Must be label and literal or just label or just a literal.      */
DECL|method|defineToken (Token tokname, Token tokliteral)
specifier|public
name|void
name|defineToken
parameter_list|(
name|Token
name|tokname
parameter_list|,
name|Token
name|tokliteral
parameter_list|)
block|{
name|String
name|name
init|=
literal|null
decl_stmt|;
name|String
name|literal
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|tokname
operator|!=
literal|null
condition|)
block|{
name|name
operator|=
name|tokname
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tokliteral
operator|!=
literal|null
condition|)
block|{
name|literal
operator|=
name|tokliteral
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
comment|// System.out.println("defining " + name + " with literal " + literal);
comment|//
if|if
condition|(
name|literal
operator|!=
literal|null
condition|)
block|{
name|StringLiteralSymbol
name|sl
init|=
operator|(
name|StringLiteralSymbol
operator|)
name|grammar
operator|.
name|tokenManager
operator|.
name|getTokenSymbol
argument_list|(
name|literal
argument_list|)
decl_stmt|;
if|if
condition|(
name|sl
operator|!=
literal|null
condition|)
block|{
comment|// This literal is known already.
comment|// If the literal has no label already, but we can provide
comment|// one here, then no problem, just map the label to the literal
comment|// and don't change anything else.
comment|// Otherwise, labels conflict: error.
if|if
condition|(
name|name
operator|==
literal|null
operator|||
name|sl
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|tool
operator|.
name|warning
argument_list|(
literal|"Redefinition of literal in tokens {...}: "
operator|+
name|literal
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|tokliteral
operator|.
name|getLine
argument_list|()
argument_list|,
name|tokliteral
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
comment|// The literal had no label, but new def does.  Set it.
name|sl
operator|.
name|setLabel
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|// Also, map the label to the literal.
name|grammar
operator|.
name|tokenManager
operator|.
name|mapToTokenSymbol
argument_list|(
name|name
argument_list|,
name|sl
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if they provide a name/label and that name/label already
comment|// exists, just hook this literal onto old token.
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
name|TokenSymbol
name|ts
init|=
operator|(
name|TokenSymbol
operator|)
name|grammar
operator|.
name|tokenManager
operator|.
name|getTokenSymbol
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|!=
literal|null
condition|)
block|{
comment|// watch out that the label is not more than just a token.
comment|// If it already has a literal attached, then: conflict.
if|if
condition|(
name|ts
operator|instanceof
name|StringLiteralSymbol
condition|)
block|{
name|tool
operator|.
name|warning
argument_list|(
literal|"Redefinition of token in tokens {...}: "
operator|+
name|name
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|tokliteral
operator|.
name|getLine
argument_list|()
argument_list|,
name|tokliteral
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// a simple token symbol such as DECL is defined
comment|// must convert it to a StringLiteralSymbol with a
comment|// label by co-opting token type and killing old
comment|// TokenSymbol.  Kill mapping and entry in vector
comment|// of token manager.
comment|// First, claim token type.
name|int
name|ttype
init|=
name|ts
operator|.
name|getTokenType
argument_list|()
decl_stmt|;
comment|// now, create string literal with label
name|sl
operator|=
operator|new
name|StringLiteralSymbol
argument_list|(
name|literal
argument_list|)
expr_stmt|;
name|sl
operator|.
name|setTokenType
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
name|sl
operator|.
name|setLabel
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|// redefine this critter as a string literal
name|grammar
operator|.
name|tokenManager
operator|.
name|define
argument_list|(
name|sl
argument_list|)
expr_stmt|;
comment|// make sure the label can be used also.
name|grammar
operator|.
name|tokenManager
operator|.
name|mapToTokenSymbol
argument_list|(
name|name
argument_list|,
name|sl
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// here, literal was labeled but not by a known token symbol.
block|}
name|sl
operator|=
operator|new
name|StringLiteralSymbol
argument_list|(
name|literal
argument_list|)
expr_stmt|;
name|int
name|tt
init|=
name|grammar
operator|.
name|tokenManager
operator|.
name|nextTokenType
argument_list|()
decl_stmt|;
name|sl
operator|.
name|setTokenType
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|sl
operator|.
name|setLabel
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|grammar
operator|.
name|tokenManager
operator|.
name|define
argument_list|(
name|sl
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
comment|// make the label point at token symbol too
name|grammar
operator|.
name|tokenManager
operator|.
name|mapToTokenSymbol
argument_list|(
name|name
argument_list|,
name|sl
argument_list|)
expr_stmt|;
block|}
block|}
comment|// create a token in the token manager not a literal
else|else
block|{
if|if
condition|(
name|grammar
operator|.
name|tokenManager
operator|.
name|tokenDefined
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|tool
operator|.
name|warning
argument_list|(
literal|"Redefinition of token in tokens {...}: "
operator|+
name|name
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|tokname
operator|.
name|getLine
argument_list|()
argument_list|,
name|tokname
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|tt
init|=
name|grammar
operator|.
name|tokenManager
operator|.
name|nextTokenType
argument_list|()
decl_stmt|;
name|TokenSymbol
name|ts
init|=
operator|new
name|TokenSymbol
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|ts
operator|.
name|setTokenType
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|grammar
operator|.
name|tokenManager
operator|.
name|define
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|endAlt ()
specifier|public
name|void
name|endAlt
parameter_list|()
block|{     }
DECL|method|endChildList ()
specifier|public
name|void
name|endChildList
parameter_list|()
block|{     }
DECL|method|endExceptionGroup ()
specifier|public
name|void
name|endExceptionGroup
parameter_list|()
block|{     }
DECL|method|endExceptionSpec ()
specifier|public
name|void
name|endExceptionSpec
parameter_list|()
block|{     }
DECL|method|endGrammar ()
specifier|public
name|void
name|endGrammar
parameter_list|()
block|{     }
comment|/** Called after the optional options section, to compensate for      * options that may not have been set.      * This method is bigger than it needs to be, but is much more      * clear if I delineate all the cases.      */
DECL|method|endOptions ()
specifier|public
name|void
name|endOptions
parameter_list|()
block|{
comment|// NO VOCAB OPTIONS
if|if
condition|(
name|grammar
operator|.
name|exportVocab
operator|==
literal|null
operator|&&
name|grammar
operator|.
name|importVocab
operator|==
literal|null
condition|)
block|{
name|grammar
operator|.
name|exportVocab
operator|=
name|grammar
operator|.
name|getClassName
argument_list|()
expr_stmt|;
comment|// Can we get initial vocab from default shared vocab?
if|if
condition|(
name|tokenManagers
operator|.
name|containsKey
argument_list|(
name|DEFAULT_TOKENMANAGER_NAME
argument_list|)
condition|)
block|{
comment|// Use the already-defined token manager
name|grammar
operator|.
name|exportVocab
operator|=
name|DEFAULT_TOKENMANAGER_NAME
expr_stmt|;
name|TokenManager
name|tm
init|=
operator|(
name|TokenManager
operator|)
name|tokenManagers
operator|.
name|get
argument_list|(
name|DEFAULT_TOKENMANAGER_NAME
argument_list|)
decl_stmt|;
comment|// System.out.println("No tokenVocabulary for '" + grammar.getClassName() + "', using default '" + tm.getName() + "'");
name|grammar
operator|.
name|setTokenManager
argument_list|(
name|tm
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// no shared vocab for file, make new one
comment|// System.out.println("No exportVocab for '" + grammar.getClassName() + "', creating default '" + grammar.exportVocab + "'");
name|TokenManager
name|tm
init|=
operator|new
name|SimpleTokenManager
argument_list|(
name|grammar
operator|.
name|exportVocab
argument_list|,
name|tool
argument_list|)
decl_stmt|;
name|grammar
operator|.
name|setTokenManager
argument_list|(
name|tm
argument_list|)
expr_stmt|;
comment|// Add the token manager to the list of token managers
name|tokenManagers
operator|.
name|put
argument_list|(
name|grammar
operator|.
name|exportVocab
argument_list|,
name|tm
argument_list|)
expr_stmt|;
comment|// no default vocab, so make this the default vocab
name|tokenManagers
operator|.
name|put
argument_list|(
name|DEFAULT_TOKENMANAGER_NAME
argument_list|,
name|tm
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// NO OUTPUT, BUT HAS INPUT VOCAB
if|if
condition|(
name|grammar
operator|.
name|exportVocab
operator|==
literal|null
operator|&&
name|grammar
operator|.
name|importVocab
operator|!=
literal|null
condition|)
block|{
name|grammar
operator|.
name|exportVocab
operator|=
name|grammar
operator|.
name|getClassName
argument_list|()
expr_stmt|;
comment|// first make sure input!=output
if|if
condition|(
name|grammar
operator|.
name|importVocab
operator|.
name|equals
argument_list|(
name|grammar
operator|.
name|exportVocab
argument_list|)
condition|)
block|{
name|tool
operator|.
name|warning
argument_list|(
literal|"Grammar "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|" cannot have importVocab same as default output vocab (grammar name); ignored."
argument_list|)
expr_stmt|;
comment|// kill importVocab option and try again: use default vocab
name|grammar
operator|.
name|importVocab
operator|=
literal|null
expr_stmt|;
name|endOptions
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// check to see if the vocab is already in memory
comment|// (defined by another grammar in the file).  Not normal situation.
if|if
condition|(
name|tokenManagers
operator|.
name|containsKey
argument_list|(
name|grammar
operator|.
name|importVocab
argument_list|)
condition|)
block|{
comment|// make a copy since we'll be generating a new output vocab
comment|// and we don't want to affect this one.  Set the name to
comment|// the default output vocab==classname.
name|TokenManager
name|tm
init|=
operator|(
name|TokenManager
operator|)
name|tokenManagers
operator|.
name|get
argument_list|(
name|grammar
operator|.
name|importVocab
argument_list|)
decl_stmt|;
comment|// System.out.println("Duping importVocab of " + grammar.importVocab);
name|TokenManager
name|dup
init|=
operator|(
name|TokenManager
operator|)
name|tm
operator|.
name|clone
argument_list|()
decl_stmt|;
name|dup
operator|.
name|setName
argument_list|(
name|grammar
operator|.
name|exportVocab
argument_list|)
expr_stmt|;
comment|// System.out.println("Setting name to " + grammar.exportVocab);
name|dup
operator|.
name|setReadOnly
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|grammar
operator|.
name|setTokenManager
argument_list|(
name|dup
argument_list|)
expr_stmt|;
name|tokenManagers
operator|.
name|put
argument_list|(
name|grammar
operator|.
name|exportVocab
argument_list|,
name|dup
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// System.out.println("reading in vocab "+grammar.importVocab);
comment|// Must be a file, go get it.
name|ImportVocabTokenManager
name|tm
init|=
operator|new
name|ImportVocabTokenManager
argument_list|(
name|grammar
argument_list|,
name|grammar
operator|.
name|importVocab
operator|+
name|CodeGenerator
operator|.
name|TokenTypesFileSuffix
operator|+
name|CodeGenerator
operator|.
name|TokenTypesFileExt
argument_list|,
name|grammar
operator|.
name|exportVocab
argument_list|,
name|tool
argument_list|)
decl_stmt|;
name|tm
operator|.
name|setReadOnly
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// since renamed, can write out
comment|// Add this token manager to the list so its tokens will be generated
name|tokenManagers
operator|.
name|put
argument_list|(
name|grammar
operator|.
name|exportVocab
argument_list|,
name|tm
argument_list|)
expr_stmt|;
comment|// System.out.println("vocab renamed to default output vocab of "+tm.getName());
comment|// Assign the token manager to this grammar.
name|grammar
operator|.
name|setTokenManager
argument_list|(
name|tm
argument_list|)
expr_stmt|;
comment|// set default vocab if none
if|if
condition|(
operator|!
name|tokenManagers
operator|.
name|containsKey
argument_list|(
name|DEFAULT_TOKENMANAGER_NAME
argument_list|)
condition|)
block|{
name|tokenManagers
operator|.
name|put
argument_list|(
name|DEFAULT_TOKENMANAGER_NAME
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// OUTPUT VOCAB, BUT NO INPUT VOCAB
if|if
condition|(
name|grammar
operator|.
name|exportVocab
operator|!=
literal|null
operator|&&
name|grammar
operator|.
name|importVocab
operator|==
literal|null
condition|)
block|{
comment|// share with previous vocab if it exists
if|if
condition|(
name|tokenManagers
operator|.
name|containsKey
argument_list|(
name|grammar
operator|.
name|exportVocab
argument_list|)
condition|)
block|{
comment|// Use the already-defined token manager
name|TokenManager
name|tm
init|=
operator|(
name|TokenManager
operator|)
name|tokenManagers
operator|.
name|get
argument_list|(
name|grammar
operator|.
name|exportVocab
argument_list|)
decl_stmt|;
comment|// System.out.println("Sharing exportVocab of " + grammar.exportVocab);
name|grammar
operator|.
name|setTokenManager
argument_list|(
name|tm
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// create new output vocab
comment|// System.out.println("Creating exportVocab " + grammar.exportVocab);
name|TokenManager
name|tm
init|=
operator|new
name|SimpleTokenManager
argument_list|(
name|grammar
operator|.
name|exportVocab
argument_list|,
name|tool
argument_list|)
decl_stmt|;
name|grammar
operator|.
name|setTokenManager
argument_list|(
name|tm
argument_list|)
expr_stmt|;
comment|// Add the token manager to the list of token managers
name|tokenManagers
operator|.
name|put
argument_list|(
name|grammar
operator|.
name|exportVocab
argument_list|,
name|tm
argument_list|)
expr_stmt|;
comment|// set default vocab if none
if|if
condition|(
operator|!
name|tokenManagers
operator|.
name|containsKey
argument_list|(
name|DEFAULT_TOKENMANAGER_NAME
argument_list|)
condition|)
block|{
name|tokenManagers
operator|.
name|put
argument_list|(
name|DEFAULT_TOKENMANAGER_NAME
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// BOTH INPUT AND OUTPUT VOCAB
if|if
condition|(
name|grammar
operator|.
name|exportVocab
operator|!=
literal|null
operator|&&
name|grammar
operator|.
name|importVocab
operator|!=
literal|null
condition|)
block|{
comment|// don't want input==output
if|if
condition|(
name|grammar
operator|.
name|importVocab
operator|.
name|equals
argument_list|(
name|grammar
operator|.
name|exportVocab
argument_list|)
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"exportVocab of "
operator|+
name|grammar
operator|.
name|exportVocab
operator|+
literal|" same as importVocab; probably not what you want"
argument_list|)
expr_stmt|;
block|}
comment|// does the input vocab already exist in memory?
if|if
condition|(
name|tokenManagers
operator|.
name|containsKey
argument_list|(
name|grammar
operator|.
name|importVocab
argument_list|)
condition|)
block|{
comment|// make a copy since we'll be generating a new output vocab
comment|// and we don't want to affect this one.
name|TokenManager
name|tm
init|=
operator|(
name|TokenManager
operator|)
name|tokenManagers
operator|.
name|get
argument_list|(
name|grammar
operator|.
name|importVocab
argument_list|)
decl_stmt|;
comment|// System.out.println("Duping importVocab of " + grammar.importVocab);
name|TokenManager
name|dup
init|=
operator|(
name|TokenManager
operator|)
name|tm
operator|.
name|clone
argument_list|()
decl_stmt|;
name|dup
operator|.
name|setName
argument_list|(
name|grammar
operator|.
name|exportVocab
argument_list|)
expr_stmt|;
comment|// System.out.println("Setting name to " + grammar.exportVocab);
name|dup
operator|.
name|setReadOnly
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|grammar
operator|.
name|setTokenManager
argument_list|(
name|dup
argument_list|)
expr_stmt|;
name|tokenManagers
operator|.
name|put
argument_list|(
name|grammar
operator|.
name|exportVocab
argument_list|,
name|dup
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Must be a file, go get it.
name|ImportVocabTokenManager
name|tm
init|=
operator|new
name|ImportVocabTokenManager
argument_list|(
name|grammar
argument_list|,
name|grammar
operator|.
name|importVocab
operator|+
name|CodeGenerator
operator|.
name|TokenTypesFileSuffix
operator|+
name|CodeGenerator
operator|.
name|TokenTypesFileExt
argument_list|,
name|grammar
operator|.
name|exportVocab
argument_list|,
name|tool
argument_list|)
decl_stmt|;
name|tm
operator|.
name|setReadOnly
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// write it out as we've changed name
comment|// Add this token manager to the list so its tokens will be generated
name|tokenManagers
operator|.
name|put
argument_list|(
name|grammar
operator|.
name|exportVocab
argument_list|,
name|tm
argument_list|)
expr_stmt|;
comment|// Assign the token manager to this grammar.
name|grammar
operator|.
name|setTokenManager
argument_list|(
name|tm
argument_list|)
expr_stmt|;
comment|// set default vocab if none
if|if
condition|(
operator|!
name|tokenManagers
operator|.
name|containsKey
argument_list|(
name|DEFAULT_TOKENMANAGER_NAME
argument_list|)
condition|)
block|{
name|tokenManagers
operator|.
name|put
argument_list|(
name|DEFAULT_TOKENMANAGER_NAME
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
DECL|method|endRule (String r)
specifier|public
name|void
name|endRule
parameter_list|(
name|String
name|r
parameter_list|)
block|{     }
DECL|method|endSubRule ()
specifier|public
name|void
name|endSubRule
parameter_list|()
block|{     }
DECL|method|endTree ()
specifier|public
name|void
name|endTree
parameter_list|()
block|{     }
DECL|method|hasError ()
specifier|public
name|void
name|hasError
parameter_list|()
block|{     }
DECL|method|noASTSubRule ()
specifier|public
name|void
name|noASTSubRule
parameter_list|()
block|{     }
DECL|method|oneOrMoreSubRule ()
specifier|public
name|void
name|oneOrMoreSubRule
parameter_list|()
block|{     }
DECL|method|optionalSubRule ()
specifier|public
name|void
name|optionalSubRule
parameter_list|()
block|{     }
DECL|method|setUserExceptions (String thr)
specifier|public
name|void
name|setUserExceptions
parameter_list|(
name|String
name|thr
parameter_list|)
block|{     }
DECL|method|refAction (Token action)
specifier|public
name|void
name|refAction
parameter_list|(
name|Token
name|action
parameter_list|)
block|{     }
DECL|method|refArgAction (Token action)
specifier|public
name|void
name|refArgAction
parameter_list|(
name|Token
name|action
parameter_list|)
block|{     }
DECL|method|refCharLiteral (Token lit, Token label, boolean inverted, int autoGenType, boolean lastInRule)
specifier|public
name|void
name|refCharLiteral
parameter_list|(
name|Token
name|lit
parameter_list|,
name|Token
name|label
parameter_list|,
name|boolean
name|inverted
parameter_list|,
name|int
name|autoGenType
parameter_list|,
name|boolean
name|lastInRule
parameter_list|)
block|{     }
DECL|method|refCharRange (Token t1, Token t2, Token label, int autoGenType, boolean lastInRule)
specifier|public
name|void
name|refCharRange
parameter_list|(
name|Token
name|t1
parameter_list|,
name|Token
name|t2
parameter_list|,
name|Token
name|label
parameter_list|,
name|int
name|autoGenType
parameter_list|,
name|boolean
name|lastInRule
parameter_list|)
block|{     }
DECL|method|refElementOption (Token option, Token value)
specifier|public
name|void
name|refElementOption
parameter_list|(
name|Token
name|option
parameter_list|,
name|Token
name|value
parameter_list|)
block|{     }
DECL|method|refTokensSpecElementOption (Token tok, Token option, Token value)
specifier|public
name|void
name|refTokensSpecElementOption
parameter_list|(
name|Token
name|tok
parameter_list|,
name|Token
name|option
parameter_list|,
name|Token
name|value
parameter_list|)
block|{     }
DECL|method|refExceptionHandler (Token exTypeAndName, Token action)
specifier|public
name|void
name|refExceptionHandler
parameter_list|(
name|Token
name|exTypeAndName
parameter_list|,
name|Token
name|action
parameter_list|)
block|{     }
comment|// Header action applies to all parsers and lexers.
DECL|method|refHeaderAction (Token name, Token act)
specifier|public
name|void
name|refHeaderAction
parameter_list|(
name|Token
name|name
parameter_list|,
name|Token
name|act
parameter_list|)
block|{
name|String
name|key
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|null
condition|)
name|key
operator|=
literal|""
expr_stmt|;
else|else
name|key
operator|=
name|StringUtils
operator|.
name|stripFrontBack
argument_list|(
name|name
operator|.
name|getText
argument_list|()
argument_list|,
literal|"\""
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
comment|// FIXME: depending on the mode the inserted header actions should
comment|// be checked for sanity.
if|if
condition|(
name|headerActions
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
name|tool
operator|.
name|error
argument_list|(
name|act
operator|.
name|getLine
argument_list|()
operator|+
literal|": header action already defined"
argument_list|)
expr_stmt|;
else|else
name|tool
operator|.
name|error
argument_list|(
name|act
operator|.
name|getLine
argument_list|()
operator|+
literal|": header action '"
operator|+
name|key
operator|+
literal|"' already defined"
argument_list|)
expr_stmt|;
block|}
name|headerActions
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|act
argument_list|)
expr_stmt|;
block|}
DECL|method|getHeaderAction (String name)
specifier|public
name|String
name|getHeaderAction
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|Token
name|t
init|=
operator|(
name|Token
operator|)
name|headerActions
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|null
condition|)
block|{
return|return
literal|""
return|;
block|}
return|return
name|t
operator|.
name|getText
argument_list|()
return|;
block|}
DECL|method|refInitAction (Token action)
specifier|public
name|void
name|refInitAction
parameter_list|(
name|Token
name|action
parameter_list|)
block|{     }
DECL|method|refMemberAction (Token act)
specifier|public
name|void
name|refMemberAction
parameter_list|(
name|Token
name|act
parameter_list|)
block|{     }
DECL|method|refPreambleAction (Token act)
specifier|public
name|void
name|refPreambleAction
parameter_list|(
name|Token
name|act
parameter_list|)
block|{
name|thePreambleAction
operator|=
name|act
expr_stmt|;
block|}
DECL|method|refReturnAction (Token returnAction)
specifier|public
name|void
name|refReturnAction
parameter_list|(
name|Token
name|returnAction
parameter_list|)
block|{     }
DECL|method|refRule (Token idAssign, Token r, Token label, Token args, int autoGenType)
specifier|public
name|void
name|refRule
parameter_list|(
name|Token
name|idAssign
parameter_list|,
name|Token
name|r
parameter_list|,
name|Token
name|label
parameter_list|,
name|Token
name|args
parameter_list|,
name|int
name|autoGenType
parameter_list|)
block|{
name|String
name|id
init|=
name|r
operator|.
name|getText
argument_list|()
decl_stmt|;
comment|//		if ( Character.isUpperCase(id.charAt(0)) ) { // lexer rule?
if|if
condition|(
name|r
operator|.
name|type
operator|==
name|ANTLRTokenTypes
operator|.
name|TOKEN_REF
condition|)
block|{
comment|// lexer rule?
name|id
operator|=
name|CodeGenerator
operator|.
name|encodeLexerRuleName
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|grammar
operator|.
name|isDefined
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|grammar
operator|.
name|define
argument_list|(
operator|new
name|RuleSymbol
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|refSemPred (Token pred)
specifier|public
name|void
name|refSemPred
parameter_list|(
name|Token
name|pred
parameter_list|)
block|{     }
DECL|method|refStringLiteral (Token lit, Token label, int autoGenType, boolean lastInRule)
specifier|public
name|void
name|refStringLiteral
parameter_list|(
name|Token
name|lit
parameter_list|,
name|Token
name|label
parameter_list|,
name|int
name|autoGenType
parameter_list|,
name|boolean
name|lastInRule
parameter_list|)
block|{
name|_refStringLiteral
argument_list|(
name|lit
argument_list|,
name|label
argument_list|,
name|autoGenType
argument_list|,
name|lastInRule
argument_list|)
expr_stmt|;
block|}
comment|/** Reference a token */
DECL|method|refToken (Token assignId, Token t, Token label, Token args, boolean inverted, int autoGenType, boolean lastInRule)
specifier|public
name|void
name|refToken
parameter_list|(
name|Token
name|assignId
parameter_list|,
name|Token
name|t
parameter_list|,
name|Token
name|label
parameter_list|,
name|Token
name|args
parameter_list|,
name|boolean
name|inverted
parameter_list|,
name|int
name|autoGenType
parameter_list|,
name|boolean
name|lastInRule
parameter_list|)
block|{
name|_refToken
argument_list|(
name|assignId
argument_list|,
name|t
argument_list|,
name|label
argument_list|,
name|args
argument_list|,
name|inverted
argument_list|,
name|autoGenType
argument_list|,
name|lastInRule
argument_list|)
expr_stmt|;
block|}
DECL|method|refTokenRange (Token t1, Token t2, Token label, int autoGenType, boolean lastInRule)
specifier|public
name|void
name|refTokenRange
parameter_list|(
name|Token
name|t1
parameter_list|,
name|Token
name|t2
parameter_list|,
name|Token
name|label
parameter_list|,
name|int
name|autoGenType
parameter_list|,
name|boolean
name|lastInRule
parameter_list|)
block|{
comment|// ensure that the DefineGrammarSymbols methods are called; otherwise a range addes more
comment|// token refs to the alternative by calling MakeGrammar.refToken etc...
if|if
condition|(
name|t1
operator|.
name|getText
argument_list|()
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'"'
condition|)
block|{
name|refStringLiteral
argument_list|(
name|t1
argument_list|,
literal|null
argument_list|,
name|GrammarElement
operator|.
name|AUTO_GEN_NONE
argument_list|,
name|lastInRule
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_refToken
argument_list|(
literal|null
argument_list|,
name|t1
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|GrammarElement
operator|.
name|AUTO_GEN_NONE
argument_list|,
name|lastInRule
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t2
operator|.
name|getText
argument_list|()
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'"'
condition|)
block|{
name|_refStringLiteral
argument_list|(
name|t2
argument_list|,
literal|null
argument_list|,
name|GrammarElement
operator|.
name|AUTO_GEN_NONE
argument_list|,
name|lastInRule
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_refToken
argument_list|(
literal|null
argument_list|,
name|t2
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|GrammarElement
operator|.
name|AUTO_GEN_NONE
argument_list|,
name|lastInRule
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|refTreeSpecifier (Token treeSpec)
specifier|public
name|void
name|refTreeSpecifier
parameter_list|(
name|Token
name|treeSpec
parameter_list|)
block|{     }
DECL|method|refWildcard (Token t, Token label, int autoGenType)
specifier|public
name|void
name|refWildcard
parameter_list|(
name|Token
name|t
parameter_list|,
name|Token
name|label
parameter_list|,
name|int
name|autoGenType
parameter_list|)
block|{     }
comment|/** Get ready to process a new grammar */
DECL|method|reset ()
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|grammar
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|setArgOfRuleRef (Token argaction)
specifier|public
name|void
name|setArgOfRuleRef
parameter_list|(
name|Token
name|argaction
parameter_list|)
block|{     }
comment|/** Set the character vocabulary for a lexer */
DECL|method|setCharVocabulary (BitSet b)
specifier|public
name|void
name|setCharVocabulary
parameter_list|(
name|BitSet
name|b
parameter_list|)
block|{
comment|// grammar should enforce that this is only called for lexer
operator|(
operator|(
name|LexerGrammar
operator|)
name|grammar
operator|)
operator|.
name|setCharVocabulary
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
comment|/** setFileOption: Associate an option value with a key.      * This applies to options for an entire grammar file.      * @param key The token containing the option name      * @param value The token containing the option value.      */
DECL|method|setFileOption (Token key, Token value, String filename)
specifier|public
name|void
name|setFileOption
parameter_list|(
name|Token
name|key
parameter_list|,
name|Token
name|value
parameter_list|,
name|String
name|filename
parameter_list|)
block|{
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"language"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|getType
argument_list|()
operator|==
name|ANTLRParser
operator|.
name|STRING_LITERAL
condition|)
block|{
name|language
operator|=
name|StringUtils
operator|.
name|stripBack
argument_list|(
name|StringUtils
operator|.
name|stripFront
argument_list|(
name|value
operator|.
name|getText
argument_list|()
argument_list|,
literal|'"'
argument_list|)
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|getType
argument_list|()
operator|==
name|ANTLRParser
operator|.
name|TOKEN_REF
operator|||
name|value
operator|.
name|getType
argument_list|()
operator|==
name|ANTLRParser
operator|.
name|RULE_REF
condition|)
block|{
name|language
operator|=
name|value
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"language option must be string or identifier"
argument_list|,
name|filename
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|,
name|value
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"mangleLiteralPrefix"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|getType
argument_list|()
operator|==
name|ANTLRParser
operator|.
name|STRING_LITERAL
condition|)
block|{
name|tool
operator|.
name|literalsPrefix
operator|=
name|StringUtils
operator|.
name|stripFrontBack
argument_list|(
name|value
operator|.
name|getText
argument_list|()
argument_list|,
literal|"\""
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"mangleLiteralPrefix option must be string"
argument_list|,
name|filename
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|,
name|value
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"upperCaseMangledLiterals"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|tool
operator|.
name|upperCaseMangledLiterals
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|tool
operator|.
name|upperCaseMangledLiterals
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|grammar
operator|.
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Value for upperCaseMangledLiterals must be true or false"
argument_list|,
name|filename
argument_list|,
name|key
operator|.
name|getLine
argument_list|()
argument_list|,
name|key
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"namespaceStd"
argument_list|)
operator|||
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"namespaceAntlr"
argument_list|)
operator|||
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"genHashLines"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|language
operator|.
name|equals
argument_list|(
literal|"Cpp"
argument_list|)
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
name|key
operator|.
name|getText
argument_list|()
operator|+
literal|" option only valid for C++"
argument_list|,
name|filename
argument_list|,
name|key
operator|.
name|getLine
argument_list|()
argument_list|,
name|key
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"noConstructors"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
operator|||
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
operator|)
condition|)
name|tool
operator|.
name|error
argument_list|(
literal|"noConstructors option must be true or false"
argument_list|,
name|filename
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|,
name|value
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
name|tool
operator|.
name|noConstructors
operator|=
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"genHashLines"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
operator|||
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
operator|)
condition|)
name|tool
operator|.
name|error
argument_list|(
literal|"genHashLines option must be true or false"
argument_list|,
name|filename
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|,
name|value
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
name|tool
operator|.
name|genHashLines
operator|=
name|value
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|.
name|getType
argument_list|()
operator|!=
name|ANTLRParser
operator|.
name|STRING_LITERAL
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
name|key
operator|.
name|getText
argument_list|()
operator|+
literal|" option must be a string"
argument_list|,
name|filename
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|,
name|value
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"namespaceStd"
argument_list|)
condition|)
name|tool
operator|.
name|namespaceStd
operator|=
name|value
operator|.
name|getText
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"namespaceAntlr"
argument_list|)
condition|)
name|tool
operator|.
name|namespaceAntlr
operator|=
name|value
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"namespace"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|language
operator|.
name|equals
argument_list|(
literal|"Cpp"
argument_list|)
operator|&&
operator|!
name|language
operator|.
name|equals
argument_list|(
literal|"CSharp"
argument_list|)
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
name|key
operator|.
name|getText
argument_list|()
operator|+
literal|" option only valid for C++ and C# (a.k.a CSharp)"
argument_list|,
name|filename
argument_list|,
name|key
operator|.
name|getLine
argument_list|()
argument_list|,
name|key
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|.
name|getType
argument_list|()
operator|!=
name|ANTLRParser
operator|.
name|STRING_LITERAL
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
name|key
operator|.
name|getText
argument_list|()
operator|+
literal|" option must be a string"
argument_list|,
name|filename
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|,
name|value
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"namespace"
argument_list|)
condition|)
name|tool
operator|.
name|setNameSpace
argument_list|(
name|value
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"Invalid file-level option: "
operator|+
name|key
operator|.
name|getText
argument_list|()
argument_list|,
name|filename
argument_list|,
name|key
operator|.
name|getLine
argument_list|()
argument_list|,
name|value
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** setGrammarOption: Associate an option value with a key.      * This function forwards to Grammar.setOption for some options.      * @param key The token containing the option name      * @param value The token containing the option value.      */
DECL|method|setGrammarOption (Token key, Token value)
specifier|public
name|void
name|setGrammarOption
parameter_list|(
name|Token
name|key
parameter_list|,
name|Token
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"tokdef"
argument_list|)
operator|||
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"tokenVocabulary"
argument_list|)
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"tokdef/tokenVocabulary options are invalid>= ANTLR 2.6.0.\n"
operator|+
literal|"  Use importVocab/exportVocab instead.  Please see the documentation.\n"
operator|+
literal|"  The previous options were so heinous that Terence changed the whole\n"
operator|+
literal|"  vocabulary mechanism; it was better to change the names rather than\n"
operator|+
literal|"  subtly change the functionality of the known options.  Sorry!"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|,
name|value
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"literal"
argument_list|)
operator|&&
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"the literal option is invalid>= ANTLR 2.6.0.\n"
operator|+
literal|"  Use the \"tokens {...}\" mechanism instead."
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|,
name|value
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"exportVocab"
argument_list|)
condition|)
block|{
comment|// Set the token manager associated with the parser
if|if
condition|(
name|value
operator|.
name|getType
argument_list|()
operator|==
name|ANTLRParser
operator|.
name|RULE_REF
operator|||
name|value
operator|.
name|getType
argument_list|()
operator|==
name|ANTLRParser
operator|.
name|TOKEN_REF
condition|)
block|{
name|grammar
operator|.
name|exportVocab
operator|=
name|value
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"exportVocab must be an identifier"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|,
name|value
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"importVocab"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|getType
argument_list|()
operator|==
name|ANTLRParser
operator|.
name|RULE_REF
operator|||
name|value
operator|.
name|getType
argument_list|()
operator|==
name|ANTLRParser
operator|.
name|TOKEN_REF
condition|)
block|{
name|grammar
operator|.
name|importVocab
operator|=
name|value
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tool
operator|.
name|error
argument_list|(
literal|"importVocab must be an identifier"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|value
operator|.
name|getLine
argument_list|()
argument_list|,
name|value
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Forward all unrecognized options to the grammar
name|grammar
operator|.
name|setOption
argument_list|(
name|key
operator|.
name|getText
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setRuleOption (Token key, Token value)
specifier|public
name|void
name|setRuleOption
parameter_list|(
name|Token
name|key
parameter_list|,
name|Token
name|value
parameter_list|)
block|{     }
DECL|method|setSubruleOption (Token key, Token value)
specifier|public
name|void
name|setSubruleOption
parameter_list|(
name|Token
name|key
parameter_list|,
name|Token
name|value
parameter_list|)
block|{     }
comment|/** Start a new lexer */
DECL|method|startLexer (String file, Token name, String superClass, String doc)
specifier|public
name|void
name|startLexer
parameter_list|(
name|String
name|file
parameter_list|,
name|Token
name|name
parameter_list|,
name|String
name|superClass
parameter_list|,
name|String
name|doc
parameter_list|)
block|{
if|if
condition|(
name|numLexers
operator|>
literal|0
condition|)
block|{
name|tool
operator|.
name|panic
argument_list|(
literal|"You may only have one lexer per grammar file: class "
operator|+
name|name
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|numLexers
operator|++
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
comment|//System.out.println("Processing lexer '" + name.getText() + "'");
comment|// Does the lexer already exist?
name|Grammar
name|g
init|=
operator|(
name|Grammar
operator|)
name|grammars
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|g
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|g
operator|instanceof
name|LexerGrammar
operator|)
condition|)
block|{
name|tool
operator|.
name|panic
argument_list|(
literal|"'"
operator|+
name|name
operator|.
name|getText
argument_list|()
operator|+
literal|"' is already defined as a non-lexer"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tool
operator|.
name|panic
argument_list|(
literal|"Lexer '"
operator|+
name|name
operator|.
name|getText
argument_list|()
operator|+
literal|"' is already defined"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Create a new lexer grammar
name|LexerGrammar
name|lg
init|=
operator|new
name|LexerGrammar
argument_list|(
name|name
operator|.
name|getText
argument_list|()
argument_list|,
name|tool
argument_list|,
name|superClass
argument_list|)
decl_stmt|;
name|lg
operator|.
name|comment
operator|=
name|doc
expr_stmt|;
name|lg
operator|.
name|processArguments
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|lg
operator|.
name|setFilename
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|grammars
operator|.
name|put
argument_list|(
name|lg
operator|.
name|getClassName
argument_list|()
argument_list|,
name|lg
argument_list|)
expr_stmt|;
comment|// Use any preamble action
name|lg
operator|.
name|preambleAction
operator|=
name|thePreambleAction
expr_stmt|;
name|thePreambleAction
operator|=
operator|new
name|CommonToken
argument_list|(
name|Token
operator|.
name|INVALID_TYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|// This is now the current grammar
name|grammar
operator|=
name|lg
expr_stmt|;
block|}
block|}
comment|/** Start a new parser */
DECL|method|startParser (String file, Token name, String superClass, String doc)
specifier|public
name|void
name|startParser
parameter_list|(
name|String
name|file
parameter_list|,
name|Token
name|name
parameter_list|,
name|String
name|superClass
parameter_list|,
name|String
name|doc
parameter_list|)
block|{
if|if
condition|(
name|numParsers
operator|>
literal|0
condition|)
block|{
name|tool
operator|.
name|panic
argument_list|(
literal|"You may only have one parser per grammar file: class "
operator|+
name|name
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|numParsers
operator|++
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
comment|//System.out.println("Processing parser '" + name.getText() + "'");
comment|// Is this grammar already defined?
name|Grammar
name|g
init|=
operator|(
name|Grammar
operator|)
name|grammars
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|g
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|g
operator|instanceof
name|ParserGrammar
operator|)
condition|)
block|{
name|tool
operator|.
name|panic
argument_list|(
literal|"'"
operator|+
name|name
operator|.
name|getText
argument_list|()
operator|+
literal|"' is already defined as a non-parser"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tool
operator|.
name|panic
argument_list|(
literal|"Parser '"
operator|+
name|name
operator|.
name|getText
argument_list|()
operator|+
literal|"' is already defined"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Create a new grammar
name|grammar
operator|=
operator|new
name|ParserGrammar
argument_list|(
name|name
operator|.
name|getText
argument_list|()
argument_list|,
name|tool
argument_list|,
name|superClass
argument_list|)
expr_stmt|;
name|grammar
operator|.
name|comment
operator|=
name|doc
expr_stmt|;
name|grammar
operator|.
name|processArguments
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|grammar
operator|.
name|setFilename
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|grammars
operator|.
name|put
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
argument_list|,
name|grammar
argument_list|)
expr_stmt|;
comment|// Use any preamble action
name|grammar
operator|.
name|preambleAction
operator|=
name|thePreambleAction
expr_stmt|;
name|thePreambleAction
operator|=
operator|new
name|CommonToken
argument_list|(
name|Token
operator|.
name|INVALID_TYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Start a new tree-walker */
DECL|method|startTreeWalker (String file, Token name, String superClass, String doc)
specifier|public
name|void
name|startTreeWalker
parameter_list|(
name|String
name|file
parameter_list|,
name|Token
name|name
parameter_list|,
name|String
name|superClass
parameter_list|,
name|String
name|doc
parameter_list|)
block|{
if|if
condition|(
name|numTreeParsers
operator|>
literal|0
condition|)
block|{
name|tool
operator|.
name|panic
argument_list|(
literal|"You may only have one tree parser per grammar file: class "
operator|+
name|name
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|numTreeParsers
operator|++
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
comment|//System.out.println("Processing tree-walker '" + name.getText() + "'");
comment|// Is this grammar already defined?
name|Grammar
name|g
init|=
operator|(
name|Grammar
operator|)
name|grammars
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|g
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|g
operator|instanceof
name|TreeWalkerGrammar
operator|)
condition|)
block|{
name|tool
operator|.
name|panic
argument_list|(
literal|"'"
operator|+
name|name
operator|.
name|getText
argument_list|()
operator|+
literal|"' is already defined as a non-tree-walker"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tool
operator|.
name|panic
argument_list|(
literal|"Tree-walker '"
operator|+
name|name
operator|.
name|getText
argument_list|()
operator|+
literal|"' is already defined"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Create a new grammar
name|grammar
operator|=
operator|new
name|TreeWalkerGrammar
argument_list|(
name|name
operator|.
name|getText
argument_list|()
argument_list|,
name|tool
argument_list|,
name|superClass
argument_list|)
expr_stmt|;
name|grammar
operator|.
name|comment
operator|=
name|doc
expr_stmt|;
name|grammar
operator|.
name|processArguments
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|grammar
operator|.
name|setFilename
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|grammars
operator|.
name|put
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
argument_list|,
name|grammar
argument_list|)
expr_stmt|;
comment|// Use any preamble action
name|grammar
operator|.
name|preambleAction
operator|=
name|thePreambleAction
expr_stmt|;
name|thePreambleAction
operator|=
operator|new
name|CommonToken
argument_list|(
name|Token
operator|.
name|INVALID_TYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|synPred ()
specifier|public
name|void
name|synPred
parameter_list|()
block|{     }
DECL|method|zeroOrMoreSubRule ()
specifier|public
name|void
name|zeroOrMoreSubRule
parameter_list|()
block|{     }
block|}
end_class

end_unit

