begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr.build
package|package
name|antlr
operator|.
name|build
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|*
import|;
end_import

begin_comment
comment|/** An application-specific build tool for ANTLR.  Old build  *  was a shell script that of course is not portable.  All it  *  did though was to compile; this Java program is a portable  *  compile script. :)  *  *  This class knows how to portable invoke a system command with  *  wildcard expansion.  It also knows to how dynamically load a project  *  description based upon the name.  Actions are just method names  *  within that object.  The ANTLR object defines build and jar methods  *  that use Tool to portably compile and jar--it is the replacement  *  the script.  *  *  I almost used Python for this, but I hate forcing users to download  *  yet another tool just to compile this one.  (Another reason not  *  to use Ant).  *  *  I am using a class to describe the build (e.g., ANTLR) rather than  *  a file format at the moment since I am not sure how all this will  *  progress.  *  *  Properties antlr.build.compiler and antlr.build.root may be set  *  according to your needs.  They default to "javac" and ".".  The  *  root is the dir containing the antlr directory associated with  *  the antlr Java package.  *  *  To build this builder, run "javac *.java" in this dir.  *  *  To build ANTLR, just run  *  *    java antlr.build.Tool build"  *  *  from the  *  directory containing package antlr's "antlr" dir.  Or, use  *  something like:  *  *  java -Dantlr.build.root=/usr/local/antlr-2.7.2 antlr.build.Tool build  *  *  To make the antlr.jar file, use  *  *  java antlr.build.Tool jar  */
end_comment

begin_class
DECL|class|Tool
specifier|public
class|class
name|Tool
block|{
DECL|field|os
specifier|public
name|String
name|os
init|=
literal|null
decl_stmt|;
DECL|method|Tool ()
specifier|public
name|Tool
parameter_list|()
block|{
name|os
operator|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.name"
argument_list|)
expr_stmt|;
block|}
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"usage: java antlr.build.Tool action"
argument_list|)
expr_stmt|;
return|return;
block|}
name|String
name|app
init|=
literal|"antlr.build.ANTLR"
decl_stmt|;
comment|// hardcode to build ANTLR app
name|String
name|action
init|=
name|args
index|[
literal|0
index|]
decl_stmt|;
name|Tool
name|t
init|=
operator|new
name|Tool
argument_list|()
decl_stmt|;
name|t
operator|.
name|perform
argument_list|(
name|app
argument_list|,
name|action
argument_list|)
expr_stmt|;
block|}
comment|/** Find a class named after the app and then find a method within      *  that is named after the action.      */
DECL|method|perform (String app, String action)
specifier|public
name|void
name|perform
parameter_list|(
name|String
name|app
parameter_list|,
name|String
name|action
parameter_list|)
block|{
if|if
condition|(
name|app
operator|==
literal|null
operator|||
name|action
operator|==
literal|null
condition|)
block|{
name|error
argument_list|(
literal|"missing app or action"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Class
name|c
init|=
literal|null
decl_stmt|;
name|Method
name|m
init|=
literal|null
decl_stmt|;
name|Object
name|appObj
init|=
literal|null
decl_stmt|;
try|try
block|{
name|c
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|app
argument_list|)
expr_stmt|;
name|appObj
operator|=
name|c
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// try again with antlr.build.app
try|try
block|{
if|if
condition|(
operator|!
name|app
operator|.
name|startsWith
argument_list|(
literal|"antlr.build."
argument_list|)
condition|)
block|{
name|c
operator|=
name|Class
operator|.
name|forName
argument_list|(
literal|"antlr.build."
operator|+
name|app
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|"no such application "
operator|+
name|app
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e2
parameter_list|)
block|{
name|error
argument_list|(
literal|"no such application "
operator|+
name|app
argument_list|,
name|e2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|null
operator|||
name|appObj
operator|==
literal|null
condition|)
block|{
return|return;
block|}
try|try
block|{
name|m
operator|=
name|c
operator|.
name|getMethod
argument_list|(
name|action
argument_list|,
operator|new
name|Class
index|[]
block|{
name|antlr
operator|.
name|build
operator|.
name|Tool
operator|.
name|class
block|}
argument_list|)
expr_stmt|;
comment|//log("begin "+action+" on "+app);
name|m
operator|.
name|invoke
argument_list|(
name|appObj
argument_list|,
operator|new
name|Object
index|[]
block|{
name|this
block|}
argument_list|)
expr_stmt|;
comment|//log("end "+action+" on "+app);
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|error
argument_list|(
literal|"no such action for application "
operator|+
name|app
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** A portable system command execution routine that logs stdout/stderr      *  and handles cmd-line wildcards properly.      */
DECL|method|system (String cmd)
specifier|public
name|void
name|system
parameter_list|(
name|String
name|cmd
parameter_list|)
block|{
name|Runtime
name|rt
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
decl_stmt|;
try|try
block|{
name|log
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|Process
name|proc
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|os
operator|.
name|startsWith
argument_list|(
literal|"Windows"
argument_list|)
condition|)
block|{
comment|// assume unixen if not windoze (windoze tool expands *)
name|proc
operator|=
name|rt
operator|.
name|exec
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"sh"
block|,
literal|"-c"
block|,
name|cmd
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|proc
operator|=
name|rt
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|StreamScarfer
name|stderrScarfer
init|=
operator|new
name|StreamScarfer
argument_list|(
name|proc
operator|.
name|getErrorStream
argument_list|()
argument_list|,
literal|"stderr"
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|StreamScarfer
name|stdoutScarfer
init|=
operator|new
name|StreamScarfer
argument_list|(
name|proc
operator|.
name|getInputStream
argument_list|()
argument_list|,
literal|"stdout"
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|stderrScarfer
operator|.
name|start
argument_list|()
expr_stmt|;
name|stdoutScarfer
operator|.
name|start
argument_list|()
expr_stmt|;
name|int
name|exitVal
init|=
name|proc
operator|.
name|waitFor
argument_list|()
decl_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|error
argument_list|(
literal|"cannot exec "
operator|+
name|cmd
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Run ANTLR on a grammar file, leaving the output in the directory of the      *  grammar file.      */
DECL|method|antlr (String fullyQualifiedFilename)
specifier|public
name|void
name|antlr
parameter_list|(
name|String
name|fullyQualifiedFilename
parameter_list|)
block|{
name|String
name|path
init|=
literal|null
decl_stmt|;
try|try
block|{
name|path
operator|=
operator|new
name|File
argument_list|(
name|fullyQualifiedFilename
argument_list|)
operator|.
name|getParent
argument_list|()
expr_stmt|;
if|if
condition|(
name|path
operator|!=
literal|null
condition|)
block|{
name|path
operator|=
operator|new
name|File
argument_list|(
name|path
argument_list|)
operator|.
name|getCanonicalPath
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|error
argument_list|(
literal|"Invalid grammar file: "
operator|+
name|fullyQualifiedFilename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|!=
literal|null
condition|)
block|{
name|log
argument_list|(
literal|"java antlr.Tool -o "
operator|+
name|path
operator|+
literal|" "
operator|+
name|fullyQualifiedFilename
argument_list|)
expr_stmt|;
name|antlr
operator|.
name|Tool
name|theTool
init|=
operator|new
name|antlr
operator|.
name|Tool
argument_list|()
decl_stmt|;
name|theTool
operator|.
name|doEverything
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"-o"
block|,
name|path
block|,
name|fullyQualifiedFilename
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Stdout from executing sub tools */
DECL|method|stdout (String s)
specifier|public
name|void
name|stdout
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/** Stderr from executing sub tools */
DECL|method|stderr (String s)
specifier|public
name|void
name|stderr
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
DECL|method|error (String msg)
specifier|public
name|void
name|error
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"antlr.build.Tool: "
operator|+
name|msg
argument_list|)
expr_stmt|;
block|}
DECL|method|log (String cmd)
specifier|public
name|void
name|log
parameter_list|(
name|String
name|cmd
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"executing: "
operator|+
name|cmd
argument_list|)
expr_stmt|;
block|}
DECL|method|error (String msg, Exception e)
specifier|public
name|void
name|error
parameter_list|(
name|String
name|msg
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"antlr.build.Tool: "
operator|+
name|msg
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

