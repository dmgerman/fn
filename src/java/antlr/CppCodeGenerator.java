begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|antlr
package|package
name|antlr
package|;
end_package

begin_comment
comment|/* ANTLR Translator Generator  * Project led by Terence Parr at http://www.jGuru.com  * Software rights: http://www.antlr.org/license.html  *  * $Id$  */
end_comment

begin_comment
comment|// C++ code generator by Pete Wells: pete@yamuna.demon.co.uk
end_comment

begin_comment
comment|// #line generation contributed by: Ric Klaren<klaren@cs.utwente.nl>
end_comment

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|antlr
operator|.
name|collections
operator|.
name|impl
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_comment
comment|//SAS: changed for proper text file io
end_comment

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileWriter
import|;
end_import

begin_comment
comment|/** Generate MyParser.cpp, MyParser.hpp, MyLexer.cpp, MyLexer.hpp  * and MyParserTokenTypes.hpp  */
end_comment

begin_class
DECL|class|CppCodeGenerator
specifier|public
class|class
name|CppCodeGenerator
extends|extends
name|CodeGenerator
block|{
DECL|field|DEBUG_CPP_CODE_GENERATOR
name|boolean
name|DEBUG_CPP_CODE_GENERATOR
init|=
literal|false
decl_stmt|;
comment|// non-zero if inside syntactic predicate generation
DECL|field|syntacticPredLevel
specifier|protected
name|int
name|syntacticPredLevel
init|=
literal|0
decl_stmt|;
comment|// Are we generating ASTs (for parsers and tree parsers) right now?
DECL|field|genAST
specifier|protected
name|boolean
name|genAST
init|=
literal|false
decl_stmt|;
comment|// Are we saving the text consumed (for lexers) right now?
DECL|field|saveText
specifier|protected
name|boolean
name|saveText
init|=
literal|false
decl_stmt|;
comment|// Generate #line's
DECL|field|genHashLines
specifier|protected
name|boolean
name|genHashLines
init|=
literal|true
decl_stmt|;
comment|// Generate constructors or not
DECL|field|noConstructors
specifier|protected
name|boolean
name|noConstructors
init|=
literal|false
decl_stmt|;
comment|// Used to keep track of lineno in output
DECL|field|outputLine
specifier|protected
name|int
name|outputLine
decl_stmt|;
DECL|field|outputFile
specifier|protected
name|String
name|outputFile
decl_stmt|;
comment|// Grammar parameters set up to handle different grammar classes.
comment|// These are used to get instanceof tests out of code generation
DECL|field|usingCustomAST
name|boolean
name|usingCustomAST
init|=
literal|false
decl_stmt|;
DECL|field|labeledElementType
name|String
name|labeledElementType
decl_stmt|;
DECL|field|labeledElementASTType
name|String
name|labeledElementASTType
decl_stmt|;
comment|// mostly the same as labeledElementType except in parsers
DECL|field|labeledElementASTInit
name|String
name|labeledElementASTInit
decl_stmt|;
DECL|field|labeledElementInit
name|String
name|labeledElementInit
decl_stmt|;
DECL|field|commonExtraArgs
name|String
name|commonExtraArgs
decl_stmt|;
DECL|field|commonExtraParams
name|String
name|commonExtraParams
decl_stmt|;
DECL|field|commonLocalVars
name|String
name|commonLocalVars
decl_stmt|;
DECL|field|lt1Value
name|String
name|lt1Value
decl_stmt|;
DECL|field|exceptionThrown
name|String
name|exceptionThrown
decl_stmt|;
DECL|field|throwNoViable
name|String
name|throwNoViable
decl_stmt|;
comment|// Tracks the rule being generated.  Used for mapTreeId
DECL|field|currentRule
name|RuleBlock
name|currentRule
decl_stmt|;
comment|// Tracks the rule or labeled subrule being generated.  Used for AST generation.
DECL|field|currentASTResult
name|String
name|currentASTResult
decl_stmt|;
comment|// Mapping between the ids used in the current alt, and the
comment|// names of variables used to represent their AST values.
DECL|field|treeVariableMap
name|Hashtable
name|treeVariableMap
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
comment|/** Used to keep track of which AST variables have been defined in a rule 	 * (except for the #rule_name and #rule_name_in var's 	 */
DECL|field|declaredASTVariables
name|Hashtable
name|declaredASTVariables
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
comment|// Count of unnamed generated variables
DECL|field|astVarNumber
name|int
name|astVarNumber
init|=
literal|1
decl_stmt|;
comment|// Special value used to mark duplicate in treeVariableMap
DECL|field|NONUNIQUE
specifier|protected
specifier|static
specifier|final
name|String
name|NONUNIQUE
init|=
operator|new
name|String
argument_list|()
decl_stmt|;
DECL|field|caseSizeThreshold
specifier|public
specifier|static
specifier|final
name|int
name|caseSizeThreshold
init|=
literal|127
decl_stmt|;
comment|// ascii is max
DECL|field|semPreds
specifier|private
name|Vector
name|semPreds
decl_stmt|;
comment|// Used to keep track of which (heterogeneous AST types are used)
comment|// which need to be set in the ASTFactory of the generated parser
DECL|field|astTypes
specifier|private
name|Vector
name|astTypes
decl_stmt|;
DECL|field|namespaceStd
specifier|private
specifier|static
name|String
name|namespaceStd
init|=
literal|"ANTLR_USE_NAMESPACE(std)"
decl_stmt|;
DECL|field|namespaceAntlr
specifier|private
specifier|static
name|String
name|namespaceAntlr
init|=
literal|"ANTLR_USE_NAMESPACE(antlr)"
decl_stmt|;
DECL|field|nameSpace
specifier|private
specifier|static
name|NameSpace
name|nameSpace
init|=
literal|null
decl_stmt|;
DECL|field|preIncludeCpp
specifier|private
specifier|static
specifier|final
name|String
name|preIncludeCpp
init|=
literal|"pre_include_cpp"
decl_stmt|;
DECL|field|preIncludeHpp
specifier|private
specifier|static
specifier|final
name|String
name|preIncludeHpp
init|=
literal|"pre_include_hpp"
decl_stmt|;
DECL|field|postIncludeCpp
specifier|private
specifier|static
specifier|final
name|String
name|postIncludeCpp
init|=
literal|"post_include_cpp"
decl_stmt|;
DECL|field|postIncludeHpp
specifier|private
specifier|static
specifier|final
name|String
name|postIncludeHpp
init|=
literal|"post_include_hpp"
decl_stmt|;
comment|/** Create a C++ code-generator using the given Grammar. 	 * The caller must still call setTool, setBehavior, and setAnalyzer 	 * before generating code. 	 */
DECL|method|CppCodeGenerator ()
specifier|public
name|CppCodeGenerator
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
name|charFormatter
operator|=
operator|new
name|CppCharFormatter
argument_list|()
expr_stmt|;
block|}
comment|/** Adds a semantic predicate string to the sem pred vector 	    These strings will be used to build an array of sem pred names 	    when building a debugging parser.  This method should only be 	    called when the debug option is specified 	 */
DECL|method|addSemPred (String predicate)
specifier|protected
name|int
name|addSemPred
parameter_list|(
name|String
name|predicate
parameter_list|)
block|{
name|semPreds
operator|.
name|appendElement
argument_list|(
name|predicate
argument_list|)
expr_stmt|;
return|return
name|semPreds
operator|.
name|size
argument_list|()
operator|-
literal|1
return|;
block|}
DECL|method|exitIfError ()
specifier|public
name|void
name|exitIfError
parameter_list|()
block|{
if|if
condition|(
name|antlrTool
operator|.
name|hasError
argument_list|()
condition|)
block|{
name|antlrTool
operator|.
name|fatalError
argument_list|(
literal|"Exiting due to errors."
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|countLines ( String s )
specifier|protected
name|int
name|countLines
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|int
name|lines
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'\n'
condition|)
name|lines
operator|++
expr_stmt|;
block|}
return|return
name|lines
return|;
block|}
comment|/** Output a String to the currentOutput stream. 	 * Ignored if string is null. 	 * @param s The string to output 	 */
DECL|method|_print (String s)
specifier|protected
name|void
name|_print
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|outputLine
operator|+=
name|countLines
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|currentOutput
operator|.
name|print
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Print an action without leading tabs, attempting to 	 * preserve the current indentation level for multi-line actions 	 * Ignored if string is null. 	 * @param s The action string to output 	 */
DECL|method|_printAction (String s)
specifier|protected
name|void
name|_printAction
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|outputLine
operator|+=
name|countLines
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
name|super
operator|.
name|_printAction
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Print an action stored in a token surrounded by #line stuff */
DECL|method|printAction (Token t)
specifier|public
name|void
name|printAction
parameter_list|(
name|Token
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|genLineNo
argument_list|(
name|t
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|printTabs
argument_list|()
expr_stmt|;
name|_printAction
argument_list|(
name|processActionForSpecialSymbols
argument_list|(
name|t
operator|.
name|getText
argument_list|()
argument_list|,
name|t
operator|.
name|getLine
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|genLineNo2
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Print a header action by #line stuff also process any tree construction 	 * @param name The name of the header part 	 */
DECL|method|printHeaderAction (String name)
specifier|public
name|void
name|printHeaderAction
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|Token
name|a
init|=
operator|(
name|antlr
operator|.
name|Token
operator|)
name|behavior
operator|.
name|headerActions
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|!=
literal|null
condition|)
block|{
name|genLineNo
argument_list|(
name|a
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|println
argument_list|(
name|processActionForSpecialSymbols
argument_list|(
name|a
operator|.
name|getText
argument_list|()
argument_list|,
name|a
operator|.
name|getLine
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|genLineNo2
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Output a String followed by newline, to the currentOutput stream. 	 * Ignored if string is null. 	 * @param s The string to output 	 */
DECL|method|_println (String s)
specifier|protected
name|void
name|_println
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|outputLine
operator|+=
name|countLines
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
name|currentOutput
operator|.
name|println
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Output tab indent followed by a String followed by newline, 	 * to the currentOutput stream.  Ignored if string is null. 	 * @param s The string to output 	 */
DECL|method|println (String s)
specifier|protected
name|void
name|println
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|printTabs
argument_list|()
expr_stmt|;
name|outputLine
operator|+=
name|countLines
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
name|currentOutput
operator|.
name|println
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate a #line or // line depending on options */
DECL|method|genLineNo (int line)
specifier|public
name|void
name|genLineNo
parameter_list|(
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|line
operator|==
literal|0
condition|)
block|{
name|line
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|genHashLines
condition|)
name|_println
argument_list|(
literal|"#line "
operator|+
name|line
operator|+
literal|" \""
operator|+
name|antlrTool
operator|.
name|fileMinusPath
argument_list|(
name|antlrTool
operator|.
name|grammarFile
argument_list|)
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
comment|/** Generate a #line or // line depending on options */
DECL|method|genLineNo (GrammarElement el)
specifier|public
name|void
name|genLineNo
parameter_list|(
name|GrammarElement
name|el
parameter_list|)
block|{
if|if
condition|(
name|el
operator|!=
literal|null
condition|)
name|genLineNo
argument_list|(
name|el
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Generate a #line or // line depending on options */
DECL|method|genLineNo (Token t)
specifier|public
name|void
name|genLineNo
parameter_list|(
name|Token
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
name|genLineNo
argument_list|(
name|t
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Generate a #line or // line depending on options */
DECL|method|genLineNo2 ()
specifier|public
name|void
name|genLineNo2
parameter_list|()
block|{
if|if
condition|(
name|genHashLines
condition|)
block|{
name|_println
argument_list|(
literal|"#line "
operator|+
operator|(
name|outputLine
operator|+
literal|1
operator|)
operator|+
literal|" \""
operator|+
name|outputFile
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
block|}
comment|/// Bound safe isDigit
DECL|method|charIsDigit ( String s, int i )
specifier|private
name|boolean
name|charIsDigit
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
operator|(
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
operator|)
operator|&&
name|Character
operator|.
name|isDigit
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
return|;
block|}
comment|/** Normalize a string coming from antlr's lexer. E.g. translate java 	 * escapes to values. Check their size (multibyte) bomb out if they are 	 * multibyte (bit crude). Then reescape to C++ style things. 	 * Used to generate strings for match() and matchRange() 	 * @param lit the literal string 	 * @param isCharLiteral if it's for a character literal 	 *                       (enforced to be one length) and enclosed in ' 	 * FIXME: bombing out on mb chars. Should be done in Lexer. 	 * FIXME: this is another horrible hack. 	 * FIXME: life would be soooo much easier if the stuff from the lexer was 	 * normalized in some way. 	 */
DECL|method|convertJavaToCppString ( String lit, boolean isCharLiteral )
specifier|private
name|String
name|convertJavaToCppString
parameter_list|(
name|String
name|lit
parameter_list|,
name|boolean
name|isCharLiteral
parameter_list|)
block|{
comment|// System.out.println("convertJavaToCppLiteral: "+lit);
name|String
name|ret
init|=
operator|new
name|String
argument_list|()
decl_stmt|;
name|String
name|s
init|=
name|lit
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isCharLiteral
condition|)
comment|// verify& strip off quotes
block|{
if|if
condition|(
operator|!
name|lit
operator|.
name|startsWith
argument_list|(
literal|"'"
argument_list|)
operator|||
operator|!
name|lit
operator|.
name|endsWith
argument_list|(
literal|"'"
argument_list|)
condition|)
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Invalid character literal: '"
operator|+
name|lit
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|s
operator|=
name|lit
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|lit
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|==
name|i
operator|+
literal|1
condition|)
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Invalid escape in char literal: '"
operator|+
name|lit
operator|+
literal|"' looking at '"
operator|+
name|s
operator|.
name|substring
argument_list|(
name|i
argument_list|)
operator|+
literal|"'"
argument_list|)
expr_stmt|;
comment|// deal with escaped junk
switch|switch
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
condition|)
block|{
case|case
literal|'a'
case|:
name|val
operator|=
literal|7
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|val
operator|=
literal|8
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|val
operator|=
literal|9
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|val
operator|=
literal|10
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|val
operator|=
literal|12
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|val
operator|=
literal|13
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
case|case
literal|'\\'
case|:
name|val
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|// Unicode char \u1234
if|if
condition|(
name|i
operator|+
literal|5
operator|<
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
name|val
operator|=
name|Character
operator|.
name|digit
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|2
argument_list|)
argument_list|,
literal|16
argument_list|)
operator|*
literal|16
operator|*
literal|16
operator|*
literal|16
operator|+
name|Character
operator|.
name|digit
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|3
argument_list|)
argument_list|,
literal|16
argument_list|)
operator|*
literal|16
operator|*
literal|16
operator|+
name|Character
operator|.
name|digit
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|4
argument_list|)
argument_list|,
literal|16
argument_list|)
operator|*
literal|16
operator|+
name|Character
operator|.
name|digit
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|5
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|6
expr_stmt|;
block|}
else|else
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Invalid escape in char literal: '"
operator|+
name|lit
operator|+
literal|"' looking at '"
operator|+
name|s
operator|.
name|substring
argument_list|(
name|i
argument_list|)
operator|+
literal|"'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
comment|// \123
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
if|if
condition|(
name|charIsDigit
argument_list|(
name|s
argument_list|,
name|i
operator|+
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
name|charIsDigit
argument_list|(
name|s
argument_list|,
name|i
operator|+
literal|3
argument_list|)
condition|)
block|{
name|val
operator|=
operator|(
name|s
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|-
literal|'0'
operator|)
operator|*
literal|8
operator|*
literal|8
operator|+
operator|(
name|s
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|2
argument_list|)
operator|-
literal|'0'
operator|)
operator|*
literal|8
operator|+
operator|(
name|s
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|3
argument_list|)
operator|-
literal|'0'
operator|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|(
name|s
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|-
literal|'0'
operator|)
operator|*
literal|8
operator|+
operator|(
name|s
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|2
argument_list|)
operator|-
literal|'0'
operator|)
expr_stmt|;
name|i
operator|+=
literal|3
expr_stmt|;
block|}
block|}
else|else
block|{
name|val
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|-
literal|'0'
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
if|if
condition|(
name|charIsDigit
argument_list|(
name|s
argument_list|,
name|i
operator|+
literal|2
argument_list|)
condition|)
block|{
name|val
operator|=
operator|(
name|s
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|-
literal|'0'
operator|)
operator|*
literal|8
operator|+
operator|(
name|s
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|2
argument_list|)
operator|-
literal|'0'
operator|)
expr_stmt|;
name|i
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|-
literal|'0'
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
default|default:
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Unhandled escape in char literal: '"
operator|+
name|lit
operator|+
literal|"' looking at '"
operator|+
name|s
operator|.
name|substring
argument_list|(
name|i
argument_list|)
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|val
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|isCharLiteral
condition|)
block|{
comment|// we should be at end of char literal here..
if|if
condition|(
name|i
operator|!=
name|s
operator|.
name|length
argument_list|()
condition|)
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Invalid char literal: '"
operator|+
name|lit
operator|+
literal|"'"
argument_list|)
expr_stmt|;
comment|//				if( val>= ' '&& val<= 126 )	// just concat if printable
comment|//					ret = "'"+(char)val+"'";
comment|//				else
if|if
condition|(
name|val
operator|>
literal|255
condition|)
comment|// abort if multibyte
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Multibyte character found in char literal: '"
operator|+
name|lit
operator|+
literal|"'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|255
condition|)
comment|// the joys of sign extension in the support lib *cough*
name|ret
operator|=
literal|"static_cast<unsigned char>(255)"
expr_stmt|;
else|else
name|ret
operator|=
literal|"'"
operator|+
name|charFormatter
operator|.
name|escapeChar
argument_list|(
name|val
argument_list|,
literal|true
argument_list|)
operator|+
literal|"'"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|val
operator|>=
literal|' '
operator|&&
name|val
operator|<=
literal|126
condition|)
comment|// just concat if printable
name|ret
operator|+=
operator|(
name|char
operator|)
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|>
literal|255
condition|)
comment|// abort if multibyte
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Multibyte character found in string constant: '"
operator|+
name|s
operator|+
literal|"'"
argument_list|)
expr_stmt|;
else|else
name|ret
operator|+=
name|charFormatter
operator|.
name|escapeChar
argument_list|(
name|val
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|// System.out.println("convertJavaToCppLiteral: "+lit+" -> "+ret);
return|return
name|ret
return|;
block|}
comment|/** Generate the parser, lexer, treeparser, and token types in C++ 	 */
DECL|method|gen ()
specifier|public
name|void
name|gen
parameter_list|()
block|{
comment|// Do the code generation
try|try
block|{
comment|// Loop over all grammars
name|Enumeration
name|grammarIter
init|=
name|behavior
operator|.
name|grammars
operator|.
name|elements
argument_list|()
decl_stmt|;
while|while
condition|(
name|grammarIter
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|Grammar
name|g
init|=
operator|(
name|Grammar
operator|)
name|grammarIter
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|g
operator|.
name|debuggingOutput
condition|)
block|{
name|antlrTool
operator|.
name|error
argument_list|(
name|g
operator|.
name|getFilename
argument_list|()
operator|+
literal|": C++ mode does not support -debug"
argument_list|)
expr_stmt|;
block|}
comment|// Connect all the components to each other
name|g
operator|.
name|setGrammarAnalyzer
argument_list|(
name|analyzer
argument_list|)
expr_stmt|;
name|g
operator|.
name|setCodeGenerator
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|setGrammar
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|// To get right overloading behavior across hetrogeneous grammars
name|setupGrammarParameters
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|g
operator|.
name|generate
argument_list|()
expr_stmt|;
name|exitIfError
argument_list|()
expr_stmt|;
block|}
comment|// Loop over all token managers (some of which are lexers)
name|Enumeration
name|tmIter
init|=
name|behavior
operator|.
name|tokenManagers
operator|.
name|elements
argument_list|()
decl_stmt|;
while|while
condition|(
name|tmIter
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|TokenManager
name|tm
init|=
operator|(
name|TokenManager
operator|)
name|tmIter
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|tm
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
comment|// Write the token manager tokens as C++
comment|// this must appear before genTokenInterchange so that
comment|// labels are set on string literals
name|genTokenTypes
argument_list|(
name|tm
argument_list|)
expr_stmt|;
comment|// Write the token manager tokens as plain text
name|genTokenInterchange
argument_list|(
name|tm
argument_list|)
expr_stmt|;
block|}
name|exitIfError
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|antlrTool
operator|.
name|reportException
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The {...} action to generate 	 */
DECL|method|gen (ActionElement action)
specifier|public
name|void
name|gen
parameter_list|(
name|ActionElement
name|action
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"genAction("
operator|+
name|action
operator|+
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|.
name|isSemPred
condition|)
block|{
name|genSemPred
argument_list|(
name|action
operator|.
name|actionText
argument_list|,
name|action
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|grammar
operator|.
name|hasSyntacticPredicate
condition|)
block|{
name|println
argument_list|(
literal|"if ( inputState->guessing==0 ) {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
block|}
name|ActionTransInfo
name|tInfo
init|=
operator|new
name|ActionTransInfo
argument_list|()
decl_stmt|;
name|String
name|actionStr
init|=
name|processActionForSpecialSymbols
argument_list|(
name|action
operator|.
name|actionText
argument_list|,
name|action
operator|.
name|getLine
argument_list|()
argument_list|,
name|currentRule
argument_list|,
name|tInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|tInfo
operator|.
name|refRuleRoot
operator|!=
literal|null
condition|)
block|{
comment|// Somebody referenced "#rule", make sure translated var is valid
comment|// assignment to #rule is left as a ref also, meaning that assignments
comment|// with no other refs like "#rule = foo();" still forces this code to be
comment|// generated (unnecessarily).
name|println
argument_list|(
name|tInfo
operator|.
name|refRuleRoot
operator|+
literal|" = "
operator|+
name|labeledElementASTType
operator|+
literal|"(currentAST.root);"
argument_list|)
expr_stmt|;
block|}
comment|// dump the translated action
name|genLineNo
argument_list|(
name|action
argument_list|)
expr_stmt|;
name|printAction
argument_list|(
name|actionStr
argument_list|)
expr_stmt|;
name|genLineNo2
argument_list|()
expr_stmt|;
if|if
condition|(
name|tInfo
operator|.
name|assignToRoot
condition|)
block|{
comment|// Somebody did a "#rule=", reset internal currentAST.root
name|println
argument_list|(
literal|"currentAST.root = "
operator|+
name|tInfo
operator|.
name|refRuleRoot
operator|+
literal|";"
argument_list|)
expr_stmt|;
comment|// reset the child pointer too to be last sibling in sibling list
comment|// now use if else in stead of x ? y : z to shut CC 4.2 up.
name|println
argument_list|(
literal|"if ( "
operator|+
name|tInfo
operator|.
name|refRuleRoot
operator|+
literal|"!="
operator|+
name|labeledElementASTInit
operator|+
literal|"&&"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
name|tInfo
operator|.
name|refRuleRoot
operator|+
literal|"->getFirstChild() != "
operator|+
name|labeledElementASTInit
operator|+
literal|" )"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"  currentAST.child = "
operator|+
name|tInfo
operator|.
name|refRuleRoot
operator|+
literal|"->getFirstChild();"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"else"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"currentAST.child = "
operator|+
name|tInfo
operator|.
name|refRuleRoot
operator|+
literal|";"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"currentAST.advanceChildToEnd();"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|grammar
operator|.
name|hasSyntacticPredicate
condition|)
block|{
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The "x|y|z|..." block to generate 	 */
DECL|method|gen (AlternativeBlock blk)
specifier|public
name|void
name|gen
parameter_list|(
name|AlternativeBlock
name|blk
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"gen("
operator|+
name|blk
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|genBlockPreamble
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|genBlockInitAction
argument_list|(
name|blk
argument_list|)
expr_stmt|;
comment|// Tell AST generation to build subrule result
name|String
name|saveCurrentASTResult
init|=
name|currentASTResult
decl_stmt|;
if|if
condition|(
name|blk
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|currentASTResult
operator|=
name|blk
operator|.
name|getLabel
argument_list|()
expr_stmt|;
block|}
name|boolean
name|ok
init|=
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|deterministic
argument_list|(
name|blk
argument_list|)
decl_stmt|;
name|CppBlockFinishingInfo
name|howToFinish
init|=
name|genCommonBlock
argument_list|(
name|blk
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|genBlockFinish
argument_list|(
name|howToFinish
argument_list|,
name|throwNoViable
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
comment|// Restore previous AST generation
name|currentASTResult
operator|=
name|saveCurrentASTResult
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The block-end element to generate.  Block-end 	 * elements are synthesized by the grammar parser to represent 	 * the end of a block. 	 */
DECL|method|gen (BlockEndElement end)
specifier|public
name|void
name|gen
parameter_list|(
name|BlockEndElement
name|end
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"genRuleEnd("
operator|+
name|end
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element. 	 * Only called from lexer grammars. 	 * @param blk The character literal reference to generate 	 */
DECL|method|gen (CharLiteralElement atom)
specifier|public
name|void
name|gen
parameter_list|(
name|CharLiteralElement
name|atom
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"genChar("
operator|+
name|atom
operator|+
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
condition|)
name|antlrTool
operator|.
name|error
argument_list|(
literal|"cannot ref character literals in grammar: "
operator|+
name|atom
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
name|atom
operator|.
name|getLabel
argument_list|()
operator|+
literal|" = "
operator|+
name|lt1Value
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
name|boolean
name|oldsaveText
init|=
name|saveText
decl_stmt|;
name|saveText
operator|=
name|saveText
operator|&&
name|atom
operator|.
name|getAutoGenType
argument_list|()
operator|==
name|GrammarElement
operator|.
name|AUTO_GEN_NONE
expr_stmt|;
comment|// if in lexer and ! on element, save buffer index to kill later
if|if
condition|(
operator|!
name|saveText
operator|||
name|atom
operator|.
name|getAutoGenType
argument_list|()
operator|==
name|GrammarElement
operator|.
name|AUTO_GEN_BANG
condition|)
name|println
argument_list|(
literal|"_saveIndex = text.length();"
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|atom
operator|.
name|not
condition|?
literal|"matchNot("
else|:
literal|"match("
argument_list|)
expr_stmt|;
name|_print
argument_list|(
name|convertJavaToCppString
argument_list|(
name|atom
operator|.
name|atomText
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|_println
argument_list|(
literal|");"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|saveText
operator|||
name|atom
operator|.
name|getAutoGenType
argument_list|()
operator|==
name|GrammarElement
operator|.
name|AUTO_GEN_BANG
condition|)
name|println
argument_list|(
literal|"text.erase(_saveIndex);"
argument_list|)
expr_stmt|;
comment|// kill text atom put in buffer
name|saveText
operator|=
name|oldsaveText
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element. 	 * Only called from lexer grammars. 	 * @param blk The character-range reference to generate 	 */
DECL|method|gen (CharRangeElement r)
specifier|public
name|void
name|gen
parameter_list|(
name|CharRangeElement
name|r
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"genCharRangeElement("
operator|+
name|r
operator|.
name|beginText
operator|+
literal|".."
operator|+
name|r
operator|.
name|endText
operator|+
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
condition|)
name|antlrTool
operator|.
name|error
argument_list|(
literal|"cannot ref character range in grammar: "
operator|+
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
operator|&&
name|syntacticPredLevel
operator|==
literal|0
condition|)
block|{
name|println
argument_list|(
name|r
operator|.
name|getLabel
argument_list|()
operator|+
literal|" = "
operator|+
name|lt1Value
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
comment|// Correctly take care of saveIndex stuff...
name|boolean
name|save
init|=
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|&&
operator|(
operator|!
name|saveText
operator|||
name|r
operator|.
name|getAutoGenType
argument_list|()
operator|==
name|GrammarElement
operator|.
name|AUTO_GEN_BANG
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|save
condition|)
name|println
argument_list|(
literal|"_saveIndex=text.length();"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"matchRange("
operator|+
name|convertJavaToCppString
argument_list|(
name|r
operator|.
name|beginText
argument_list|,
literal|true
argument_list|)
operator|+
literal|","
operator|+
name|convertJavaToCppString
argument_list|(
name|r
operator|.
name|endText
argument_list|,
literal|true
argument_list|)
operator|+
literal|");"
argument_list|)
expr_stmt|;
if|if
condition|(
name|save
condition|)
name|println
argument_list|(
literal|"text.setLength(_saveIndex);"
argument_list|)
expr_stmt|;
block|}
comment|/** Generate the lexer C++ files */
DECL|method|gen (LexerGrammar g)
specifier|public
name|void
name|gen
parameter_list|(
name|LexerGrammar
name|g
parameter_list|)
throws|throws
name|IOException
block|{
comment|// If debugging, create a new sempred vector for this grammar
if|if
condition|(
name|g
operator|.
name|debuggingOutput
condition|)
name|semPreds
operator|=
operator|new
name|Vector
argument_list|()
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|charVocabulary
operator|.
name|size
argument_list|()
operator|>
literal|256
condition|)
name|antlrTool
operator|.
name|warning
argument_list|(
name|g
operator|.
name|getFilename
argument_list|()
operator|+
literal|": C++ mode does not support more than 8 bit characters (vocabulary size now: "
operator|+
name|g
operator|.
name|charVocabulary
operator|.
name|size
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|setGrammar
argument_list|(
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
condition|)
block|{
name|antlrTool
operator|.
name|panic
argument_list|(
literal|"Internal error generating lexer"
argument_list|)
expr_stmt|;
block|}
name|genBody
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|genInclude
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The (...)+ block to generate 	 */
DECL|method|gen (OneOrMoreBlock blk)
specifier|public
name|void
name|gen
parameter_list|(
name|OneOrMoreBlock
name|blk
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"gen+("
operator|+
name|blk
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|String
name|label
decl_stmt|;
name|String
name|cnt
decl_stmt|;
name|println
argument_list|(
literal|"{ // ( ... )+"
argument_list|)
expr_stmt|;
name|genBlockPreamble
argument_list|(
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|cnt
operator|=
literal|"_cnt_"
operator|+
name|blk
operator|.
name|getLabel
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|cnt
operator|=
literal|"_cnt"
operator|+
name|blk
operator|.
name|ID
expr_stmt|;
block|}
name|println
argument_list|(
literal|"int "
operator|+
name|cnt
operator|+
literal|"=0;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|label
operator|=
name|blk
operator|.
name|getLabel
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|label
operator|=
literal|"_loop"
operator|+
name|blk
operator|.
name|ID
expr_stmt|;
block|}
name|println
argument_list|(
literal|"for (;;) {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// generate the init action for ()+ ()* inside the loop
comment|// this allows us to do usefull EOF checking...
name|genBlockInitAction
argument_list|(
name|blk
argument_list|)
expr_stmt|;
comment|// Tell AST generation to build subrule result
name|String
name|saveCurrentASTResult
init|=
name|currentASTResult
decl_stmt|;
if|if
condition|(
name|blk
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|currentASTResult
operator|=
name|blk
operator|.
name|getLabel
argument_list|()
expr_stmt|;
block|}
name|boolean
name|ok
init|=
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|deterministic
argument_list|(
name|blk
argument_list|)
decl_stmt|;
comment|// generate exit test if greedy set to false
comment|// and an alt is ambiguous with exit branch
comment|// or when lookahead derived purely from end-of-file
comment|// Lookahead analysis stops when end-of-file is hit,
comment|// returning set {epsilon}.  Since {epsilon} is not
comment|// ambig with any real tokens, no error is reported
comment|// by deterministic() routines and we have to check
comment|// for the case where the lookahead depth didn't get
comment|// set to NONDETERMINISTIC (this only happens when the
comment|// FOLLOW contains real atoms + epsilon).
name|boolean
name|generateNonGreedyExitPath
init|=
literal|false
decl_stmt|;
name|int
name|nonGreedyExitDepth
init|=
name|grammar
operator|.
name|maxk
decl_stmt|;
if|if
condition|(
operator|!
name|blk
operator|.
name|greedy
operator|&&
name|blk
operator|.
name|exitLookaheadDepth
operator|<=
name|grammar
operator|.
name|maxk
operator|&&
name|blk
operator|.
name|exitCache
index|[
name|blk
operator|.
name|exitLookaheadDepth
index|]
operator|.
name|containsEpsilon
argument_list|()
condition|)
block|{
name|generateNonGreedyExitPath
operator|=
literal|true
expr_stmt|;
name|nonGreedyExitDepth
operator|=
name|blk
operator|.
name|exitLookaheadDepth
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|blk
operator|.
name|greedy
operator|&&
name|blk
operator|.
name|exitLookaheadDepth
operator|==
name|LLkGrammarAnalyzer
operator|.
name|NONDETERMINISTIC
condition|)
block|{
name|generateNonGreedyExitPath
operator|=
literal|true
expr_stmt|;
block|}
comment|// generate exit test if greedy set to false
comment|// and an alt is ambiguous with exit branch
if|if
condition|(
name|generateNonGreedyExitPath
condition|)
block|{
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"nongreedy (...)+ loop; exit depth is "
operator|+
name|blk
operator|.
name|exitLookaheadDepth
argument_list|)
expr_stmt|;
block|}
name|String
name|predictExit
init|=
name|getLookaheadTestExpression
argument_list|(
name|blk
operator|.
name|exitCache
argument_list|,
name|nonGreedyExitDepth
argument_list|)
decl_stmt|;
name|println
argument_list|(
literal|"// nongreedy exit test"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"if ( "
operator|+
name|cnt
operator|+
literal|">=1&& "
operator|+
name|predictExit
operator|+
literal|") goto "
operator|+
name|label
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
name|CppBlockFinishingInfo
name|howToFinish
init|=
name|genCommonBlock
argument_list|(
name|blk
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|genBlockFinish
argument_list|(
name|howToFinish
argument_list|,
literal|"if ( "
operator|+
name|cnt
operator|+
literal|">=1 ) { goto "
operator|+
name|label
operator|+
literal|"; } else {"
operator|+
name|throwNoViable
operator|+
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
name|cnt
operator|+
literal|"++;"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
name|label
operator|+
literal|":;"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"}  // ( ... )+"
argument_list|)
expr_stmt|;
comment|// Restore previous AST generation
name|currentASTResult
operator|=
name|saveCurrentASTResult
expr_stmt|;
block|}
comment|/** Generate the parser C++ file */
DECL|method|gen (ParserGrammar g)
specifier|public
name|void
name|gen
parameter_list|(
name|ParserGrammar
name|g
parameter_list|)
throws|throws
name|IOException
block|{
comment|// if debugging, set up a new vector to keep track of sempred
comment|//   strings for this grammar
if|if
condition|(
name|g
operator|.
name|debuggingOutput
condition|)
name|semPreds
operator|=
operator|new
name|Vector
argument_list|()
expr_stmt|;
name|setGrammar
argument_list|(
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|grammar
operator|instanceof
name|ParserGrammar
operator|)
condition|)
block|{
name|antlrTool
operator|.
name|panic
argument_list|(
literal|"Internal error generating parser"
argument_list|)
expr_stmt|;
block|}
name|genBody
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|genInclude
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The rule-reference to generate 	 */
DECL|method|gen (RuleRefElement rr)
specifier|public
name|void
name|gen
parameter_list|(
name|RuleRefElement
name|rr
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"genRR("
operator|+
name|rr
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|grammar
operator|.
name|getSymbol
argument_list|(
name|rr
operator|.
name|targetRule
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|==
literal|null
operator|||
operator|!
name|rs
operator|.
name|isDefined
argument_list|()
condition|)
block|{
comment|// Is this redundant???
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Rule '"
operator|+
name|rr
operator|.
name|targetRule
operator|+
literal|"' is not defined"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|rr
operator|.
name|getLine
argument_list|()
argument_list|,
name|rr
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|rs
operator|instanceof
name|RuleSymbol
operator|)
condition|)
block|{
comment|// Is this redundant???
name|antlrTool
operator|.
name|error
argument_list|(
literal|"'"
operator|+
name|rr
operator|.
name|targetRule
operator|+
literal|"' does not name a grammar rule"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|rr
operator|.
name|getLine
argument_list|()
argument_list|,
name|rr
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|genErrorTryForElement
argument_list|(
name|rr
argument_list|)
expr_stmt|;
comment|// AST value for labeled rule refs in tree walker.
comment|// This is not AST construction;  it is just the input tree node value.
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
operator|&&
name|rr
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
operator|&&
name|syntacticPredLevel
operator|==
literal|0
condition|)
block|{
name|println
argument_list|(
name|rr
operator|.
name|getLabel
argument_list|()
operator|+
literal|" = (_t == ASTNULL) ? "
operator|+
name|labeledElementASTInit
operator|+
literal|" : "
operator|+
name|lt1Value
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
comment|// if in lexer and ! on rule ref or alt or rule, save buffer index to
comment|// kill later
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|&&
operator|(
operator|!
name|saveText
operator|||
name|rr
operator|.
name|getAutoGenType
argument_list|()
operator|==
name|GrammarElement
operator|.
name|AUTO_GEN_BANG
operator|)
condition|)
block|{
name|println
argument_list|(
literal|"_saveIndex = text.length();"
argument_list|)
expr_stmt|;
block|}
comment|// Process return value assignment if any
name|printTabs
argument_list|()
expr_stmt|;
if|if
condition|(
name|rr
operator|.
name|idAssign
operator|!=
literal|null
condition|)
block|{
comment|// Warn if the rule has no return type
if|if
condition|(
name|rs
operator|.
name|block
operator|.
name|returnAction
operator|==
literal|null
condition|)
block|{
name|antlrTool
operator|.
name|warning
argument_list|(
literal|"Rule '"
operator|+
name|rr
operator|.
name|targetRule
operator|+
literal|"' has no return type"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|rr
operator|.
name|getLine
argument_list|()
argument_list|,
name|rr
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|_print
argument_list|(
name|rr
operator|.
name|idAssign
operator|+
literal|"="
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Warn about return value if any, but not inside syntactic predicate
if|if
condition|(
operator|!
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
operator|&&
name|syntacticPredLevel
operator|==
literal|0
operator|&&
name|rs
operator|.
name|block
operator|.
name|returnAction
operator|!=
literal|null
condition|)
block|{
name|antlrTool
operator|.
name|warning
argument_list|(
literal|"Rule '"
operator|+
name|rr
operator|.
name|targetRule
operator|+
literal|"' returns a value"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|rr
operator|.
name|getLine
argument_list|()
argument_list|,
name|rr
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Call the rule
name|GenRuleInvocation
argument_list|(
name|rr
argument_list|)
expr_stmt|;
comment|// if in lexer and ! on element or alt or rule, save buffer index to kill later
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|&&
operator|(
operator|!
name|saveText
operator|||
name|rr
operator|.
name|getAutoGenType
argument_list|()
operator|==
name|GrammarElement
operator|.
name|AUTO_GEN_BANG
operator|)
condition|)
block|{
name|println
argument_list|(
literal|"text.erase(_saveIndex);"
argument_list|)
expr_stmt|;
block|}
comment|// if not in a syntactic predicate
if|if
condition|(
name|syntacticPredLevel
operator|==
literal|0
condition|)
block|{
name|boolean
name|doNoGuessTest
init|=
operator|(
name|grammar
operator|.
name|hasSyntacticPredicate
operator|&&
operator|(
name|grammar
operator|.
name|buildAST
operator|&&
name|rr
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
operator|||
operator|(
name|genAST
operator|&&
name|rr
operator|.
name|getAutoGenType
argument_list|()
operator|==
name|GrammarElement
operator|.
name|AUTO_GEN_NONE
operator|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|doNoGuessTest
condition|)
block|{
name|println
argument_list|(
literal|"if (inputState->guessing==0) {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|grammar
operator|.
name|buildAST
operator|&&
name|rr
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// always gen variable for rule return on labeled rules
comment|// RK: hmm do I know here if the returnAST needs a cast ?
name|println
argument_list|(
name|rr
operator|.
name|getLabel
argument_list|()
operator|+
literal|"_AST = returnAST;"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|genAST
condition|)
block|{
switch|switch
condition|(
name|rr
operator|.
name|getAutoGenType
argument_list|()
condition|)
block|{
case|case
name|GrammarElement
operator|.
name|AUTO_GEN_NONE
case|:
if|if
condition|(
name|usingCustomAST
condition|)
name|println
argument_list|(
literal|"astFactory->addASTChild(currentAST, "
operator|+
name|namespaceAntlr
operator|+
literal|"RefAST(returnAST));"
argument_list|)
expr_stmt|;
else|else
name|println
argument_list|(
literal|"astFactory->addASTChild( currentAST, returnAST );"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GrammarElement
operator|.
name|AUTO_GEN_CARET
case|:
comment|// FIXME: RK: I'm not so sure this should be an error..
comment|// I think it might actually work and be usefull at times.
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Internal: encountered ^ after rule reference"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|// if a lexer and labeled, Token label defined at rule level, just set it here
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|&&
name|rr
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
name|rr
operator|.
name|getLabel
argument_list|()
operator|+
literal|"=_returnToken;"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doNoGuessTest
condition|)
block|{
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
block|}
name|genErrorCatchForElement
argument_list|(
name|rr
argument_list|)
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The string-literal reference to generate 	 */
DECL|method|gen (StringLiteralElement atom)
specifier|public
name|void
name|gen
parameter_list|(
name|StringLiteralElement
name|atom
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"genString("
operator|+
name|atom
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// Variable declarations for labeled elements
if|if
condition|(
name|atom
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
operator|&&
name|syntacticPredLevel
operator|==
literal|0
condition|)
block|{
name|println
argument_list|(
name|atom
operator|.
name|getLabel
argument_list|()
operator|+
literal|" = "
operator|+
name|lt1Value
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
comment|// AST
name|genElementAST
argument_list|(
name|atom
argument_list|)
expr_stmt|;
comment|// is there a bang on the literal?
name|boolean
name|oldsaveText
init|=
name|saveText
decl_stmt|;
name|saveText
operator|=
name|saveText
operator|&&
name|atom
operator|.
name|getAutoGenType
argument_list|()
operator|==
name|GrammarElement
operator|.
name|AUTO_GEN_NONE
expr_stmt|;
comment|// matching
name|genMatch
argument_list|(
name|atom
argument_list|)
expr_stmt|;
name|saveText
operator|=
name|oldsaveText
expr_stmt|;
comment|// tack on tree cursor motion if doing a tree walker
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
name|println
argument_list|(
literal|"_t = _t->getNextSibling();"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The token-range reference to generate 	 */
DECL|method|gen (TokenRangeElement r)
specifier|public
name|void
name|gen
parameter_list|(
name|TokenRangeElement
name|r
parameter_list|)
block|{
name|genErrorTryForElement
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
operator|&&
name|syntacticPredLevel
operator|==
literal|0
condition|)
block|{
name|println
argument_list|(
name|r
operator|.
name|getLabel
argument_list|()
operator|+
literal|" = "
operator|+
name|lt1Value
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
comment|// AST
name|genElementAST
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|// match
name|println
argument_list|(
literal|"matchRange("
operator|+
name|r
operator|.
name|beginText
operator|+
literal|","
operator|+
name|r
operator|.
name|endText
operator|+
literal|");"
argument_list|)
expr_stmt|;
name|genErrorCatchForElement
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The token-reference to generate 	 */
DECL|method|gen (TokenRefElement atom)
specifier|public
name|void
name|gen
parameter_list|(
name|TokenRefElement
name|atom
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"genTokenRef("
operator|+
name|atom
operator|+
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
block|{
name|antlrTool
operator|.
name|panic
argument_list|(
literal|"Token reference found in lexer"
argument_list|)
expr_stmt|;
block|}
name|genErrorTryForElement
argument_list|(
name|atom
argument_list|)
expr_stmt|;
comment|// Assign Token value to token label variable
if|if
condition|(
name|atom
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
operator|&&
name|syntacticPredLevel
operator|==
literal|0
condition|)
block|{
name|println
argument_list|(
name|atom
operator|.
name|getLabel
argument_list|()
operator|+
literal|" = "
operator|+
name|lt1Value
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
comment|// AST
name|genElementAST
argument_list|(
name|atom
argument_list|)
expr_stmt|;
comment|// matching
name|genMatch
argument_list|(
name|atom
argument_list|)
expr_stmt|;
name|genErrorCatchForElement
argument_list|(
name|atom
argument_list|)
expr_stmt|;
comment|// tack on tree cursor motion if doing a tree walker
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
name|println
argument_list|(
literal|"_t = _t->getNextSibling();"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|gen (TreeElement t)
specifier|public
name|void
name|gen
parameter_list|(
name|TreeElement
name|t
parameter_list|)
block|{
comment|// save AST cursor
name|println
argument_list|(
name|labeledElementType
operator|+
literal|" __t"
operator|+
name|t
operator|.
name|ID
operator|+
literal|" = _t;"
argument_list|)
expr_stmt|;
comment|// If there is a label on the root, then assign that to the variable
if|if
condition|(
name|t
operator|.
name|root
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
name|t
operator|.
name|root
operator|.
name|getLabel
argument_list|()
operator|+
literal|" = (_t == ASTNULL) ? "
operator|+
name|labeledElementASTInit
operator|+
literal|" : _t;"
argument_list|)
expr_stmt|;
block|}
comment|// check for invalid modifiers ! and ^ on tree element roots
if|if
condition|(
name|t
operator|.
name|root
operator|.
name|getAutoGenType
argument_list|()
operator|==
name|GrammarElement
operator|.
name|AUTO_GEN_BANG
condition|)
block|{
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Suffixing a root node with '!' is not implemented"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|t
operator|.
name|getLine
argument_list|()
argument_list|,
name|t
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|root
operator|.
name|setAutoGenType
argument_list|(
name|GrammarElement
operator|.
name|AUTO_GEN_NONE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|.
name|root
operator|.
name|getAutoGenType
argument_list|()
operator|==
name|GrammarElement
operator|.
name|AUTO_GEN_CARET
condition|)
block|{
name|antlrTool
operator|.
name|warning
argument_list|(
literal|"Suffixing a root node with '^' is redundant; already a root"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|t
operator|.
name|getLine
argument_list|()
argument_list|,
name|t
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|root
operator|.
name|setAutoGenType
argument_list|(
name|GrammarElement
operator|.
name|AUTO_GEN_NONE
argument_list|)
expr_stmt|;
block|}
comment|// Generate AST variables
name|genElementAST
argument_list|(
name|t
operator|.
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|grammar
operator|.
name|buildAST
condition|)
block|{
comment|// Save the AST construction state
name|println
argument_list|(
name|namespaceAntlr
operator|+
literal|"ASTPair __currentAST"
operator|+
name|t
operator|.
name|ID
operator|+
literal|" = currentAST;"
argument_list|)
expr_stmt|;
comment|// Make the next item added a child of the TreeElement root
name|println
argument_list|(
literal|"currentAST.root = currentAST.child;"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"currentAST.child = "
operator|+
name|labeledElementASTInit
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
comment|// match root
if|if
condition|(
name|t
operator|.
name|root
operator|instanceof
name|WildcardElement
condition|)
block|{
name|println
argument_list|(
literal|"if ( _t == ASTNULL ) throw "
operator|+
name|namespaceAntlr
operator|+
literal|"MismatchedTokenException();"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|genMatch
argument_list|(
name|t
operator|.
name|root
argument_list|)
expr_stmt|;
block|}
comment|// move to list of children
name|println
argument_list|(
literal|"_t = _t->getFirstChild();"
argument_list|)
expr_stmt|;
comment|// walk list of children, generating code for each
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|t
operator|.
name|getAlternatives
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Alternative
name|a
init|=
name|t
operator|.
name|getAlternativeAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|AlternativeElement
name|e
init|=
name|a
operator|.
name|head
decl_stmt|;
while|while
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
name|e
operator|.
name|generate
argument_list|()
expr_stmt|;
name|e
operator|=
name|e
operator|.
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|grammar
operator|.
name|buildAST
condition|)
block|{
comment|// restore the AST construction state to that just after the
comment|// tree root was added
name|println
argument_list|(
literal|"currentAST = __currentAST"
operator|+
name|t
operator|.
name|ID
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
comment|// restore AST cursor
name|println
argument_list|(
literal|"_t = __t"
operator|+
name|t
operator|.
name|ID
operator|+
literal|";"
argument_list|)
expr_stmt|;
comment|// move cursor to sibling of tree just parsed
name|println
argument_list|(
literal|"_t = _t->getNextSibling();"
argument_list|)
expr_stmt|;
block|}
comment|/** Generate the tree-parser C++ files */
DECL|method|gen (TreeWalkerGrammar g)
specifier|public
name|void
name|gen
parameter_list|(
name|TreeWalkerGrammar
name|g
parameter_list|)
throws|throws
name|IOException
block|{
name|setGrammar
argument_list|(
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
operator|)
condition|)
block|{
name|antlrTool
operator|.
name|panic
argument_list|(
literal|"Internal error generating tree-walker"
argument_list|)
expr_stmt|;
block|}
name|genBody
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|genInclude
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
comment|/** Generate code for the given grammar element. 	 * @param wc The wildcard element to generate 	 */
DECL|method|gen (WildcardElement wc)
specifier|public
name|void
name|gen
parameter_list|(
name|WildcardElement
name|wc
parameter_list|)
block|{
comment|// Variable assignment for labeled elements
if|if
condition|(
name|wc
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
operator|&&
name|syntacticPredLevel
operator|==
literal|0
condition|)
block|{
name|println
argument_list|(
name|wc
operator|.
name|getLabel
argument_list|()
operator|+
literal|" = "
operator|+
name|lt1Value
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
comment|// AST
name|genElementAST
argument_list|(
name|wc
argument_list|)
expr_stmt|;
comment|// Match anything but EOF
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
name|println
argument_list|(
literal|"if ( _t == "
operator|+
name|labeledElementASTInit
operator|+
literal|" ) throw "
operator|+
name|namespaceAntlr
operator|+
literal|"MismatchedTokenException();"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
block|{
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|&&
operator|(
operator|!
name|saveText
operator|||
name|wc
operator|.
name|getAutoGenType
argument_list|()
operator|==
name|GrammarElement
operator|.
name|AUTO_GEN_BANG
operator|)
condition|)
block|{
name|println
argument_list|(
literal|"_saveIndex = text.length();"
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
literal|"matchNot(EOF/*_CHAR*/);"
argument_list|)
expr_stmt|;
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|&&
operator|(
operator|!
name|saveText
operator|||
name|wc
operator|.
name|getAutoGenType
argument_list|()
operator|==
name|GrammarElement
operator|.
name|AUTO_GEN_BANG
operator|)
condition|)
block|{
name|println
argument_list|(
literal|"text.erase(_saveIndex);"
argument_list|)
expr_stmt|;
comment|// kill text atom put in buffer
block|}
block|}
else|else
block|{
name|println
argument_list|(
literal|"matchNot("
operator|+
name|getValueString
argument_list|(
name|Token
operator|.
name|EOF_TYPE
argument_list|)
operator|+
literal|");"
argument_list|)
expr_stmt|;
block|}
comment|// tack on tree cursor motion if doing a tree walker
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
name|println
argument_list|(
literal|"_t = _t->getNextSibling();"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate code for the given grammar element. 	 * @param blk The (...)* block to generate 	 */
DECL|method|gen (ZeroOrMoreBlock blk)
specifier|public
name|void
name|gen
parameter_list|(
name|ZeroOrMoreBlock
name|blk
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"gen*("
operator|+
name|blk
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{ // ( ... )*"
argument_list|)
expr_stmt|;
name|genBlockPreamble
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|String
name|label
decl_stmt|;
if|if
condition|(
name|blk
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|label
operator|=
name|blk
operator|.
name|getLabel
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|label
operator|=
literal|"_loop"
operator|+
name|blk
operator|.
name|ID
expr_stmt|;
block|}
name|println
argument_list|(
literal|"for (;;) {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// generate the init action for ()+ ()* inside the loop
comment|// this allows us to do usefull EOF checking...
name|genBlockInitAction
argument_list|(
name|blk
argument_list|)
expr_stmt|;
comment|// Tell AST generation to build subrule result
name|String
name|saveCurrentASTResult
init|=
name|currentASTResult
decl_stmt|;
if|if
condition|(
name|blk
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|currentASTResult
operator|=
name|blk
operator|.
name|getLabel
argument_list|()
expr_stmt|;
block|}
name|boolean
name|ok
init|=
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|deterministic
argument_list|(
name|blk
argument_list|)
decl_stmt|;
comment|// generate exit test if greedy set to false
comment|// and an alt is ambiguous with exit branch
comment|// or when lookahead derived purely from end-of-file
comment|// Lookahead analysis stops when end-of-file is hit,
comment|// returning set {epsilon}.  Since {epsilon} is not
comment|// ambig with any real tokens, no error is reported
comment|// by deterministic() routines and we have to check
comment|// for the case where the lookahead depth didn't get
comment|// set to NONDETERMINISTIC (this only happens when the
comment|// FOLLOW contains real atoms + epsilon).
name|boolean
name|generateNonGreedyExitPath
init|=
literal|false
decl_stmt|;
name|int
name|nonGreedyExitDepth
init|=
name|grammar
operator|.
name|maxk
decl_stmt|;
if|if
condition|(
operator|!
name|blk
operator|.
name|greedy
operator|&&
name|blk
operator|.
name|exitLookaheadDepth
operator|<=
name|grammar
operator|.
name|maxk
operator|&&
name|blk
operator|.
name|exitCache
index|[
name|blk
operator|.
name|exitLookaheadDepth
index|]
operator|.
name|containsEpsilon
argument_list|()
condition|)
block|{
name|generateNonGreedyExitPath
operator|=
literal|true
expr_stmt|;
name|nonGreedyExitDepth
operator|=
name|blk
operator|.
name|exitLookaheadDepth
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|blk
operator|.
name|greedy
operator|&&
name|blk
operator|.
name|exitLookaheadDepth
operator|==
name|LLkGrammarAnalyzer
operator|.
name|NONDETERMINISTIC
condition|)
block|{
name|generateNonGreedyExitPath
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|generateNonGreedyExitPath
condition|)
block|{
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"nongreedy (...)* loop; exit depth is "
operator|+
name|blk
operator|.
name|exitLookaheadDepth
argument_list|)
expr_stmt|;
block|}
name|String
name|predictExit
init|=
name|getLookaheadTestExpression
argument_list|(
name|blk
operator|.
name|exitCache
argument_list|,
name|nonGreedyExitDepth
argument_list|)
decl_stmt|;
name|println
argument_list|(
literal|"// nongreedy exit test"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"if ("
operator|+
name|predictExit
operator|+
literal|") goto "
operator|+
name|label
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
name|CppBlockFinishingInfo
name|howToFinish
init|=
name|genCommonBlock
argument_list|(
name|blk
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|genBlockFinish
argument_list|(
name|howToFinish
argument_list|,
literal|"goto "
operator|+
name|label
operator|+
literal|";"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
name|label
operator|+
literal|":;"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"} // ( ... )*"
argument_list|)
expr_stmt|;
comment|// Restore previous AST generation
name|currentASTResult
operator|=
name|saveCurrentASTResult
expr_stmt|;
block|}
comment|/** Generate an alternative. 	  * @param alt  The alternative to generate 	  * @param blk The block to which the alternative belongs 	  */
DECL|method|genAlt (Alternative alt, AlternativeBlock blk)
specifier|protected
name|void
name|genAlt
parameter_list|(
name|Alternative
name|alt
parameter_list|,
name|AlternativeBlock
name|blk
parameter_list|)
block|{
comment|// Save the AST generation state, and set it to that of the alt
name|boolean
name|savegenAST
init|=
name|genAST
decl_stmt|;
name|genAST
operator|=
name|genAST
operator|&&
name|alt
operator|.
name|getAutoGen
argument_list|()
expr_stmt|;
name|boolean
name|oldsaveTest
init|=
name|saveText
decl_stmt|;
name|saveText
operator|=
name|saveText
operator|&&
name|alt
operator|.
name|getAutoGen
argument_list|()
expr_stmt|;
comment|// Reset the variable name map for the alternative
name|Hashtable
name|saveMap
init|=
name|treeVariableMap
decl_stmt|;
name|treeVariableMap
operator|=
operator|new
name|Hashtable
argument_list|()
expr_stmt|;
comment|// Generate try block around the alt for  error handling
if|if
condition|(
name|alt
operator|.
name|exceptionSpec
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"try {      // for error handling"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
block|}
name|AlternativeElement
name|elem
init|=
name|alt
operator|.
name|head
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|elem
operator|instanceof
name|BlockEndElement
operator|)
condition|)
block|{
name|elem
operator|.
name|generate
argument_list|()
expr_stmt|;
comment|// alt can begin with anything. Ask target to gen.
name|elem
operator|=
name|elem
operator|.
name|next
expr_stmt|;
block|}
if|if
condition|(
name|genAST
condition|)
block|{
if|if
condition|(
name|blk
operator|instanceof
name|RuleBlock
condition|)
block|{
comment|// Set the AST return value for the rule
name|RuleBlock
name|rblk
init|=
operator|(
name|RuleBlock
operator|)
name|blk
decl_stmt|;
if|if
condition|(
name|usingCustomAST
condition|)
name|println
argument_list|(
name|rblk
operator|.
name|getRuleName
argument_list|()
operator|+
literal|"_AST = "
operator|+
name|labeledElementASTType
operator|+
literal|"(currentAST.root);"
argument_list|)
expr_stmt|;
else|else
name|println
argument_list|(
name|rblk
operator|.
name|getRuleName
argument_list|()
operator|+
literal|"_AST = currentAST.root;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blk
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// ### future: also set AST value for labeled subrules.
comment|// println(blk.getLabel() + "_AST = "+labeledElementASTType+"(currentAST.root);");
name|antlrTool
operator|.
name|warning
argument_list|(
literal|"Labeled subrules are not implemented"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|blk
operator|.
name|getLine
argument_list|()
argument_list|,
name|blk
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|alt
operator|.
name|exceptionSpec
operator|!=
literal|null
condition|)
block|{
comment|// close try block
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|genErrorHandler
argument_list|(
name|alt
operator|.
name|exceptionSpec
argument_list|)
expr_stmt|;
block|}
name|genAST
operator|=
name|savegenAST
expr_stmt|;
name|saveText
operator|=
name|oldsaveTest
expr_stmt|;
name|treeVariableMap
operator|=
name|saveMap
expr_stmt|;
block|}
comment|/** Generate all the bitsets to be used in the parser or lexer 	 * Generate the raw bitset data like "long _tokenSet1_data[] = {...};" 	 * and the BitSet object declarations like 	 * "BitSet _tokenSet1 = new BitSet(_tokenSet1_data);" 	 * Note that most languages do not support object initialization inside a 	 * class definition, so other code-generators may have to separate the 	 * bitset declarations from the initializations (e.g., put the 	 * initializations in the generated constructor instead). 	 * @param bitsetList The list of bitsets to generate. 	 * @param maxVocabulary Ensure that each generated bitset can contain at 	 *        least this value. 	 * @param prefix string glued in from of bitset names used for namespace 	 *        qualifications. 	 */
DECL|method|genBitsets ( Vector bitsetList, int maxVocabulary, String prefix )
specifier|protected
name|void
name|genBitsets
parameter_list|(
name|Vector
name|bitsetList
parameter_list|,
name|int
name|maxVocabulary
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
name|TokenManager
name|tm
init|=
name|grammar
operator|.
name|tokenManager
decl_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bitsetList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|BitSet
name|p
init|=
operator|(
name|BitSet
operator|)
name|bitsetList
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Ensure that generated BitSet is large enough for vocabulary
name|p
operator|.
name|growToInclude
argument_list|(
name|maxVocabulary
argument_list|)
expr_stmt|;
comment|// initialization data
name|println
argument_list|(
literal|"const unsigned long "
operator|+
name|prefix
operator|+
name|getBitsetName
argument_list|(
name|i
argument_list|)
operator|+
literal|"_data_"
operator|+
literal|"[] = { "
operator|+
name|p
operator|.
name|toStringOfHalfWords
argument_list|()
operator|+
literal|" };"
argument_list|)
expr_stmt|;
comment|// Dump the contents of the bitset in readable format...
name|String
name|t
init|=
literal|"// "
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|tm
operator|.
name|getVocabulary
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|.
name|member
argument_list|(
name|j
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
condition|)
block|{
comment|// only dump out for pure printable ascii.
if|if
condition|(
operator|(
literal|0x20
operator|<=
name|j
operator|)
operator|&&
operator|(
name|j
operator|<
literal|0x7F
operator|)
condition|)
name|t
operator|+=
name|charFormatter
operator|.
name|escapeChar
argument_list|(
name|j
argument_list|,
literal|true
argument_list|)
operator|+
literal|" "
expr_stmt|;
else|else
name|t
operator|+=
literal|"0x"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|j
argument_list|,
literal|16
argument_list|)
operator|+
literal|" "
expr_stmt|;
block|}
else|else
name|t
operator|+=
name|tm
operator|.
name|getTokenStringAt
argument_list|(
name|j
argument_list|)
operator|+
literal|" "
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|length
argument_list|()
operator|>
literal|70
condition|)
block|{
name|println
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
literal|"// "
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|t
operator|!=
literal|"// "
condition|)
name|println
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|// BitSet object
name|println
argument_list|(
literal|"const "
operator|+
name|namespaceAntlr
operator|+
literal|"BitSet "
operator|+
name|prefix
operator|+
name|getBitsetName
argument_list|(
name|i
argument_list|)
operator|+
literal|"("
operator|+
name|getBitsetName
argument_list|(
name|i
argument_list|)
operator|+
literal|"_data_,"
operator|+
name|p
operator|.
name|size
argument_list|()
operator|/
literal|32
operator|+
literal|");"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|genBitsetsHeader ( Vector bitsetList, int maxVocabulary )
specifier|protected
name|void
name|genBitsetsHeader
parameter_list|(
name|Vector
name|bitsetList
parameter_list|,
name|int
name|maxVocabulary
parameter_list|)
block|{
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bitsetList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|BitSet
name|p
init|=
operator|(
name|BitSet
operator|)
name|bitsetList
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Ensure that generated BitSet is large enough for vocabulary
name|p
operator|.
name|growToInclude
argument_list|(
name|maxVocabulary
argument_list|)
expr_stmt|;
comment|// initialization data
name|println
argument_list|(
literal|"static const unsigned long "
operator|+
name|getBitsetName
argument_list|(
name|i
argument_list|)
operator|+
literal|"_data_"
operator|+
literal|"[];"
argument_list|)
expr_stmt|;
comment|// BitSet object
name|println
argument_list|(
literal|"static const "
operator|+
name|namespaceAntlr
operator|+
literal|"BitSet "
operator|+
name|getBitsetName
argument_list|(
name|i
argument_list|)
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate the finish of a block, using a combination of the info 	 * returned from genCommonBlock() and the action to perform when 	 * no alts were taken 	 * @param howToFinish The return of genCommonBlock() 	 * @param noViableAction What to generate when no alt is taken 	 */
DECL|method|genBlockFinish (CppBlockFinishingInfo howToFinish, String noViableAction)
specifier|private
name|void
name|genBlockFinish
parameter_list|(
name|CppBlockFinishingInfo
name|howToFinish
parameter_list|,
name|String
name|noViableAction
parameter_list|)
block|{
if|if
condition|(
name|howToFinish
operator|.
name|needAnErrorClause
operator|&&
operator|(
name|howToFinish
operator|.
name|generatedAnIf
operator|||
name|howToFinish
operator|.
name|generatedSwitch
operator|)
condition|)
block|{
if|if
condition|(
name|howToFinish
operator|.
name|generatedAnIf
condition|)
block|{
name|println
argument_list|(
literal|"else {"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
block|}
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
name|noViableAction
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|howToFinish
operator|.
name|postscript
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
name|howToFinish
operator|.
name|postscript
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate the initaction for a block, which may be a RuleBlock or a 	 * plain AlternativeBLock. 	 * @blk The block for which the preamble is to be generated. 	 */
DECL|method|genBlockInitAction ( AlternativeBlock blk )
specifier|protected
name|void
name|genBlockInitAction
parameter_list|(
name|AlternativeBlock
name|blk
parameter_list|)
block|{
comment|// dump out init action
if|if
condition|(
name|blk
operator|.
name|initAction
operator|!=
literal|null
condition|)
block|{
name|genLineNo
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|printAction
argument_list|(
name|processActionForSpecialSymbols
argument_list|(
name|blk
operator|.
name|initAction
argument_list|,
name|blk
operator|.
name|line
argument_list|,
name|currentRule
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|genLineNo2
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Generate the header for a block, which may be a RuleBlock or a 	 * plain AlternativeBlock. This generates any variable declarations 	 * and syntactic-predicate-testing variables. 	 * @blk The block for which the preamble is to be generated. 	 */
DECL|method|genBlockPreamble (AlternativeBlock blk)
specifier|protected
name|void
name|genBlockPreamble
parameter_list|(
name|AlternativeBlock
name|blk
parameter_list|)
block|{
comment|// define labels for rule blocks.
if|if
condition|(
name|blk
operator|instanceof
name|RuleBlock
condition|)
block|{
name|RuleBlock
name|rblk
init|=
operator|(
name|RuleBlock
operator|)
name|blk
decl_stmt|;
if|if
condition|(
name|rblk
operator|.
name|labeledElements
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rblk
operator|.
name|labeledElements
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|AlternativeElement
name|a
init|=
operator|(
name|AlternativeElement
operator|)
name|rblk
operator|.
name|labeledElements
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|//System.out.println("looking at labeled element: "+a);
comment|// Variables for labeled rule refs and subrules are different than
comment|// variables for grammar atoms.  This test is a little tricky because
comment|// we want to get all rule refs and ebnf, but not rule blocks or
comment|// syntactic predicates
if|if
condition|(
name|a
operator|instanceof
name|RuleRefElement
operator|||
name|a
operator|instanceof
name|AlternativeBlock
operator|&&
operator|!
operator|(
name|a
operator|instanceof
name|RuleBlock
operator|)
operator|&&
operator|!
operator|(
name|a
operator|instanceof
name|SynPredBlock
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|a
operator|instanceof
name|RuleRefElement
operator|)
operator|&&
operator|(
operator|(
name|AlternativeBlock
operator|)
name|a
operator|)
operator|.
name|not
operator|&&
name|analyzer
operator|.
name|subruleCanBeInverted
argument_list|(
operator|(
operator|(
name|AlternativeBlock
operator|)
name|a
operator|)
argument_list|,
name|grammar
operator|instanceof
name|LexerGrammar
argument_list|)
condition|)
block|{
comment|// Special case for inverted subrules that will be
comment|// inlined. Treat these like token or char literal
comment|// references
name|println
argument_list|(
name|labeledElementType
operator|+
literal|" "
operator|+
name|a
operator|.
name|getLabel
argument_list|()
operator|+
literal|" = "
operator|+
name|labeledElementInit
operator|+
literal|";"
argument_list|)
expr_stmt|;
if|if
condition|(
name|grammar
operator|.
name|buildAST
condition|)
block|{
name|genASTDeclaration
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|grammar
operator|.
name|buildAST
condition|)
block|{
comment|// Always gen AST variables for labeled elements,
comment|// even if the element itself is marked with !
name|genASTDeclaration
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
name|println
argument_list|(
name|namespaceAntlr
operator|+
literal|"RefToken "
operator|+
name|a
operator|.
name|getLabel
argument_list|()
operator|+
literal|";"
argument_list|)
expr_stmt|;
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
comment|// always generate rule-ref variables for tree walker
name|println
argument_list|(
name|labeledElementType
operator|+
literal|" "
operator|+
name|a
operator|.
name|getLabel
argument_list|()
operator|+
literal|" = "
operator|+
name|labeledElementInit
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// It is a token or literal reference.  Generate the
comment|// correct variable type for this grammar
name|println
argument_list|(
name|labeledElementType
operator|+
literal|" "
operator|+
name|a
operator|.
name|getLabel
argument_list|()
operator|+
literal|" = "
operator|+
name|labeledElementInit
operator|+
literal|";"
argument_list|)
expr_stmt|;
comment|// In addition, generate *_AST variables if building ASTs
if|if
condition|(
name|grammar
operator|.
name|buildAST
condition|)
block|{
if|if
condition|(
name|a
operator|instanceof
name|GrammarAtom
operator|&&
operator|(
operator|(
name|GrammarAtom
operator|)
name|a
operator|)
operator|.
name|getASTNodeType
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|GrammarAtom
name|ga
init|=
operator|(
name|GrammarAtom
operator|)
name|a
decl_stmt|;
name|genASTDeclaration
argument_list|(
name|a
argument_list|,
literal|"Ref"
operator|+
name|ga
operator|.
name|getASTNodeType
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|genASTDeclaration
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
DECL|method|genBody (LexerGrammar g)
specifier|public
name|void
name|genBody
parameter_list|(
name|LexerGrammar
name|g
parameter_list|)
throws|throws
name|IOException
block|{
name|outputFile
operator|=
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|".cpp"
expr_stmt|;
name|outputLine
operator|=
literal|1
expr_stmt|;
name|currentOutput
operator|=
name|antlrTool
operator|.
name|openOutputFile
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
comment|//SAS: changed for proper text file io
name|genAST
operator|=
literal|false
expr_stmt|;
comment|// no way to gen trees.
name|saveText
operator|=
literal|true
expr_stmt|;
comment|// save consumed characters.
name|tabs
operator|=
literal|0
expr_stmt|;
comment|// Generate header common to all C++ output files
name|genHeader
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
name|printHeaderAction
argument_list|(
name|preIncludeCpp
argument_list|)
expr_stmt|;
comment|// Generate header specific to lexer C++ file
name|println
argument_list|(
literal|"#include \""
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|".hpp\""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/CharBuffer.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/TokenStreamException.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/TokenStreamIOException.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/TokenStreamRecognitionException.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/CharStreamException.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/CharStreamIOException.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/NoViableAltForCharException.hpp>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
condition|)
name|println
argument_list|(
literal|"#include<antlr/DebuggingInputBuffer.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printHeaderAction
argument_list|(
name|postIncludeCpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameSpace
operator|!=
literal|null
condition|)
name|nameSpace
operator|.
name|emitDeclarations
argument_list|(
name|currentOutput
argument_list|)
expr_stmt|;
comment|// Generate user-defined lexer file preamble
name|printAction
argument_list|(
name|grammar
operator|.
name|preambleAction
argument_list|)
expr_stmt|;
comment|// Generate lexer class definition
name|String
name|sup
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|grammar
operator|.
name|superClass
operator|!=
literal|null
condition|)
block|{
name|sup
operator|=
name|grammar
operator|.
name|superClass
expr_stmt|;
block|}
else|else
block|{
name|sup
operator|=
name|grammar
operator|.
name|getSuperClass
argument_list|()
expr_stmt|;
if|if
condition|(
name|sup
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|sup
operator|=
name|sup
operator|.
name|substring
argument_list|(
name|sup
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sup
operator|=
name|namespaceAntlr
operator|+
name|sup
expr_stmt|;
block|}
if|if
condition|(
name|noConstructors
condition|)
block|{
name|println
argument_list|(
literal|"#if 0"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// constructor creation turned of with 'noConstructor' option"
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Generate the constructor from InputStream
comment|//
name|println
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"("
operator|+
name|namespaceStd
operator|+
literal|"istream& in)"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// if debugging, wrap the input buffer in a debugger
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
condition|)
name|println
argument_list|(
literal|": "
operator|+
name|sup
operator|+
literal|"(new "
operator|+
name|namespaceAntlr
operator|+
literal|"DebuggingInputBuffer(new "
operator|+
name|namespaceAntlr
operator|+
literal|"CharBuffer(in)),"
operator|+
name|g
operator|.
name|caseSensitive
operator|+
literal|")"
argument_list|)
expr_stmt|;
else|else
name|println
argument_list|(
literal|": "
operator|+
name|sup
operator|+
literal|"(new "
operator|+
name|namespaceAntlr
operator|+
literal|"CharBuffer(in),"
operator|+
name|g
operator|.
name|caseSensitive
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// if debugging, set up array variables and call user-overridable
comment|//   debugging setup method
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
condition|)
block|{
name|println
argument_list|(
literal|"setRuleNames(_ruleNames);"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"setSemPredNames(_semPredNames);"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"setupDebugging();"
argument_list|)
expr_stmt|;
block|}
comment|//		println("setCaseSensitive("+g.caseSensitive+");");
name|println
argument_list|(
literal|"initLiterals();"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// Generate the constructor from InputBuffer
name|println
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"("
operator|+
name|namespaceAntlr
operator|+
literal|"InputBuffer& ib)"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// if debugging, wrap the input buffer in a debugger
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
condition|)
name|println
argument_list|(
literal|": "
operator|+
name|sup
operator|+
literal|"(new "
operator|+
name|namespaceAntlr
operator|+
literal|"DebuggingInputBuffer(ib),"
operator|+
name|g
operator|.
name|caseSensitive
operator|+
literal|")"
argument_list|)
expr_stmt|;
else|else
name|println
argument_list|(
literal|": "
operator|+
name|sup
operator|+
literal|"(ib,"
operator|+
name|g
operator|.
name|caseSensitive
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// if debugging, set up array variables and call user-overridable
comment|//   debugging setup method
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
condition|)
block|{
name|println
argument_list|(
literal|"setRuleNames(_ruleNames);"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"setSemPredNames(_semPredNames);"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"setupDebugging();"
argument_list|)
expr_stmt|;
block|}
comment|//		println("setCaseSensitive("+g.caseSensitive+");");
name|println
argument_list|(
literal|"initLiterals();"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// Generate the constructor from LexerSharedInputState
name|println
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"(const "
operator|+
name|namespaceAntlr
operator|+
literal|"LexerSharedInputState& state)"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|": "
operator|+
name|sup
operator|+
literal|"(state,"
operator|+
name|g
operator|.
name|caseSensitive
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// if debugging, set up array variables and call user-overridable
comment|//   debugging setup method
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
condition|)
block|{
name|println
argument_list|(
literal|"setRuleNames(_ruleNames);"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"setSemPredNames(_semPredNames);"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"setupDebugging();"
argument_list|)
expr_stmt|;
block|}
comment|//		println("setCaseSensitive("+g.caseSensitive+");");
name|println
argument_list|(
literal|"initLiterals();"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|noConstructors
condition|)
block|{
name|println
argument_list|(
literal|"// constructor creation turned of with 'noConstructor' option"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
literal|"void "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::initLiterals()"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// Generate the initialization of the map
comment|// containing the string literals used in the lexer
comment|// The literals variable itself is in CharScanner
name|Enumeration
name|keys
init|=
name|grammar
operator|.
name|tokenManager
operator|.
name|getTokenSymbolKeys
argument_list|()
decl_stmt|;
while|while
condition|(
name|keys
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|keys
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'"'
condition|)
block|{
continue|continue;
block|}
name|TokenSymbol
name|sym
init|=
name|grammar
operator|.
name|tokenManager
operator|.
name|getTokenSymbol
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym
operator|instanceof
name|StringLiteralSymbol
condition|)
block|{
name|StringLiteralSymbol
name|s
init|=
operator|(
name|StringLiteralSymbol
operator|)
name|sym
decl_stmt|;
name|println
argument_list|(
literal|"literals["
operator|+
name|s
operator|.
name|getId
argument_list|()
operator|+
literal|"] = "
operator|+
name|s
operator|.
name|getTokenType
argument_list|()
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Generate the setting of various generated options.
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|Enumeration
name|ids
decl_stmt|;
comment|// generate the rule name array for debugging
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
condition|)
block|{
name|println
argument_list|(
literal|"const char* "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::_ruleNames[] = {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|ids
operator|=
name|grammar
operator|.
name|rules
operator|.
name|elements
argument_list|()
expr_stmt|;
name|int
name|ruleNum
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ids
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|GrammarSymbol
name|sym
init|=
operator|(
name|GrammarSymbol
operator|)
name|ids
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|sym
operator|instanceof
name|RuleSymbol
condition|)
name|println
argument_list|(
literal|"\""
operator|+
operator|(
operator|(
name|RuleSymbol
operator|)
name|sym
operator|)
operator|.
name|getId
argument_list|()
operator|+
literal|"\","
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"};"
argument_list|)
expr_stmt|;
block|}
comment|// Generate nextToken() rule.
comment|// nextToken() is a synthetic lexer rule that is the implicit OR of all
comment|// user-defined lexer rules.
name|genNextToken
argument_list|()
expr_stmt|;
comment|// Generate code for each rule in the lexer
name|ids
operator|=
name|grammar
operator|.
name|rules
operator|.
name|elements
argument_list|()
expr_stmt|;
name|int
name|ruleNum
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ids
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|RuleSymbol
name|sym
init|=
operator|(
name|RuleSymbol
operator|)
name|ids
operator|.
name|nextElement
argument_list|()
decl_stmt|;
comment|// Don't generate the synthetic rules
if|if
condition|(
operator|!
name|sym
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
literal|"mnextToken"
argument_list|)
condition|)
block|{
name|genRule
argument_list|(
name|sym
argument_list|,
literal|false
argument_list|,
name|ruleNum
operator|++
argument_list|,
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
argument_list|)
expr_stmt|;
block|}
name|exitIfError
argument_list|()
expr_stmt|;
block|}
comment|// Generate the semantic predicate map for debugging
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
condition|)
name|genSemPredMap
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
argument_list|)
expr_stmt|;
comment|// Generate the bitsets used throughout the lexer
name|genBitsets
argument_list|(
name|bitsetsUsed
argument_list|,
operator|(
operator|(
name|LexerGrammar
operator|)
name|grammar
operator|)
operator|.
name|charVocabulary
operator|.
name|size
argument_list|()
argument_list|,
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameSpace
operator|!=
literal|null
condition|)
name|nameSpace
operator|.
name|emitClosures
argument_list|(
name|currentOutput
argument_list|)
expr_stmt|;
comment|// Close the lexer output stream
name|currentOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentOutput
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|genInitFactory ( Grammar g )
specifier|public
name|void
name|genInitFactory
parameter_list|(
name|Grammar
name|g
parameter_list|)
block|{
comment|// Generate the method to initialize an ASTFactory when we're
comment|// building AST's
name|String
name|param_name
init|=
literal|"factory "
decl_stmt|;
if|if
condition|(
operator|!
name|g
operator|.
name|buildAST
condition|)
name|param_name
operator|=
literal|""
expr_stmt|;
name|println
argument_list|(
literal|"void "
operator|+
name|g
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::initializeASTFactory( "
operator|+
name|namespaceAntlr
operator|+
literal|"ASTFactory& "
operator|+
name|param_name
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|buildAST
condition|)
block|{
comment|// sort out custom AST types... synchronize token manager with token
comment|// specs on rules (and other stuff we were able to see from
comment|// action.g) (imperfect of course)
name|TokenManager
name|tm
init|=
name|grammar
operator|.
name|tokenManager
decl_stmt|;
name|Enumeration
name|tokens
init|=
name|tm
operator|.
name|getTokenSymbolKeys
argument_list|()
decl_stmt|;
while|while
condition|(
name|tokens
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|String
name|tok
init|=
operator|(
name|String
operator|)
name|tokens
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|TokenSymbol
name|ts
init|=
name|tm
operator|.
name|getTokenSymbol
argument_list|(
name|tok
argument_list|)
decl_stmt|;
comment|// if we have a custom type and there's not a more local override
comment|// of the tokentype then mark this as the type for the tokentype
if|if
condition|(
name|ts
operator|.
name|getASTNodeType
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// ensure capacity with this pseudo vector...
name|astTypes
operator|.
name|ensureCapacity
argument_list|(
name|ts
operator|.
name|getTokenType
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|type
init|=
operator|(
name|String
operator|)
name|astTypes
operator|.
name|elementAt
argument_list|(
name|ts
operator|.
name|getTokenType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
name|astTypes
operator|.
name|setElementAt
argument_list|(
name|ts
operator|.
name|getASTNodeType
argument_list|()
argument_list|,
name|ts
operator|.
name|getTokenType
argument_list|()
argument_list|)
expr_stmt|;
else|else
block|{
comment|// give a warning over action taken if the types are unequal
if|if
condition|(
operator|!
name|ts
operator|.
name|getASTNodeType
argument_list|()
operator|.
name|equals
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|antlrTool
operator|.
name|warning
argument_list|(
literal|"Token "
operator|+
name|tok
operator|+
literal|" taking most specific AST type"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|antlrTool
operator|.
name|warning
argument_list|(
literal|"  using "
operator|+
name|type
operator|+
literal|" ignoring "
operator|+
name|ts
operator|.
name|getASTNodeType
argument_list|()
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// now actually write out all the registered types. (except the default
comment|// type.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|astTypes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|type
init|=
operator|(
name|String
operator|)
name|astTypes
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"factory.registerFactory("
operator|+
name|i
operator|+
literal|", \""
operator|+
name|type
operator|+
literal|"\", "
operator|+
name|type
operator|+
literal|"::factory);"
argument_list|)
expr_stmt|;
block|}
block|}
name|println
argument_list|(
literal|"factory.setMaxNodeType("
operator|+
name|grammar
operator|.
name|tokenManager
operator|.
name|maxTokenType
argument_list|()
operator|+
literal|");"
argument_list|)
expr_stmt|;
block|}
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
comment|// FIXME: and so why are we passing here a g param while inside
comment|// we merrily use the global grammar.
DECL|method|genBody (ParserGrammar g)
specifier|public
name|void
name|genBody
parameter_list|(
name|ParserGrammar
name|g
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Open the output stream for the parser and set the currentOutput
name|outputFile
operator|=
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|".cpp"
expr_stmt|;
name|outputLine
operator|=
literal|1
expr_stmt|;
name|currentOutput
operator|=
name|antlrTool
operator|.
name|openOutputFile
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
name|genAST
operator|=
name|grammar
operator|.
name|buildAST
expr_stmt|;
name|tabs
operator|=
literal|0
expr_stmt|;
comment|// Generate the header common to all output files.
name|genHeader
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
name|printHeaderAction
argument_list|(
name|preIncludeCpp
argument_list|)
expr_stmt|;
comment|// Generate header for the parser
name|println
argument_list|(
literal|"#include \""
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|".hpp\""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/NoViableAltException.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/SemanticException.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/ASTFactory.hpp>"
argument_list|)
expr_stmt|;
name|printHeaderAction
argument_list|(
name|postIncludeCpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameSpace
operator|!=
literal|null
condition|)
name|nameSpace
operator|.
name|emitDeclarations
argument_list|(
name|currentOutput
argument_list|)
expr_stmt|;
comment|// Output the user-defined parser preamble
name|printAction
argument_list|(
name|grammar
operator|.
name|preambleAction
argument_list|)
expr_stmt|;
name|String
name|sup
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|grammar
operator|.
name|superClass
operator|!=
literal|null
condition|)
name|sup
operator|=
name|grammar
operator|.
name|superClass
expr_stmt|;
else|else
block|{
name|sup
operator|=
name|grammar
operator|.
name|getSuperClass
argument_list|()
expr_stmt|;
if|if
condition|(
name|sup
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|sup
operator|=
name|sup
operator|.
name|substring
argument_list|(
name|sup
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sup
operator|=
name|namespaceAntlr
operator|+
name|sup
expr_stmt|;
block|}
comment|// set up an array of all the rule names so the debugger can
comment|// keep track of them only by number -- less to store in tree...
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
condition|)
block|{
name|println
argument_list|(
literal|"const char* "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::_ruleNames[] = {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|Enumeration
name|ids
init|=
name|grammar
operator|.
name|rules
operator|.
name|elements
argument_list|()
decl_stmt|;
name|int
name|ruleNum
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ids
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|GrammarSymbol
name|sym
init|=
operator|(
name|GrammarSymbol
operator|)
name|ids
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|sym
operator|instanceof
name|RuleSymbol
condition|)
name|println
argument_list|(
literal|"\""
operator|+
operator|(
operator|(
name|RuleSymbol
operator|)
name|sym
operator|)
operator|.
name|getId
argument_list|()
operator|+
literal|"\","
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"};"
argument_list|)
expr_stmt|;
block|}
comment|// Generate _initialize function
comment|// disabled since it isn't used anymore..
comment|//		println("void " + grammar.getClassName() + "::_initialize(void)");
comment|//		println("{");
comment|//		tabs++;
comment|// if debugging, set up arrays and call the user-overridable
comment|//   debugging setup method
comment|//		if ( grammar.debuggingOutput ) {
comment|//			println("setRuleNames(_ruleNames);");
comment|//			println("setSemPredNames(_semPredNames);");
comment|//			println("setupDebugging();");
comment|//		}
comment|//		tabs--;
comment|//		println("}");
if|if
condition|(
name|noConstructors
condition|)
block|{
name|println
argument_list|(
literal|"#if 0"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// constructor creation turned of with 'noConstructor' option"
argument_list|)
expr_stmt|;
block|}
comment|// Generate parser class constructor from TokenBuffer
name|print
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"("
operator|+
name|namespaceAntlr
operator|+
literal|"TokenBuffer& tokenBuf, int k)"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|": "
operator|+
name|sup
operator|+
literal|"(tokenBuf,k)"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
comment|//		tabs++;
comment|//		println("_initialize();");
comment|//		tabs--;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"("
operator|+
name|namespaceAntlr
operator|+
literal|"TokenBuffer& tokenBuf)"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|": "
operator|+
name|sup
operator|+
literal|"(tokenBuf,"
operator|+
name|grammar
operator|.
name|maxk
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
comment|//		tabs++;
comment|//		println("_initialize();");
comment|//		tabs--;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// Generate parser class constructor from TokenStream
name|print
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"("
operator|+
name|namespaceAntlr
operator|+
literal|"TokenStream& lexer, int k)"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|": "
operator|+
name|sup
operator|+
literal|"(lexer,k)"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
comment|//		tabs++;
comment|//		println("_initialize();");
comment|//		tabs--;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"("
operator|+
name|namespaceAntlr
operator|+
literal|"TokenStream& lexer)"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|": "
operator|+
name|sup
operator|+
literal|"(lexer,"
operator|+
name|grammar
operator|.
name|maxk
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
comment|//		tabs++;
comment|//		println("_initialize();");
comment|//		tabs--;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"(const "
operator|+
name|namespaceAntlr
operator|+
literal|"ParserSharedInputState& state)"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|": "
operator|+
name|sup
operator|+
literal|"(state,"
operator|+
name|grammar
operator|.
name|maxk
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
comment|//		tabs++;
comment|//		println("_initialize();");
comment|//		tabs--;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|noConstructors
condition|)
block|{
name|println
argument_list|(
literal|"// constructor creation turned of with 'noConstructor' option"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
block|}
name|astTypes
operator|=
operator|new
name|Vector
argument_list|()
expr_stmt|;
comment|// Generate code for each rule in the grammar
name|Enumeration
name|ids
init|=
name|grammar
operator|.
name|rules
operator|.
name|elements
argument_list|()
decl_stmt|;
name|int
name|ruleNum
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ids
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|GrammarSymbol
name|sym
init|=
operator|(
name|GrammarSymbol
operator|)
name|ids
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|sym
operator|instanceof
name|RuleSymbol
condition|)
block|{
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|sym
decl_stmt|;
name|genRule
argument_list|(
name|rs
argument_list|,
name|rs
operator|.
name|references
operator|.
name|size
argument_list|()
operator|==
literal|0
argument_list|,
name|ruleNum
operator|++
argument_list|,
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
argument_list|)
expr_stmt|;
block|}
name|exitIfError
argument_list|()
expr_stmt|;
block|}
name|genInitFactory
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|// Generate the token names
name|genTokenStrings
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
argument_list|)
expr_stmt|;
comment|// Generate the bitsets used throughout the grammar
name|genBitsets
argument_list|(
name|bitsetsUsed
argument_list|,
name|grammar
operator|.
name|tokenManager
operator|.
name|maxTokenType
argument_list|()
argument_list|,
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
argument_list|)
expr_stmt|;
comment|// Generate the semantic predicate map for debugging
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
condition|)
name|genSemPredMap
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
argument_list|)
expr_stmt|;
comment|// Close class definition
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameSpace
operator|!=
literal|null
condition|)
name|nameSpace
operator|.
name|emitClosures
argument_list|(
name|currentOutput
argument_list|)
expr_stmt|;
comment|// Close the parser output stream
name|currentOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentOutput
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|genBody (TreeWalkerGrammar g)
specifier|public
name|void
name|genBody
parameter_list|(
name|TreeWalkerGrammar
name|g
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Open the output stream for the parser and set the currentOutput
name|outputFile
operator|=
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|".cpp"
expr_stmt|;
name|outputLine
operator|=
literal|1
expr_stmt|;
name|currentOutput
operator|=
name|antlrTool
operator|.
name|openOutputFile
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
comment|//SAS: changed for proper text file io
name|genAST
operator|=
name|grammar
operator|.
name|buildAST
expr_stmt|;
name|tabs
operator|=
literal|0
expr_stmt|;
comment|// Generate the header common to all output files.
name|genHeader
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
name|printHeaderAction
argument_list|(
name|preIncludeCpp
argument_list|)
expr_stmt|;
comment|// Generate header for the parser
name|println
argument_list|(
literal|"#include \""
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|".hpp\""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/Token.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/AST.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/NoViableAltException.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/MismatchedTokenException.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/SemanticException.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/BitSet.hpp>"
argument_list|)
expr_stmt|;
name|printHeaderAction
argument_list|(
name|postIncludeCpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameSpace
operator|!=
literal|null
condition|)
name|nameSpace
operator|.
name|emitDeclarations
argument_list|(
name|currentOutput
argument_list|)
expr_stmt|;
comment|// Output the user-defined parser premamble
name|printAction
argument_list|(
name|grammar
operator|.
name|preambleAction
argument_list|)
expr_stmt|;
comment|// Generate parser class definition
name|String
name|sup
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|grammar
operator|.
name|superClass
operator|!=
literal|null
condition|)
block|{
name|sup
operator|=
name|grammar
operator|.
name|superClass
expr_stmt|;
block|}
else|else
block|{
name|sup
operator|=
name|grammar
operator|.
name|getSuperClass
argument_list|()
expr_stmt|;
if|if
condition|(
name|sup
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|sup
operator|=
name|sup
operator|.
name|substring
argument_list|(
name|sup
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sup
operator|=
name|namespaceAntlr
operator|+
name|sup
expr_stmt|;
block|}
if|if
condition|(
name|noConstructors
condition|)
block|{
name|println
argument_list|(
literal|"#if 0"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// constructor creation turned of with 'noConstructor' option"
argument_list|)
expr_stmt|;
block|}
comment|// Generate default parser class constructor
name|println
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"()"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"\t: "
operator|+
name|namespaceAntlr
operator|+
literal|"TreeParser() {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|//		println("setTokenNames(_tokenNames);");
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|noConstructors
condition|)
block|{
name|println
argument_list|(
literal|"// constructor creation turned of with 'noConstructor' option"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|astTypes
operator|=
operator|new
name|Vector
argument_list|()
expr_stmt|;
comment|// Generate code for each rule in the grammar
name|Enumeration
name|ids
init|=
name|grammar
operator|.
name|rules
operator|.
name|elements
argument_list|()
decl_stmt|;
name|int
name|ruleNum
init|=
literal|0
decl_stmt|;
name|String
name|ruleNameInits
init|=
literal|""
decl_stmt|;
while|while
condition|(
name|ids
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|GrammarSymbol
name|sym
init|=
operator|(
name|GrammarSymbol
operator|)
name|ids
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|sym
operator|instanceof
name|RuleSymbol
condition|)
block|{
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|sym
decl_stmt|;
name|genRule
argument_list|(
name|rs
argument_list|,
name|rs
operator|.
name|references
operator|.
name|size
argument_list|()
operator|==
literal|0
argument_list|,
name|ruleNum
operator|++
argument_list|,
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
argument_list|)
expr_stmt|;
block|}
name|exitIfError
argument_list|()
expr_stmt|;
block|}
comment|// Generate the ASTFactory initialization function
name|genInitFactory
argument_list|(
name|grammar
argument_list|)
expr_stmt|;
comment|// Generate the token names
name|genTokenStrings
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
argument_list|)
expr_stmt|;
comment|// Generate the bitsets used throughout the grammar
name|genBitsets
argument_list|(
name|bitsetsUsed
argument_list|,
name|grammar
operator|.
name|tokenManager
operator|.
name|maxTokenType
argument_list|()
argument_list|,
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::"
argument_list|)
expr_stmt|;
comment|// Close class definition
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameSpace
operator|!=
literal|null
condition|)
name|nameSpace
operator|.
name|emitClosures
argument_list|(
name|currentOutput
argument_list|)
expr_stmt|;
comment|// Close the parser output stream
name|currentOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentOutput
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Generate a series of case statements that implement a BitSet test. 	 * @param p The Bitset for which cases are to be generated 	 */
DECL|method|genCases (BitSet p)
specifier|protected
name|void
name|genCases
parameter_list|(
name|BitSet
name|p
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"genCases("
operator|+
name|p
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|int
index|[]
name|elems
decl_stmt|;
name|elems
operator|=
name|p
operator|.
name|toArray
argument_list|()
expr_stmt|;
comment|// Wrap cases four-per-line for lexer, one-per-line for parser
name|int
name|wrap
init|=
literal|1
decl_stmt|;
comment|//(grammar instanceof LexerGrammar) ? 4 : 1;
name|int
name|j
init|=
literal|1
decl_stmt|;
name|boolean
name|startOfLine
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|elems
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
literal|1
condition|)
block|{
name|print
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_print
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
name|_print
argument_list|(
literal|"case "
operator|+
name|getValueString
argument_list|(
name|elems
index|[
name|i
index|]
argument_list|)
operator|+
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|wrap
condition|)
block|{
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|startOfLine
operator|=
literal|true
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|j
operator|++
expr_stmt|;
name|startOfLine
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|startOfLine
condition|)
block|{
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate common code for a block of alternatives; return a postscript 	 * that needs to be generated at the end of the block.  Other routines 	 * may append else-clauses and such for error checking before the postfix 	 * is generated. 	 * If the grammar is a lexer, then generate alternatives in an order where 	 * alternatives requiring deeper lookahead are generated first, and 	 * EOF in the lookahead set reduces the depth of the lookahead. 	 * @param blk The block to generate 	 * @param noTestForSingle If true, then it does not generate a test for a single alternative. 	 */
DECL|method|genCommonBlock ( AlternativeBlock blk, boolean noTestForSingle )
specifier|public
name|CppBlockFinishingInfo
name|genCommonBlock
parameter_list|(
name|AlternativeBlock
name|blk
parameter_list|,
name|boolean
name|noTestForSingle
parameter_list|)
block|{
name|int
name|nIF
init|=
literal|0
decl_stmt|;
name|boolean
name|createdLL1Switch
init|=
literal|false
decl_stmt|;
name|int
name|closingBracesOfIFSequence
init|=
literal|0
decl_stmt|;
name|CppBlockFinishingInfo
name|finishingInfo
init|=
operator|new
name|CppBlockFinishingInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"genCommonBlk("
operator|+
name|blk
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// Save the AST generation state, and set it to that of the block
name|boolean
name|savegenAST
init|=
name|genAST
decl_stmt|;
name|genAST
operator|=
name|genAST
operator|&&
name|blk
operator|.
name|getAutoGen
argument_list|()
expr_stmt|;
name|boolean
name|oldsaveTest
init|=
name|saveText
decl_stmt|;
name|saveText
operator|=
name|saveText
operator|&&
name|blk
operator|.
name|getAutoGen
argument_list|()
expr_stmt|;
comment|// Is this block inverted?  If so, generate special-case code
if|if
condition|(
name|blk
operator|.
name|not
operator|&&
name|analyzer
operator|.
name|subruleCanBeInverted
argument_list|(
name|blk
argument_list|,
name|grammar
operator|instanceof
name|LexerGrammar
argument_list|)
condition|)
block|{
name|Lookahead
name|p
init|=
name|analyzer
operator|.
name|look
argument_list|(
literal|1
argument_list|,
name|blk
argument_list|)
decl_stmt|;
comment|// Variable assignment for labeled elements
if|if
condition|(
name|blk
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
operator|&&
name|syntacticPredLevel
operator|==
literal|0
condition|)
block|{
name|println
argument_list|(
name|blk
operator|.
name|getLabel
argument_list|()
operator|+
literal|" = "
operator|+
name|lt1Value
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
comment|// AST
name|genElementAST
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|String
name|astArgs
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
if|if
condition|(
name|usingCustomAST
condition|)
name|astArgs
operator|=
name|namespaceAntlr
operator|+
literal|"RefAST"
operator|+
literal|"(_t),"
expr_stmt|;
else|else
name|astArgs
operator|=
literal|"_t,"
expr_stmt|;
block|}
comment|// match the bitset for the alternative
name|println
argument_list|(
literal|"match("
operator|+
name|astArgs
operator|+
name|getBitsetName
argument_list|(
name|markBitsetForGen
argument_list|(
name|p
operator|.
name|fset
argument_list|)
argument_list|)
operator|+
literal|");"
argument_list|)
expr_stmt|;
comment|// tack on tree cursor motion if doing a tree walker
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
name|println
argument_list|(
literal|"_t = _t->getNextSibling();"
argument_list|)
expr_stmt|;
block|}
return|return
name|finishingInfo
return|;
block|}
comment|// Special handling for single alt
if|if
condition|(
name|blk
operator|.
name|getAlternatives
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|Alternative
name|alt
init|=
name|blk
operator|.
name|getAlternativeAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Generate a warning if there is a synPred for single alt.
if|if
condition|(
name|alt
operator|.
name|synPred
operator|!=
literal|null
condition|)
block|{
name|antlrTool
operator|.
name|warning
argument_list|(
literal|"Syntactic predicate superfluous for single alternative"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|blk
operator|.
name|getAlternativeAt
argument_list|(
literal|0
argument_list|)
operator|.
name|synPred
operator|.
name|getLine
argument_list|()
argument_list|,
name|blk
operator|.
name|getAlternativeAt
argument_list|(
literal|0
argument_list|)
operator|.
name|synPred
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noTestForSingle
condition|)
block|{
if|if
condition|(
name|alt
operator|.
name|semPred
operator|!=
literal|null
condition|)
block|{
comment|// Generate validating predicate
name|genSemPred
argument_list|(
name|alt
operator|.
name|semPred
argument_list|,
name|blk
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
name|genAlt
argument_list|(
name|alt
argument_list|,
name|blk
argument_list|)
expr_stmt|;
return|return
name|finishingInfo
return|;
block|}
block|}
comment|// count number of simple LL(1) cases; only do switch for
comment|// many LL(1) cases (no preds, no end of token refs)
comment|// We don't care about exit paths for (...)*, (...)+
comment|// because we don't explicitly have a test for them
comment|// as an alt in the loop.
comment|//
comment|// Also, we now count how many unicode lookahead sets
comment|// there are--they must be moved to DEFAULT or ELSE
comment|// clause.
name|int
name|nLL1
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blk
operator|.
name|getAlternatives
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Alternative
name|a
init|=
name|blk
operator|.
name|getAlternativeAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|suitableForCaseExpression
argument_list|(
name|a
argument_list|)
condition|)
name|nLL1
operator|++
expr_stmt|;
block|}
comment|// do LL(1) cases
if|if
condition|(
name|nLL1
operator|>=
name|makeSwitchThreshold
condition|)
block|{
comment|// Determine the name of the item to be compared
name|String
name|testExpr
init|=
name|lookaheadString
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|createdLL1Switch
operator|=
literal|true
expr_stmt|;
comment|// when parsing trees, convert null to valid tree node with NULL lookahead
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
name|println
argument_list|(
literal|"if (_t == "
operator|+
name|labeledElementASTInit
operator|+
literal|" )"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"_t = ASTNULL;"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
block|}
name|println
argument_list|(
literal|"switch ( "
operator|+
name|testExpr
operator|+
literal|") {"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blk
operator|.
name|alternatives
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Alternative
name|alt
init|=
name|blk
operator|.
name|getAlternativeAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// ignore any non-LL(1) alts, predicated alts or end-of-token alts
comment|// or end-of-token alts for case expressions
if|if
condition|(
operator|!
name|suitableForCaseExpression
argument_list|(
name|alt
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|Lookahead
name|p
init|=
name|alt
operator|.
name|cache
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|fset
operator|.
name|degree
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|p
operator|.
name|containsEpsilon
argument_list|()
condition|)
block|{
name|antlrTool
operator|.
name|warning
argument_list|(
literal|"Alternate omitted due to empty prediction set"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|alt
operator|.
name|head
operator|.
name|getLine
argument_list|()
argument_list|,
name|alt
operator|.
name|head
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|genCases
argument_list|(
name|p
operator|.
name|fset
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|genAlt
argument_list|(
name|alt
argument_list|,
name|blk
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"break;"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
block|}
name|println
argument_list|(
literal|"default:"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
block|}
comment|// do non-LL(1) and nondeterministic cases
comment|// This is tricky in the lexer, because of cases like:
comment|//     STAR : '*' ;
comment|//     ASSIGN_STAR : "*=";
comment|// Since nextToken is generated without a loop, then the STAR will
comment|// have end-of-token as it's lookahead set for LA(2).  So, we must generate the
comment|// alternatives containing trailing end-of-token in their lookahead sets *after*
comment|// the alternatives without end-of-token.  This implements the usual
comment|// lexer convention that longer matches come before shorter ones, e.g.
comment|// "*=" matches ASSIGN_STAR not STAR
comment|//
comment|// For non-lexer grammars, this does not sort the alternates by depth
comment|// Note that alts whose lookahead is purely end-of-token at k=1 end up
comment|// as default or else clauses.
name|int
name|startDepth
init|=
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
condition|?
name|grammar
operator|.
name|maxk
else|:
literal|0
decl_stmt|;
for|for
control|(
name|int
name|altDepth
init|=
name|startDepth
init|;
name|altDepth
operator|>=
literal|0
condition|;
name|altDepth
operator|--
control|)
block|{
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"checking depth "
operator|+
name|altDepth
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blk
operator|.
name|alternatives
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Alternative
name|alt
init|=
name|blk
operator|.
name|getAlternativeAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"genAlt: "
operator|+
name|i
argument_list|)
expr_stmt|;
comment|// if we made a switch above, ignore what we already took care
comment|// of.  Specifically, LL(1) alts with no preds
comment|// that do not have end-of-token in their prediction set
if|if
condition|(
name|createdLL1Switch
operator|&&
name|suitableForCaseExpression
argument_list|(
name|alt
argument_list|)
condition|)
block|{
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"ignoring alt because it was in the switch"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|String
name|e
decl_stmt|;
name|boolean
name|unpredicted
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
block|{
comment|// Calculate the "effective depth" of the alt, which is the max
comment|// depth at which cache[depth]!=end-of-token
name|int
name|effectiveDepth
init|=
name|alt
operator|.
name|lookaheadDepth
decl_stmt|;
if|if
condition|(
name|effectiveDepth
operator|==
name|GrammarAnalyzer
operator|.
name|NONDETERMINISTIC
condition|)
block|{
comment|// use maximum lookahead
name|effectiveDepth
operator|=
name|grammar
operator|.
name|maxk
expr_stmt|;
block|}
while|while
condition|(
name|effectiveDepth
operator|>=
literal|1
operator|&&
name|alt
operator|.
name|cache
index|[
name|effectiveDepth
index|]
operator|.
name|containsEpsilon
argument_list|()
condition|)
block|{
name|effectiveDepth
operator|--
expr_stmt|;
block|}
comment|// Ignore alts whose effective depth is other than the ones we
comment|// are generating for this iteration.
if|if
condition|(
name|effectiveDepth
operator|!=
name|altDepth
condition|)
block|{
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"ignoring alt because effectiveDepth!=altDepth;"
operator|+
name|effectiveDepth
operator|+
literal|"!="
operator|+
name|altDepth
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|unpredicted
operator|=
name|lookaheadIsEmpty
argument_list|(
name|alt
argument_list|,
name|effectiveDepth
argument_list|)
expr_stmt|;
name|e
operator|=
name|getLookaheadTestExpression
argument_list|(
name|alt
argument_list|,
name|effectiveDepth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unpredicted
operator|=
name|lookaheadIsEmpty
argument_list|(
name|alt
argument_list|,
name|grammar
operator|.
name|maxk
argument_list|)
expr_stmt|;
name|e
operator|=
name|getLookaheadTestExpression
argument_list|(
name|alt
argument_list|,
name|grammar
operator|.
name|maxk
argument_list|)
expr_stmt|;
block|}
comment|// Was it a big unicode range that forced unsuitability
comment|// for a case expression?
if|if
condition|(
name|alt
operator|.
name|cache
index|[
literal|1
index|]
operator|.
name|fset
operator|.
name|degree
argument_list|()
operator|>
name|caseSizeThreshold
operator|&&
name|suitableForCaseExpression
argument_list|(
name|alt
argument_list|)
condition|)
block|{
if|if
condition|(
name|nIF
operator|==
literal|0
condition|)
block|{
comment|// generate this only for the first if the elseif's
comment|// are covered by this one
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
name|println
argument_list|(
literal|"if (_t == "
operator|+
name|labeledElementASTInit
operator|+
literal|" )"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"_t = ASTNULL;"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
block|}
name|println
argument_list|(
literal|"if "
operator|+
name|e
operator|+
literal|" {"
argument_list|)
expr_stmt|;
block|}
else|else
name|println
argument_list|(
literal|"else if "
operator|+
name|e
operator|+
literal|" {"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unpredicted
operator|&&
name|alt
operator|.
name|semPred
operator|==
literal|null
operator|&&
name|alt
operator|.
name|synPred
operator|==
literal|null
condition|)
block|{
comment|// The alt has empty prediction set and no
comment|// predicate to help out.  if we have not
comment|// generated a previous if, just put {...} around
comment|// the end-of-token clause
if|if
condition|(
name|nIF
operator|==
literal|0
condition|)
block|{
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
literal|"else {"
argument_list|)
expr_stmt|;
block|}
name|finishingInfo
operator|.
name|needAnErrorClause
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// check for sem and syn preds
comment|// Add any semantic predicate expression to the lookahead test
if|if
condition|(
name|alt
operator|.
name|semPred
operator|!=
literal|null
condition|)
block|{
comment|// if debugging, wrap the evaluation of the predicate in a method
comment|//
comment|// translate $ and # references
name|ActionTransInfo
name|tInfo
init|=
operator|new
name|ActionTransInfo
argument_list|()
decl_stmt|;
name|String
name|actionStr
init|=
name|processActionForSpecialSymbols
argument_list|(
name|alt
operator|.
name|semPred
argument_list|,
name|blk
operator|.
name|line
argument_list|,
name|currentRule
argument_list|,
name|tInfo
argument_list|)
decl_stmt|;
comment|// ignore translation info...we don't need to do anything with it.
comment|// call that will inform SemanticPredicateListeners of the
comment|// result
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
operator|&&
operator|(
operator|(
name|grammar
operator|instanceof
name|ParserGrammar
operator|)
operator|||
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
operator|)
condition|)
name|e
operator|=
literal|"("
operator|+
name|e
operator|+
literal|"&& fireSemanticPredicateEvaluated(antlr.debug.SemanticPredicateEvent.PREDICTING,"
operator|+
comment|//FIXME
name|addSemPred
argument_list|(
name|charFormatter
operator|.
name|escapeString
argument_list|(
name|actionStr
argument_list|)
argument_list|)
operator|+
literal|","
operator|+
name|actionStr
operator|+
literal|"))"
expr_stmt|;
else|else
name|e
operator|=
literal|"("
operator|+
name|e
operator|+
literal|"&&("
operator|+
name|actionStr
operator|+
literal|"))"
expr_stmt|;
block|}
comment|// Generate any syntactic predicates
if|if
condition|(
name|nIF
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|alt
operator|.
name|synPred
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"else {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|genSynPred
argument_list|(
name|alt
operator|.
name|synPred
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|closingBracesOfIFSequence
operator|++
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
literal|"else if "
operator|+
name|e
operator|+
literal|" {"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|alt
operator|.
name|synPred
operator|!=
literal|null
condition|)
block|{
name|genSynPred
argument_list|(
name|alt
operator|.
name|synPred
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// when parsing trees, convert null to valid tree node
comment|// with NULL lookahead.
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
name|println
argument_list|(
literal|"if (_t == "
operator|+
name|labeledElementASTInit
operator|+
literal|" )"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"_t = ASTNULL;"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
block|}
name|println
argument_list|(
literal|"if "
operator|+
name|e
operator|+
literal|" {"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|nIF
operator|++
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|genAlt
argument_list|(
name|alt
argument_list|,
name|blk
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|ps
init|=
literal|""
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|closingBracesOfIFSequence
condition|;
name|i
operator|++
control|)
block|{
name|tabs
operator|--
expr_stmt|;
comment|// does JavaCodeGenerator need this?
name|ps
operator|+=
literal|"}"
expr_stmt|;
block|}
comment|// Restore the AST generation state
name|genAST
operator|=
name|savegenAST
expr_stmt|;
comment|// restore save text state
name|saveText
operator|=
name|oldsaveTest
expr_stmt|;
comment|// Return the finishing info.
if|if
condition|(
name|createdLL1Switch
condition|)
block|{
name|tabs
operator|--
expr_stmt|;
name|finishingInfo
operator|.
name|postscript
operator|=
name|ps
operator|+
literal|"}"
expr_stmt|;
name|finishingInfo
operator|.
name|generatedSwitch
operator|=
literal|true
expr_stmt|;
name|finishingInfo
operator|.
name|generatedAnIf
operator|=
name|nIF
operator|>
literal|0
expr_stmt|;
comment|//return new CppBlockFinishingInfo(ps+"}",true,nIF>0); // close up switch statement
block|}
else|else
block|{
name|finishingInfo
operator|.
name|postscript
operator|=
name|ps
expr_stmt|;
name|finishingInfo
operator|.
name|generatedSwitch
operator|=
literal|false
expr_stmt|;
name|finishingInfo
operator|.
name|generatedAnIf
operator|=
name|nIF
operator|>
literal|0
expr_stmt|;
comment|//return new CppBlockFinishingInfo(ps, false,nIF>0);
block|}
return|return
name|finishingInfo
return|;
block|}
DECL|method|suitableForCaseExpression (Alternative a)
specifier|private
specifier|static
name|boolean
name|suitableForCaseExpression
parameter_list|(
name|Alternative
name|a
parameter_list|)
block|{
return|return
name|a
operator|.
name|lookaheadDepth
operator|==
literal|1
operator|&&
name|a
operator|.
name|semPred
operator|==
literal|null
operator|&&
operator|!
name|a
operator|.
name|cache
index|[
literal|1
index|]
operator|.
name|containsEpsilon
argument_list|()
operator|&&
name|a
operator|.
name|cache
index|[
literal|1
index|]
operator|.
name|fset
operator|.
name|degree
argument_list|()
operator|<=
name|caseSizeThreshold
return|;
block|}
comment|/** Generate code to link an element reference into the AST 	 */
DECL|method|genElementAST (AlternativeElement el)
specifier|private
name|void
name|genElementAST
parameter_list|(
name|AlternativeElement
name|el
parameter_list|)
block|{
comment|// handle case where you're not building trees, but are in tree walker.
comment|// Just need to get labels set up.
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
operator|&&
operator|!
name|grammar
operator|.
name|buildAST
condition|)
block|{
name|String
name|elementRef
decl_stmt|;
name|String
name|astName
decl_stmt|;
comment|// Generate names and declarations of the AST variable(s)
if|if
condition|(
name|el
operator|.
name|getLabel
argument_list|()
operator|==
literal|null
condition|)
block|{
name|elementRef
operator|=
name|lt1Value
expr_stmt|;
comment|// Generate AST variables for unlabeled stuff
name|astName
operator|=
literal|"tmp"
operator|+
name|astVarNumber
operator|+
literal|"_AST"
expr_stmt|;
name|astVarNumber
operator|++
expr_stmt|;
comment|// Map the generated AST variable in the alternate
name|mapTreeVariable
argument_list|(
name|el
argument_list|,
name|astName
argument_list|)
expr_stmt|;
comment|// Generate an "input" AST variable also
name|println
argument_list|(
name|labeledElementASTType
operator|+
literal|" "
operator|+
name|astName
operator|+
literal|"_in = "
operator|+
name|elementRef
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|grammar
operator|.
name|buildAST
operator|&&
name|syntacticPredLevel
operator|==
literal|0
condition|)
block|{
name|boolean
name|needASTDecl
init|=
operator|(
name|genAST
operator|&&
operator|(
name|el
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
operator|||
name|el
operator|.
name|getAutoGenType
argument_list|()
operator|!=
name|GrammarElement
operator|.
name|AUTO_GEN_BANG
operator|)
operator|)
decl_stmt|;
comment|// RK: if we have a grammar element always generate the decl
comment|// since some guy can access it from an action and we can't
comment|// peek ahead (well not without making a mess).
comment|// I'd prefer taking this out.
if|if
condition|(
name|el
operator|.
name|getAutoGenType
argument_list|()
operator|!=
name|GrammarElement
operator|.
name|AUTO_GEN_BANG
operator|&&
operator|(
name|el
operator|instanceof
name|TokenRefElement
operator|)
condition|)
name|needASTDecl
operator|=
literal|true
expr_stmt|;
name|boolean
name|doNoGuessTest
init|=
operator|(
name|grammar
operator|.
name|hasSyntacticPredicate
operator|&&
name|needASTDecl
operator|)
decl_stmt|;
name|String
name|elementRef
decl_stmt|;
name|String
name|astNameBase
decl_stmt|;
comment|// Generate names and declarations of the AST variable(s)
if|if
condition|(
name|el
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// if the element is labeled use that name...
name|elementRef
operator|=
name|el
operator|.
name|getLabel
argument_list|()
expr_stmt|;
name|astNameBase
operator|=
name|el
operator|.
name|getLabel
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// else generate a temporary name...
name|elementRef
operator|=
name|lt1Value
expr_stmt|;
comment|// Generate AST variables for unlabeled stuff
name|astNameBase
operator|=
literal|"tmp"
operator|+
name|astVarNumber
expr_stmt|;
name|astVarNumber
operator|++
expr_stmt|;
block|}
comment|// Generate the declaration if required.
if|if
condition|(
name|needASTDecl
condition|)
block|{
if|if
condition|(
name|el
operator|instanceof
name|GrammarAtom
condition|)
block|{
name|GrammarAtom
name|ga
init|=
operator|(
name|GrammarAtom
operator|)
name|el
decl_stmt|;
if|if
condition|(
name|ga
operator|.
name|getASTNodeType
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|genASTDeclaration
argument_list|(
name|el
argument_list|,
name|astNameBase
argument_list|,
literal|"Ref"
operator|+
name|ga
operator|.
name|getASTNodeType
argument_list|()
argument_list|)
expr_stmt|;
comment|//						println("Ref"+ga.getASTNodeType()+" " + astName + ";");
block|}
else|else
block|{
name|genASTDeclaration
argument_list|(
name|el
argument_list|,
name|astNameBase
argument_list|,
name|labeledElementASTType
argument_list|)
expr_stmt|;
comment|//						println(labeledElementASTType+" " + astName + " = "+labeledElementASTInit+";");
block|}
block|}
else|else
block|{
name|genASTDeclaration
argument_list|(
name|el
argument_list|,
name|astNameBase
argument_list|,
name|labeledElementASTType
argument_list|)
expr_stmt|;
comment|//					println(labeledElementASTType+" " + astName + " = "+labeledElementASTInit+";");
block|}
block|}
comment|// for convenience..
name|String
name|astName
init|=
name|astNameBase
operator|+
literal|"_AST"
decl_stmt|;
comment|// Map the generated AST variable in the alternate
name|mapTreeVariable
argument_list|(
name|el
argument_list|,
name|astName
argument_list|)
expr_stmt|;
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
comment|// Generate an "input" AST variable also
name|println
argument_list|(
name|labeledElementASTType
operator|+
literal|" "
operator|+
name|astName
operator|+
literal|"_in = "
operator|+
name|labeledElementASTInit
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
comment|// Enclose actions with !guessing
if|if
condition|(
name|doNoGuessTest
condition|)
block|{
name|println
argument_list|(
literal|"if ( inputState->guessing == 0 ) {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
block|}
comment|// if something has a label assume it will be used
comment|// so we must initialize the RefAST
if|if
condition|(
name|el
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|el
operator|instanceof
name|GrammarAtom
condition|)
block|{
name|println
argument_list|(
name|astName
operator|+
literal|" = "
operator|+
name|getASTCreateString
argument_list|(
operator|(
name|GrammarAtom
operator|)
name|el
argument_list|,
name|elementRef
argument_list|)
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
name|astName
operator|+
literal|" = "
operator|+
name|getASTCreateString
argument_list|(
name|elementRef
argument_list|)
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if it has no label but a declaration exists initialize it.
if|if
condition|(
name|el
operator|.
name|getLabel
argument_list|()
operator|==
literal|null
operator|&&
name|needASTDecl
condition|)
block|{
name|elementRef
operator|=
name|lt1Value
expr_stmt|;
if|if
condition|(
name|el
operator|instanceof
name|GrammarAtom
condition|)
block|{
name|println
argument_list|(
name|astName
operator|+
literal|" = "
operator|+
name|getASTCreateString
argument_list|(
operator|(
name|GrammarAtom
operator|)
name|el
argument_list|,
name|elementRef
argument_list|)
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
name|astName
operator|+
literal|" = "
operator|+
name|getASTCreateString
argument_list|(
name|elementRef
argument_list|)
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
comment|// Map the generated AST variable in the alternate
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
comment|// set "input" AST variable also
name|println
argument_list|(
name|astName
operator|+
literal|"_in = "
operator|+
name|elementRef
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|genAST
condition|)
block|{
switch|switch
condition|(
name|el
operator|.
name|getAutoGenType
argument_list|()
condition|)
block|{
case|case
name|GrammarElement
operator|.
name|AUTO_GEN_NONE
case|:
if|if
condition|(
name|usingCustomAST
operator|||
operator|(
name|el
operator|instanceof
name|GrammarAtom
operator|&&
operator|(
operator|(
name|GrammarAtom
operator|)
name|el
operator|)
operator|.
name|getASTNodeType
argument_list|()
operator|!=
literal|null
operator|)
condition|)
name|println
argument_list|(
literal|"astFactory->addASTChild(currentAST, "
operator|+
name|namespaceAntlr
operator|+
literal|"RefAST("
operator|+
name|astName
operator|+
literal|"));"
argument_list|)
expr_stmt|;
else|else
name|println
argument_list|(
literal|"astFactory->addASTChild(currentAST, "
operator|+
name|astName
operator|+
literal|");"
argument_list|)
expr_stmt|;
comment|//						println("astFactory.addASTChild(currentAST, "+namespaceAntlr+"RefAST(" + astName + "));");
break|break;
case|case
name|GrammarElement
operator|.
name|AUTO_GEN_CARET
case|:
if|if
condition|(
name|usingCustomAST
operator|||
operator|(
name|el
operator|instanceof
name|GrammarAtom
operator|&&
operator|(
operator|(
name|GrammarAtom
operator|)
name|el
operator|)
operator|.
name|getASTNodeType
argument_list|()
operator|!=
literal|null
operator|)
condition|)
name|println
argument_list|(
literal|"astFactory->makeASTRoot(currentAST, "
operator|+
name|namespaceAntlr
operator|+
literal|"RefAST("
operator|+
name|astName
operator|+
literal|"));"
argument_list|)
expr_stmt|;
else|else
name|println
argument_list|(
literal|"astFactory->makeASTRoot(currentAST, "
operator|+
name|astName
operator|+
literal|");"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|doNoGuessTest
condition|)
block|{
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Close the try block and generate catch phrases 	 * if the element has a labeled handler in the rule 	 */
DECL|method|genErrorCatchForElement (AlternativeElement el)
specifier|private
name|void
name|genErrorCatchForElement
parameter_list|(
name|AlternativeElement
name|el
parameter_list|)
block|{
if|if
condition|(
name|el
operator|.
name|getLabel
argument_list|()
operator|==
literal|null
condition|)
return|return;
name|String
name|r
init|=
name|el
operator|.
name|enclosingRuleName
decl_stmt|;
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
block|{
name|r
operator|=
name|CodeGenerator
operator|.
name|encodeLexerRuleName
argument_list|(
name|el
operator|.
name|enclosingRuleName
argument_list|)
expr_stmt|;
block|}
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|grammar
operator|.
name|getSymbol
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|==
literal|null
condition|)
block|{
name|antlrTool
operator|.
name|panic
argument_list|(
literal|"Enclosing rule not found!"
argument_list|)
expr_stmt|;
block|}
name|ExceptionSpec
name|ex
init|=
name|rs
operator|.
name|block
operator|.
name|findExceptionSpec
argument_list|(
name|el
operator|.
name|getLabel
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
block|{
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|genErrorHandler
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate the catch phrases for a user-specified error handler */
DECL|method|genErrorHandler (ExceptionSpec ex)
specifier|private
name|void
name|genErrorHandler
parameter_list|(
name|ExceptionSpec
name|ex
parameter_list|)
block|{
comment|// Each ExceptionHandler in the ExceptionSpec is a separate catch
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ex
operator|.
name|handlers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ExceptionHandler
name|handler
init|=
operator|(
name|ExceptionHandler
operator|)
name|ex
operator|.
name|handlers
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Generate catch phrase
name|println
argument_list|(
literal|"catch ("
operator|+
name|handler
operator|.
name|exceptionTypeAndName
operator|.
name|getText
argument_list|()
operator|+
literal|") {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
if|if
condition|(
name|grammar
operator|.
name|hasSyntacticPredicate
condition|)
block|{
name|println
argument_list|(
literal|"if (inputState->guessing==0) {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
block|}
comment|// When not guessing, execute user handler action
name|ActionTransInfo
name|tInfo
init|=
operator|new
name|ActionTransInfo
argument_list|()
decl_stmt|;
name|genLineNo
argument_list|(
name|handler
operator|.
name|action
argument_list|)
expr_stmt|;
name|printAction
argument_list|(
name|processActionForSpecialSymbols
argument_list|(
name|handler
operator|.
name|action
operator|.
name|getText
argument_list|()
argument_list|,
name|handler
operator|.
name|action
operator|.
name|getLine
argument_list|()
argument_list|,
name|currentRule
argument_list|,
name|tInfo
argument_list|)
argument_list|)
expr_stmt|;
name|genLineNo2
argument_list|()
expr_stmt|;
if|if
condition|(
name|grammar
operator|.
name|hasSyntacticPredicate
condition|)
block|{
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"} else {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// When guessing, rethrow exception
name|println
argument_list|(
literal|"throw;"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
comment|// Close catch phrase
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Generate a try { opening if the element has a labeled handler in the rule */
DECL|method|genErrorTryForElement (AlternativeElement el)
specifier|private
name|void
name|genErrorTryForElement
parameter_list|(
name|AlternativeElement
name|el
parameter_list|)
block|{
if|if
condition|(
name|el
operator|.
name|getLabel
argument_list|()
operator|==
literal|null
condition|)
return|return;
name|String
name|r
init|=
name|el
operator|.
name|enclosingRuleName
decl_stmt|;
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
block|{
name|r
operator|=
name|CodeGenerator
operator|.
name|encodeLexerRuleName
argument_list|(
name|el
operator|.
name|enclosingRuleName
argument_list|)
expr_stmt|;
block|}
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|grammar
operator|.
name|getSymbol
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|==
literal|null
condition|)
block|{
name|antlrTool
operator|.
name|panic
argument_list|(
literal|"Enclosing rule not found!"
argument_list|)
expr_stmt|;
block|}
name|ExceptionSpec
name|ex
init|=
name|rs
operator|.
name|block
operator|.
name|findExceptionSpec
argument_list|(
name|el
operator|.
name|getLabel
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"try { // for error handling"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
block|}
block|}
comment|/** Generate a header that is common to all C++ files */
DECL|method|genHeader (String fileName)
specifier|protected
name|void
name|genHeader
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
name|println
argument_list|(
literal|"/* $ANTLR "
operator|+
name|antlrTool
operator|.
name|version
operator|+
literal|": "
operator|+
literal|"\""
operator|+
name|antlrTool
operator|.
name|fileMinusPath
argument_list|(
name|antlrTool
operator|.
name|grammarFile
argument_list|)
operator|+
literal|"\""
operator|+
literal|" -> "
operator|+
literal|"\""
operator|+
name|fileName
operator|+
literal|"\"$ */"
argument_list|)
expr_stmt|;
block|}
comment|// these are unique to C++ mode
DECL|method|genInclude (LexerGrammar g)
specifier|public
name|void
name|genInclude
parameter_list|(
name|LexerGrammar
name|g
parameter_list|)
throws|throws
name|IOException
block|{
name|outputFile
operator|=
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|".hpp"
expr_stmt|;
name|outputLine
operator|=
literal|1
expr_stmt|;
name|currentOutput
operator|=
name|antlrTool
operator|.
name|openOutputFile
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
comment|//SAS: changed for proper text file io
name|genAST
operator|=
literal|false
expr_stmt|;
comment|// no way to gen trees.
name|saveText
operator|=
literal|true
expr_stmt|;
comment|// save consumed characters.
name|tabs
operator|=
literal|0
expr_stmt|;
comment|// Generate a guard wrapper
name|println
argument_list|(
literal|"#ifndef INC_"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"_hpp_"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#define INC_"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"_hpp_"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printHeaderAction
argument_list|(
name|preIncludeHpp
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/config.hpp>"
argument_list|)
expr_stmt|;
comment|// Generate header common to all C++ output files
name|genHeader
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
comment|// Generate header specific to lexer header file
name|println
argument_list|(
literal|"#include<antlr/CommonToken.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/InputBuffer.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/BitSet.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include \""
operator|+
name|grammar
operator|.
name|tokenManager
operator|.
name|getName
argument_list|()
operator|+
name|TokenTypesFileSuffix
operator|+
literal|".hpp\""
argument_list|)
expr_stmt|;
comment|// Find the name of the super class
name|String
name|sup
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|grammar
operator|.
name|superClass
operator|!=
literal|null
condition|)
block|{
name|sup
operator|=
name|grammar
operator|.
name|superClass
expr_stmt|;
name|println
argument_list|(
literal|"\n// Include correct superclass header with a header statement for example:"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// header \"post_include_hpp\" {"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// #include \""
operator|+
name|sup
operator|+
literal|".hpp\""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// }"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// Or...."
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// header {"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// #include \""
operator|+
name|sup
operator|+
literal|".hpp\""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// }\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sup
operator|=
name|grammar
operator|.
name|getSuperClass
argument_list|()
expr_stmt|;
if|if
condition|(
name|sup
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|sup
operator|=
name|sup
operator|.
name|substring
argument_list|(
name|sup
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/"
operator|+
name|sup
operator|+
literal|".hpp>"
argument_list|)
expr_stmt|;
name|sup
operator|=
name|namespaceAntlr
operator|+
name|sup
expr_stmt|;
block|}
comment|// Do not use printAction because we assume tabs==0
name|printHeaderAction
argument_list|(
name|postIncludeHpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameSpace
operator|!=
literal|null
condition|)
name|nameSpace
operator|.
name|emitDeclarations
argument_list|(
name|currentOutput
argument_list|)
expr_stmt|;
name|printHeaderAction
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// print javadoc comment if any
if|if
condition|(
name|grammar
operator|.
name|comment
operator|!=
literal|null
condition|)
block|{
name|_println
argument_list|(
name|grammar
operator|.
name|comment
argument_list|)
expr_stmt|;
block|}
comment|// Generate lexer class definition
name|print
argument_list|(
literal|"class CUSTOM_API "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|" : public "
operator|+
name|sup
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|", public "
operator|+
name|grammar
operator|.
name|tokenManager
operator|.
name|getName
argument_list|()
operator|+
name|TokenTypesFileSuffix
argument_list|)
expr_stmt|;
name|Token
name|tsuffix
init|=
operator|(
name|Token
operator|)
name|grammar
operator|.
name|options
operator|.
name|get
argument_list|(
literal|"classHeaderSuffix"
argument_list|)
decl_stmt|;
if|if
condition|(
name|tsuffix
operator|!=
literal|null
condition|)
block|{
name|String
name|suffix
init|=
name|StringUtils
operator|.
name|stripFrontBack
argument_list|(
name|tsuffix
operator|.
name|getText
argument_list|()
argument_list|,
literal|"\""
argument_list|,
literal|"\""
argument_list|)
decl_stmt|;
if|if
condition|(
name|suffix
operator|!=
literal|null
condition|)
block|{
name|print
argument_list|(
literal|", "
operator|+
name|suffix
argument_list|)
expr_stmt|;
comment|// must be an interface name for Java
block|}
block|}
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
comment|// Generate user-defined lexer class members
if|if
condition|(
name|grammar
operator|.
name|classMemberAction
operator|!=
literal|null
condition|)
block|{
name|genLineNo
argument_list|(
name|grammar
operator|.
name|classMemberAction
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|processActionForSpecialSymbols
argument_list|(
name|grammar
operator|.
name|classMemberAction
operator|.
name|getText
argument_list|()
argument_list|,
name|grammar
operator|.
name|classMemberAction
operator|.
name|getLine
argument_list|()
argument_list|,
name|currentRule
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|genLineNo2
argument_list|()
expr_stmt|;
block|}
comment|// Generate initLiterals() method
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"private:"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
name|println
argument_list|(
literal|"void initLiterals();"
argument_list|)
expr_stmt|;
comment|// Generate getCaseSensitiveLiterals() method
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"public:"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
name|println
argument_list|(
literal|"bool getCaseSensitiveLiterals() const"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"return "
operator|+
name|g
operator|.
name|caseSensitiveLiterals
operator|+
literal|";"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
comment|// Make constructors public
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"public:"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|noConstructors
condition|)
block|{
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"#if 0"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// constructor creation turned of with 'noConstructor' option"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
block|}
comment|// Generate the constructor from std::istream
name|println
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"("
operator|+
name|namespaceStd
operator|+
literal|"istream& in);"
argument_list|)
expr_stmt|;
comment|// Generate the constructor from InputBuffer
name|println
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"("
operator|+
name|namespaceAntlr
operator|+
literal|"InputBuffer& ib);"
argument_list|)
expr_stmt|;
name|println
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"(const "
operator|+
name|namespaceAntlr
operator|+
literal|"LexerSharedInputState& state);"
argument_list|)
expr_stmt|;
if|if
condition|(
name|noConstructors
condition|)
block|{
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"// constructor creation turned of with 'noConstructor' option"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
block|}
comment|// Generate nextToken() rule.
comment|// nextToken() is a synthetic lexer rule that is the implicit OR of all
comment|// user-defined lexer rules.
name|println
argument_list|(
name|namespaceAntlr
operator|+
literal|"RefToken nextToken();"
argument_list|)
expr_stmt|;
comment|// Generate code for each rule in the lexer
name|Enumeration
name|ids
init|=
name|grammar
operator|.
name|rules
operator|.
name|elements
argument_list|()
decl_stmt|;
while|while
condition|(
name|ids
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|RuleSymbol
name|sym
init|=
operator|(
name|RuleSymbol
operator|)
name|ids
operator|.
name|nextElement
argument_list|()
decl_stmt|;
comment|// Don't generate the synthetic rules
if|if
condition|(
operator|!
name|sym
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
literal|"mnextToken"
argument_list|)
condition|)
block|{
name|genRuleHeader
argument_list|(
name|sym
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|exitIfError
argument_list|()
expr_stmt|;
block|}
comment|// Make the rest private
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"private:"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
comment|// generate the rule name array for debugging
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
condition|)
block|{
name|println
argument_list|(
literal|"static const char* _ruleNames[];"
argument_list|)
expr_stmt|;
block|}
comment|// Generate the semantic predicate map for debugging
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
condition|)
name|println
argument_list|(
literal|"static const char* _semPredNames[];"
argument_list|)
expr_stmt|;
comment|// Generate the bitsets used throughout the lexer
name|genBitsetsHeader
argument_list|(
name|bitsetsUsed
argument_list|,
operator|(
operator|(
name|LexerGrammar
operator|)
name|grammar
operator|)
operator|.
name|charVocabulary
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"};"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameSpace
operator|!=
literal|null
condition|)
name|nameSpace
operator|.
name|emitClosures
argument_list|(
name|currentOutput
argument_list|)
expr_stmt|;
comment|// Generate a guard wrapper
name|println
argument_list|(
literal|"#endif /*INC_"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"_hpp_*/"
argument_list|)
expr_stmt|;
comment|// Close the lexer output stream
name|currentOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentOutput
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|genInclude (ParserGrammar g)
specifier|public
name|void
name|genInclude
parameter_list|(
name|ParserGrammar
name|g
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Open the output stream for the parser and set the currentOutput
name|outputFile
operator|=
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|".hpp"
expr_stmt|;
name|outputLine
operator|=
literal|1
expr_stmt|;
name|currentOutput
operator|=
name|antlrTool
operator|.
name|openOutputFile
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
comment|//SAS: changed for proper text file io
name|genAST
operator|=
name|grammar
operator|.
name|buildAST
expr_stmt|;
name|tabs
operator|=
literal|0
expr_stmt|;
comment|// Generate a guard wrapper
name|println
argument_list|(
literal|"#ifndef INC_"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"_hpp_"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#define INC_"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"_hpp_"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printHeaderAction
argument_list|(
name|preIncludeHpp
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/config.hpp>"
argument_list|)
expr_stmt|;
comment|// Generate the header common to all output files.
name|genHeader
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
comment|// Generate header for the parser
name|println
argument_list|(
literal|"#include<antlr/TokenStream.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/TokenBuffer.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include \""
operator|+
name|grammar
operator|.
name|tokenManager
operator|.
name|getName
argument_list|()
operator|+
name|TokenTypesFileSuffix
operator|+
literal|".hpp\""
argument_list|)
expr_stmt|;
comment|// Generate parser class definition
name|String
name|sup
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|grammar
operator|.
name|superClass
operator|!=
literal|null
condition|)
block|{
name|sup
operator|=
name|grammar
operator|.
name|superClass
expr_stmt|;
name|println
argument_list|(
literal|"\n// Include correct superclass header with a header statement for example:"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// header \"post_include_hpp\" {"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// #include \""
operator|+
name|sup
operator|+
literal|".hpp\""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// }"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// Or...."
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// header {"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// #include \""
operator|+
name|sup
operator|+
literal|".hpp\""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// }\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sup
operator|=
name|grammar
operator|.
name|getSuperClass
argument_list|()
expr_stmt|;
if|if
condition|(
name|sup
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|sup
operator|=
name|sup
operator|.
name|substring
argument_list|(
name|sup
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/"
operator|+
name|sup
operator|+
literal|".hpp>"
argument_list|)
expr_stmt|;
name|sup
operator|=
name|namespaceAntlr
operator|+
name|sup
expr_stmt|;
block|}
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// Do not use printAction because we assume tabs==0
name|printHeaderAction
argument_list|(
name|postIncludeHpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameSpace
operator|!=
literal|null
condition|)
name|nameSpace
operator|.
name|emitDeclarations
argument_list|(
name|currentOutput
argument_list|)
expr_stmt|;
name|printHeaderAction
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// print javadoc comment if any
if|if
condition|(
name|grammar
operator|.
name|comment
operator|!=
literal|null
condition|)
block|{
name|_println
argument_list|(
name|grammar
operator|.
name|comment
argument_list|)
expr_stmt|;
block|}
comment|// generate the actual class definition
name|print
argument_list|(
literal|"class CUSTOM_API "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|" : public "
operator|+
name|sup
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|", public "
operator|+
name|grammar
operator|.
name|tokenManager
operator|.
name|getName
argument_list|()
operator|+
name|TokenTypesFileSuffix
argument_list|)
expr_stmt|;
name|Token
name|tsuffix
init|=
operator|(
name|Token
operator|)
name|grammar
operator|.
name|options
operator|.
name|get
argument_list|(
literal|"classHeaderSuffix"
argument_list|)
decl_stmt|;
if|if
condition|(
name|tsuffix
operator|!=
literal|null
condition|)
block|{
name|String
name|suffix
init|=
name|StringUtils
operator|.
name|stripFrontBack
argument_list|(
name|tsuffix
operator|.
name|getText
argument_list|()
argument_list|,
literal|"\""
argument_list|,
literal|"\""
argument_list|)
decl_stmt|;
if|if
condition|(
name|suffix
operator|!=
literal|null
condition|)
name|print
argument_list|(
literal|", "
operator|+
name|suffix
argument_list|)
expr_stmt|;
comment|// must be an interface name for Java
block|}
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
comment|// set up an array of all the rule names so the debugger can
comment|// keep track of them only by number -- less to store in tree...
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
condition|)
block|{
name|println
argument_list|(
literal|"public: static const char* _ruleNames[];"
argument_list|)
expr_stmt|;
block|}
comment|// Generate user-defined parser class members
if|if
condition|(
name|grammar
operator|.
name|classMemberAction
operator|!=
literal|null
condition|)
block|{
name|genLineNo
argument_list|(
name|grammar
operator|.
name|classMemberAction
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|processActionForSpecialSymbols
argument_list|(
name|grammar
operator|.
name|classMemberAction
operator|.
name|getText
argument_list|()
argument_list|,
name|grammar
operator|.
name|classMemberAction
operator|.
name|getLine
argument_list|()
argument_list|,
name|currentRule
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|genLineNo2
argument_list|()
expr_stmt|;
block|}
name|println
argument_list|(
literal|"public:"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
name|println
argument_list|(
literal|"void initializeASTFactory( "
operator|+
name|namespaceAntlr
operator|+
literal|"ASTFactory& factory );"
argument_list|)
expr_stmt|;
comment|//		println("// called from constructors");
comment|//		println("void _initialize( void );");
comment|// Generate parser class constructor from TokenBuffer
name|tabs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|noConstructors
condition|)
block|{
name|println
argument_list|(
literal|"#if 0"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// constructor creation turned of with 'noConstructor' option"
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
literal|"protected:"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
name|println
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"("
operator|+
name|namespaceAntlr
operator|+
literal|"TokenBuffer& tokenBuf, int k);"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"public:"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
name|println
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"("
operator|+
name|namespaceAntlr
operator|+
literal|"TokenBuffer& tokenBuf);"
argument_list|)
expr_stmt|;
comment|// Generate parser class constructor from TokenStream
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"protected:"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
name|println
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"("
operator|+
name|namespaceAntlr
operator|+
literal|"TokenStream& lexer, int k);"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"public:"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
name|println
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"("
operator|+
name|namespaceAntlr
operator|+
literal|"TokenStream& lexer);"
argument_list|)
expr_stmt|;
name|println
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"(const "
operator|+
name|namespaceAntlr
operator|+
literal|"ParserSharedInputState& state);"
argument_list|)
expr_stmt|;
if|if
condition|(
name|noConstructors
condition|)
block|{
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"// constructor creation turned of with 'noConstructor' option"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
block|}
name|println
argument_list|(
literal|"int getNumTokens() const"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"return "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::NUM_TOKENS;"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"const char* getTokenName( int type ) const"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"if( type> getNumTokens() ) return 0;"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"return "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::tokenNames[type];"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"const char* const* getTokenNames() const"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"return "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::tokenNames;"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
comment|// Generate code for each rule in the grammar
name|Enumeration
name|ids
init|=
name|grammar
operator|.
name|rules
operator|.
name|elements
argument_list|()
decl_stmt|;
while|while
condition|(
name|ids
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|GrammarSymbol
name|sym
init|=
operator|(
name|GrammarSymbol
operator|)
name|ids
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|sym
operator|instanceof
name|RuleSymbol
condition|)
block|{
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|sym
decl_stmt|;
name|genRuleHeader
argument_list|(
name|rs
argument_list|,
name|rs
operator|.
name|references
operator|.
name|size
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|exitIfError
argument_list|()
expr_stmt|;
block|}
comment|// RK: when we are using a custom ast override Parser::getAST to return
comment|// the custom AST type. Ok, this does not work anymore with newer
comment|// compilers gcc 3.2.x and up. The reference counter is probably
comment|// getting in the way.
comment|// So now we just patch the return type back to RefAST
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"public:"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
name|println
argument_list|(
name|namespaceAntlr
operator|+
literal|"RefAST getAST()"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usingCustomAST
condition|)
block|{
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"return "
operator|+
name|namespaceAntlr
operator|+
literal|"RefAST(returnAST);"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
block|}
else|else
block|{
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"return returnAST;"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
block|}
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"protected:"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
name|println
argument_list|(
name|labeledElementASTType
operator|+
literal|" returnAST;"
argument_list|)
expr_stmt|;
comment|// Make the rest private
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"private:"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
comment|// Generate the token names
name|println
argument_list|(
literal|"static const char* tokenNames[];"
argument_list|)
expr_stmt|;
comment|// and how many there are of them
name|_println
argument_list|(
literal|"#ifndef NO_STATIC_CONSTS"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"static const int NUM_TOKENS = "
operator|+
name|grammar
operator|.
name|tokenManager
operator|.
name|getVocabulary
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|";"
argument_list|)
expr_stmt|;
name|_println
argument_list|(
literal|"#else"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"enum {"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"\tNUM_TOKENS = "
operator|+
name|grammar
operator|.
name|tokenManager
operator|.
name|getVocabulary
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"};"
argument_list|)
expr_stmt|;
name|_println
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
comment|// Generate the bitsets used throughout the grammar
name|genBitsetsHeader
argument_list|(
name|bitsetsUsed
argument_list|,
name|grammar
operator|.
name|tokenManager
operator|.
name|maxTokenType
argument_list|()
argument_list|)
expr_stmt|;
comment|// Generate the semantic predicate map for debugging
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
condition|)
name|println
argument_list|(
literal|"static const char* _semPredNames[];"
argument_list|)
expr_stmt|;
comment|// Close class definition
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"};"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameSpace
operator|!=
literal|null
condition|)
name|nameSpace
operator|.
name|emitClosures
argument_list|(
name|currentOutput
argument_list|)
expr_stmt|;
comment|// Generate a guard wrapper
name|println
argument_list|(
literal|"#endif /*INC_"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"_hpp_*/"
argument_list|)
expr_stmt|;
comment|// Close the parser output stream
name|currentOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentOutput
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|genInclude (TreeWalkerGrammar g)
specifier|public
name|void
name|genInclude
parameter_list|(
name|TreeWalkerGrammar
name|g
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Open the output stream for the parser and set the currentOutput
name|outputFile
operator|=
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|".hpp"
expr_stmt|;
name|outputLine
operator|=
literal|1
expr_stmt|;
name|currentOutput
operator|=
name|antlrTool
operator|.
name|openOutputFile
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
comment|//SAS: changed for proper text file io
name|genAST
operator|=
name|grammar
operator|.
name|buildAST
expr_stmt|;
name|tabs
operator|=
literal|0
expr_stmt|;
comment|// Generate a guard wrapper
name|println
argument_list|(
literal|"#ifndef INC_"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"_hpp_"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#define INC_"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"_hpp_"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printHeaderAction
argument_list|(
name|preIncludeHpp
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/config.hpp>"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include \""
operator|+
name|grammar
operator|.
name|tokenManager
operator|.
name|getName
argument_list|()
operator|+
name|TokenTypesFileSuffix
operator|+
literal|".hpp\""
argument_list|)
expr_stmt|;
comment|// Generate the header common to all output files.
name|genHeader
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
comment|// Find the name of the super class
name|String
name|sup
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|grammar
operator|.
name|superClass
operator|!=
literal|null
condition|)
block|{
name|sup
operator|=
name|grammar
operator|.
name|superClass
expr_stmt|;
name|println
argument_list|(
literal|"\n// Include correct superclass header with a header statement for example:"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// header \"post_include_hpp\" {"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// #include \""
operator|+
name|sup
operator|+
literal|".hpp\""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// }"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// Or...."
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// header {"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// #include \""
operator|+
name|sup
operator|+
literal|".hpp\""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// }\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sup
operator|=
name|grammar
operator|.
name|getSuperClass
argument_list|()
expr_stmt|;
if|if
condition|(
name|sup
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|sup
operator|=
name|sup
operator|.
name|substring
argument_list|(
name|sup
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#include<antlr/"
operator|+
name|sup
operator|+
literal|".hpp>"
argument_list|)
expr_stmt|;
name|sup
operator|=
name|namespaceAntlr
operator|+
name|sup
expr_stmt|;
block|}
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// Generate header for the parser
comment|//
comment|// Do not use printAction because we assume tabs==0
name|printHeaderAction
argument_list|(
name|postIncludeHpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameSpace
operator|!=
literal|null
condition|)
name|nameSpace
operator|.
name|emitDeclarations
argument_list|(
name|currentOutput
argument_list|)
expr_stmt|;
name|printHeaderAction
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// print javadoc comment if any
if|if
condition|(
name|grammar
operator|.
name|comment
operator|!=
literal|null
condition|)
block|{
name|_println
argument_list|(
name|grammar
operator|.
name|comment
argument_list|)
expr_stmt|;
block|}
comment|// Generate parser class definition
name|print
argument_list|(
literal|"class CUSTOM_API "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|" : public "
operator|+
name|sup
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|", public "
operator|+
name|grammar
operator|.
name|tokenManager
operator|.
name|getName
argument_list|()
operator|+
name|TokenTypesFileSuffix
argument_list|)
expr_stmt|;
name|Token
name|tsuffix
init|=
operator|(
name|Token
operator|)
name|grammar
operator|.
name|options
operator|.
name|get
argument_list|(
literal|"classHeaderSuffix"
argument_list|)
decl_stmt|;
if|if
condition|(
name|tsuffix
operator|!=
literal|null
condition|)
block|{
name|String
name|suffix
init|=
name|StringUtils
operator|.
name|stripFrontBack
argument_list|(
name|tsuffix
operator|.
name|getText
argument_list|()
argument_list|,
literal|"\""
argument_list|,
literal|"\""
argument_list|)
decl_stmt|;
if|if
condition|(
name|suffix
operator|!=
literal|null
condition|)
block|{
name|print
argument_list|(
literal|", "
operator|+
name|suffix
argument_list|)
expr_stmt|;
comment|// must be an interface name for Java
block|}
block|}
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
comment|// Generate user-defined parser class members
if|if
condition|(
name|grammar
operator|.
name|classMemberAction
operator|!=
literal|null
condition|)
block|{
name|genLineNo
argument_list|(
name|grammar
operator|.
name|classMemberAction
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|processActionForSpecialSymbols
argument_list|(
name|grammar
operator|.
name|classMemberAction
operator|.
name|getText
argument_list|()
argument_list|,
name|grammar
operator|.
name|classMemberAction
operator|.
name|getLine
argument_list|()
argument_list|,
name|currentRule
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|genLineNo2
argument_list|()
expr_stmt|;
block|}
comment|// Generate default parser class constructor
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"public:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|noConstructors
condition|)
block|{
name|println
argument_list|(
literal|"#if 0"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"// constructor creation turned of with 'noConstructor' option"
argument_list|)
expr_stmt|;
block|}
name|tabs
operator|=
literal|1
expr_stmt|;
name|println
argument_list|(
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"();"
argument_list|)
expr_stmt|;
if|if
condition|(
name|noConstructors
condition|)
block|{
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
block|}
comment|// Generate declaration for the initializeFactory method
name|println
argument_list|(
literal|"static void initializeASTFactory( "
operator|+
name|namespaceAntlr
operator|+
literal|"ASTFactory& factory );"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"int getNumTokens() const"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"return "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::NUM_TOKENS;"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"const char* getTokenName( int type ) const"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"if( type> getNumTokens() ) return 0;"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"return "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::tokenNames[type];"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"const char* const* getTokenNames() const"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"return "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::tokenNames;"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
comment|// Generate code for each rule in the grammar
name|Enumeration
name|ids
init|=
name|grammar
operator|.
name|rules
operator|.
name|elements
argument_list|()
decl_stmt|;
name|String
name|ruleNameInits
init|=
literal|""
decl_stmt|;
while|while
condition|(
name|ids
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|GrammarSymbol
name|sym
init|=
operator|(
name|GrammarSymbol
operator|)
name|ids
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|sym
operator|instanceof
name|RuleSymbol
condition|)
block|{
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|sym
decl_stmt|;
name|genRuleHeader
argument_list|(
name|rs
argument_list|,
name|rs
operator|.
name|references
operator|.
name|size
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|exitIfError
argument_list|()
expr_stmt|;
block|}
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"public:"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
name|println
argument_list|(
name|namespaceAntlr
operator|+
literal|"RefAST getAST()"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usingCustomAST
condition|)
block|{
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"return "
operator|+
name|namespaceAntlr
operator|+
literal|"RefAST(returnAST);"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
block|}
else|else
block|{
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"return returnAST;"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
block|}
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"protected:"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
name|println
argument_list|(
name|labeledElementASTType
operator|+
literal|" returnAST;"
argument_list|)
expr_stmt|;
name|println
argument_list|(
name|labeledElementASTType
operator|+
literal|" _retTree;"
argument_list|)
expr_stmt|;
comment|// Make the rest private
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"private:"
argument_list|)
expr_stmt|;
name|tabs
operator|=
literal|1
expr_stmt|;
comment|// Generate the token names
name|println
argument_list|(
literal|"static const char* tokenNames[];"
argument_list|)
expr_stmt|;
comment|// and how many there are of them
name|_println
argument_list|(
literal|"#ifndef NO_STATIC_CONSTS"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"static const int NUM_TOKENS = "
operator|+
name|grammar
operator|.
name|tokenManager
operator|.
name|getVocabulary
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|";"
argument_list|)
expr_stmt|;
name|_println
argument_list|(
literal|"#else"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"enum {"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"\tNUM_TOKENS = "
operator|+
name|grammar
operator|.
name|tokenManager
operator|.
name|getVocabulary
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"};"
argument_list|)
expr_stmt|;
name|_println
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
comment|// Generate the bitsets used throughout the grammar
name|genBitsetsHeader
argument_list|(
name|bitsetsUsed
argument_list|,
name|grammar
operator|.
name|tokenManager
operator|.
name|maxTokenType
argument_list|()
argument_list|)
expr_stmt|;
comment|// Close class definition
name|tabs
operator|=
literal|0
expr_stmt|;
name|println
argument_list|(
literal|"};"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameSpace
operator|!=
literal|null
condition|)
name|nameSpace
operator|.
name|emitClosures
argument_list|(
name|currentOutput
argument_list|)
expr_stmt|;
comment|// Generate a guard wrapper
name|println
argument_list|(
literal|"#endif /*INC_"
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"_hpp_*/"
argument_list|)
expr_stmt|;
comment|// Close the parser output stream
name|currentOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentOutput
operator|=
literal|null
expr_stmt|;
block|}
comment|/// for convenience
DECL|method|genASTDeclaration ( AlternativeElement el )
specifier|protected
name|void
name|genASTDeclaration
parameter_list|(
name|AlternativeElement
name|el
parameter_list|)
block|{
name|genASTDeclaration
argument_list|(
name|el
argument_list|,
name|labeledElementASTType
argument_list|)
expr_stmt|;
block|}
comment|/// for convenience
DECL|method|genASTDeclaration ( AlternativeElement el, String node_type )
specifier|protected
name|void
name|genASTDeclaration
parameter_list|(
name|AlternativeElement
name|el
parameter_list|,
name|String
name|node_type
parameter_list|)
block|{
name|genASTDeclaration
argument_list|(
name|el
argument_list|,
name|el
operator|.
name|getLabel
argument_list|()
argument_list|,
name|node_type
argument_list|)
expr_stmt|;
block|}
comment|/// Generate (if not already done) a declaration for the AST for el.
DECL|method|genASTDeclaration ( AlternativeElement el, String var_name, String node_type )
specifier|protected
name|void
name|genASTDeclaration
parameter_list|(
name|AlternativeElement
name|el
parameter_list|,
name|String
name|var_name
parameter_list|,
name|String
name|node_type
parameter_list|)
block|{
comment|// already declared?
if|if
condition|(
name|declaredASTVariables
operator|.
name|contains
argument_list|(
name|el
argument_list|)
condition|)
return|return;
name|String
name|init
init|=
name|labeledElementASTInit
decl_stmt|;
if|if
condition|(
name|el
operator|instanceof
name|GrammarAtom
operator|&&
operator|(
operator|(
name|GrammarAtom
operator|)
name|el
operator|)
operator|.
name|getASTNodeType
argument_list|()
operator|!=
literal|null
condition|)
name|init
operator|=
literal|"Ref"
operator|+
operator|(
operator|(
name|GrammarAtom
operator|)
name|el
operator|)
operator|.
name|getASTNodeType
argument_list|()
operator|+
literal|"("
operator|+
name|labeledElementASTInit
operator|+
literal|")"
expr_stmt|;
comment|// emit code
name|println
argument_list|(
name|node_type
operator|+
literal|" "
operator|+
name|var_name
operator|+
literal|"_AST = "
operator|+
name|init
operator|+
literal|";"
argument_list|)
expr_stmt|;
comment|// mark as declared
name|declaredASTVariables
operator|.
name|put
argument_list|(
name|el
argument_list|,
name|el
argument_list|)
expr_stmt|;
block|}
DECL|method|genLiteralsTest ()
specifier|private
name|void
name|genLiteralsTest
parameter_list|()
block|{
name|println
argument_list|(
literal|"_ttype = testLiteralsTable(_ttype);"
argument_list|)
expr_stmt|;
block|}
DECL|method|genLiteralsTestForPartialToken ()
specifier|private
name|void
name|genLiteralsTestForPartialToken
parameter_list|()
block|{
name|println
argument_list|(
literal|"_ttype = testLiteralsTable(text.substr(_begin, text.length()-_begin),_ttype);"
argument_list|)
expr_stmt|;
block|}
DECL|method|genMatch (BitSet b)
specifier|protected
name|void
name|genMatch
parameter_list|(
name|BitSet
name|b
parameter_list|)
block|{ 	}
DECL|method|genMatch (GrammarAtom atom)
specifier|protected
name|void
name|genMatch
parameter_list|(
name|GrammarAtom
name|atom
parameter_list|)
block|{
if|if
condition|(
name|atom
operator|instanceof
name|StringLiteralElement
condition|)
block|{
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
block|{
name|genMatchUsingAtomText
argument_list|(
name|atom
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|genMatchUsingAtomTokenType
argument_list|(
name|atom
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|atom
operator|instanceof
name|CharLiteralElement
condition|)
block|{
comment|// Lexer case is handled in the gen( CharLiteralElement x )
name|antlrTool
operator|.
name|error
argument_list|(
literal|"cannot ref character literals in grammar: "
operator|+
name|atom
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|instanceof
name|TokenRefElement
condition|)
block|{
name|genMatchUsingAtomTokenType
argument_list|(
name|atom
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|instanceof
name|WildcardElement
condition|)
block|{
name|gen
argument_list|(
operator|(
name|WildcardElement
operator|)
name|atom
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|genMatchUsingAtomText (GrammarAtom atom)
specifier|protected
name|void
name|genMatchUsingAtomText
parameter_list|(
name|GrammarAtom
name|atom
parameter_list|)
block|{
comment|// match() for trees needs the _t cursor
name|String
name|astArgs
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
if|if
condition|(
name|usingCustomAST
condition|)
name|astArgs
operator|=
name|namespaceAntlr
operator|+
literal|"RefAST"
operator|+
literal|"(_t),"
expr_stmt|;
else|else
name|astArgs
operator|=
literal|"_t,"
expr_stmt|;
block|}
comment|// if in lexer and ! on element, save buffer index to kill later
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|&&
operator|(
operator|!
name|saveText
operator|||
name|atom
operator|.
name|getAutoGenType
argument_list|()
operator|==
name|GrammarElement
operator|.
name|AUTO_GEN_BANG
operator|)
condition|)
block|{
name|println
argument_list|(
literal|"_saveIndex = text.length();"
argument_list|)
expr_stmt|;
block|}
name|print
argument_list|(
name|atom
operator|.
name|not
condition|?
literal|"matchNot("
else|:
literal|"match("
argument_list|)
expr_stmt|;
name|_print
argument_list|(
name|astArgs
argument_list|)
expr_stmt|;
comment|// print out what to match
if|if
condition|(
name|atom
operator|.
name|atomText
operator|.
name|equals
argument_list|(
literal|"EOF"
argument_list|)
condition|)
block|{
comment|// horrible hack to handle EOF case
name|_print
argument_list|(
name|namespaceAntlr
operator|+
literal|"Token::EOF_TYPE"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
comment|// lexer needs special handling
block|{
name|String
name|cppstring
init|=
name|convertJavaToCppString
argument_list|(
name|atom
operator|.
name|atomText
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|_print
argument_list|(
name|cppstring
argument_list|)
expr_stmt|;
block|}
else|else
name|_print
argument_list|(
name|atom
operator|.
name|atomText
argument_list|)
expr_stmt|;
block|}
name|_println
argument_list|(
literal|");"
argument_list|)
expr_stmt|;
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|&&
operator|(
operator|!
name|saveText
operator|||
name|atom
operator|.
name|getAutoGenType
argument_list|()
operator|==
name|GrammarElement
operator|.
name|AUTO_GEN_BANG
operator|)
condition|)
block|{
name|println
argument_list|(
literal|"text.erase(_saveIndex);"
argument_list|)
expr_stmt|;
comment|// kill text atom put in buffer
block|}
block|}
DECL|method|genMatchUsingAtomTokenType (GrammarAtom atom)
specifier|protected
name|void
name|genMatchUsingAtomTokenType
parameter_list|(
name|GrammarAtom
name|atom
parameter_list|)
block|{
comment|// match() for trees needs the _t cursor
name|String
name|astArgs
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
if|if
condition|(
name|usingCustomAST
condition|)
name|astArgs
operator|=
name|namespaceAntlr
operator|+
literal|"RefAST"
operator|+
literal|"(_t),"
expr_stmt|;
else|else
name|astArgs
operator|=
literal|"_t,"
expr_stmt|;
block|}
comment|// If the literal can be mangled, generate the symbolic constant instead
name|String
name|s
init|=
name|astArgs
operator|+
name|getValueString
argument_list|(
name|atom
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
comment|// matching
name|println
argument_list|(
operator|(
name|atom
operator|.
name|not
condition|?
literal|"matchNot("
else|:
literal|"match("
operator|)
operator|+
name|s
operator|+
literal|");"
argument_list|)
expr_stmt|;
block|}
comment|/** Generate the nextToken() rule. 	 * nextToken() is a synthetic lexer rule that is the implicit OR of all 	 * user-defined lexer rules. 	 * @param RuleBlock 	 */
DECL|method|genNextToken ()
specifier|public
name|void
name|genNextToken
parameter_list|()
block|{
comment|// Are there any public rules?  If not, then just generate a
comment|// fake nextToken().
name|boolean
name|hasPublicRules
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grammar
operator|.
name|rules
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|grammar
operator|.
name|rules
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|isDefined
argument_list|()
operator|&&
name|rs
operator|.
name|access
operator|.
name|equals
argument_list|(
literal|"public"
argument_list|)
condition|)
block|{
name|hasPublicRules
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|hasPublicRules
condition|)
block|{
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
name|namespaceAntlr
operator|+
literal|"RefToken "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::nextToken() { return "
operator|+
name|namespaceAntlr
operator|+
literal|"RefToken(new "
operator|+
name|namespaceAntlr
operator|+
literal|"CommonToken("
operator|+
name|namespaceAntlr
operator|+
literal|"Token::EOF_TYPE, \"\")); }"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Create the synthesized nextToken() rule
name|RuleBlock
name|nextTokenBlk
init|=
name|MakeGrammar
operator|.
name|createNextTokenRule
argument_list|(
name|grammar
argument_list|,
name|grammar
operator|.
name|rules
argument_list|,
literal|"nextToken"
argument_list|)
decl_stmt|;
comment|// Define the nextToken rule symbol
name|RuleSymbol
name|nextTokenRs
init|=
operator|new
name|RuleSymbol
argument_list|(
literal|"mnextToken"
argument_list|)
decl_stmt|;
name|nextTokenRs
operator|.
name|setDefined
argument_list|()
expr_stmt|;
name|nextTokenRs
operator|.
name|setBlock
argument_list|(
name|nextTokenBlk
argument_list|)
expr_stmt|;
name|nextTokenRs
operator|.
name|access
operator|=
literal|"private"
expr_stmt|;
name|grammar
operator|.
name|define
argument_list|(
name|nextTokenRs
argument_list|)
expr_stmt|;
comment|// Analyze the nextToken rule
name|boolean
name|ok
init|=
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|deterministic
argument_list|(
name|nextTokenBlk
argument_list|)
decl_stmt|;
comment|// Generate the next token rule
name|String
name|filterRule
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|LexerGrammar
operator|)
name|grammar
operator|)
operator|.
name|filterMode
condition|)
block|{
name|filterRule
operator|=
operator|(
operator|(
name|LexerGrammar
operator|)
name|grammar
operator|)
operator|.
name|filterRule
expr_stmt|;
block|}
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
name|namespaceAntlr
operator|+
literal|"RefToken "
operator|+
name|grammar
operator|.
name|getClassName
argument_list|()
operator|+
literal|"::nextToken()"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
name|namespaceAntlr
operator|+
literal|"RefToken theRetToken;"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"for (;;) {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
name|namespaceAntlr
operator|+
literal|"RefToken theRetToken;"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"int _ttype = "
operator|+
name|namespaceAntlr
operator|+
literal|"Token::INVALID_TYPE;"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|LexerGrammar
operator|)
name|grammar
operator|)
operator|.
name|filterMode
condition|)
block|{
name|println
argument_list|(
literal|"setCommitToPath(false);"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filterRule
operator|!=
literal|null
condition|)
block|{
comment|// Here's a good place to ensure that the filter rule actually exists
if|if
condition|(
operator|!
name|grammar
operator|.
name|isDefined
argument_list|(
name|CodeGenerator
operator|.
name|encodeLexerRuleName
argument_list|(
name|filterRule
argument_list|)
argument_list|)
condition|)
block|{
name|grammar
operator|.
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Filter rule "
operator|+
name|filterRule
operator|+
literal|" does not exist in this lexer"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|grammar
operator|.
name|getSymbol
argument_list|(
name|CodeGenerator
operator|.
name|encodeLexerRuleName
argument_list|(
name|filterRule
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|isDefined
argument_list|()
condition|)
block|{
name|grammar
operator|.
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Filter rule "
operator|+
name|filterRule
operator|+
literal|" does not exist in this lexer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs
operator|.
name|access
operator|.
name|equals
argument_list|(
literal|"public"
argument_list|)
condition|)
block|{
name|grammar
operator|.
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Filter rule "
operator|+
name|filterRule
operator|+
literal|" must be protected"
argument_list|)
expr_stmt|;
block|}
block|}
name|println
argument_list|(
literal|"int _m;"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"_m = mark();"
argument_list|)
expr_stmt|;
block|}
block|}
name|println
argument_list|(
literal|"resetText();"
argument_list|)
expr_stmt|;
comment|// Generate try around whole thing to trap scanner errors
name|println
argument_list|(
literal|"try {   // for lexical and char stream error handling"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// Test for public lexical rules with empty paths
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nextTokenBlk
operator|.
name|getAlternatives
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Alternative
name|a
init|=
name|nextTokenBlk
operator|.
name|getAlternativeAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|cache
index|[
literal|1
index|]
operator|.
name|containsEpsilon
argument_list|()
condition|)
block|{
name|antlrTool
operator|.
name|warning
argument_list|(
literal|"found optional path in nextToken()"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Generate the block
name|String
name|newline
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
name|CppBlockFinishingInfo
name|howToFinish
init|=
name|genCommonBlock
argument_list|(
name|nextTokenBlk
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|String
name|errFinish
init|=
literal|"if (LA(1)==EOF_CHAR)"
operator|+
name|newline
operator|+
literal|"\t\t\t\t{"
operator|+
name|newline
operator|+
literal|"\t\t\t\t\tuponEOF();"
operator|+
name|newline
operator|+
literal|"\t\t\t\t\t_returnToken = makeToken("
operator|+
name|namespaceAntlr
operator|+
literal|"Token::EOF_TYPE);"
operator|+
name|newline
operator|+
literal|"\t\t\t\t}"
decl_stmt|;
name|errFinish
operator|+=
name|newline
operator|+
literal|"\t\t\t\t"
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|LexerGrammar
operator|)
name|grammar
operator|)
operator|.
name|filterMode
condition|)
block|{
if|if
condition|(
name|filterRule
operator|==
literal|null
condition|)
block|{
name|errFinish
operator|+=
literal|"else {consume(); goto tryAgain;}"
expr_stmt|;
block|}
else|else
block|{
name|errFinish
operator|+=
literal|"else {"
operator|+
name|newline
operator|+
literal|"\t\t\t\t\tcommit();"
operator|+
name|newline
operator|+
literal|"\t\t\t\t\ttry {m"
operator|+
name|filterRule
operator|+
literal|"(false);}"
operator|+
name|newline
operator|+
literal|"\t\t\t\t\tcatch("
operator|+
name|namespaceAntlr
operator|+
literal|"RecognitionException& e) {"
operator|+
name|newline
operator|+
literal|"\t\t\t\t\t	// catastrophic failure"
operator|+
name|newline
operator|+
literal|"\t\t\t\t\t	reportError(e);"
operator|+
name|newline
operator|+
literal|"\t\t\t\t\t	consume();"
operator|+
name|newline
operator|+
literal|"\t\t\t\t\t}"
operator|+
name|newline
operator|+
literal|"\t\t\t\t\tgoto tryAgain;"
operator|+
name|newline
operator|+
literal|"\t\t\t\t}"
expr_stmt|;
block|}
block|}
else|else
block|{
name|errFinish
operator|+=
literal|"else {"
operator|+
name|throwNoViable
operator|+
literal|"}"
expr_stmt|;
block|}
name|genBlockFinish
argument_list|(
name|howToFinish
argument_list|,
name|errFinish
argument_list|)
expr_stmt|;
comment|// at this point a valid token has been matched, undo "mark" that was done
if|if
condition|(
operator|(
operator|(
name|LexerGrammar
operator|)
name|grammar
operator|)
operator|.
name|filterMode
operator|&&
name|filterRule
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"commit();"
argument_list|)
expr_stmt|;
block|}
comment|// Generate literals test if desired
comment|// make sure _ttype is set first; note _returnToken must be
comment|// non-null as the rule was required to create it.
name|println
argument_list|(
literal|"if ( !_returnToken )"
operator|+
name|newline
operator|+
literal|"\t\t\t\tgoto tryAgain; // found SKIP token"
operator|+
name|newline
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"_ttype = _returnToken->getType();"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|LexerGrammar
operator|)
name|grammar
operator|)
operator|.
name|getTestLiterals
argument_list|()
condition|)
block|{
name|genLiteralsTest
argument_list|()
expr_stmt|;
block|}
comment|// return token created by rule reference in switch
name|println
argument_list|(
literal|"_returnToken->setType(_ttype);"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"return _returnToken;"
argument_list|)
expr_stmt|;
comment|// Close try block
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"catch ("
operator|+
name|namespaceAntlr
operator|+
literal|"RecognitionException& e) {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|LexerGrammar
operator|)
name|grammar
operator|)
operator|.
name|filterMode
condition|)
block|{
if|if
condition|(
name|filterRule
operator|==
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"if ( !getCommitToPath() ) {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"consume();"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"goto tryAgain;"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
literal|"if ( !getCommitToPath() ) {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"rewind(_m);"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"resetText();"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"try {m"
operator|+
name|filterRule
operator|+
literal|"(false);}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"catch("
operator|+
name|namespaceAntlr
operator|+
literal|"RecognitionException& ee) {"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"	// horrendous failure: error in filter rule"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"	reportError(ee);"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"	consume();"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
comment|// println("goto tryAgain;");
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"else"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nextTokenBlk
operator|.
name|getDefaultErrorHandler
argument_list|()
condition|)
block|{
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"reportError(e);"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"consume();"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// pass on to invoking routine
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"throw "
operator|+
name|namespaceAntlr
operator|+
literal|"TokenStreamRecognitionException(e);"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
block|}
comment|// close CharStreamException try
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"catch ("
operator|+
name|namespaceAntlr
operator|+
literal|"CharStreamIOException& csie) {"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"\tthrow "
operator|+
name|namespaceAntlr
operator|+
literal|"TokenStreamIOException(csie.io);"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"catch ("
operator|+
name|namespaceAntlr
operator|+
literal|"CharStreamException& cse) {"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"\tthrow "
operator|+
name|namespaceAntlr
operator|+
literal|"TokenStreamException(cse.getMessage());"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
comment|// close for-loop
name|_println
argument_list|(
literal|"tryAgain:;"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
comment|// close method nextToken
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/** Gen a named rule block. 	 * ASTs are generated for each element of an alternative unless 	 * the rule or the alternative have a '!' modifier. 	 * 	 * If an alternative defeats the default tree construction, it 	 * must set<rule>_AST to the root of the returned AST. 	 * 	 * Each alternative that does automatic tree construction, builds 	 * up root and child list pointers in an ASTPair structure. 	 * 	 * A rule finishes by setting the returnAST variable from the 	 * ASTPair. 	 * 	 * @param rule The name of the rule to generate 	 * @param startSymbol true if the rule is a start symbol (i.e., not referenced elsewhere) 	*/
DECL|method|genRule (RuleSymbol s, boolean startSymbol, int ruleNum, String prefix)
specifier|public
name|void
name|genRule
parameter_list|(
name|RuleSymbol
name|s
parameter_list|,
name|boolean
name|startSymbol
parameter_list|,
name|int
name|ruleNum
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
comment|//		tabs=1; // JavaCodeGenerator needs this
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"genRule("
operator|+
name|s
operator|.
name|getId
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|isDefined
argument_list|()
condition|)
block|{
name|antlrTool
operator|.
name|error
argument_list|(
literal|"undefined rule: "
operator|+
name|s
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Generate rule return type, name, arguments
name|RuleBlock
name|rblk
init|=
name|s
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|currentRule
operator|=
name|rblk
expr_stmt|;
name|currentASTResult
operator|=
name|s
operator|.
name|getId
argument_list|()
expr_stmt|;
comment|// clear list of declared ast variables..
name|declaredASTVariables
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Save the AST generation state, and set it to that of the rule
name|boolean
name|savegenAST
init|=
name|genAST
decl_stmt|;
name|genAST
operator|=
name|genAST
operator|&&
name|rblk
operator|.
name|getAutoGen
argument_list|()
expr_stmt|;
comment|// boolean oldsaveTest = saveText;
name|saveText
operator|=
name|rblk
operator|.
name|getAutoGen
argument_list|()
expr_stmt|;
comment|// print javadoc comment if any
if|if
condition|(
name|s
operator|.
name|comment
operator|!=
literal|null
condition|)
block|{
name|_println
argument_list|(
name|s
operator|.
name|comment
argument_list|)
expr_stmt|;
block|}
comment|// Gen method return type (note lexer return action set at rule creation)
if|if
condition|(
name|rblk
operator|.
name|returnAction
operator|!=
literal|null
condition|)
block|{
comment|// Has specified return value
name|_print
argument_list|(
name|extractTypeOfAction
argument_list|(
name|rblk
operator|.
name|returnAction
argument_list|,
name|rblk
operator|.
name|getLine
argument_list|()
argument_list|,
name|rblk
operator|.
name|getColumn
argument_list|()
argument_list|)
operator|+
literal|" "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No specified return value
name|_print
argument_list|(
literal|"void "
argument_list|)
expr_stmt|;
block|}
comment|// Gen method name
name|_print
argument_list|(
name|prefix
operator|+
name|s
operator|.
name|getId
argument_list|()
operator|+
literal|"("
argument_list|)
expr_stmt|;
comment|// Additional rule parameters common to all rules for this grammar
name|_print
argument_list|(
name|commonExtraParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|commonExtraParams
operator|.
name|length
argument_list|()
operator|!=
literal|0
operator|&&
name|rblk
operator|.
name|argAction
operator|!=
literal|null
condition|)
block|{
name|_print
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
comment|// Gen arguments
if|if
condition|(
name|rblk
operator|.
name|argAction
operator|!=
literal|null
condition|)
block|{
comment|// Has specified arguments
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// FIXME: make argAction also a token? Hmmmmm
comment|//			genLineNo(rblk);
name|tabs
operator|++
expr_stmt|;
comment|// Process arguments for default arguments
comment|// newer gcc's don't accept these in two places (header/cpp)
comment|//
comment|// Old appraoch with StringBuffer gave trouble with gcj.
comment|//
comment|// RK: Actually this breaks with string default arguments containing
comment|// a comma's or equal signs. Then again the old StringBuffer method
comment|// suffered from the same.
name|String
name|oldarg
init|=
name|rblk
operator|.
name|argAction
decl_stmt|;
name|String
name|newarg
init|=
literal|""
decl_stmt|;
name|String
name|comma
init|=
literal|""
decl_stmt|;
name|int
name|eqpos
init|=
name|oldarg
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|)
decl_stmt|;
if|if
condition|(
name|eqpos
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|cmpos
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|cmpos
operator|!=
operator|-
literal|1
condition|)
block|{
name|newarg
operator|=
name|newarg
operator|+
name|comma
operator|+
name|oldarg
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|eqpos
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
name|comma
operator|=
literal|", "
expr_stmt|;
name|cmpos
operator|=
name|oldarg
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|,
name|eqpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmpos
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// cut off part we just handled
name|oldarg
operator|=
name|oldarg
operator|.
name|substring
argument_list|(
name|cmpos
operator|+
literal|1
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
name|eqpos
operator|=
name|oldarg
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|newarg
operator|=
name|oldarg
expr_stmt|;
name|println
argument_list|(
name|newarg
argument_list|)
expr_stmt|;
comment|//			println(rblk.argAction);
name|tabs
operator|--
expr_stmt|;
name|print
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
comment|//			genLineNo2();	// gcc gives error on the brace... hope it works for the others too
block|}
else|else
block|{
comment|// No specified arguments
name|_print
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
block|}
name|_println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
if|if
condition|(
name|grammar
operator|.
name|traceRules
condition|)
block|{
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
if|if
condition|(
name|usingCustomAST
condition|)
name|println
argument_list|(
literal|"Tracer traceInOut(this,\""
operator|+
name|s
operator|.
name|getId
argument_list|()
operator|+
literal|"\","
operator|+
name|namespaceAntlr
operator|+
literal|"RefAST"
operator|+
literal|"(_t));"
argument_list|)
expr_stmt|;
else|else
name|println
argument_list|(
literal|"Tracer traceInOut(this,\""
operator|+
name|s
operator|.
name|getId
argument_list|()
operator|+
literal|"\",_t);"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
literal|"Tracer traceInOut(this, \""
operator|+
name|s
operator|.
name|getId
argument_list|()
operator|+
literal|"\");"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Convert return action to variable declaration
if|if
condition|(
name|rblk
operator|.
name|returnAction
operator|!=
literal|null
condition|)
block|{
name|genLineNo
argument_list|(
name|rblk
argument_list|)
expr_stmt|;
name|println
argument_list|(
name|rblk
operator|.
name|returnAction
operator|+
literal|";"
argument_list|)
expr_stmt|;
name|genLineNo2
argument_list|()
expr_stmt|;
block|}
comment|// print out definitions needed by rules for various grammar types
if|if
condition|(
operator|!
name|commonLocalVars
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
name|println
argument_list|(
name|commonLocalVars
argument_list|)
expr_stmt|;
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
block|{
comment|// RK: why is this here? It seems not supported in the rest of the
comment|// tool.
comment|// lexer rule default return value is the rule's token name
comment|// This is a horrible hack to support the built-in EOF lexer rule.
if|if
condition|(
name|s
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
literal|"mEOF"
argument_list|)
condition|)
name|println
argument_list|(
literal|"_ttype = "
operator|+
name|namespaceAntlr
operator|+
literal|"Token::EOF_TYPE;"
argument_list|)
expr_stmt|;
else|else
name|println
argument_list|(
literal|"_ttype = "
operator|+
name|s
operator|.
name|getId
argument_list|()
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
operator|+
literal|";"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"int _saveIndex;"
argument_list|)
expr_stmt|;
comment|// used for element! (so we can kill text matched for element)
comment|/* 			println("boolean old_saveConsumedInput=saveConsumedInput;"); 			if ( !rblk.getAutoGen() ) {      // turn off "save input" if ! on rule 				println("saveConsumedInput=false;"); 			} */
block|}
comment|// if debugging, write code to mark entry to the rule
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
condition|)
if|if
condition|(
name|grammar
operator|instanceof
name|ParserGrammar
condition|)
name|println
argument_list|(
literal|"fireEnterRule("
operator|+
name|ruleNum
operator|+
literal|",0);"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
name|println
argument_list|(
literal|"fireEnterRule("
operator|+
name|ruleNum
operator|+
literal|",_ttype);"
argument_list|)
expr_stmt|;
comment|// Generate trace code if desired
comment|//		if ( grammar.debuggingOutput || grammar.traceRules) {
comment|//			println("try { // debugging");
comment|//			tabs++;
comment|//		}
comment|// Initialize AST variables
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
comment|// "Input" value for rule
comment|//			println(labeledElementASTType+" " + s.getId() + "_AST_in = "+labeledElementASTType+"(_t);");
name|println
argument_list|(
name|labeledElementASTType
operator|+
literal|" "
operator|+
name|s
operator|.
name|getId
argument_list|()
operator|+
literal|"_AST_in = (_t == ASTNULL) ? "
operator|+
name|labeledElementASTInit
operator|+
literal|" : _t;"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|grammar
operator|.
name|buildAST
condition|)
block|{
comment|// Parser member used to pass AST returns from rule invocations
name|println
argument_list|(
literal|"returnAST = "
operator|+
name|labeledElementASTInit
operator|+
literal|";"
argument_list|)
expr_stmt|;
comment|// Tracks AST construction
name|println
argument_list|(
name|namespaceAntlr
operator|+
literal|"ASTPair currentAST;"
argument_list|)
expr_stmt|;
comment|// = new ASTPair();");
comment|// User-settable return value for rule.
name|println
argument_list|(
name|labeledElementASTType
operator|+
literal|" "
operator|+
name|s
operator|.
name|getId
argument_list|()
operator|+
literal|"_AST = "
operator|+
name|labeledElementASTInit
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
name|genBlockPreamble
argument_list|(
name|rblk
argument_list|)
expr_stmt|;
name|genBlockInitAction
argument_list|(
name|rblk
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// Search for an unlabeled exception specification attached to the rule
name|ExceptionSpec
name|unlabeledUserSpec
init|=
name|rblk
operator|.
name|findExceptionSpec
argument_list|(
literal|""
argument_list|)
decl_stmt|;
comment|// Generate try block around the entire rule for  error handling
if|if
condition|(
name|unlabeledUserSpec
operator|!=
literal|null
operator|||
name|rblk
operator|.
name|getDefaultErrorHandler
argument_list|()
condition|)
block|{
name|println
argument_list|(
literal|"try {      // for error handling"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
block|}
comment|// Generate the alternatives
if|if
condition|(
name|rblk
operator|.
name|alternatives
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// One alternative -- use simple form
name|Alternative
name|alt
init|=
name|rblk
operator|.
name|getAlternativeAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|pred
init|=
name|alt
operator|.
name|semPred
decl_stmt|;
if|if
condition|(
name|pred
operator|!=
literal|null
condition|)
name|genSemPred
argument_list|(
name|pred
argument_list|,
name|currentRule
operator|.
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt
operator|.
name|synPred
operator|!=
literal|null
condition|)
block|{
name|antlrTool
operator|.
name|warning
argument_list|(
literal|"Syntactic predicate ignored for single alternative"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|alt
operator|.
name|synPred
operator|.
name|getLine
argument_list|()
argument_list|,
name|alt
operator|.
name|synPred
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|genAlt
argument_list|(
name|alt
argument_list|,
name|rblk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Multiple alternatives -- generate complex form
name|boolean
name|ok
init|=
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|deterministic
argument_list|(
name|rblk
argument_list|)
decl_stmt|;
name|CppBlockFinishingInfo
name|howToFinish
init|=
name|genCommonBlock
argument_list|(
name|rblk
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|genBlockFinish
argument_list|(
name|howToFinish
argument_list|,
name|throwNoViable
argument_list|)
expr_stmt|;
block|}
comment|// Generate catch phrase for error handling
if|if
condition|(
name|unlabeledUserSpec
operator|!=
literal|null
operator|||
name|rblk
operator|.
name|getDefaultErrorHandler
argument_list|()
condition|)
block|{
comment|// Close the try block
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
comment|// Generate user-defined or default catch phrases
if|if
condition|(
name|unlabeledUserSpec
operator|!=
literal|null
condition|)
block|{
name|genErrorHandler
argument_list|(
name|unlabeledUserSpec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rblk
operator|.
name|getDefaultErrorHandler
argument_list|()
condition|)
block|{
comment|// Generate default catch phrase
name|println
argument_list|(
literal|"catch ("
operator|+
name|exceptionThrown
operator|+
literal|"& ex) {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// Generate code to handle error if not guessing
if|if
condition|(
name|grammar
operator|.
name|hasSyntacticPredicate
condition|)
block|{
name|println
argument_list|(
literal|"if( inputState->guessing == 0 ) {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
block|}
name|println
argument_list|(
literal|"reportError(ex);"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
operator|)
condition|)
block|{
comment|// Generate code to consume until token in k==1 follow set
name|Lookahead
name|follow
init|=
name|grammar
operator|.
name|theLLkAnalyzer
operator|.
name|FOLLOW
argument_list|(
literal|1
argument_list|,
name|rblk
operator|.
name|endNode
argument_list|)
decl_stmt|;
name|String
name|followSetName
init|=
name|getBitsetName
argument_list|(
name|markBitsetForGen
argument_list|(
name|follow
operator|.
name|fset
argument_list|)
argument_list|)
decl_stmt|;
name|println
argument_list|(
literal|"consume();"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"consumeUntil("
operator|+
name|followSetName
operator|+
literal|");"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Just consume one token
name|println
argument_list|(
literal|"if ( _t != "
operator|+
name|labeledElementASTInit
operator|+
literal|" )"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"_t = _t->getNextSibling();"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|grammar
operator|.
name|hasSyntacticPredicate
condition|)
block|{
name|tabs
operator|--
expr_stmt|;
comment|// When guessing, rethrow exception
name|println
argument_list|(
literal|"} else {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"throw;"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
comment|// Close catch phrase
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
comment|// Squirrel away the AST "return" value
if|if
condition|(
name|grammar
operator|.
name|buildAST
condition|)
block|{
name|println
argument_list|(
literal|"returnAST = "
operator|+
name|s
operator|.
name|getId
argument_list|()
operator|+
literal|"_AST;"
argument_list|)
expr_stmt|;
block|}
comment|// Set return tree value for tree walkers
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
name|println
argument_list|(
literal|"_retTree = _t;"
argument_list|)
expr_stmt|;
block|}
comment|// Generate literals test for lexer rules so marked
if|if
condition|(
name|rblk
operator|.
name|getTestLiterals
argument_list|()
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|access
operator|.
name|equals
argument_list|(
literal|"protected"
argument_list|)
condition|)
block|{
name|genLiteralsTestForPartialToken
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|genLiteralsTest
argument_list|()
expr_stmt|;
block|}
block|}
comment|// if doing a lexer rule, dump code to create token if necessary
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
block|{
name|println
argument_list|(
literal|"if ( _createToken&& _token=="
operator|+
name|namespaceAntlr
operator|+
literal|"nullToken&& _ttype!="
operator|+
name|namespaceAntlr
operator|+
literal|"Token::SKIP ) {"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"   _token = makeToken(_ttype);"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"   _token->setText(text.substr(_begin, text.length()-_begin));"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"_returnToken = _token;"
argument_list|)
expr_stmt|;
comment|// It should be easy for an optimizing compiler to realize this does nothing
comment|// but it avoids the warning about the variable being unused.
name|println
argument_list|(
literal|"_saveIndex=0;"
argument_list|)
expr_stmt|;
block|}
comment|// Gen the return statement if there is one (lexer has hard-wired return action)
if|if
condition|(
name|rblk
operator|.
name|returnAction
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"return "
operator|+
name|extractIdOfAction
argument_list|(
name|rblk
operator|.
name|returnAction
argument_list|,
name|rblk
operator|.
name|getLine
argument_list|()
argument_list|,
name|rblk
operator|.
name|getColumn
argument_list|()
argument_list|)
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
comment|//		if ( grammar.debuggingOutput || grammar.traceRules) {
comment|////			tabs--;
comment|////			println("} finally { // debugging");
comment|////			tabs++;
comment|//
comment|//			// Generate trace code if desired
comment|//			if ( grammar.debuggingOutput)
comment|//				if (grammar instanceof ParserGrammar)
comment|//					println("fireExitRule(" + ruleNum + ",0);");
comment|//				else if (grammar instanceof LexerGrammar)
comment|//					println("fireExitRule(" + ruleNum + ",_ttype);");
comment|//
comment|////			if (grammar.traceRules) {
comment|////				if ( grammar instanceof TreeWalkerGrammar ) {
comment|////					println("traceOut(\""+ s.getId() +"\",_t);");
comment|////				}
comment|////				else {
comment|////					println("traceOut(\""+ s.getId() +"\");");
comment|////				}
comment|////			}
comment|////
comment|////			tabs--;
comment|////			println("}");
comment|//		}
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// Restore the AST generation state
name|genAST
operator|=
name|savegenAST
expr_stmt|;
comment|// restore char save state
comment|// saveText = oldsaveTest;
block|}
DECL|method|genRuleHeader (RuleSymbol s, boolean startSymbol)
specifier|public
name|void
name|genRuleHeader
parameter_list|(
name|RuleSymbol
name|s
parameter_list|,
name|boolean
name|startSymbol
parameter_list|)
block|{
name|tabs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"genRuleHeader("
operator|+
name|s
operator|.
name|getId
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|isDefined
argument_list|()
condition|)
block|{
name|antlrTool
operator|.
name|error
argument_list|(
literal|"undefined rule: "
operator|+
name|s
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Generate rule return type, name, arguments
name|RuleBlock
name|rblk
init|=
name|s
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|currentRule
operator|=
name|rblk
expr_stmt|;
name|currentASTResult
operator|=
name|s
operator|.
name|getId
argument_list|()
expr_stmt|;
comment|// Save the AST generation state, and set it to that of the rule
name|boolean
name|savegenAST
init|=
name|genAST
decl_stmt|;
name|genAST
operator|=
name|genAST
operator|&&
name|rblk
operator|.
name|getAutoGen
argument_list|()
expr_stmt|;
comment|// boolean oldsaveTest = saveText;
name|saveText
operator|=
name|rblk
operator|.
name|getAutoGen
argument_list|()
expr_stmt|;
comment|// Gen method access
name|print
argument_list|(
name|s
operator|.
name|access
operator|+
literal|": "
argument_list|)
expr_stmt|;
comment|// Gen method return type (note lexer return action set at rule creation)
if|if
condition|(
name|rblk
operator|.
name|returnAction
operator|!=
literal|null
condition|)
block|{
comment|// Has specified return value
name|_print
argument_list|(
name|extractTypeOfAction
argument_list|(
name|rblk
operator|.
name|returnAction
argument_list|,
name|rblk
operator|.
name|getLine
argument_list|()
argument_list|,
name|rblk
operator|.
name|getColumn
argument_list|()
argument_list|)
operator|+
literal|" "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No specified return value
name|_print
argument_list|(
literal|"void "
argument_list|)
expr_stmt|;
block|}
comment|// Gen method name
name|_print
argument_list|(
name|s
operator|.
name|getId
argument_list|()
operator|+
literal|"("
argument_list|)
expr_stmt|;
comment|// Additional rule parameters common to all rules for this grammar
name|_print
argument_list|(
name|commonExtraParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|commonExtraParams
operator|.
name|length
argument_list|()
operator|!=
literal|0
operator|&&
name|rblk
operator|.
name|argAction
operator|!=
literal|null
condition|)
block|{
name|_print
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
comment|// Gen arguments
if|if
condition|(
name|rblk
operator|.
name|argAction
operator|!=
literal|null
condition|)
block|{
comment|// Has specified arguments
name|_println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
name|rblk
operator|.
name|argAction
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|print
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No specified arguments
name|_print
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|_println
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
comment|// Restore the AST generation state
name|genAST
operator|=
name|savegenAST
expr_stmt|;
comment|// restore char save state
comment|// saveText = oldsaveTest;
block|}
DECL|method|GenRuleInvocation (RuleRefElement rr)
specifier|private
name|void
name|GenRuleInvocation
parameter_list|(
name|RuleRefElement
name|rr
parameter_list|)
block|{
comment|// dump rule name
name|_print
argument_list|(
name|rr
operator|.
name|targetRule
operator|+
literal|"("
argument_list|)
expr_stmt|;
comment|// lexers must tell rule if it should set _returnToken
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
block|{
comment|// if labeled, could access Token, so tell rule to create
if|if
condition|(
name|rr
operator|.
name|getLabel
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|_print
argument_list|(
literal|"true"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_print
argument_list|(
literal|"false"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commonExtraArgs
operator|.
name|length
argument_list|()
operator|!=
literal|0
operator|||
name|rr
operator|.
name|args
operator|!=
literal|null
condition|)
block|{
name|_print
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Extra arguments common to all rules for this grammar
name|_print
argument_list|(
name|commonExtraArgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|commonExtraArgs
operator|.
name|length
argument_list|()
operator|!=
literal|0
operator|&&
name|rr
operator|.
name|args
operator|!=
literal|null
condition|)
block|{
name|_print
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
comment|// Process arguments to method, if any
name|RuleSymbol
name|rs
init|=
operator|(
name|RuleSymbol
operator|)
name|grammar
operator|.
name|getSymbol
argument_list|(
name|rr
operator|.
name|targetRule
argument_list|)
decl_stmt|;
if|if
condition|(
name|rr
operator|.
name|args
operator|!=
literal|null
condition|)
block|{
comment|// When not guessing, execute user arg action
name|ActionTransInfo
name|tInfo
init|=
operator|new
name|ActionTransInfo
argument_list|()
decl_stmt|;
comment|// FIXME: fix line number passed to processActionForTreeSpecifiers here..
comment|// this one might be a bit off..
name|String
name|args
init|=
name|processActionForSpecialSymbols
argument_list|(
name|rr
operator|.
name|args
argument_list|,
name|rr
operator|.
name|line
argument_list|,
name|currentRule
argument_list|,
name|tInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|tInfo
operator|.
name|assignToRoot
operator|||
name|tInfo
operator|.
name|refRuleRoot
operator|!=
literal|null
condition|)
block|{
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Arguments of rule reference '"
operator|+
name|rr
operator|.
name|targetRule
operator|+
literal|"' cannot set or ref #"
operator|+
name|currentRule
operator|.
name|getRuleName
argument_list|()
operator|+
literal|" on line "
operator|+
name|rr
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|_print
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|// Warn if the rule accepts no arguments
if|if
condition|(
name|rs
operator|.
name|block
operator|.
name|argAction
operator|==
literal|null
condition|)
block|{
name|antlrTool
operator|.
name|warning
argument_list|(
literal|"Rule '"
operator|+
name|rr
operator|.
name|targetRule
operator|+
literal|"' accepts no arguments"
argument_list|,
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|,
name|rr
operator|.
name|getLine
argument_list|()
argument_list|,
name|rr
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// For C++, no warning if rule has parameters, because there may be default
comment|// values for all of the parameters
comment|//if (rs.block.argAction != null) {
comment|//	tool.warning("Missing parameters on reference to rule "+rr.targetRule, rr.getLine());
comment|//}
block|}
name|_println
argument_list|(
literal|");"
argument_list|)
expr_stmt|;
comment|// move down to the first child while parsing
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
name|println
argument_list|(
literal|"_t = _retTree;"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|genSemPred (String pred, int line)
specifier|protected
name|void
name|genSemPred
parameter_list|(
name|String
name|pred
parameter_list|,
name|int
name|line
parameter_list|)
block|{
comment|// translate $ and # references
name|ActionTransInfo
name|tInfo
init|=
operator|new
name|ActionTransInfo
argument_list|()
decl_stmt|;
name|pred
operator|=
name|processActionForSpecialSymbols
argument_list|(
name|pred
argument_list|,
name|line
argument_list|,
name|currentRule
argument_list|,
name|tInfo
argument_list|)
expr_stmt|;
comment|// ignore translation info...we don't need to do anything with it.
name|String
name|escapedPred
init|=
name|charFormatter
operator|.
name|escapeString
argument_list|(
name|pred
argument_list|)
decl_stmt|;
comment|// if debugging, wrap the semantic predicate evaluation in a method
comment|// that can tell SemanticPredicateListeners the result
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
operator|&&
operator|(
operator|(
name|grammar
operator|instanceof
name|ParserGrammar
operator|)
operator|||
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
operator|)
condition|)
name|pred
operator|=
literal|"fireSemanticPredicateEvaluated(antlr.debug.SemanticPredicateEvent.VALIDATING,"
comment|//FIXME
operator|+
name|addSemPred
argument_list|(
name|escapedPred
argument_list|)
operator|+
literal|","
operator|+
name|pred
operator|+
literal|")"
expr_stmt|;
name|println
argument_list|(
literal|"if (!("
operator|+
name|pred
operator|+
literal|"))"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"throw "
operator|+
name|namespaceAntlr
operator|+
literal|"SemanticException(\""
operator|+
name|escapedPred
operator|+
literal|"\");"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
block|}
comment|/** Write an array of Strings which are the semantic predicate 	 *  expressions.  The debugger will reference them by number only 	 */
DECL|method|genSemPredMap (String prefix)
specifier|protected
name|void
name|genSemPredMap
parameter_list|(
name|String
name|prefix
parameter_list|)
block|{
name|Enumeration
name|e
init|=
name|semPreds
operator|.
name|elements
argument_list|()
decl_stmt|;
name|println
argument_list|(
literal|"const char* "
operator|+
name|prefix
operator|+
literal|"_semPredNames[] = {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
while|while
condition|(
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|)
name|println
argument_list|(
literal|"\""
operator|+
name|e
operator|.
name|nextElement
argument_list|()
operator|+
literal|"\","
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"};"
argument_list|)
expr_stmt|;
block|}
DECL|method|genSynPred (SynPredBlock blk, String lookaheadExpr)
specifier|protected
name|void
name|genSynPred
parameter_list|(
name|SynPredBlock
name|blk
parameter_list|,
name|String
name|lookaheadExpr
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_CODE_GENERATOR
operator|||
name|DEBUG_CPP_CODE_GENERATOR
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"gen=>("
operator|+
name|blk
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// Dump synpred result variable
name|println
argument_list|(
literal|"bool synPredMatched"
operator|+
name|blk
operator|.
name|ID
operator|+
literal|" = false;"
argument_list|)
expr_stmt|;
comment|// Gen normal lookahead test
name|println
argument_list|(
literal|"if ("
operator|+
name|lookaheadExpr
operator|+
literal|") {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// Save input state
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
name|println
argument_list|(
name|labeledElementType
operator|+
literal|" __t"
operator|+
name|blk
operator|.
name|ID
operator|+
literal|" = _t;"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
literal|"int _m"
operator|+
name|blk
operator|.
name|ID
operator|+
literal|" = mark();"
argument_list|)
expr_stmt|;
block|}
comment|// Once inside the try, assume synpred works unless exception caught
name|println
argument_list|(
literal|"synPredMatched"
operator|+
name|blk
operator|.
name|ID
operator|+
literal|" = true;"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"inputState->guessing++;"
argument_list|)
expr_stmt|;
comment|// if debugging, tell listeners that a synpred has started
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
operator|&&
operator|(
operator|(
name|grammar
operator|instanceof
name|ParserGrammar
operator|)
operator|||
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
operator|)
condition|)
block|{
name|println
argument_list|(
literal|"fireSyntacticPredicateStarted();"
argument_list|)
expr_stmt|;
block|}
name|syntacticPredLevel
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"try {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|gen
argument_list|(
operator|(
name|AlternativeBlock
operator|)
name|blk
argument_list|)
expr_stmt|;
comment|// gen code to test predicate
name|tabs
operator|--
expr_stmt|;
comment|//println("System.out.println(\"pred "+blk+" succeeded\");");
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"catch ("
operator|+
name|exceptionThrown
operator|+
literal|"& pe) {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"synPredMatched"
operator|+
name|blk
operator|.
name|ID
operator|+
literal|" = false;"
argument_list|)
expr_stmt|;
comment|//println("System.out.println(\"pred "+blk+" failed\");");
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
comment|// Restore input state
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
name|println
argument_list|(
literal|"_t = __t"
operator|+
name|blk
operator|.
name|ID
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
literal|"rewind(_m"
operator|+
name|blk
operator|.
name|ID
operator|+
literal|");"
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
literal|"inputState->guessing--;"
argument_list|)
expr_stmt|;
comment|// if debugging, tell listeners how the synpred turned out
if|if
condition|(
name|grammar
operator|.
name|debuggingOutput
operator|&&
operator|(
operator|(
name|grammar
operator|instanceof
name|ParserGrammar
operator|)
operator|||
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|)
operator|)
condition|)
block|{
name|println
argument_list|(
literal|"if (synPredMatched"
operator|+
name|blk
operator|.
name|ID
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"  fireSyntacticPredicateSucceeded();"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"else"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"  fireSyntacticPredicateFailed();"
argument_list|)
expr_stmt|;
block|}
name|syntacticPredLevel
operator|--
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
comment|// Close lookahead test
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
comment|// Test synpred result
name|println
argument_list|(
literal|"if ( synPredMatched"
operator|+
name|blk
operator|.
name|ID
operator|+
literal|" ) {"
argument_list|)
expr_stmt|;
block|}
comment|/** Generate a static array containing the names of the tokens, 	 * indexed by the token type values.  This static array is used 	 * to format error messages so that the token identifers or literal 	 * strings are displayed instead of the token numbers. 	 * 	 * If a lexical rule has a paraphrase, use it rather than the 	 * token label. 	 */
DECL|method|genTokenStrings (String prefix)
specifier|public
name|void
name|genTokenStrings
parameter_list|(
name|String
name|prefix
parameter_list|)
block|{
comment|// Generate a string for each token.  This creates a static
comment|// array of Strings indexed by token type.
comment|//		println("");
name|println
argument_list|(
literal|"const char* "
operator|+
name|prefix
operator|+
literal|"tokenNames[] = {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// Walk the token vocabulary and generate a Vector of strings
comment|// from the tokens.
name|Vector
name|v
init|=
name|grammar
operator|.
name|tokenManager
operator|.
name|getVocabulary
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|v
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|s
init|=
operator|(
name|String
operator|)
name|v
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
name|s
operator|=
literal|"<"
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
operator|+
literal|">"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|.
name|startsWith
argument_list|(
literal|"\""
argument_list|)
operator|&&
operator|!
name|s
operator|.
name|startsWith
argument_list|(
literal|"<"
argument_list|)
condition|)
block|{
name|TokenSymbol
name|ts
init|=
operator|(
name|TokenSymbol
operator|)
name|grammar
operator|.
name|tokenManager
operator|.
name|getTokenSymbol
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|!=
literal|null
operator|&&
name|ts
operator|.
name|getParaphrase
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|s
operator|=
name|StringUtils
operator|.
name|stripFrontBack
argument_list|(
name|ts
operator|.
name|getParaphrase
argument_list|()
argument_list|,
literal|"\""
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
block|}
name|print
argument_list|(
name|charFormatter
operator|.
name|literalString
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|_println
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
comment|// Close the string array initailizer
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"};"
argument_list|)
expr_stmt|;
block|}
comment|/** Generate the token types C++ file */
DECL|method|genTokenTypes (TokenManager tm)
specifier|protected
name|void
name|genTokenTypes
parameter_list|(
name|TokenManager
name|tm
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Open the token output header file and set the currentOutput stream
name|outputFile
operator|=
name|tm
operator|.
name|getName
argument_list|()
operator|+
name|TokenTypesFileSuffix
operator|+
literal|".hpp"
expr_stmt|;
name|outputLine
operator|=
literal|1
expr_stmt|;
name|currentOutput
operator|=
name|antlrTool
operator|.
name|openOutputFile
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
comment|//SAS: changed for proper text file io
name|tabs
operator|=
literal|0
expr_stmt|;
comment|// Generate a guard wrapper
name|println
argument_list|(
literal|"#ifndef INC_"
operator|+
name|tm
operator|.
name|getName
argument_list|()
operator|+
name|TokenTypesFileSuffix
operator|+
literal|"_hpp_"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#define INC_"
operator|+
name|tm
operator|.
name|getName
argument_list|()
operator|+
name|TokenTypesFileSuffix
operator|+
literal|"_hpp_"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameSpace
operator|!=
literal|null
condition|)
name|nameSpace
operator|.
name|emitDeclarations
argument_list|(
name|currentOutput
argument_list|)
expr_stmt|;
comment|// Generate the header common to all C++ files
name|genHeader
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
comment|// Encapsulate the definitions in an interface.  This can be done
comment|// because they are all constants.
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#ifndef CUSTOM_API"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"# define CUSTOM_API"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// In the case that the .hpp is included from C source (flexLexer!)
comment|// we just turn things into a plain enum
name|println
argument_list|(
literal|"#ifdef __cplusplus"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"struct CUSTOM_API "
operator|+
name|tm
operator|.
name|getName
argument_list|()
operator|+
name|TokenTypesFileSuffix
operator|+
literal|" {"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
name|println
argument_list|(
literal|"enum {"
argument_list|)
expr_stmt|;
name|tabs
operator|++
expr_stmt|;
comment|// Generate a definition for each token type
name|Vector
name|v
init|=
name|tm
operator|.
name|getVocabulary
argument_list|()
decl_stmt|;
comment|// Do special tokens manually
name|println
argument_list|(
literal|"EOF_ = "
operator|+
name|Token
operator|.
name|EOF_TYPE
operator|+
literal|","
argument_list|)
expr_stmt|;
comment|// Move the other special token to the end, so we can solve
comment|// the superfluous comma problem easily
for|for
control|(
name|int
name|i
init|=
name|Token
operator|.
name|MIN_USER_TYPE
init|;
name|i
operator|<
name|v
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|s
init|=
operator|(
name|String
operator|)
name|v
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
literal|"\""
argument_list|)
condition|)
block|{
comment|// a string literal
name|StringLiteralSymbol
name|sl
init|=
operator|(
name|StringLiteralSymbol
operator|)
name|tm
operator|.
name|getTokenSymbol
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|sl
operator|==
literal|null
condition|)
block|{
name|antlrTool
operator|.
name|panic
argument_list|(
literal|"String literal "
operator|+
name|s
operator|+
literal|" not in symbol table"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sl
operator|.
name|label
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
name|sl
operator|.
name|label
operator|+
literal|" = "
operator|+
name|i
operator|+
literal|","
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|mangledName
init|=
name|mangleLiteral
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|mangledName
operator|!=
literal|null
condition|)
block|{
comment|// We were able to create a meaningful mangled token name
name|println
argument_list|(
name|mangledName
operator|+
literal|" = "
operator|+
name|i
operator|+
literal|","
argument_list|)
expr_stmt|;
comment|// if no label specified, make the label equal to the mangled name
name|sl
operator|.
name|label
operator|=
name|mangledName
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
literal|"// "
operator|+
name|s
operator|+
literal|" = "
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|s
operator|.
name|startsWith
argument_list|(
literal|"<"
argument_list|)
condition|)
block|{
name|println
argument_list|(
name|s
operator|+
literal|" = "
operator|+
name|i
operator|+
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Moved from above
name|println
argument_list|(
literal|"NULL_TREE_LOOKAHEAD = "
operator|+
name|Token
operator|.
name|NULL_TREE_LOOKAHEAD
argument_list|)
expr_stmt|;
comment|// Close the enum
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"};"
argument_list|)
expr_stmt|;
comment|// Close the interface
name|tabs
operator|--
expr_stmt|;
name|println
argument_list|(
literal|"#ifdef __cplusplus"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"};"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameSpace
operator|!=
literal|null
condition|)
name|nameSpace
operator|.
name|emitClosures
argument_list|(
name|currentOutput
argument_list|)
expr_stmt|;
comment|// Generate a guard wrapper
name|println
argument_list|(
literal|"#endif /*INC_"
operator|+
name|tm
operator|.
name|getName
argument_list|()
operator|+
name|TokenTypesFileSuffix
operator|+
literal|"_hpp_*/"
argument_list|)
expr_stmt|;
comment|// Close the tokens output file
name|currentOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentOutput
operator|=
literal|null
expr_stmt|;
name|exitIfError
argument_list|()
expr_stmt|;
block|}
comment|/** Process a string for an simple expression for use in xx/action.g 	 * it is used to cast simple tokens/references to the right type for 	 * the generated language. Basically called for every element in 	 * the vector to getASTCreateString(vector V) 	 * @param str A String. 	 */
DECL|method|processStringForASTConstructor ( String str )
specifier|public
name|String
name|processStringForASTConstructor
parameter_list|(
name|String
name|str
parameter_list|)
block|{
if|if
condition|(
name|usingCustomAST
operator|&&
operator|(
operator|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
operator|)
operator|||
operator|(
name|grammar
operator|instanceof
name|ParserGrammar
operator|)
operator|)
operator|&&
operator|!
operator|(
name|grammar
operator|.
name|tokenManager
operator|.
name|tokenDefined
argument_list|(
name|str
argument_list|)
operator|)
condition|)
block|{
comment|//			System.out.println("processStringForASTConstructor: "+str+" with cast");
return|return
name|namespaceAntlr
operator|+
literal|"RefAST("
operator|+
name|str
operator|+
literal|")"
return|;
block|}
else|else
block|{
comment|//			System.out.println("processStringForASTConstructor: "+str);
return|return
name|str
return|;
block|}
block|}
comment|/** Get a string for an expression to generate creation of an AST subtree. 	  * @param v A Vector of String, where each element is an expression 	  * in the target language yielding an AST node. 	  */
DECL|method|getASTCreateString (Vector v)
specifier|public
name|String
name|getASTCreateString
parameter_list|(
name|Vector
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
comment|// the labeledElementASTType here can probably be a cast or nothing
comment|// in the case of ! usingCustomAST
name|buf
operator|.
name|append
argument_list|(
name|labeledElementASTType
operator|+
literal|"(astFactory->make((new "
operator|+
name|namespaceAntlr
operator|+
literal|"ASTArray("
operator|+
name|v
operator|.
name|size
argument_list|()
operator|+
literal|"))"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|v
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"->add("
operator|+
name|v
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"))"
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Get a string for an expression to generate creating of an AST node 	 * @param str The arguments to the AST constructor 	 */
DECL|method|getASTCreateString (GrammarAtom atom, String str)
specifier|public
name|String
name|getASTCreateString
parameter_list|(
name|GrammarAtom
name|atom
parameter_list|,
name|String
name|str
parameter_list|)
block|{
if|if
condition|(
name|atom
operator|!=
literal|null
operator|&&
name|atom
operator|.
name|getASTNodeType
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// this atom is using a heterogeneous AST type. (and maybe a local
comment|// override we can't see at the TokenManager level)
comment|// make note of the factory needed to generate it..
comment|// later this is inserted into the initializeFactory method.
name|astTypes
operator|.
name|ensureCapacity
argument_list|(
name|atom
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|astTypes
operator|.
name|setElementAt
argument_list|(
name|atom
operator|.
name|getASTNodeType
argument_list|()
argument_list|,
name|atom
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
comment|// after above init the factory knows what to generate...
return|return
literal|"astFactory->create("
operator|+
name|str
operator|+
literal|")"
return|;
block|}
else|else
block|{
comment|// FIXME: This is *SO* ugly! but it will have to do for now...
comment|// 2.7.2 will have better I hope
comment|// this is due to the usage of getASTCreateString from inside
comment|// actions/cpp/action.g
name|boolean
name|is_constructor
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|str
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|is_constructor
operator|=
name|grammar
operator|.
name|tokenManager
operator|.
name|tokenDefined
argument_list|(
name|str
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|str
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|//			System.out.println("getAstCreateString(as): "+str+" "+grammar.tokenManager.tokenDefined(str));
if|if
condition|(
name|usingCustomAST
operator|&&
operator|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
operator|)
operator|&&
operator|!
operator|(
name|grammar
operator|.
name|tokenManager
operator|.
name|tokenDefined
argument_list|(
name|str
argument_list|)
operator|)
operator|&&
operator|!
name|is_constructor
condition|)
return|return
literal|"astFactory->create("
operator|+
name|namespaceAntlr
operator|+
literal|"RefAST("
operator|+
name|str
operator|+
literal|"))"
return|;
else|else
return|return
literal|"astFactory->create("
operator|+
name|str
operator|+
literal|")"
return|;
block|}
block|}
comment|/** Get a string for an expression to generate creating of an AST node 	 * @param str The arguments to the AST constructor 	 */
DECL|method|getASTCreateString (String str)
specifier|public
name|String
name|getASTCreateString
parameter_list|(
name|String
name|str
parameter_list|)
block|{
comment|//		System.out.println("getAstCreateString(str): "+str+" "+grammar.tokenManager.tokenDefined(str));
if|if
condition|(
name|usingCustomAST
condition|)
return|return
name|labeledElementASTType
operator|+
literal|"(astFactory->create("
operator|+
name|namespaceAntlr
operator|+
literal|"RefAST("
operator|+
name|str
operator|+
literal|")))"
return|;
else|else
return|return
literal|"astFactory->create("
operator|+
name|str
operator|+
literal|")"
return|;
block|}
DECL|method|getLookaheadTestExpression (Lookahead[] look, int k)
specifier|protected
name|String
name|getLookaheadTestExpression
parameter_list|(
name|Lookahead
index|[]
name|look
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|StringBuffer
name|e
init|=
operator|new
name|StringBuffer
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
name|e
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|k
condition|;
name|i
operator|++
control|)
block|{
name|BitSet
name|p
init|=
name|look
index|[
name|i
index|]
operator|.
name|fset
decl_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
block|{
name|e
operator|.
name|append
argument_list|(
literal|")&& ("
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
literal|false
expr_stmt|;
comment|// Syn preds can yield<end-of-syn-pred> (epsilon) lookahead.
comment|// There is no way to predict what that token would be.  Just
comment|// allow anything instead.
if|if
condition|(
name|look
index|[
name|i
index|]
operator|.
name|containsEpsilon
argument_list|()
condition|)
block|{
name|e
operator|.
name|append
argument_list|(
literal|"true"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|.
name|append
argument_list|(
name|getLookaheadTestTerm
argument_list|(
name|i
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|e
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
name|e
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Generate a lookahead test expression for an alternate.  This 	 * will be a series of tests joined by '&&' and enclosed by '()', 	 * the number of such tests being determined by the depth of the lookahead. 	 */
DECL|method|getLookaheadTestExpression (Alternative alt, int maxDepth)
specifier|protected
name|String
name|getLookaheadTestExpression
parameter_list|(
name|Alternative
name|alt
parameter_list|,
name|int
name|maxDepth
parameter_list|)
block|{
name|int
name|depth
init|=
name|alt
operator|.
name|lookaheadDepth
decl_stmt|;
if|if
condition|(
name|depth
operator|==
name|GrammarAnalyzer
operator|.
name|NONDETERMINISTIC
condition|)
block|{
comment|// if the decision is nondeterministic, do the best we can: LL(k)
comment|// any predicates that are around will be generated later.
name|depth
operator|=
name|grammar
operator|.
name|maxk
expr_stmt|;
block|}
if|if
condition|(
name|maxDepth
operator|==
literal|0
condition|)
block|{
comment|// empty lookahead can result from alt with sem pred
comment|// that can see end of token.  E.g., A : {pred}? ('a')? ;
return|return
literal|"true"
return|;
block|}
comment|/* boolean first = true; 		for (int i=1; i<=depth&& i<=maxDepth; i++) { 			BitSet p = alt.cache[i].fset; 			if (!first) { 				e.append(")&& ("); 			} 			first = false;  			// Syn preds can yield<end-of-syn-pred> (epsilon) lookahead. 			// There is no way to predict what that token would be.  Just 			// allow anything instead. 			if ( alt.cache[i].containsEpsilon() ) { 				e.append("true"); 			} 			else { 				e.append(getLookaheadTestTerm(i, p)); 			} 		}  		e.append(")"); */
return|return
literal|"("
operator|+
name|getLookaheadTestExpression
argument_list|(
name|alt
operator|.
name|cache
argument_list|,
name|depth
argument_list|)
operator|+
literal|")"
return|;
block|}
comment|/**Generate a depth==1 lookahead test expression given the BitSet. 	 * This may be one of: 	 * 1) a series of 'x==X||' tests 	 * 2) a range test using>=&&<= where possible, 	 * 3) a bitset membership test for complex comparisons 	 * @param k The lookahead level 	 * @param p The lookahead set for level k 	 */
DECL|method|getLookaheadTestTerm (int k, BitSet p)
specifier|protected
name|String
name|getLookaheadTestTerm
parameter_list|(
name|int
name|k
parameter_list|,
name|BitSet
name|p
parameter_list|)
block|{
comment|// Determine the name of the item to be compared
name|String
name|ts
init|=
name|lookaheadString
argument_list|(
name|k
argument_list|)
decl_stmt|;
comment|// Generate a range expression if possible
name|int
index|[]
name|elems
init|=
name|p
operator|.
name|toArray
argument_list|()
decl_stmt|;
if|if
condition|(
name|elementsAreRange
argument_list|(
name|elems
argument_list|)
condition|)
block|{
return|return
name|getRangeExpression
argument_list|(
name|k
argument_list|,
name|elems
argument_list|)
return|;
block|}
comment|// Generate a bitset membership test if possible
name|StringBuffer
name|e
decl_stmt|;
name|int
name|degree
init|=
name|p
operator|.
name|degree
argument_list|()
decl_stmt|;
if|if
condition|(
name|degree
operator|==
literal|0
condition|)
block|{
return|return
literal|"true"
return|;
block|}
if|if
condition|(
name|degree
operator|>=
name|bitsetTestThreshold
condition|)
block|{
name|int
name|bitsetIdx
init|=
name|markBitsetForGen
argument_list|(
name|p
argument_list|)
decl_stmt|;
return|return
name|getBitsetName
argument_list|(
name|bitsetIdx
argument_list|)
operator|+
literal|".member("
operator|+
name|ts
operator|+
literal|")"
return|;
block|}
comment|// Otherwise, generate the long-winded series of "x==X||" tests
name|e
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|elems
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// Get the compared-to item (token or character value)
name|String
name|cs
init|=
name|getValueString
argument_list|(
name|elems
index|[
name|i
index|]
argument_list|)
decl_stmt|;
comment|// Generate the element comparison
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|e
operator|.
name|append
argument_list|(
literal|" || "
argument_list|)
expr_stmt|;
name|e
operator|.
name|append
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|e
operator|.
name|append
argument_list|(
literal|" == "
argument_list|)
expr_stmt|;
name|e
operator|.
name|append
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
return|return
name|e
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Return an expression for testing a contiguous renage of elements 	 * @param k The lookahead level 	 * @param elems The elements representing the set, usually from BitSet.toArray(). 	 * @return String containing test expression. 	 */
DECL|method|getRangeExpression (int k, int[] elems)
specifier|public
name|String
name|getRangeExpression
parameter_list|(
name|int
name|k
parameter_list|,
name|int
index|[]
name|elems
parameter_list|)
block|{
if|if
condition|(
operator|!
name|elementsAreRange
argument_list|(
name|elems
argument_list|)
condition|)
block|{
name|antlrTool
operator|.
name|panic
argument_list|(
literal|"getRangeExpression called with non-range"
argument_list|)
expr_stmt|;
block|}
name|int
name|begin
init|=
name|elems
index|[
literal|0
index|]
decl_stmt|;
name|int
name|end
init|=
name|elems
index|[
name|elems
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
return|return
literal|"("
operator|+
name|lookaheadString
argument_list|(
name|k
argument_list|)
operator|+
literal|">= "
operator|+
name|getValueString
argument_list|(
name|begin
argument_list|)
operator|+
literal|"&& "
operator|+
name|lookaheadString
argument_list|(
name|k
argument_list|)
operator|+
literal|"<= "
operator|+
name|getValueString
argument_list|(
name|end
argument_list|)
operator|+
literal|")"
return|;
block|}
comment|/** getValueString: get a string representation of a token or char value 	 * @param value The token or char value 	 */
DECL|method|getValueString (int value)
specifier|private
name|String
name|getValueString
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|String
name|cs
decl_stmt|;
if|if
condition|(
name|grammar
operator|instanceof
name|LexerGrammar
condition|)
block|{
name|cs
operator|=
name|charFormatter
operator|.
name|literalChar
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TokenSymbol
name|ts
init|=
name|grammar
operator|.
name|tokenManager
operator|.
name|getTokenSymbolAt
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|==
literal|null
condition|)
block|{
return|return
literal|""
operator|+
name|value
return|;
comment|// return token type as string
comment|// tool.panic("vocabulary for token type " + value + " is null");
block|}
name|String
name|tId
init|=
name|ts
operator|.
name|getId
argument_list|()
decl_stmt|;
if|if
condition|(
name|ts
operator|instanceof
name|StringLiteralSymbol
condition|)
block|{
comment|// if string literal, use predefined label if any
comment|// if no predefined, try to mangle into LITERAL_xxx.
comment|// if can't mangle, use int value as last resort
name|StringLiteralSymbol
name|sl
init|=
operator|(
name|StringLiteralSymbol
operator|)
name|ts
decl_stmt|;
name|String
name|label
init|=
name|sl
operator|.
name|getLabel
argument_list|()
decl_stmt|;
if|if
condition|(
name|label
operator|!=
literal|null
condition|)
block|{
name|cs
operator|=
name|label
expr_stmt|;
block|}
else|else
block|{
name|cs
operator|=
name|mangleLiteral
argument_list|(
name|tId
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|==
literal|null
condition|)
block|{
name|cs
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|tId
operator|.
name|equals
argument_list|(
literal|"EOF"
argument_list|)
condition|)
name|cs
operator|=
name|namespaceAntlr
operator|+
literal|"Token::EOF_TYPE"
expr_stmt|;
else|else
name|cs
operator|=
name|tId
expr_stmt|;
block|}
block|}
return|return
name|cs
return|;
block|}
comment|/**Is the lookahead for this alt empty? */
DECL|method|lookaheadIsEmpty (Alternative alt, int maxDepth)
specifier|protected
name|boolean
name|lookaheadIsEmpty
parameter_list|(
name|Alternative
name|alt
parameter_list|,
name|int
name|maxDepth
parameter_list|)
block|{
name|int
name|depth
init|=
name|alt
operator|.
name|lookaheadDepth
decl_stmt|;
if|if
condition|(
name|depth
operator|==
name|GrammarAnalyzer
operator|.
name|NONDETERMINISTIC
condition|)
block|{
name|depth
operator|=
name|grammar
operator|.
name|maxk
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|depth
operator|&&
name|i
operator|<=
name|maxDepth
condition|;
name|i
operator|++
control|)
block|{
name|BitSet
name|p
init|=
name|alt
operator|.
name|cache
index|[
name|i
index|]
operator|.
name|fset
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|degree
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|lookaheadString (int k)
specifier|private
name|String
name|lookaheadString
parameter_list|(
name|int
name|k
parameter_list|)
block|{
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
return|return
literal|"_t->getType()"
return|;
block|}
return|return
literal|"LA("
operator|+
name|k
operator|+
literal|")"
return|;
block|}
comment|/** Mangle a string literal into a meaningful token name.  This is 	  * only possible for literals that are all characters.  The resulting 	  * mangled literal name is literalsPrefix with the text of the literal 	  * appended. 	  * @return A string representing the mangled literal, or null if not possible. 	  */
DECL|method|mangleLiteral (String s)
specifier|private
name|String
name|mangleLiteral
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|String
name|mangled
init|=
name|antlrTool
operator|.
name|literalsPrefix
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Character
operator|.
name|isLetter
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&&
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|!=
literal|'_'
condition|)
block|{
return|return
literal|null
return|;
block|}
name|mangled
operator|+=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|antlrTool
operator|.
name|upperCaseMangledLiterals
condition|)
block|{
name|mangled
operator|=
name|mangled
operator|.
name|toUpperCase
argument_list|()
expr_stmt|;
block|}
return|return
name|mangled
return|;
block|}
comment|/** Map an identifier to it's corresponding tree-node variable. 	  * This is context-sensitive, depending on the rule and alternative 	  * being generated 	  * @param idParam The identifier name to map 	  * @return The mapped id (which may be the same as the input), or null if the mapping is invalid due to duplicates 	  */
DECL|method|mapTreeId (String idParam, ActionTransInfo transInfo)
specifier|public
name|String
name|mapTreeId
parameter_list|(
name|String
name|idParam
parameter_list|,
name|ActionTransInfo
name|transInfo
parameter_list|)
block|{
comment|// if not in an action of a rule, nothing to map.
if|if
condition|(
name|currentRule
operator|==
literal|null
condition|)
return|return
name|idParam
return|;
comment|//		System.out.print("mapTreeId: "+idParam+" "+currentRule.getRuleName()+" ");
name|boolean
name|in_var
init|=
literal|false
decl_stmt|;
name|String
name|id
init|=
name|idParam
decl_stmt|;
if|if
condition|(
name|grammar
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
comment|//			RK: hmmm this seems odd. If buildAST is false it translates
comment|//			#rulename_in to 'rulename_in' else to 'rulename_AST_in' which indeed
comment|//			exists. disabling for now.. and hope it doesn't blow up somewhere.
if|if
condition|(
operator|!
name|grammar
operator|.
name|buildAST
condition|)
block|{
name|in_var
operator|=
literal|true
expr_stmt|;
comment|//				System.out.println("in_var1");
block|}
comment|// If the id ends with "_in", then map it to the input variable
comment|//			else
if|if
condition|(
name|id
operator|.
name|length
argument_list|()
operator|>
literal|3
operator|&&
name|id
operator|.
name|lastIndexOf
argument_list|(
literal|"_in"
argument_list|)
operator|==
name|id
operator|.
name|length
argument_list|()
operator|-
literal|3
condition|)
block|{
comment|// Strip off the "_in"
name|id
operator|=
name|id
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|id
operator|.
name|length
argument_list|()
operator|-
literal|3
argument_list|)
expr_stmt|;
name|in_var
operator|=
literal|true
expr_stmt|;
comment|//				System.out.println("in_var2");
block|}
block|}
comment|//		System.out.print(in_var+"\t");
comment|// Check the rule labels.  If id is a label, then the output
comment|// variable is label_AST, and the input variable is plain label.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|currentRule
operator|.
name|labeledElements
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|AlternativeElement
name|elt
init|=
operator|(
name|AlternativeElement
operator|)
name|currentRule
operator|.
name|labeledElements
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|elt
operator|.
name|getLabel
argument_list|()
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|)
block|{
comment|//				if( in_var )
comment|//					System.out.println("returning (vec) "+(in_var ? id : id + "_AST"));
return|return
name|in_var
condition|?
name|id
else|:
name|id
operator|+
literal|"_AST"
return|;
block|}
block|}
comment|// Failing that, check the id-to-variable map for the alternative.
comment|// If the id is in the map, then output variable is the name in the
comment|// map, and input variable is name_in
name|String
name|s
init|=
operator|(
name|String
operator|)
name|treeVariableMap
operator|.
name|get
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|NONUNIQUE
condition|)
block|{
comment|//				if( in_var )
comment|//					System.out.println("returning null (nonunique)");
comment|// There is more than one element with this id
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Ambiguous reference to AST element "
operator|+
name|id
operator|+
literal|" in rule "
operator|+
name|currentRule
operator|.
name|getRuleName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
name|currentRule
operator|.
name|getRuleName
argument_list|()
argument_list|)
condition|)
block|{
comment|// a recursive call to the enclosing rule is
comment|// ambiguous with the rule itself.
comment|//				if( in_var )
comment|//					System.out.println("returning null (rulename)");
name|antlrTool
operator|.
name|error
argument_list|(
literal|"Ambiguous reference to AST element "
operator|+
name|id
operator|+
literal|" in rule "
operator|+
name|currentRule
operator|.
name|getRuleName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
comment|//				if( in_var )
comment|//				System.out.println("returning "+(in_var?s+"_in":s));
return|return
name|in_var
condition|?
name|s
operator|+
literal|"_in"
else|:
name|s
return|;
block|}
block|}
comment|//		System.out.println("Last check: "+id+" == "+currentRule.getRuleName());
comment|// Failing that, check the rule name itself.  Output variable
comment|// is rule_AST; input variable is rule_AST_in (treeparsers).
if|if
condition|(
name|id
operator|.
name|equals
argument_list|(
name|currentRule
operator|.
name|getRuleName
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|r
init|=
name|in_var
condition|?
name|id
operator|+
literal|"_AST_in"
else|:
name|id
operator|+
literal|"_AST"
decl_stmt|;
if|if
condition|(
name|transInfo
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|in_var
condition|)
block|{
name|transInfo
operator|.
name|refRuleRoot
operator|=
name|r
expr_stmt|;
block|}
block|}
comment|//			if( in_var )
comment|//				System.out.println("returning (r) "+r);
return|return
name|r
return|;
block|}
else|else
block|{
comment|//			if( in_var )
comment|//			System.out.println("returning (last) "+id);
comment|// id does not map to anything -- return itself.
return|return
name|id
return|;
block|}
block|}
comment|/** Given an element and the name of an associated AST variable, 	  * create a mapping between the element "name" and the variable name. 	  */
DECL|method|mapTreeVariable (AlternativeElement e, String name)
specifier|private
name|void
name|mapTreeVariable
parameter_list|(
name|AlternativeElement
name|e
parameter_list|,
name|String
name|name
parameter_list|)
block|{
comment|// For tree elements, defer to the root
if|if
condition|(
name|e
operator|instanceof
name|TreeElement
condition|)
block|{
name|mapTreeVariable
argument_list|(
operator|(
operator|(
name|TreeElement
operator|)
name|e
operator|)
operator|.
name|root
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Determine the name of the element, if any, for mapping purposes
name|String
name|elName
init|=
literal|null
decl_stmt|;
comment|// Don't map labeled items
if|if
condition|(
name|e
operator|.
name|getLabel
argument_list|()
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|TokenRefElement
condition|)
block|{
comment|// use the token id
name|elName
operator|=
operator|(
operator|(
name|TokenRefElement
operator|)
name|e
operator|)
operator|.
name|atomText
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|RuleRefElement
condition|)
block|{
comment|// use the rule name
name|elName
operator|=
operator|(
operator|(
name|RuleRefElement
operator|)
name|e
operator|)
operator|.
name|targetRule
expr_stmt|;
block|}
block|}
comment|// Add the element to the tree variable map if it has a name
if|if
condition|(
name|elName
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|treeVariableMap
operator|.
name|get
argument_list|(
name|elName
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// Name is already in the map -- mark it as duplicate
name|treeVariableMap
operator|.
name|remove
argument_list|(
name|elName
argument_list|)
expr_stmt|;
name|treeVariableMap
operator|.
name|put
argument_list|(
name|elName
argument_list|,
name|NONUNIQUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|treeVariableMap
operator|.
name|put
argument_list|(
name|elName
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Lexically process tree-specifiers in the action. 	 * This will replace #id and #(...) with the appropriate 	 * function calls and/or variables. 	 */
DECL|method|processActionForSpecialSymbols (String actionStr, int line, RuleBlock currentRule, ActionTransInfo tInfo)
specifier|protected
name|String
name|processActionForSpecialSymbols
parameter_list|(
name|String
name|actionStr
parameter_list|,
name|int
name|line
parameter_list|,
name|RuleBlock
name|currentRule
parameter_list|,
name|ActionTransInfo
name|tInfo
parameter_list|)
block|{
if|if
condition|(
name|actionStr
operator|==
literal|null
operator|||
name|actionStr
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
comment|// The action trans info tells us (at the moment) whether an
comment|// assignment was done to the rule's tree root.
if|if
condition|(
name|grammar
operator|==
literal|null
condition|)
return|return
name|actionStr
return|;
if|if
condition|(
operator|(
name|grammar
operator|.
name|buildAST
operator|&&
name|actionStr
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|||
name|grammar
operator|instanceof
name|TreeWalkerGrammar
operator|||
operator|(
operator|(
name|grammar
operator|instanceof
name|LexerGrammar
operator|||
name|grammar
operator|instanceof
name|ParserGrammar
operator|)
operator|&&
name|actionStr
operator|.
name|indexOf
argument_list|(
literal|'$'
argument_list|)
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
comment|// Create a lexer to read an action and return the translated version
name|antlr
operator|.
name|actions
operator|.
name|cpp
operator|.
name|ActionLexer
name|lexer
init|=
operator|new
name|antlr
operator|.
name|actions
operator|.
name|cpp
operator|.
name|ActionLexer
argument_list|(
name|actionStr
argument_list|,
name|currentRule
argument_list|,
name|this
argument_list|,
name|tInfo
argument_list|)
decl_stmt|;
name|lexer
operator|.
name|setLineOffset
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|lexer
operator|.
name|setFilename
argument_list|(
name|grammar
operator|.
name|getFilename
argument_list|()
argument_list|)
expr_stmt|;
name|lexer
operator|.
name|setTool
argument_list|(
name|antlrTool
argument_list|)
expr_stmt|;
try|try
block|{
name|lexer
operator|.
name|mACTION
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|actionStr
operator|=
name|lexer
operator|.
name|getTokenObject
argument_list|()
operator|.
name|getText
argument_list|()
expr_stmt|;
comment|// System.out.println("action translated: "+actionStr);
comment|// System.out.println("trans info is "+tInfo);
block|}
catch|catch
parameter_list|(
name|RecognitionException
name|ex
parameter_list|)
block|{
name|lexer
operator|.
name|reportError
argument_list|(
name|ex
argument_list|)
expr_stmt|;
return|return
name|actionStr
return|;
block|}
catch|catch
parameter_list|(
name|TokenStreamException
name|tex
parameter_list|)
block|{
name|antlrTool
operator|.
name|panic
argument_list|(
literal|"Error reading action:"
operator|+
name|actionStr
argument_list|)
expr_stmt|;
return|return
name|actionStr
return|;
block|}
catch|catch
parameter_list|(
name|CharStreamException
name|io
parameter_list|)
block|{
name|antlrTool
operator|.
name|panic
argument_list|(
literal|"Error reading action:"
operator|+
name|actionStr
argument_list|)
expr_stmt|;
return|return
name|actionStr
return|;
block|}
block|}
return|return
name|actionStr
return|;
block|}
DECL|method|fixNameSpaceOption ( String ns )
specifier|private
name|String
name|fixNameSpaceOption
parameter_list|(
name|String
name|ns
parameter_list|)
block|{
name|ns
operator|=
name|StringUtils
operator|.
name|stripFrontBack
argument_list|(
name|ns
argument_list|,
literal|"\""
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns
operator|.
name|length
argument_list|()
operator|>
literal|2
operator|&&
operator|!
name|ns
operator|.
name|substring
argument_list|(
name|ns
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|ns
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
literal|"::"
argument_list|)
condition|)
name|ns
operator|+=
literal|"::"
expr_stmt|;
return|return
name|ns
return|;
block|}
DECL|method|setupGrammarParameters (Grammar g)
specifier|private
name|void
name|setupGrammarParameters
parameter_list|(
name|Grammar
name|g
parameter_list|)
block|{
if|if
condition|(
name|g
operator|instanceof
name|ParserGrammar
operator|||
name|g
operator|instanceof
name|LexerGrammar
operator|||
name|g
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
comment|/* RK: options also have to be added to Grammar.java and for options 			 * on the file level entries have to be defined in 			 * DefineGrammarSymbols.java and passed around via 'globals' in 			 * antlrTool.java 			 */
if|if
condition|(
name|antlrTool
operator|.
name|nameSpace
operator|!=
literal|null
condition|)
name|nameSpace
operator|=
name|antlrTool
operator|.
name|nameSpace
expr_stmt|;
if|if
condition|(
name|antlrTool
operator|.
name|namespaceStd
operator|!=
literal|null
condition|)
name|namespaceStd
operator|=
name|fixNameSpaceOption
argument_list|(
name|antlrTool
operator|.
name|namespaceStd
argument_list|)
expr_stmt|;
if|if
condition|(
name|antlrTool
operator|.
name|namespaceAntlr
operator|!=
literal|null
condition|)
name|namespaceAntlr
operator|=
name|fixNameSpaceOption
argument_list|(
name|antlrTool
operator|.
name|namespaceAntlr
argument_list|)
expr_stmt|;
name|genHashLines
operator|=
name|antlrTool
operator|.
name|genHashLines
expr_stmt|;
comment|/* let grammar level options override filelevel ones... 			 */
if|if
condition|(
name|g
operator|.
name|hasOption
argument_list|(
literal|"namespace"
argument_list|)
condition|)
block|{
name|Token
name|t
init|=
name|g
operator|.
name|getOption
argument_list|(
literal|"namespace"
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|nameSpace
operator|=
operator|new
name|NameSpace
argument_list|(
name|t
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|g
operator|.
name|hasOption
argument_list|(
literal|"namespaceAntlr"
argument_list|)
condition|)
block|{
name|Token
name|t
init|=
name|g
operator|.
name|getOption
argument_list|(
literal|"namespaceAntlr"
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|String
name|ns
init|=
name|StringUtils
operator|.
name|stripFrontBack
argument_list|(
name|t
operator|.
name|getText
argument_list|()
argument_list|,
literal|"\""
argument_list|,
literal|"\""
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ns
operator|.
name|length
argument_list|()
operator|>
literal|2
operator|&&
operator|!
name|ns
operator|.
name|substring
argument_list|(
name|ns
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|ns
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
literal|"::"
argument_list|)
condition|)
name|ns
operator|+=
literal|"::"
expr_stmt|;
name|namespaceAntlr
operator|=
name|ns
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|g
operator|.
name|hasOption
argument_list|(
literal|"namespaceStd"
argument_list|)
condition|)
block|{
name|Token
name|t
init|=
name|g
operator|.
name|getOption
argument_list|(
literal|"namespaceStd"
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|String
name|ns
init|=
name|StringUtils
operator|.
name|stripFrontBack
argument_list|(
name|t
operator|.
name|getText
argument_list|()
argument_list|,
literal|"\""
argument_list|,
literal|"\""
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ns
operator|.
name|length
argument_list|()
operator|>
literal|2
operator|&&
operator|!
name|ns
operator|.
name|substring
argument_list|(
name|ns
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|ns
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
literal|"::"
argument_list|)
condition|)
name|ns
operator|+=
literal|"::"
expr_stmt|;
name|namespaceStd
operator|=
name|ns
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|g
operator|.
name|hasOption
argument_list|(
literal|"genHashLines"
argument_list|)
condition|)
block|{
name|Token
name|t
init|=
name|g
operator|.
name|getOption
argument_list|(
literal|"genHashLines"
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|String
name|val
init|=
name|StringUtils
operator|.
name|stripFrontBack
argument_list|(
name|t
operator|.
name|getText
argument_list|()
argument_list|,
literal|"\""
argument_list|,
literal|"\""
argument_list|)
decl_stmt|;
name|genHashLines
operator|=
name|val
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
expr_stmt|;
block|}
block|}
name|noConstructors
operator|=
name|antlrTool
operator|.
name|noConstructors
expr_stmt|;
comment|// get the default
if|if
condition|(
name|g
operator|.
name|hasOption
argument_list|(
literal|"noConstructors"
argument_list|)
condition|)
block|{
name|Token
name|t
init|=
name|g
operator|.
name|getOption
argument_list|(
literal|"noConstructors"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|!=
literal|null
operator|)
operator|&&
operator|!
operator|(
name|t
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
operator|||
name|t
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
operator|)
condition|)
name|antlrTool
operator|.
name|error
argument_list|(
literal|"noConstructors option must be true or false"
argument_list|,
name|antlrTool
operator|.
name|getGrammarFile
argument_list|()
argument_list|,
name|t
operator|.
name|getLine
argument_list|()
argument_list|,
name|t
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
name|noConstructors
operator|=
name|t
operator|.
name|getText
argument_list|()
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|g
operator|instanceof
name|ParserGrammar
condition|)
block|{
name|labeledElementASTType
operator|=
name|namespaceAntlr
operator|+
literal|"RefAST"
expr_stmt|;
name|labeledElementASTInit
operator|=
name|namespaceAntlr
operator|+
literal|"nullAST"
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|hasOption
argument_list|(
literal|"ASTLabelType"
argument_list|)
condition|)
block|{
name|Token
name|tsuffix
init|=
name|g
operator|.
name|getOption
argument_list|(
literal|"ASTLabelType"
argument_list|)
decl_stmt|;
if|if
condition|(
name|tsuffix
operator|!=
literal|null
condition|)
block|{
name|String
name|suffix
init|=
name|StringUtils
operator|.
name|stripFrontBack
argument_list|(
name|tsuffix
operator|.
name|getText
argument_list|()
argument_list|,
literal|"\""
argument_list|,
literal|"\""
argument_list|)
decl_stmt|;
if|if
condition|(
name|suffix
operator|!=
literal|null
condition|)
block|{
name|usingCustomAST
operator|=
literal|true
expr_stmt|;
name|labeledElementASTType
operator|=
name|suffix
expr_stmt|;
name|labeledElementASTInit
operator|=
name|suffix
operator|+
literal|"("
operator|+
name|namespaceAntlr
operator|+
literal|"nullAST)"
expr_stmt|;
block|}
block|}
block|}
name|labeledElementType
operator|=
name|namespaceAntlr
operator|+
literal|"RefToken "
expr_stmt|;
name|labeledElementInit
operator|=
name|namespaceAntlr
operator|+
literal|"nullToken"
expr_stmt|;
name|commonExtraArgs
operator|=
literal|""
expr_stmt|;
name|commonExtraParams
operator|=
literal|""
expr_stmt|;
name|commonLocalVars
operator|=
literal|""
expr_stmt|;
name|lt1Value
operator|=
literal|"LT(1)"
expr_stmt|;
name|exceptionThrown
operator|=
name|namespaceAntlr
operator|+
literal|"RecognitionException"
expr_stmt|;
name|throwNoViable
operator|=
literal|"throw "
operator|+
name|namespaceAntlr
operator|+
literal|"NoViableAltException(LT(1), getFilename());"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g
operator|instanceof
name|LexerGrammar
condition|)
block|{
name|labeledElementType
operator|=
literal|"char "
expr_stmt|;
name|labeledElementInit
operator|=
literal|"'\\0'"
expr_stmt|;
name|commonExtraArgs
operator|=
literal|""
expr_stmt|;
name|commonExtraParams
operator|=
literal|"bool _createToken"
expr_stmt|;
name|commonLocalVars
operator|=
literal|"int _ttype; "
operator|+
name|namespaceAntlr
operator|+
literal|"RefToken _token; int _begin=text.length();"
expr_stmt|;
name|lt1Value
operator|=
literal|"LA(1)"
expr_stmt|;
name|exceptionThrown
operator|=
name|namespaceAntlr
operator|+
literal|"RecognitionException"
expr_stmt|;
name|throwNoViable
operator|=
literal|"throw "
operator|+
name|namespaceAntlr
operator|+
literal|"NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g
operator|instanceof
name|TreeWalkerGrammar
condition|)
block|{
name|labeledElementInit
operator|=
name|namespaceAntlr
operator|+
literal|"nullAST"
expr_stmt|;
name|labeledElementASTInit
operator|=
name|namespaceAntlr
operator|+
literal|"nullAST"
expr_stmt|;
name|labeledElementASTType
operator|=
name|namespaceAntlr
operator|+
literal|"RefAST"
expr_stmt|;
name|labeledElementType
operator|=
name|namespaceAntlr
operator|+
literal|"RefAST"
expr_stmt|;
name|commonExtraParams
operator|=
name|namespaceAntlr
operator|+
literal|"RefAST _t"
expr_stmt|;
name|throwNoViable
operator|=
literal|"throw "
operator|+
name|namespaceAntlr
operator|+
literal|"NoViableAltException(_t);"
expr_stmt|;
name|lt1Value
operator|=
literal|"_t"
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|hasOption
argument_list|(
literal|"ASTLabelType"
argument_list|)
condition|)
block|{
name|Token
name|tsuffix
init|=
name|g
operator|.
name|getOption
argument_list|(
literal|"ASTLabelType"
argument_list|)
decl_stmt|;
if|if
condition|(
name|tsuffix
operator|!=
literal|null
condition|)
block|{
name|String
name|suffix
init|=
name|StringUtils
operator|.
name|stripFrontBack
argument_list|(
name|tsuffix
operator|.
name|getText
argument_list|()
argument_list|,
literal|"\""
argument_list|,
literal|"\""
argument_list|)
decl_stmt|;
if|if
condition|(
name|suffix
operator|!=
literal|null
condition|)
block|{
name|usingCustomAST
operator|=
literal|true
expr_stmt|;
name|labeledElementASTType
operator|=
name|suffix
expr_stmt|;
name|labeledElementType
operator|=
name|suffix
expr_stmt|;
name|labeledElementInit
operator|=
name|suffix
operator|+
literal|"("
operator|+
name|namespaceAntlr
operator|+
literal|"nullAST)"
expr_stmt|;
name|labeledElementASTInit
operator|=
name|labeledElementInit
expr_stmt|;
name|commonExtraParams
operator|=
name|suffix
operator|+
literal|" _t"
expr_stmt|;
name|throwNoViable
operator|=
literal|"throw "
operator|+
name|namespaceAntlr
operator|+
literal|"NoViableAltException("
operator|+
name|namespaceAntlr
operator|+
literal|"RefAST(_t));"
expr_stmt|;
name|lt1Value
operator|=
literal|"_t"
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|g
operator|.
name|hasOption
argument_list|(
literal|"ASTLabelType"
argument_list|)
condition|)
block|{
name|g
operator|.
name|setOption
argument_list|(
literal|"ASTLabelType"
argument_list|,
operator|new
name|Token
argument_list|(
name|ANTLRTokenTypes
operator|.
name|STRING_LITERAL
argument_list|,
name|namespaceAntlr
operator|+
literal|"RefAST"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|commonExtraArgs
operator|=
literal|"_t"
expr_stmt|;
name|commonLocalVars
operator|=
literal|""
expr_stmt|;
name|exceptionThrown
operator|=
name|namespaceAntlr
operator|+
literal|"RecognitionException"
expr_stmt|;
block|}
else|else
block|{
name|antlrTool
operator|.
name|panic
argument_list|(
literal|"Unknown grammar type"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

