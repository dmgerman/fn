begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|gnu.dtools.ritopt
package|package
name|gnu
operator|.
name|dtools
operator|.
name|ritopt
package|;
end_package

begin_comment
comment|/**  * Utility.java  *  * Version:  *    $Id$  */
end_comment

begin_comment
comment|/**  * This class provides static utility members for some basic string operations.  *  *<hr>  *  *<pre>  * Copyright (C) Damian Ryan Eads, 2001. All Rights Reserved.  *  * ritopt is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.   * ritopt is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with ritopt; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  *</pre>  *  * @author Damian Eads  */
end_comment

begin_class
DECL|class|Utility
specifier|public
class|class
name|Utility
block|{
comment|/**      * Returns true if any of the characters in the list appear in the      * check string passed.      *      * @param check The string to check.      * @param list  The list of valid characters.      *      * @return true if the criteria of this method is satisfied.      */
DECL|method|contains ( String check, String list )
specifier|public
specifier|static
name|boolean
name|contains
parameter_list|(
name|String
name|check
parameter_list|,
name|String
name|list
parameter_list|)
block|{
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
name|list
operator|.
name|length
argument_list|()
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|check
operator|.
name|indexOf
argument_list|(
name|list
operator|.
name|substring
argument_list|(
name|n
argument_list|,
name|n
operator|+
literal|1
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Returns the number of occurances the character specification      * appears in the check string passed.      *      * @param check The string to check.      * @param spec  The character specification.      *      * @return the number of occurances of the character specification.      */
DECL|method|count ( String check, char spec )
specifier|public
specifier|static
name|int
name|count
parameter_list|(
name|String
name|check
parameter_list|,
name|char
name|spec
parameter_list|)
block|{
name|int
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
name|check
operator|.
name|length
argument_list|()
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|check
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|spec
condition|)
name|sum
operator|++
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
comment|/**      * Returns true if any of the characters in the list are equal to      * the check character.      *      * @param check The character to check.      * @param list  The list of valid characters.      *      * @return true if any of the characters in the list equal the check      *              character.       */
DECL|method|contains ( char check, String list )
specifier|public
specifier|static
name|boolean
name|contains
parameter_list|(
name|char
name|check
parameter_list|,
name|String
name|list
parameter_list|)
block|{
return|return
name|contains
argument_list|(
literal|""
operator|+
name|check
argument_list|,
name|list
argument_list|)
return|;
block|}
comment|/**      * Returns true if the string only contains letters in the phonetic      * alphabet.      *      * @param check The string to check.      *      * @return If this method's criteria is matched.      */
DECL|method|isAlpha ( String check )
specifier|public
specifier|static
name|boolean
name|isAlpha
parameter_list|(
name|String
name|check
parameter_list|)
block|{
name|boolean
name|retval
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
name|check
operator|.
name|length
argument_list|()
condition|;
name|n
operator|++
control|)
block|{
name|retval
operator|=
name|isAlphaLower
argument_list|(
name|check
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
argument_list|)
operator|||
name|isAlphaUpper
argument_list|(
name|check
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * Returns true if the string only contains lower case letters in the      * phonetic alphabet.      *      * @param check The string to check.      *      * @return If this method's criteria is matched.      */
DECL|method|isAlphaLower ( String check )
specifier|public
specifier|static
name|boolean
name|isAlphaLower
parameter_list|(
name|String
name|check
parameter_list|)
block|{
name|boolean
name|retval
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
name|check
operator|.
name|length
argument_list|()
condition|;
name|n
operator|++
control|)
block|{
name|retval
operator|=
name|isAlphaLower
argument_list|(
name|check
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * Returns true if the string only contains upper case letters in the      * phonetic alphabet.      *      * @param check The string to check.      *      * @return If this method's criteria is matched.      */
DECL|method|isAlphaUpper ( String check )
specifier|public
specifier|static
name|boolean
name|isAlphaUpper
parameter_list|(
name|String
name|check
parameter_list|)
block|{
name|boolean
name|retval
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
name|check
operator|.
name|length
argument_list|()
condition|;
name|n
operator|++
control|)
block|{
name|retval
operator|=
name|isAlphaUpper
argument_list|(
name|check
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * Returns true if the character is a letter in the phonetic alphabetic.      *      * @param check The character to check.      *      * @return true if this method's criteria is matched.      */
DECL|method|isAlpha ( char check )
specifier|public
specifier|static
name|boolean
name|isAlpha
parameter_list|(
name|char
name|check
parameter_list|)
block|{
return|return
name|isAlphaLower
argument_list|(
name|check
argument_list|)
operator|||
name|isAlphaUpper
argument_list|(
name|check
argument_list|)
return|;
block|}
comment|/**      * Returns true if the character is a lower case letter in the      * phonetic alphabetic.      *      * @param check The character to check.      *      * @return true if this method's criteria is matched.      */
DECL|method|isAlphaLower ( char check )
specifier|public
specifier|static
name|boolean
name|isAlphaLower
parameter_list|(
name|char
name|check
parameter_list|)
block|{
return|return
name|check
operator|>=
literal|'a'
operator|&&
name|check
operator|<=
literal|'z'
return|;
block|}
comment|/**      * Returns true if the character is a upper case letter in the      * phonetic alphabetic.      *      * @param check The character to check.      *      * @return true if this method's criteria is matched.      */
DECL|method|isAlphaUpper ( char check )
specifier|public
specifier|static
name|boolean
name|isAlphaUpper
parameter_list|(
name|char
name|check
parameter_list|)
block|{
return|return
name|check
operator|>=
literal|'A'
operator|&&
name|check
operator|<=
literal|'Z'
return|;
block|}
comment|/**      * Returns true if the character is a letter in the phonetic alphabetic      * or is a decimal number.      *      * @param check The character to check.      *      * @return true if this method's criteria is matched.      */
DECL|method|isAlphaNumeric ( char check )
specifier|public
specifier|static
name|boolean
name|isAlphaNumeric
parameter_list|(
name|char
name|check
parameter_list|)
block|{
return|return
name|isAlpha
argument_list|(
name|check
argument_list|)
operator|||
name|isNumeric
argument_list|(
name|check
argument_list|)
return|;
block|}
comment|/**      * Returns true if the character is a decimal number.      *      * @param check The character to check.      *      * @return true if this method's criteria is matched.      */
DECL|method|isNumeric ( char check )
specifier|public
specifier|static
name|boolean
name|isNumeric
parameter_list|(
name|char
name|check
parameter_list|)
block|{
return|return
name|check
operator|>=
literal|'0'
operator|&&
name|check
operator|<=
literal|'9'
return|;
block|}
comment|/**      * Returns a string with no more and no less than<em>n</em> characters      * where n is the length. If the string passed is less than this length,      * an appropriate number of spaces is concatenated. If the string is      * longer than the length passed, a substring of the length passed      * is returned.      *      * @param s       The string to expand.      * @param length  The required length.      *      * @return The expanded string.      */
DECL|method|expandString ( String s, int length )
specifier|public
specifier|static
name|String
name|expandString
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>
name|length
condition|)
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|s
operator|+
name|getSpaces
argument_list|(
name|length
operator|-
name|s
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns a string containing the number of spaces passed as an      * argument.      *      * @param count The number of spaces in the string returned.      *      * @return a string containing the number of spaces passed.      */
DECL|method|getSpaces ( int count )
specifier|public
specifier|static
name|String
name|getSpaces
parameter_list|(
name|int
name|count
parameter_list|)
block|{
return|return
name|repeat
argument_list|(
literal|' '
argument_list|,
name|count
argument_list|)
return|;
block|}
comment|/**      * Returns a string with a character repeated based on a count passed.      *      * @param c     The character to repeat.      * @param count The number of times to repeat the character.      */
DECL|method|repeat ( char c, int count )
specifier|public
specifier|static
name|String
name|repeat
parameter_list|(
name|char
name|c
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|StringBuffer
name|retval
init|=
operator|new
name|StringBuffer
argument_list|(
name|count
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|retval
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Trim spaces off the left side of this string.      *      * @param s The string to trim.      *      * @return  The trimmed string.      */
DECL|method|ltrim ( String s )
specifier|public
specifier|static
name|String
name|ltrim
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|(
name|s
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
name|buf
operator|.
name|length
argument_list|()
operator|&&
name|buf
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
operator|==
literal|' '
condition|;
control|)
block|{
name|buf
operator|.
name|delete
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Trim spaces off the right side of this string.      *      * @param s The string to trim.      *      * @return  The trimmed string.      */
DECL|method|rtrim ( String s )
specifier|public
specifier|static
name|String
name|rtrim
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|(
name|s
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
name|buf
operator|.
name|length
argument_list|()
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
operator|&&
name|buf
operator|.
name|charAt
argument_list|(
name|k
argument_list|)
operator|==
literal|' '
condition|;
name|k
operator|=
name|buf
operator|.
name|length
argument_list|()
operator|-
literal|1
control|)
block|{
name|buf
operator|.
name|delete
argument_list|(
name|buf
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
name|buf
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Trim spaces off both sides of this string.      *      * @param s The string to trim.      *      * @return  The trimmed string.      */
DECL|method|trim ( String s )
specifier|public
specifier|static
name|String
name|trim
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|ltrim
argument_list|(
name|rtrim
argument_list|(
name|s
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Takes a line (presumably from a file) and removes a comment if      * one exists. If the comment character is enclosed within a literal      * string defined by the delimiter passed, then the character is      * ignored.      *      * @param s         The string to strip comments off.      * @param delim     The string delimiter.      * @param comment   The comment character.      *      * @return A string stripped of comments.      */
DECL|method|stripComments ( String s, char delim, char comment )
specifier|public
specifier|static
name|String
name|stripComments
parameter_list|(
name|String
name|s
parameter_list|,
name|char
name|delim
parameter_list|,
name|char
name|comment
parameter_list|)
block|{
name|String
name|retval
init|=
operator|new
name|String
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|boolean
name|q
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
operator|==
name|delim
condition|)
block|{
name|q
operator|=
operator|!
name|q
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|q
operator|&&
name|s
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
operator|==
name|comment
condition|)
block|{
name|retval
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/**      * Returns a string with the passed string repeated based on the       * integer count passed.      *      * @param s     The string to repeat.      * @param count The number of times to repeat the string.      *      * @return      The repeated string.      */
DECL|method|repeat ( String s, int count )
specifier|public
specifier|static
name|String
name|repeat
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|StringBuffer
name|retval
init|=
operator|new
name|StringBuffer
argument_list|(
name|s
operator|.
name|length
argument_list|()
operator|*
name|count
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|retval
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

