begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.jabref.logic.bibtex
package|package
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|bibtex
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|util
operator|.
name|strings
operator|.
name|StringSimilarity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|EntryTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabaseMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|AuthorList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|BibEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|EntryType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|FieldName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|FieldProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|InternalBibtexFields
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|FieldName
operator|.
name|AUTHOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|FieldName
operator|.
name|CHAPTER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|FieldName
operator|.
name|EDITION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|FieldName
operator|.
name|EDITOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|FieldName
operator|.
name|JOURNAL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|FieldName
operator|.
name|PAGES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|FieldName
operator|.
name|TITLE
import|;
end_import

begin_comment
comment|/**  * This class contains utility method for duplicate checking of entries.  */
end_comment

begin_class
DECL|class|DuplicateCheck
specifier|public
class|class
name|DuplicateCheck
block|{
DECL|field|DUPLICATE_THRESHOLD
specifier|private
specifier|static
specifier|final
name|double
name|DUPLICATE_THRESHOLD
init|=
literal|0.75
decl_stmt|;
comment|// The overall threshold to signal a duplicate pair
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DuplicateCheck
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/*      * Integer values for indicating result of duplicate check (for entries):      */
DECL|field|NOT_EQUAL
specifier|private
specifier|static
specifier|final
name|int
name|NOT_EQUAL
init|=
literal|0
decl_stmt|;
DECL|field|EQUAL
specifier|private
specifier|static
specifier|final
name|int
name|EQUAL
init|=
literal|1
decl_stmt|;
DECL|field|EMPTY_IN_ONE
specifier|private
specifier|static
specifier|final
name|int
name|EMPTY_IN_ONE
init|=
literal|2
decl_stmt|;
DECL|field|EMPTY_IN_TWO
specifier|private
specifier|static
specifier|final
name|int
name|EMPTY_IN_TWO
init|=
literal|3
decl_stmt|;
DECL|field|EMPTY_IN_BOTH
specifier|private
specifier|static
specifier|final
name|int
name|EMPTY_IN_BOTH
init|=
literal|4
decl_stmt|;
comment|// Non-required fields are investigated only if the required fields give a value within
comment|// the doubt range of the threshold:
DECL|field|DOUBT_RANGE
specifier|private
specifier|static
specifier|final
name|double
name|DOUBT_RANGE
init|=
literal|0.05
decl_stmt|;
DECL|field|REQUIRED_WEIGHT
specifier|private
specifier|static
specifier|final
name|double
name|REQUIRED_WEIGHT
init|=
literal|3
decl_stmt|;
comment|// Weighting of all required fields
comment|// Extra weighting of those fields that are most likely to provide correct duplicate detection:
DECL|field|FIELD_WEIGHTS
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
name|FIELD_WEIGHTS
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
static|static
block|{
name|DuplicateCheck
operator|.
name|FIELD_WEIGHTS
operator|.
name|put
argument_list|(
name|AUTHOR
argument_list|,
literal|2.5
argument_list|)
expr_stmt|;
name|DuplicateCheck
operator|.
name|FIELD_WEIGHTS
operator|.
name|put
argument_list|(
name|EDITOR
argument_list|,
literal|2.5
argument_list|)
expr_stmt|;
name|DuplicateCheck
operator|.
name|FIELD_WEIGHTS
operator|.
name|put
argument_list|(
name|TITLE
argument_list|,
literal|3.
argument_list|)
expr_stmt|;
name|DuplicateCheck
operator|.
name|FIELD_WEIGHTS
operator|.
name|put
argument_list|(
name|JOURNAL
argument_list|,
literal|2.
argument_list|)
expr_stmt|;
block|}
DECL|method|DuplicateCheck ()
specifier|private
name|DuplicateCheck
parameter_list|()
block|{     }
comment|/**      * Checks if the two entries represent the same publication.      *      * @param one BibEntry      * @param two BibEntry      * @return boolean      */
DECL|method|isDuplicate (final BibEntry one, final BibEntry two, final BibDatabaseMode bibDatabaseMode)
specifier|public
specifier|static
name|boolean
name|isDuplicate
parameter_list|(
specifier|final
name|BibEntry
name|one
parameter_list|,
specifier|final
name|BibEntry
name|two
parameter_list|,
specifier|final
name|BibDatabaseMode
name|bibDatabaseMode
parameter_list|)
block|{
if|if
condition|(
name|haveSameIdentifier
argument_list|(
name|one
argument_list|,
name|two
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|haveDifferentEntryType
argument_list|(
name|one
argument_list|,
name|two
argument_list|)
operator|||
name|haveDifferentEditions
argument_list|(
name|one
argument_list|,
name|two
argument_list|)
operator|||
name|haveDifferentChaptersOrPagesOfTheSameBook
argument_list|(
name|one
argument_list|,
name|two
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|EntryType
name|type
init|=
name|EntryTypes
operator|.
name|getTypeOrDefault
argument_list|(
name|one
operator|.
name|getType
argument_list|()
argument_list|,
name|bibDatabaseMode
argument_list|)
decl_stmt|;
specifier|final
name|double
index|[]
name|reqCmpResult
init|=
name|compareRequiredFields
argument_list|(
name|type
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
decl_stmt|;
if|if
condition|(
name|isFarFromThreshold
argument_list|(
name|reqCmpResult
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|// Far from the threshold value, so we base our decision on the required fields only
return|return
name|reqCmpResult
index|[
literal|0
index|]
operator|>=
name|DuplicateCheck
operator|.
name|DUPLICATE_THRESHOLD
return|;
block|}
comment|// Close to the threshold value, so we take a look at the optional fields, if any:
return|return
name|compareOptionalFields
argument_list|(
name|type
argument_list|,
name|one
argument_list|,
name|two
argument_list|,
name|reqCmpResult
argument_list|)
return|;
block|}
DECL|method|haveSameIdentifier (final BibEntry one, final BibEntry two)
specifier|private
specifier|static
name|boolean
name|haveSameIdentifier
parameter_list|(
specifier|final
name|BibEntry
name|one
parameter_list|,
specifier|final
name|BibEntry
name|two
parameter_list|)
block|{
for|for
control|(
specifier|final
name|String
name|name
range|:
name|FieldName
operator|.
name|getIdentifierFieldNames
argument_list|()
control|)
block|{
if|if
condition|(
name|one
operator|.
name|getField
argument_list|(
name|name
argument_list|)
operator|.
name|isPresent
argument_list|()
operator|&&
name|one
operator|.
name|getField
argument_list|(
name|name
argument_list|)
operator|.
name|equals
argument_list|(
name|two
operator|.
name|getField
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|haveDifferentEntryType (final BibEntry one, final BibEntry two)
specifier|private
specifier|static
name|boolean
name|haveDifferentEntryType
parameter_list|(
specifier|final
name|BibEntry
name|one
parameter_list|,
specifier|final
name|BibEntry
name|two
parameter_list|)
block|{
return|return
operator|!
name|one
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|two
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
DECL|method|haveDifferentEditions (final BibEntry one, final BibEntry two)
specifier|private
specifier|static
name|boolean
name|haveDifferentEditions
parameter_list|(
specifier|final
name|BibEntry
name|one
parameter_list|,
specifier|final
name|BibEntry
name|two
parameter_list|)
block|{
specifier|final
name|Optional
argument_list|<
name|String
argument_list|>
name|editionOne
init|=
name|one
operator|.
name|getField
argument_list|(
name|EDITION
argument_list|)
decl_stmt|;
specifier|final
name|Optional
argument_list|<
name|String
argument_list|>
name|editionTwo
init|=
name|two
operator|.
name|getField
argument_list|(
name|EDITION
argument_list|)
decl_stmt|;
return|return
name|editionOne
operator|.
name|isPresent
argument_list|()
operator|&&
name|editionTwo
operator|.
name|isPresent
argument_list|()
operator|&&
operator|!
name|editionOne
operator|.
name|get
argument_list|()
operator|.
name|equals
argument_list|(
name|editionTwo
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
DECL|method|haveDifferentChaptersOrPagesOfTheSameBook (final BibEntry one, final BibEntry two)
specifier|private
specifier|static
name|boolean
name|haveDifferentChaptersOrPagesOfTheSameBook
parameter_list|(
specifier|final
name|BibEntry
name|one
parameter_list|,
specifier|final
name|BibEntry
name|two
parameter_list|)
block|{
return|return
operator|(
name|compareSingleField
argument_list|(
name|AUTHOR
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
operator|==
name|EQUAL
operator|)
operator|&&
operator|(
name|compareSingleField
argument_list|(
name|TITLE
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
operator|==
name|EQUAL
operator|)
operator|&&
operator|(
operator|(
name|compareSingleField
argument_list|(
name|CHAPTER
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
operator|==
name|NOT_EQUAL
operator|)
operator|||
operator|(
name|compareSingleField
argument_list|(
name|PAGES
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
operator|==
name|NOT_EQUAL
operator|)
operator|)
return|;
block|}
DECL|method|compareRequiredFields (final EntryType type, final BibEntry one, final BibEntry two)
specifier|private
specifier|static
name|double
index|[]
name|compareRequiredFields
parameter_list|(
specifier|final
name|EntryType
name|type
parameter_list|,
specifier|final
name|BibEntry
name|one
parameter_list|,
specifier|final
name|BibEntry
name|two
parameter_list|)
block|{
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|requiredFields
init|=
name|type
operator|.
name|getRequiredFieldsFlat
argument_list|()
decl_stmt|;
return|return
name|requiredFields
operator|==
literal|null
condition|?
operator|new
name|double
index|[]
block|{
literal|0.
block|,
literal|0.
block|}
else|:
name|DuplicateCheck
operator|.
name|compareFieldSet
argument_list|(
name|requiredFields
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
return|;
block|}
DECL|method|isFarFromThreshold (double value)
specifier|private
specifier|static
name|boolean
name|isFarFromThreshold
parameter_list|(
name|double
name|value
parameter_list|)
block|{
return|return
name|Math
operator|.
name|abs
argument_list|(
name|value
operator|-
name|DuplicateCheck
operator|.
name|DUPLICATE_THRESHOLD
argument_list|)
operator|>
name|DuplicateCheck
operator|.
name|DOUBT_RANGE
return|;
block|}
DECL|method|compareOptionalFields (final EntryType type, final BibEntry one, final BibEntry two, final double[] req)
specifier|private
specifier|static
name|boolean
name|compareOptionalFields
parameter_list|(
specifier|final
name|EntryType
name|type
parameter_list|,
specifier|final
name|BibEntry
name|one
parameter_list|,
specifier|final
name|BibEntry
name|two
parameter_list|,
specifier|final
name|double
index|[]
name|req
parameter_list|)
block|{
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|optionalFields
init|=
name|type
operator|.
name|getOptionalFields
argument_list|()
decl_stmt|;
if|if
condition|(
name|optionalFields
operator|==
literal|null
condition|)
block|{
return|return
name|req
index|[
literal|0
index|]
operator|>=
name|DuplicateCheck
operator|.
name|DUPLICATE_THRESHOLD
return|;
block|}
specifier|final
name|double
index|[]
name|opt
init|=
name|DuplicateCheck
operator|.
name|compareFieldSet
argument_list|(
name|optionalFields
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
decl_stmt|;
specifier|final
name|double
name|numerator
init|=
operator|(
name|DuplicateCheck
operator|.
name|REQUIRED_WEIGHT
operator|*
name|req
index|[
literal|0
index|]
operator|*
name|req
index|[
literal|1
index|]
operator|)
operator|+
operator|(
name|opt
index|[
literal|0
index|]
operator|*
name|opt
index|[
literal|1
index|]
operator|)
decl_stmt|;
specifier|final
name|double
name|denominator
init|=
operator|(
name|req
index|[
literal|1
index|]
operator|*
name|DuplicateCheck
operator|.
name|REQUIRED_WEIGHT
operator|)
operator|+
name|opt
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|double
name|totValue
init|=
name|numerator
operator|/
name|denominator
decl_stmt|;
return|return
name|totValue
operator|>=
name|DuplicateCheck
operator|.
name|DUPLICATE_THRESHOLD
return|;
block|}
DECL|method|compareFieldSet (final Collection<String> fields, final BibEntry one, final BibEntry two)
specifier|private
specifier|static
name|double
index|[]
name|compareFieldSet
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|,
specifier|final
name|BibEntry
name|one
parameter_list|,
specifier|final
name|BibEntry
name|two
parameter_list|)
block|{
name|double
name|res
init|=
literal|0
decl_stmt|;
name|double
name|totWeights
init|=
literal|0.
decl_stmt|;
for|for
control|(
specifier|final
name|String
name|field
range|:
name|fields
control|)
block|{
specifier|final
name|double
name|weight
init|=
name|DuplicateCheck
operator|.
name|FIELD_WEIGHTS
operator|.
name|getOrDefault
argument_list|(
name|field
argument_list|,
literal|1.0
argument_list|)
decl_stmt|;
name|totWeights
operator|+=
name|weight
expr_stmt|;
name|int
name|result
init|=
name|DuplicateCheck
operator|.
name|compareSingleField
argument_list|(
name|field
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|EQUAL
condition|)
block|{
name|res
operator|+=
name|weight
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|EMPTY_IN_BOTH
condition|)
block|{
name|totWeights
operator|-=
name|weight
expr_stmt|;
block|}
block|}
if|if
condition|(
name|totWeights
operator|>
literal|0
condition|)
block|{
return|return
operator|new
name|double
index|[]
block|{
name|res
operator|/
name|totWeights
block|,
name|totWeights
block|}
return|;
block|}
return|return
operator|new
name|double
index|[]
block|{
literal|0.5
block|,
literal|0.0
block|}
return|;
block|}
DECL|method|compareSingleField (final String field, final BibEntry one, final BibEntry two)
specifier|private
specifier|static
name|int
name|compareSingleField
parameter_list|(
specifier|final
name|String
name|field
parameter_list|,
specifier|final
name|BibEntry
name|one
parameter_list|,
specifier|final
name|BibEntry
name|two
parameter_list|)
block|{
specifier|final
name|Optional
argument_list|<
name|String
argument_list|>
name|optionalStringOne
init|=
name|one
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
specifier|final
name|Optional
argument_list|<
name|String
argument_list|>
name|optionalStringTwo
init|=
name|two
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|optionalStringOne
operator|.
name|isPresent
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|optionalStringTwo
operator|.
name|isPresent
argument_list|()
condition|)
block|{
return|return
name|EMPTY_IN_BOTH
return|;
block|}
return|return
name|EMPTY_IN_ONE
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|optionalStringTwo
operator|.
name|isPresent
argument_list|()
condition|)
block|{
return|return
name|EMPTY_IN_TWO
return|;
block|}
comment|// Both strings present
specifier|final
name|String
name|stringOne
init|=
name|optionalStringOne
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|final
name|String
name|stringTwo
init|=
name|optionalStringTwo
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|InternalBibtexFields
operator|.
name|getFieldProperties
argument_list|(
name|field
argument_list|)
operator|.
name|contains
argument_list|(
name|FieldProperty
operator|.
name|PERSON_NAMES
argument_list|)
condition|)
block|{
return|return
name|compareAuthorField
argument_list|(
name|stringOne
argument_list|,
name|stringTwo
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|PAGES
operator|.
name|equals
argument_list|(
name|field
argument_list|)
condition|)
block|{
return|return
name|comparePagesField
argument_list|(
name|stringOne
argument_list|,
name|stringTwo
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|JOURNAL
operator|.
name|equals
argument_list|(
name|field
argument_list|)
condition|)
block|{
return|return
name|compareJournalField
argument_list|(
name|stringOne
argument_list|,
name|stringTwo
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|CHAPTER
operator|.
name|equals
argument_list|(
name|field
argument_list|)
condition|)
block|{
return|return
name|compareChapterField
argument_list|(
name|stringOne
argument_list|,
name|stringTwo
argument_list|)
return|;
block|}
return|return
name|compareField
argument_list|(
name|stringOne
argument_list|,
name|stringTwo
argument_list|)
return|;
block|}
DECL|method|compareAuthorField (final String stringOne, final String stringTwo)
specifier|private
specifier|static
name|int
name|compareAuthorField
parameter_list|(
specifier|final
name|String
name|stringOne
parameter_list|,
specifier|final
name|String
name|stringTwo
parameter_list|)
block|{
comment|// Specific for name fields.
comment|// Harmonise case:
specifier|final
name|String
name|authorOne
init|=
name|AuthorList
operator|.
name|fixAuthorLastNameOnlyCommas
argument_list|(
name|stringOne
argument_list|,
literal|false
argument_list|)
operator|.
name|replace
argument_list|(
literal|" and "
argument_list|,
literal|" "
argument_list|)
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
specifier|final
name|String
name|authorTwo
init|=
name|AuthorList
operator|.
name|fixAuthorLastNameOnlyCommas
argument_list|(
name|stringTwo
argument_list|,
literal|false
argument_list|)
operator|.
name|replace
argument_list|(
literal|" and "
argument_list|,
literal|" "
argument_list|)
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
specifier|final
name|double
name|similarity
init|=
name|DuplicateCheck
operator|.
name|correlateByWords
argument_list|(
name|authorOne
argument_list|,
name|authorTwo
argument_list|)
decl_stmt|;
if|if
condition|(
name|similarity
operator|>
literal|0.8
condition|)
block|{
return|return
name|EQUAL
return|;
block|}
return|return
name|NOT_EQUAL
return|;
block|}
comment|/**      * Pages can be given with a variety of delimiters, "-", "--", " - ", " -- ".      * We do a replace to harmonize these to a simple "-"      * After this, a simple test for equality should be enough      */
DECL|method|comparePagesField (final String stringOne, final String stringTwo)
specifier|private
specifier|static
name|int
name|comparePagesField
parameter_list|(
specifier|final
name|String
name|stringOne
parameter_list|,
specifier|final
name|String
name|stringTwo
parameter_list|)
block|{
specifier|final
name|String
name|processedStringOne
init|=
name|stringOne
operator|.
name|replaceAll
argument_list|(
literal|"[- ]+"
argument_list|,
literal|"-"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|processedStringTwo
init|=
name|stringTwo
operator|.
name|replaceAll
argument_list|(
literal|"[- ]+"
argument_list|,
literal|"-"
argument_list|)
decl_stmt|;
if|if
condition|(
name|processedStringOne
operator|.
name|equals
argument_list|(
name|processedStringTwo
argument_list|)
condition|)
block|{
return|return
name|EQUAL
return|;
block|}
return|return
name|NOT_EQUAL
return|;
block|}
comment|/**      * We do not attempt to harmonize abbreviation state of the journal names,      * but we remove periods from the names in case they are abbreviated with and without dots:      */
DECL|method|compareJournalField (final String stringOne, final String stringTwo)
specifier|private
specifier|static
name|int
name|compareJournalField
parameter_list|(
specifier|final
name|String
name|stringOne
parameter_list|,
specifier|final
name|String
name|stringTwo
parameter_list|)
block|{
specifier|final
name|String
name|processedStringOne
init|=
name|stringOne
operator|.
name|replace
argument_list|(
literal|"."
argument_list|,
literal|""
argument_list|)
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
specifier|final
name|String
name|processedStringTwo
init|=
name|stringTwo
operator|.
name|replace
argument_list|(
literal|"."
argument_list|,
literal|""
argument_list|)
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
specifier|final
name|double
name|similarity
init|=
name|DuplicateCheck
operator|.
name|correlateByWords
argument_list|(
name|processedStringOne
argument_list|,
name|processedStringTwo
argument_list|)
decl_stmt|;
if|if
condition|(
name|similarity
operator|>
literal|0.8
condition|)
block|{
return|return
name|EQUAL
return|;
block|}
return|return
name|NOT_EQUAL
return|;
block|}
DECL|method|compareChapterField (final String stringOne, final String stringTwo)
specifier|private
specifier|static
name|int
name|compareChapterField
parameter_list|(
specifier|final
name|String
name|stringOne
parameter_list|,
specifier|final
name|String
name|stringTwo
parameter_list|)
block|{
specifier|final
name|String
name|processedStringOne
init|=
name|stringOne
operator|.
name|replaceAll
argument_list|(
literal|"(?i)chapter"
argument_list|,
literal|""
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
specifier|final
name|String
name|processedStringTwo
init|=
name|stringTwo
operator|.
name|replaceAll
argument_list|(
literal|"(?i)chapter"
argument_list|,
literal|""
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
return|return
name|compareField
argument_list|(
name|processedStringOne
argument_list|,
name|processedStringTwo
argument_list|)
return|;
block|}
DECL|method|compareField (final String stringOne, final String stringTwo)
specifier|private
specifier|static
name|int
name|compareField
parameter_list|(
specifier|final
name|String
name|stringOne
parameter_list|,
specifier|final
name|String
name|stringTwo
parameter_list|)
block|{
specifier|final
name|String
name|processedStringOne
init|=
name|stringOne
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
specifier|final
name|String
name|processedStringTwo
init|=
name|stringTwo
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
specifier|final
name|double
name|similarity
init|=
name|DuplicateCheck
operator|.
name|correlateByWords
argument_list|(
name|processedStringOne
argument_list|,
name|processedStringTwo
argument_list|)
decl_stmt|;
if|if
condition|(
name|similarity
operator|>
literal|0.8
condition|)
block|{
return|return
name|EQUAL
return|;
block|}
return|return
name|NOT_EQUAL
return|;
block|}
DECL|method|compareEntriesStrictly (BibEntry one, BibEntry two)
specifier|public
specifier|static
name|double
name|compareEntriesStrictly
parameter_list|(
name|BibEntry
name|one
parameter_list|,
name|BibEntry
name|two
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|allFields
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|allFields
operator|.
name|addAll
argument_list|(
name|one
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
name|allFields
operator|.
name|addAll
argument_list|(
name|two
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|score
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|String
name|field
range|:
name|allFields
control|)
block|{
specifier|final
name|Optional
argument_list|<
name|String
argument_list|>
name|stringOne
init|=
name|one
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
specifier|final
name|Optional
argument_list|<
name|String
argument_list|>
name|stringTwo
init|=
name|two
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|stringOne
operator|.
name|equals
argument_list|(
name|stringTwo
argument_list|)
condition|)
block|{
name|score
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|score
operator|==
name|allFields
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|1.01
return|;
comment|// Just to make sure we can use score> 1 without trouble.
block|}
return|return
operator|(
name|double
operator|)
name|score
operator|/
name|allFields
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Goes through all entries in the given database, and if at least one of      * them is a duplicate of the given entry, as per      * Util.isDuplicate(BibEntry, BibEntry), the duplicate is returned.      * The search is terminated when the first duplicate is found.      *      * @param database The database to search.      * @param entry    The entry of which we are looking for duplicates.      * @return The first duplicate entry found. Empty Optional if no duplicates are found.      */
DECL|method|containsDuplicate (final BibDatabase database, final BibEntry entry, final BibDatabaseMode bibDatabaseMode)
specifier|public
specifier|static
name|Optional
argument_list|<
name|BibEntry
argument_list|>
name|containsDuplicate
parameter_list|(
specifier|final
name|BibDatabase
name|database
parameter_list|,
specifier|final
name|BibEntry
name|entry
parameter_list|,
specifier|final
name|BibDatabaseMode
name|bibDatabaseMode
parameter_list|)
block|{
return|return
name|database
operator|.
name|getEntries
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|other
lambda|->
name|DuplicateCheck
operator|.
name|isDuplicate
argument_list|(
name|entry
argument_list|,
name|other
argument_list|,
name|bibDatabaseMode
argument_list|)
argument_list|)
operator|.
name|findFirst
argument_list|()
return|;
block|}
comment|/**      * Compare two strings on the basis of word-by-word correlation analysis.      *      * @param s1 The first string      * @param s2 The second string      * @return a value in the interval [0, 1] indicating the degree of match.      */
DECL|method|correlateByWords (final String s1, final String s2)
specifier|public
specifier|static
name|double
name|correlateByWords
parameter_list|(
specifier|final
name|String
name|s1
parameter_list|,
specifier|final
name|String
name|s2
parameter_list|)
block|{
specifier|final
name|String
index|[]
name|w1
init|=
name|s1
operator|.
name|split
argument_list|(
literal|"\\s"
argument_list|)
decl_stmt|;
specifier|final
name|String
index|[]
name|w2
init|=
name|s2
operator|.
name|split
argument_list|(
literal|"\\s"
argument_list|)
decl_stmt|;
specifier|final
name|int
name|n
init|=
name|Math
operator|.
name|min
argument_list|(
name|w1
operator|.
name|length
argument_list|,
name|w2
operator|.
name|length
argument_list|)
decl_stmt|;
name|int
name|misses
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|double
name|corr
init|=
name|similarity
argument_list|(
name|w1
index|[
name|i
index|]
argument_list|,
name|w2
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|corr
operator|<
literal|0.75
condition|)
block|{
name|misses
operator|++
expr_stmt|;
block|}
block|}
specifier|final
name|double
name|missRate
init|=
operator|(
name|double
operator|)
name|misses
operator|/
operator|(
name|double
operator|)
name|n
decl_stmt|;
return|return
literal|1
operator|-
name|missRate
return|;
block|}
comment|/*      * Calculates the similarity (a number within 0 and 1) between two strings.      * http://stackoverflow.com/questions/955110/similarity-string-comparison-in-java      */
DECL|method|similarity (final String first, final String second)
specifier|private
specifier|static
name|double
name|similarity
parameter_list|(
specifier|final
name|String
name|first
parameter_list|,
specifier|final
name|String
name|second
parameter_list|)
block|{
specifier|final
name|String
name|longer
decl_stmt|;
specifier|final
name|String
name|shorter
decl_stmt|;
if|if
condition|(
name|first
operator|.
name|length
argument_list|()
operator|<
name|second
operator|.
name|length
argument_list|()
condition|)
block|{
name|longer
operator|=
name|second
expr_stmt|;
name|shorter
operator|=
name|first
expr_stmt|;
block|}
else|else
block|{
name|longer
operator|=
name|first
expr_stmt|;
name|shorter
operator|=
name|second
expr_stmt|;
block|}
specifier|final
name|int
name|longerLength
init|=
name|longer
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// both strings are zero length
if|if
condition|(
name|longerLength
operator|==
literal|0
condition|)
block|{
return|return
literal|1.0
return|;
block|}
specifier|final
name|double
name|distanceIgnoredCase
init|=
operator|new
name|StringSimilarity
argument_list|()
operator|.
name|editDistanceIgnoreCase
argument_list|(
name|longer
argument_list|,
name|shorter
argument_list|)
decl_stmt|;
specifier|final
name|double
name|similarity
init|=
operator|(
name|longerLength
operator|-
name|distanceIgnoredCase
operator|)
operator|/
name|longerLength
decl_stmt|;
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Longer string: "
operator|+
name|longer
operator|+
literal|" Shorter string: "
operator|+
name|shorter
operator|+
literal|" Similarity: "
operator|+
name|similarity
argument_list|)
expr_stmt|;
return|return
name|similarity
return|;
block|}
block|}
end_class

end_unit

