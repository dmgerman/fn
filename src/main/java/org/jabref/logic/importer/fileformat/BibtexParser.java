begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.jabref.logic.importer.fileformat
package|package
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|importer
operator|.
name|fileformat
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PushbackReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|bibtex
operator|.
name|FieldContentParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|exporter
operator|.
name|BibtexDatabaseWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|exporter
operator|.
name|SavePreferences
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|importer
operator|.
name|ImportFormatPreferences
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|importer
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|importer
operator|.
name|Parser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|importer
operator|.
name|ParserResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|importer
operator|.
name|util
operator|.
name|MetaDataParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|l10n
operator|.
name|Localization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|KeyCollisionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|BibEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|BibtexString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|CustomEntryType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|EntryType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|FieldName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|FieldProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|InternalBibtexFields
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|metadata
operator|.
name|MetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_comment
comment|/**  * Class for importing BibTeX-files.  *<p>  * Use:  *<p>  * BibtexParser parser = new BibtexParser(reader);  *<p>  * ParserResult result = parser.parse();  *<p>  * or  *<p>  * ParserResult result = BibtexParser.parse(reader);  *<p>  * Can be used stand-alone.  */
end_comment

begin_class
DECL|class|BibtexParser
specifier|public
class|class
name|BibtexParser
implements|implements
name|Parser
block|{
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Log
name|LOGGER
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|BibtexParser
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|LOOKAHEAD
specifier|private
specifier|static
specifier|final
name|Integer
name|LOOKAHEAD
init|=
literal|64
decl_stmt|;
DECL|field|fieldContentParser
specifier|private
specifier|final
name|FieldContentParser
name|fieldContentParser
decl_stmt|;
DECL|field|pureTextFromFile
specifier|private
specifier|final
name|Deque
argument_list|<
name|Character
argument_list|>
name|pureTextFromFile
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|importFormatPreferences
specifier|private
specifier|final
name|ImportFormatPreferences
name|importFormatPreferences
decl_stmt|;
DECL|field|pushbackReader
specifier|private
name|PushbackReader
name|pushbackReader
decl_stmt|;
DECL|field|database
specifier|private
name|BibDatabase
name|database
decl_stmt|;
DECL|field|entryTypes
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|EntryType
argument_list|>
name|entryTypes
decl_stmt|;
DECL|field|eof
specifier|private
name|boolean
name|eof
decl_stmt|;
DECL|field|line
specifier|private
name|int
name|line
init|=
literal|1
decl_stmt|;
DECL|field|parserResult
specifier|private
name|ParserResult
name|parserResult
decl_stmt|;
DECL|method|BibtexParser (ImportFormatPreferences importFormatPreferences)
specifier|public
name|BibtexParser
parameter_list|(
name|ImportFormatPreferences
name|importFormatPreferences
parameter_list|)
block|{
name|this
operator|.
name|importFormatPreferences
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|importFormatPreferences
argument_list|)
expr_stmt|;
name|fieldContentParser
operator|=
operator|new
name|FieldContentParser
argument_list|(
name|importFormatPreferences
operator|.
name|getFieldContentParserPreferences
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Shortcut usage to create a Parser and read the input.      *      * @param in the Reader to read from      * @throws IOException      * @deprecated inline this method      */
annotation|@
name|Deprecated
DECL|method|parse (Reader in, ImportFormatPreferences importFormatPreferences)
specifier|public
specifier|static
name|ParserResult
name|parse
parameter_list|(
name|Reader
name|in
parameter_list|,
name|ImportFormatPreferences
name|importFormatPreferences
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|BibtexParser
argument_list|(
name|importFormatPreferences
argument_list|)
operator|.
name|parse
argument_list|(
name|in
argument_list|)
return|;
block|}
comment|/**      * Parses BibtexEntries from the given string and returns one entry found (or null if none found)      *<p>      * It is undetermined which entry is returned, so use this in case you know there is only one entry in the string.      *      * @param bibtexString      * @return An Optional<BibEntry>. Optional.empty() if non was found or an error occurred.      * @throws ParseException      */
DECL|method|singleFromString (String bibtexString, ImportFormatPreferences importFormatPreferences)
specifier|public
specifier|static
name|Optional
argument_list|<
name|BibEntry
argument_list|>
name|singleFromString
parameter_list|(
name|String
name|bibtexString
parameter_list|,
name|ImportFormatPreferences
name|importFormatPreferences
parameter_list|)
throws|throws
name|ParseException
block|{
name|Collection
argument_list|<
name|BibEntry
argument_list|>
name|entries
init|=
operator|new
name|BibtexParser
argument_list|(
name|importFormatPreferences
argument_list|)
operator|.
name|parseEntries
argument_list|(
name|bibtexString
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|entries
operator|==
literal|null
operator|)
operator|||
name|entries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
return|return
name|Optional
operator|.
name|of
argument_list|(
name|entries
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|parseEntries (InputStream inputStream)
specifier|public
name|List
argument_list|<
name|BibEntry
argument_list|>
name|parseEntries
parameter_list|(
name|InputStream
name|inputStream
parameter_list|)
throws|throws
name|ParseException
block|{
name|BufferedReader
name|reader
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|inputStream
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|parseEntries
argument_list|(
name|reader
argument_list|)
return|;
block|}
DECL|method|parseEntries (Reader reader)
specifier|public
name|List
argument_list|<
name|BibEntry
argument_list|>
name|parseEntries
parameter_list|(
name|Reader
name|reader
parameter_list|)
throws|throws
name|ParseException
block|{
try|try
block|{
return|return
name|parse
argument_list|(
name|reader
argument_list|)
operator|.
name|getDatabase
argument_list|()
operator|.
name|getEntries
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|parseEntries (String bibtexString)
specifier|public
name|List
argument_list|<
name|BibEntry
argument_list|>
name|parseEntries
parameter_list|(
name|String
name|bibtexString
parameter_list|)
throws|throws
name|ParseException
block|{
return|return
name|parseEntries
argument_list|(
operator|new
name|StringReader
argument_list|(
name|bibtexString
argument_list|)
argument_list|)
return|;
block|}
DECL|method|parseSingleEntry (String bibtexString)
specifier|public
name|Optional
argument_list|<
name|BibEntry
argument_list|>
name|parseSingleEntry
parameter_list|(
name|String
name|bibtexString
parameter_list|)
throws|throws
name|ParseException
block|{
return|return
name|parseEntries
argument_list|(
name|bibtexString
argument_list|)
operator|.
name|stream
argument_list|()
operator|.
name|findFirst
argument_list|()
return|;
block|}
comment|/**      * Will parse the BibTex-Data found when reading from reader. Ignores any encoding supplied in the file by      * "Encoding: myEncoding".      *<p>      * The reader will be consumed.      *<p>      * Multiple calls to parse() return the same results      *      * @return ParserResult      * @throws IOException      */
DECL|method|parse (Reader in)
specifier|public
name|ParserResult
name|parse
parameter_list|(
name|Reader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|pushbackReader
operator|=
operator|new
name|PushbackReader
argument_list|(
name|in
argument_list|,
name|BibtexParser
operator|.
name|LOOKAHEAD
argument_list|)
expr_stmt|;
comment|// Bibtex related contents.
name|initializeParserResult
argument_list|()
expr_stmt|;
name|parseDatabaseID
argument_list|()
expr_stmt|;
name|skipWhitespace
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|parseFileContent
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|KeyCollisionException
name|kce
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Duplicate ID in bibtex file: "
operator|+
name|kce
argument_list|)
throw|;
block|}
block|}
DECL|method|initializeParserResult ()
specifier|private
name|void
name|initializeParserResult
parameter_list|()
block|{
name|database
operator|=
operator|new
name|BibDatabase
argument_list|()
expr_stmt|;
name|entryTypes
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
comment|// To store custom entry types parsed.
name|parserResult
operator|=
operator|new
name|ParserResult
argument_list|(
name|database
argument_list|,
operator|new
name|MetaData
argument_list|()
argument_list|,
name|entryTypes
argument_list|)
expr_stmt|;
block|}
DECL|method|parseDatabaseID ()
specifier|private
name|void
name|parseDatabaseID
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
operator|!
name|eof
condition|)
block|{
name|skipWhitespace
argument_list|()
expr_stmt|;
name|char
name|c
init|=
operator|(
name|char
operator|)
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
name|skipWhitespace
argument_list|()
expr_stmt|;
name|String
name|label
init|=
name|parseTextToken
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|label
operator|.
name|equals
argument_list|(
name|BibtexDatabaseWriter
operator|.
name|DATABASE_ID_PREFIX
argument_list|)
condition|)
block|{
name|skipWhitespace
argument_list|()
expr_stmt|;
name|database
operator|.
name|setSharedDatabaseID
argument_list|(
name|parseTextToken
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'@'
condition|)
block|{
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
DECL|method|parseFileContent ()
specifier|private
name|ParserResult
name|parseFileContent
parameter_list|()
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|meta
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|eof
condition|)
block|{
name|boolean
name|found
init|=
name|consumeUncritically
argument_list|(
literal|'@'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
break|break;
block|}
name|skipWhitespace
argument_list|()
expr_stmt|;
comment|// Try to read the entry type
name|String
name|entryType
init|=
name|parseTextToken
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"preamble"
operator|.
name|equals
argument_list|(
name|entryType
argument_list|)
condition|)
block|{
name|database
operator|.
name|setPreamble
argument_list|(
name|parsePreamble
argument_list|()
argument_list|)
expr_stmt|;
comment|// Consume new line which signals end of preamble
name|skipOneNewline
argument_list|()
expr_stmt|;
comment|// the preamble is saved verbatim anyways, so the text read so far can be dropped
name|dumpTextReadSoFarToString
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"string"
operator|.
name|equals
argument_list|(
name|entryType
argument_list|)
condition|)
block|{
name|parseBibtexString
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"comment"
operator|.
name|equals
argument_list|(
name|entryType
argument_list|)
condition|)
block|{
name|parseJabRefComment
argument_list|(
name|meta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Not a comment, preamble, or string. Thus, it is an entry
name|parseAndAddEntry
argument_list|(
name|entryType
argument_list|)
expr_stmt|;
block|}
name|skipWhitespace
argument_list|()
expr_stmt|;
block|}
comment|// Instantiate meta data:
try|try
block|{
name|parserResult
operator|.
name|setMetaData
argument_list|(
name|MetaDataParser
operator|.
name|parse
argument_list|(
name|meta
argument_list|,
name|importFormatPreferences
operator|.
name|getKeywordSeparator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|exception
parameter_list|)
block|{
name|parserResult
operator|.
name|addException
argument_list|(
name|exception
argument_list|)
expr_stmt|;
block|}
name|parseRemainingContent
argument_list|()
expr_stmt|;
return|return
name|parserResult
return|;
block|}
DECL|method|parseRemainingContent ()
specifier|private
name|void
name|parseRemainingContent
parameter_list|()
block|{
name|database
operator|.
name|setEpilog
argument_list|(
name|dumpTextReadSoFarToString
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|parseAndAddEntry (String type)
specifier|private
name|void
name|parseAndAddEntry
parameter_list|(
name|String
name|type
parameter_list|)
block|{
comment|/**          * Morten Alver 13 Aug 2006: Trying to make the parser more          * robust. If an exception is thrown when parsing an entry,          * drop the entry and try to resume parsing. Add a warning          * for the user.          */
try|try
block|{
comment|// collect all comments and the entry type definition in front of the actual entry
comment|// this is at least `@Type`
name|String
name|commentsAndEntryTypeDefinition
init|=
name|dumpTextReadSoFarToString
argument_list|()
decl_stmt|;
name|BibEntry
name|entry
init|=
name|parseEntry
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|// store comments collected without type definition
name|entry
operator|.
name|setCommentsBeforeEntry
argument_list|(
name|commentsAndEntryTypeDefinition
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|commentsAndEntryTypeDefinition
operator|.
name|lastIndexOf
argument_list|(
literal|'@'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// store complete parsed serialization (comments, type definition + type contents)
name|entry
operator|.
name|setParsedSerialization
argument_list|(
name|commentsAndEntryTypeDefinition
operator|+
name|dumpTextReadSoFarToString
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|duplicateKey
init|=
name|database
operator|.
name|insertEntry
argument_list|(
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|duplicateKey
condition|)
block|{
name|parserResult
operator|.
name|addDuplicateKey
argument_list|(
name|entry
operator|.
name|getCiteKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Could not parse entry"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|parserResult
operator|.
name|addWarning
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Error occurred when parsing entry"
argument_list|)
operator|+
literal|": '"
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
operator|+
literal|"'. "
operator|+
name|Localization
operator|.
name|lang
argument_list|(
literal|"Skipped entry."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|parseJabRefComment (Map<String, String> meta)
specifier|private
name|void
name|parseJabRefComment
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|meta
parameter_list|)
block|{
name|StringBuilder
name|buffer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|buffer
operator|=
name|parseBracketedTextExactly
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|/* if we get an IO Exception here, than we have an unbracketed comment,             * which means that we should just return and the comment will be picked up as arbitrary text             *  by the parser              */
name|LOGGER
operator|.
name|info
argument_list|(
literal|"Found unbracketed comment"
argument_list|)
expr_stmt|;
return|return;
block|}
name|String
name|comment
init|=
name|buffer
operator|.
name|toString
argument_list|()
operator|.
name|replaceAll
argument_list|(
literal|"[\\x0d\\x0a]"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|comment
operator|.
name|length
argument_list|()
argument_list|,
name|MetaData
operator|.
name|META_FLAG
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
operator|.
name|equals
argument_list|(
name|MetaData
operator|.
name|META_FLAG
argument_list|)
condition|)
block|{
if|if
condition|(
name|comment
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|MetaData
operator|.
name|META_FLAG
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|MetaData
operator|.
name|META_FLAG
argument_list|)
condition|)
block|{
name|String
name|rest
init|=
name|comment
operator|.
name|substring
argument_list|(
name|MetaData
operator|.
name|META_FLAG
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|rest
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
block|{
comment|// We remove all line breaks in the metadata - these
comment|// will have been inserted
comment|// to prevent too long lines when the file was
comment|// saved, and are not part of the data.
name|meta
operator|.
name|put
argument_list|(
name|rest
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|pos
argument_list|)
argument_list|,
name|rest
operator|.
name|substring
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// meta comments are always re-written by JabRef and not stored in the file
name|dumpTextReadSoFarToString
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|comment
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|comment
operator|.
name|length
argument_list|()
argument_list|,
name|CustomEntryType
operator|.
name|ENTRYTYPE_FLAG
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
operator|.
name|equals
argument_list|(
name|CustomEntryType
operator|.
name|ENTRYTYPE_FLAG
argument_list|)
condition|)
block|{
comment|// A custom entry type can also be stored in a
comment|// "@comment"
name|Optional
argument_list|<
name|CustomEntryType
argument_list|>
name|typ
init|=
name|CustomEntryType
operator|.
name|parse
argument_list|(
name|comment
argument_list|)
decl_stmt|;
if|if
condition|(
name|typ
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|entryTypes
operator|.
name|put
argument_list|(
name|typ
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|typ
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parserResult
operator|.
name|addWarning
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Ill-formed entrytype comment in BIB file"
argument_list|)
operator|+
literal|": "
operator|+
name|comment
argument_list|)
expr_stmt|;
block|}
comment|// custom entry types are always re-written by JabRef and not stored in the file
name|dumpTextReadSoFarToString
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|parseBibtexString ()
specifier|private
name|void
name|parseBibtexString
parameter_list|()
throws|throws
name|IOException
block|{
name|BibtexString
name|bibtexString
init|=
name|parseString
argument_list|()
decl_stmt|;
name|bibtexString
operator|.
name|setParsedSerialization
argument_list|(
name|dumpTextReadSoFarToString
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|database
operator|.
name|addString
argument_list|(
name|bibtexString
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeyCollisionException
name|ex
parameter_list|)
block|{
name|parserResult
operator|.
name|addWarning
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Duplicate string name"
argument_list|)
operator|+
literal|": "
operator|+
name|bibtexString
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Puts all text that has been read from the reader, including newlines, etc., since the last call of this method into a string.      * Removes the JabRef file header, if it is found      *      * @return the text read so far      */
DECL|method|dumpTextReadSoFarToString ()
specifier|private
name|String
name|dumpTextReadSoFarToString
parameter_list|()
block|{
name|String
name|result
init|=
name|getPureTextFromFile
argument_list|()
decl_stmt|;
name|int
name|indexOfAt
init|=
name|result
operator|.
name|indexOf
argument_list|(
literal|"@"
argument_list|)
decl_stmt|;
comment|// if there is no entry found, simply return the content (necessary to parse text remaining after the last entry)
if|if
condition|(
name|indexOfAt
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|purgeEOFCharacters
argument_list|(
name|result
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|result
operator|.
name|contains
argument_list|(
name|BibtexDatabaseWriter
operator|.
name|DATABASE_ID_PREFIX
argument_list|)
condition|)
block|{
return|return
name|purge
argument_list|(
name|result
argument_list|,
name|BibtexDatabaseWriter
operator|.
name|DATABASE_ID_PREFIX
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|result
operator|.
name|contains
argument_list|(
name|SavePreferences
operator|.
name|ENCODING_PREFIX
argument_list|)
condition|)
block|{
return|return
name|purge
argument_list|(
name|result
argument_list|,
name|SavePreferences
operator|.
name|ENCODING_PREFIX
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|result
return|;
block|}
block|}
DECL|method|purge (String context, String stringToPurge)
specifier|private
name|String
name|purge
parameter_list|(
name|String
name|context
parameter_list|,
name|String
name|stringToPurge
parameter_list|)
block|{
comment|// purge the encoding line if it exists
name|int
name|runningIndex
init|=
name|context
operator|.
name|indexOf
argument_list|(
name|stringToPurge
argument_list|)
decl_stmt|;
name|int
name|indexOfAt
init|=
name|context
operator|.
name|indexOf
argument_list|(
literal|"@"
argument_list|)
decl_stmt|;
while|while
condition|(
name|runningIndex
operator|<
name|indexOfAt
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|charAt
argument_list|(
name|runningIndex
argument_list|)
operator|==
literal|'\n'
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|context
operator|.
name|charAt
argument_list|(
name|runningIndex
argument_list|)
operator|==
literal|'\r'
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|charAt
argument_list|(
name|runningIndex
operator|+
literal|1
argument_list|)
operator|==
literal|'\n'
condition|)
block|{
name|runningIndex
operator|++
expr_stmt|;
block|}
break|break;
block|}
name|runningIndex
operator|++
expr_stmt|;
block|}
return|return
name|context
operator|.
name|substring
argument_list|(
name|runningIndex
operator|+
literal|1
argument_list|)
return|;
block|}
DECL|method|getPureTextFromFile ()
specifier|private
name|String
name|getPureTextFromFile
parameter_list|()
block|{
name|StringBuilder
name|entry
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|pureTextFromFile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|entry
operator|.
name|append
argument_list|(
name|pureTextFromFile
operator|.
name|pollFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|entry
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Removes all eof characters from a StringBuilder and returns a new String with the resulting content      *      * @return a String without eof characters      */
DECL|method|purgeEOFCharacters (String input)
specifier|private
name|String
name|purgeEOFCharacters
parameter_list|(
name|String
name|input
parameter_list|)
block|{
name|StringBuilder
name|remainingText
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Character
name|character
range|:
name|input
operator|.
name|toCharArray
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|isEOFCharacter
argument_list|(
name|character
argument_list|)
operator|)
condition|)
block|{
name|remainingText
operator|.
name|append
argument_list|(
name|character
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|remainingText
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|skipWhitespace ()
specifier|private
name|void
name|skipWhitespace
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|character
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|character
operator|=
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|isEOFCharacter
argument_list|(
name|character
argument_list|)
condition|)
block|{
name|eof
operator|=
literal|true
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
condition|)
block|{
comment|// found non-whitespace char
name|unread
argument_list|(
name|character
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
DECL|method|skipSpace ()
specifier|private
name|void
name|skipSpace
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|character
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|character
operator|=
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|isEOFCharacter
argument_list|(
name|character
argument_list|)
condition|)
block|{
name|eof
operator|=
literal|true
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|char
operator|)
name|character
operator|!=
literal|' '
condition|)
block|{
comment|// found non-space char
name|unread
argument_list|(
name|character
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
DECL|method|skipOneNewline ()
specifier|private
name|void
name|skipOneNewline
parameter_list|()
throws|throws
name|IOException
block|{
name|skipSpace
argument_list|()
expr_stmt|;
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'\r'
condition|)
block|{
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'\n'
condition|)
block|{
name|read
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|isEOFCharacter (int character)
specifier|private
name|boolean
name|isEOFCharacter
parameter_list|(
name|int
name|character
parameter_list|)
block|{
return|return
operator|(
name|character
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|character
operator|==
literal|65535
operator|)
return|;
block|}
DECL|method|skipAndRecordWhitespace (int character)
specifier|private
name|String
name|skipAndRecordWhitespace
parameter_list|(
name|int
name|character
parameter_list|)
throws|throws
name|IOException
block|{
name|StringBuilder
name|stringBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|character
operator|!=
literal|' '
condition|)
block|{
name|stringBuilder
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|nextCharacter
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|isEOFCharacter
argument_list|(
name|nextCharacter
argument_list|)
condition|)
block|{
name|eof
operator|=
literal|true
expr_stmt|;
return|return
name|stringBuilder
operator|.
name|toString
argument_list|()
return|;
block|}
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
operator|(
name|char
operator|)
name|nextCharacter
argument_list|)
condition|)
block|{
if|if
condition|(
name|nextCharacter
operator|!=
literal|' '
condition|)
block|{
name|stringBuilder
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|nextCharacter
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// found non-whitespace char
name|unread
argument_list|(
name|nextCharacter
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|stringBuilder
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|peek ()
specifier|private
name|int
name|peek
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|character
init|=
name|read
argument_list|()
decl_stmt|;
name|unread
argument_list|(
name|character
argument_list|)
expr_stmt|;
return|return
name|character
return|;
block|}
DECL|method|read ()
specifier|private
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|character
init|=
name|pushbackReader
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isEOFCharacter
argument_list|(
name|character
argument_list|)
condition|)
block|{
name|pureTextFromFile
operator|.
name|offerLast
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|character
operator|==
literal|'\n'
condition|)
block|{
name|line
operator|++
expr_stmt|;
block|}
return|return
name|character
return|;
block|}
DECL|method|unread (int character)
specifier|private
name|void
name|unread
parameter_list|(
name|int
name|character
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|character
operator|==
literal|'\n'
condition|)
block|{
name|line
operator|--
expr_stmt|;
block|}
name|pushbackReader
operator|.
name|unread
argument_list|(
name|character
argument_list|)
expr_stmt|;
if|if
condition|(
name|pureTextFromFile
operator|.
name|getLast
argument_list|()
operator|==
name|character
condition|)
block|{
name|pureTextFromFile
operator|.
name|pollLast
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|parseString ()
specifier|private
name|BibtexString
name|parseString
parameter_list|()
throws|throws
name|IOException
block|{
name|skipWhitespace
argument_list|()
expr_stmt|;
name|consume
argument_list|(
literal|'{'
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|skipWhitespace
argument_list|()
expr_stmt|;
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Parsing string name"
argument_list|)
expr_stmt|;
name|String
name|name
init|=
name|parseTextToken
argument_list|()
decl_stmt|;
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Parsed string name"
argument_list|)
expr_stmt|;
name|skipWhitespace
argument_list|()
expr_stmt|;
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Now the contents"
argument_list|)
expr_stmt|;
name|consume
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|String
name|content
init|=
name|parseFieldContent
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Now I'm going to consume a }"
argument_list|)
expr_stmt|;
name|consume
argument_list|(
literal|'}'
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
comment|// Consume new line which signals end of entry
name|skipOneNewline
argument_list|()
expr_stmt|;
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Finished string parsing."
argument_list|)
expr_stmt|;
return|return
operator|new
name|BibtexString
argument_list|(
name|name
argument_list|,
name|content
argument_list|)
return|;
block|}
DECL|method|parsePreamble ()
specifier|private
name|String
name|parsePreamble
parameter_list|()
throws|throws
name|IOException
block|{
name|skipWhitespace
argument_list|()
expr_stmt|;
return|return
name|parseBracketedText
argument_list|()
return|;
block|}
DECL|method|parseEntry (String entryType)
specifier|private
name|BibEntry
name|parseEntry
parameter_list|(
name|String
name|entryType
parameter_list|)
throws|throws
name|IOException
block|{
name|BibEntry
name|result
init|=
operator|new
name|BibEntry
argument_list|(
name|entryType
argument_list|)
decl_stmt|;
name|skipWhitespace
argument_list|()
expr_stmt|;
name|consume
argument_list|(
literal|'{'
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|int
name|character
init|=
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|character
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|character
operator|!=
literal|'\r'
operator|)
condition|)
block|{
name|skipWhitespace
argument_list|()
expr_stmt|;
block|}
name|String
name|key
init|=
name|parseKey
argument_list|()
decl_stmt|;
name|result
operator|.
name|setCiteKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|skipWhitespace
argument_list|()
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|character
operator|=
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|character
operator|==
literal|'}'
operator|)
operator|||
operator|(
name|character
operator|==
literal|')'
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|character
operator|==
literal|','
condition|)
block|{
name|consume
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|skipWhitespace
argument_list|()
expr_stmt|;
name|character
operator|=
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|character
operator|==
literal|'}'
operator|)
operator|||
operator|(
name|character
operator|==
literal|')'
operator|)
condition|)
block|{
break|break;
block|}
name|parseField
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|consume
argument_list|(
literal|'}'
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
comment|// Consume new line which signals end of entry
name|skipOneNewline
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|method|parseField (BibEntry entry)
specifier|private
name|void
name|parseField
parameter_list|(
name|BibEntry
name|entry
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|key
init|=
name|parseTextToken
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
name|skipWhitespace
argument_list|()
expr_stmt|;
name|consume
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|String
name|content
init|=
name|parseFieldContent
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|content
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|entry
operator|.
name|hasField
argument_list|(
name|key
argument_list|)
condition|)
block|{
comment|// The following hack enables the parser to deal with multiple
comment|// author or
comment|// editor lines, stringing them together instead of getting just
comment|// one of them.
comment|// Multiple author or editor lines are not allowed by the bibtex
comment|// format, but
comment|// at least one online database exports bibtex like that, making
comment|// it inconvenient
comment|// for users if JabRef did not accept it.
if|if
condition|(
name|InternalBibtexFields
operator|.
name|getFieldProperties
argument_list|(
name|key
argument_list|)
operator|.
name|contains
argument_list|(
name|FieldProperty
operator|.
name|PERSON_NAMES
argument_list|)
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|key
argument_list|,
name|entry
operator|.
name|getField
argument_list|(
name|key
argument_list|)
operator|.
name|get
argument_list|()
operator|+
literal|" and "
operator|+
name|content
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FieldName
operator|.
name|KEYWORDS
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
comment|//multiple keywords fields should be combined to one
name|entry
operator|.
name|addKeyword
argument_list|(
name|content
argument_list|,
name|importFormatPreferences
operator|.
name|getKeywordSeparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|entry
operator|.
name|setField
argument_list|(
name|key
argument_list|,
name|content
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|parseFieldContent (String key)
specifier|private
name|String
name|parseFieldContent
parameter_list|(
name|String
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|skipWhitespace
argument_list|()
expr_stmt|;
name|StringBuilder
name|value
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|character
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|character
operator|=
name|peek
argument_list|()
operator|)
operator|!=
literal|','
operator|)
operator|&&
operator|(
name|character
operator|!=
literal|'}'
operator|)
operator|&&
operator|(
name|character
operator|!=
literal|')'
operator|)
condition|)
block|{
if|if
condition|(
name|eof
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|": EOF in mid-string"
argument_list|)
throw|;
block|}
if|if
condition|(
name|character
operator|==
literal|'"'
condition|)
block|{
name|StringBuilder
name|text
init|=
name|parseQuotedFieldExactly
argument_list|()
decl_stmt|;
name|value
operator|.
name|append
argument_list|(
name|fieldContentParser
operator|.
name|format
argument_list|(
name|text
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|character
operator|==
literal|'{'
condition|)
block|{
comment|// Value is a string enclosed in brackets. There can be pairs
comment|// of brackets inside of a field, so we need to count the
comment|// brackets to know when the string is finished.
name|StringBuilder
name|text
init|=
name|parseBracketedTextExactly
argument_list|()
decl_stmt|;
name|value
operator|.
name|append
argument_list|(
name|fieldContentParser
operator|.
name|format
argument_list|(
name|text
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Character
operator|.
name|isDigit
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
condition|)
block|{
comment|// value is a number
name|String
name|number
init|=
name|parseTextToken
argument_list|()
decl_stmt|;
name|value
operator|.
name|append
argument_list|(
name|number
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|character
operator|==
literal|'#'
condition|)
block|{
name|consume
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|textToken
init|=
name|parseTextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|textToken
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|" or above: "
operator|+
literal|"Empty text token.\nThis could be caused "
operator|+
literal|"by a missing comma between two fields."
argument_list|)
throw|;
block|}
name|value
operator|.
name|append
argument_list|(
literal|'#'
argument_list|)
operator|.
name|append
argument_list|(
name|textToken
argument_list|)
operator|.
name|append
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
block|}
name|skipWhitespace
argument_list|()
expr_stmt|;
block|}
return|return
name|value
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This method is used to parse string labels, field names, entry type and      * numbers outside brackets.      */
DECL|method|parseTextToken ()
specifier|private
name|String
name|parseTextToken
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuilder
name|token
init|=
operator|new
name|StringBuilder
argument_list|(
literal|20
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|character
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|character
operator|==
operator|-
literal|1
condition|)
block|{
name|eof
operator|=
literal|true
expr_stmt|;
return|return
name|token
operator|.
name|toString
argument_list|()
return|;
block|}
if|if
condition|(
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
operator|||
operator|(
literal|":-_*+./'"
operator|.
name|indexOf
argument_list|(
name|character
argument_list|)
operator|>=
literal|0
operator|)
condition|)
block|{
name|token
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unread
argument_list|(
name|character
argument_list|)
expr_stmt|;
return|return
name|token
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
comment|/**      * Tries to restore the key      *      * @return rest of key on success, otherwise empty string      * @throws IOException on Reader-Error      */
DECL|method|fixKey ()
specifier|private
name|String
name|fixKey
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuilder
name|key
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|lookaheadUsed
init|=
literal|0
decl_stmt|;
name|char
name|currentChar
decl_stmt|;
comment|// Find a char which ends key (','&&'\n') or entryfield ('='):
do|do
block|{
name|currentChar
operator|=
operator|(
name|char
operator|)
name|read
argument_list|()
expr_stmt|;
name|key
operator|.
name|append
argument_list|(
name|currentChar
argument_list|)
expr_stmt|;
name|lookaheadUsed
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|currentChar
operator|!=
literal|','
operator|)
operator|&&
operator|(
name|currentChar
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|currentChar
operator|!=
literal|'='
operator|)
operator|&&
operator|(
name|lookaheadUsed
operator|<
name|BibtexParser
operator|.
name|LOOKAHEAD
operator|)
condition|)
do|;
comment|// Consumed a char too much, back into reader and remove from key:
name|unread
argument_list|(
name|currentChar
argument_list|)
expr_stmt|;
name|key
operator|.
name|deleteCharAt
argument_list|(
name|key
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Restore if possible:
switch|switch
condition|(
name|currentChar
condition|)
block|{
case|case
literal|'='
case|:
comment|// Get entryfieldname, push it back and take rest as key
name|key
operator|=
name|key
operator|.
name|reverse
argument_list|()
expr_stmt|;
name|boolean
name|matchedAlpha
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|key
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|currentChar
operator|=
name|key
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/// Skip spaces:
if|if
condition|(
operator|!
name|matchedAlpha
operator|&&
operator|(
name|currentChar
operator|==
literal|' '
operator|)
condition|)
block|{
continue|continue;
block|}
name|matchedAlpha
operator|=
literal|true
expr_stmt|;
comment|// Begin of entryfieldname (e.g. author) -> push back:
name|unread
argument_list|(
name|currentChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|currentChar
operator|==
literal|' '
operator|)
operator|||
operator|(
name|currentChar
operator|==
literal|'\n'
operator|)
condition|)
block|{
comment|/*                      * found whitespaces, entryfieldname completed -> key in                      * keybuffer, skip whitespaces                      */
name|StringBuilder
name|newKey
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|<
name|key
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|currentChar
operator|=
name|key
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|currentChar
argument_list|)
condition|)
block|{
name|newKey
operator|.
name|append
argument_list|(
name|currentChar
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Finished, now reverse newKey and remove whitespaces:
name|parserResult
operator|.
name|addWarning
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Line %0: Found corrupted BibTeX key."
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|line
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|=
name|newKey
operator|.
name|reverse
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|','
case|:
name|parserResult
operator|.
name|addWarning
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Line %0: Found corrupted BibTeX key (contains whitespaces)."
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|line
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|parserResult
operator|.
name|addWarning
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Line %0: Found corrupted BibTeX key (comma missing)."
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|line
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// No more lookahead, give up:
name|unreadBuffer
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
return|return
name|removeWhitespaces
argument_list|(
name|key
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * returns a new<code>StringBuilder</code> which corresponds to<code>toRemove</code> without whitespaces      *      * @param toRemove      * @return      */
DECL|method|removeWhitespaces (StringBuilder toRemove)
specifier|private
name|StringBuilder
name|removeWhitespaces
parameter_list|(
name|StringBuilder
name|toRemove
parameter_list|)
block|{
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|char
name|current
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toRemove
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|current
operator|=
name|toRemove
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|current
argument_list|)
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**      * pushes buffer back into input      *      * @param stringBuilder      * @throws IOException can be thrown if buffer is bigger than LOOKAHEAD      */
DECL|method|unreadBuffer (StringBuilder stringBuilder)
specifier|private
name|void
name|unreadBuffer
parameter_list|(
name|StringBuilder
name|stringBuilder
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
name|stringBuilder
operator|.
name|length
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|unread
argument_list|(
name|stringBuilder
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This method is used to parse the bibtex key for an entry.      */
DECL|method|parseKey ()
specifier|private
name|String
name|parseKey
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuilder
name|token
init|=
operator|new
name|StringBuilder
argument_list|(
literal|20
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|character
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|character
operator|==
operator|-
literal|1
condition|)
block|{
name|eof
operator|=
literal|true
expr_stmt|;
return|return
name|token
operator|.
name|toString
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
operator|&&
operator|(
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
operator|||
operator|(
name|character
operator|==
literal|':'
operator|)
operator|||
operator|(
literal|"#{}~,=\uFFFD"
operator|.
name|indexOf
argument_list|(
name|character
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|token
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
condition|)
block|{
comment|// We have encountered white space instead of the comma at
comment|// the end of
comment|// the key. Possibly the comma is missing, so we try to
comment|// return what we
comment|// have found, as the key and try to restore the rest in fixKey().
return|return
name|token
operator|+
name|fixKey
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|character
operator|==
literal|','
operator|)
operator|||
operator|(
name|character
operator|==
literal|'}'
operator|)
condition|)
block|{
name|unread
argument_list|(
name|character
argument_list|)
expr_stmt|;
return|return
name|token
operator|.
name|toString
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|character
operator|==
literal|'='
condition|)
block|{
comment|// If we find a '=' sign, it is either an error, or
comment|// the entry lacked a comma signifying the end of the key.
return|return
name|token
operator|.
name|toString
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|":"
operator|+
literal|"Character '"
operator|+
operator|(
name|char
operator|)
name|character
operator|+
literal|"' is not "
operator|+
literal|"allowed in bibtex keys."
argument_list|)
throw|;
block|}
block|}
block|}
block|}
DECL|method|parseBracketedText ()
specifier|private
name|String
name|parseBracketedText
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuilder
name|value
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|consume
argument_list|(
literal|'{'
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|int
name|brackets
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|isClosingBracketNext
argument_list|()
operator|)
operator|&&
operator|(
name|brackets
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|int
name|character
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|isEOFCharacter
argument_list|(
name|character
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|": EOF in mid-string"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|(
name|character
operator|==
literal|'{'
operator|)
operator|||
operator|(
name|character
operator|==
literal|'('
operator|)
condition|)
block|{
name|brackets
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|character
operator|==
literal|'}'
operator|)
operator|||
operator|(
name|character
operator|==
literal|')'
operator|)
condition|)
block|{
name|brackets
operator|--
expr_stmt|;
block|}
comment|// If we encounter whitespace of any kind, read it as a
comment|// simple space, and ignore any others that follow immediately.
comment|/*              * if (j == '\n') { if (peek() == '\n') value.append('\n'); } else              */
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
condition|)
block|{
name|String
name|whitespacesReduced
init|=
name|skipAndRecordWhitespace
argument_list|(
name|character
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|whitespacesReduced
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
operator|!
literal|"\n\t"
operator|.
name|equals
argument_list|(
name|whitespacesReduced
argument_list|)
condition|)
block|{
comment|//&&
name|whitespacesReduced
operator|=
name|whitespacesReduced
operator|.
name|replace
argument_list|(
literal|"\t"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|// Remove tabulators.
name|value
operator|.
name|append
argument_list|(
name|whitespacesReduced
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|value
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
expr_stmt|;
block|}
block|}
name|consume
argument_list|(
literal|'}'
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
return|return
name|value
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|isClosingBracketNext ()
specifier|private
name|boolean
name|isClosingBracketNext
parameter_list|()
block|{
try|try
block|{
name|int
name|peek
init|=
name|peek
argument_list|()
decl_stmt|;
name|boolean
name|isCurlyBracket
init|=
name|peek
operator|==
literal|'}'
decl_stmt|;
name|boolean
name|isRoundBracket
init|=
name|peek
operator|==
literal|')'
decl_stmt|;
return|return
name|isCurlyBracket
operator|||
name|isRoundBracket
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|method|parseBracketedTextExactly ()
specifier|private
name|StringBuilder
name|parseBracketedTextExactly
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuilder
name|value
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|consume
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|int
name|brackets
init|=
literal|0
decl_stmt|;
name|char
name|character
decl_stmt|;
name|char
name|lastCharacter
init|=
literal|'\0'
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|character
operator|=
operator|(
name|char
operator|)
name|read
argument_list|()
expr_stmt|;
name|boolean
name|isClosingBracket
init|=
operator|(
name|character
operator|==
literal|'}'
operator|)
operator|&&
operator|(
name|lastCharacter
operator|!=
literal|'\\'
operator|)
decl_stmt|;
if|if
condition|(
name|isClosingBracket
operator|&&
operator|(
name|brackets
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|isEOFCharacter
argument_list|(
name|character
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|": EOF in mid-string"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|(
name|character
operator|==
literal|'{'
operator|)
operator|&&
operator|(
operator|!
name|isEscapeSymbol
argument_list|(
name|lastCharacter
argument_list|)
operator|)
condition|)
block|{
name|brackets
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isClosingBracket
condition|)
block|{
name|brackets
operator|--
expr_stmt|;
block|}
name|value
operator|.
name|append
argument_list|(
name|character
argument_list|)
expr_stmt|;
name|lastCharacter
operator|=
name|character
expr_stmt|;
block|}
block|}
DECL|method|isEscapeSymbol (char character)
specifier|private
name|boolean
name|isEscapeSymbol
parameter_list|(
name|char
name|character
parameter_list|)
block|{
return|return
literal|'\\'
operator|==
name|character
return|;
block|}
DECL|method|parseQuotedFieldExactly ()
specifier|private
name|StringBuilder
name|parseQuotedFieldExactly
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuilder
name|value
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|consume
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|int
name|brackets
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|peek
argument_list|()
operator|==
literal|'"'
operator|)
operator|&&
operator|(
name|brackets
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|int
name|j
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|isEOFCharacter
argument_list|(
name|j
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|": EOF in mid-string"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|j
operator|==
literal|'{'
condition|)
block|{
name|brackets
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|==
literal|'}'
condition|)
block|{
name|brackets
operator|--
expr_stmt|;
block|}
name|value
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|j
argument_list|)
expr_stmt|;
block|}
name|consume
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
DECL|method|consume (char expected)
specifier|private
name|void
name|consume
parameter_list|(
name|char
name|expected
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|character
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|character
operator|!=
name|expected
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|": Expected "
operator|+
name|expected
operator|+
literal|" but received "
operator|+
operator|(
name|char
operator|)
name|character
argument_list|)
throw|;
block|}
block|}
DECL|method|consumeUncritically (char expected)
specifier|private
name|boolean
name|consumeUncritically
parameter_list|(
name|char
name|expected
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|character
decl_stmt|;
do|do
block|{
name|character
operator|=
name|read
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|character
operator|!=
name|expected
operator|)
operator|&&
operator|(
name|character
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|character
operator|!=
literal|65535
operator|)
condition|)
do|;
if|if
condition|(
name|isEOFCharacter
argument_list|(
name|character
argument_list|)
condition|)
block|{
name|eof
operator|=
literal|true
expr_stmt|;
block|}
comment|// Return true if we actually found the character we were looking for:
return|return
name|character
operator|==
name|expected
return|;
block|}
DECL|method|consume (char firstOption, char secondOption)
specifier|private
name|void
name|consume
parameter_list|(
name|char
name|firstOption
parameter_list|,
name|char
name|secondOption
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Consumes one of the two, doesn't care which appears.
name|int
name|character
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|character
operator|!=
name|firstOption
operator|)
operator|&&
operator|(
name|character
operator|!=
name|secondOption
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|": Expected "
operator|+
name|firstOption
operator|+
literal|" or "
operator|+
name|secondOption
operator|+
literal|" but received "
operator|+
operator|(
name|char
operator|)
name|character
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

