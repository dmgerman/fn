begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.jabref.logic.openoffice
package|package
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|openoffice
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|layout
operator|.
name|Layout
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|layout
operator|.
name|LayoutFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|layout
operator|.
name|LayoutFormatterPreferences
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|layout
operator|.
name|LayoutHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|Author
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|AuthorList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|BibEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|FieldName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|strings
operator|.
name|StringUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * This class embodies a bibliography formatting for OpenOffice, which is composed  * of the following elements:  *<p>  * 1) Each OO BIB entry type must have a formatting. A formatting is an array of elements, each  * of which is either a piece of constant text, an entry field value, or a tab. Each element has  * a character format associated with it.  *<p>  * 2) Many field values (e.g. author) need to be formatted before input to OpenOffice. The style  * has the responsibility of formatting all field values. Formatting is handled by 0-n  * JabRef LayoutFormatter classes.  *<p>  * 3) If the entries are not numbered, a citation marker must be produced for each entry. This  * operation is performed for each JabRef BibEntry.  */
end_comment

begin_class
DECL|class|OOBibStyle
specifier|public
class|class
name|OOBibStyle
implements|implements
name|Comparable
argument_list|<
name|OOBibStyle
argument_list|>
block|{
DECL|field|ITALIC_ET_AL
specifier|public
specifier|static
specifier|final
name|String
name|ITALIC_ET_AL
init|=
literal|"ItalicEtAl"
decl_stmt|;
DECL|field|MULTI_CITE_CHRONOLOGICAL
specifier|public
specifier|static
specifier|final
name|String
name|MULTI_CITE_CHRONOLOGICAL
init|=
literal|"MultiCiteChronological"
decl_stmt|;
DECL|field|MINIMUM_GROUPING_COUNT
specifier|public
specifier|static
specifier|final
name|String
name|MINIMUM_GROUPING_COUNT
init|=
literal|"MinimumGroupingCount"
decl_stmt|;
DECL|field|ET_AL_STRING
specifier|public
specifier|static
specifier|final
name|String
name|ET_AL_STRING
init|=
literal|"EtAlString"
decl_stmt|;
DECL|field|MAX_AUTHORS_FIRST
specifier|public
specifier|static
specifier|final
name|String
name|MAX_AUTHORS_FIRST
init|=
literal|"MaxAuthorsFirst"
decl_stmt|;
DECL|field|REFERENCE_HEADER_PARAGRAPH_FORMAT
specifier|public
specifier|static
specifier|final
name|String
name|REFERENCE_HEADER_PARAGRAPH_FORMAT
init|=
literal|"ReferenceHeaderParagraphFormat"
decl_stmt|;
DECL|field|REFERENCE_PARAGRAPH_FORMAT
specifier|public
specifier|static
specifier|final
name|String
name|REFERENCE_PARAGRAPH_FORMAT
init|=
literal|"ReferenceParagraphFormat"
decl_stmt|;
DECL|field|TITLE
specifier|public
specifier|static
specifier|final
name|String
name|TITLE
init|=
literal|"Title"
decl_stmt|;
DECL|field|UNDEFINED_CITATION_MARKER
specifier|public
specifier|static
specifier|final
name|String
name|UNDEFINED_CITATION_MARKER
init|=
literal|"??"
decl_stmt|;
DECL|field|NUM_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|NUM_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"-?\\d+"
argument_list|)
decl_stmt|;
DECL|field|LAYOUT_MRK
specifier|private
specifier|static
specifier|final
name|String
name|LAYOUT_MRK
init|=
literal|"LAYOUT"
decl_stmt|;
DECL|field|PROPERTIES_MARK
specifier|private
specifier|static
specifier|final
name|String
name|PROPERTIES_MARK
init|=
literal|"PROPERTIES"
decl_stmt|;
DECL|field|CITATION_MARK
specifier|private
specifier|static
specifier|final
name|String
name|CITATION_MARK
init|=
literal|"CITATION"
decl_stmt|;
DECL|field|NAME_MARK
specifier|private
specifier|static
specifier|final
name|String
name|NAME_MARK
init|=
literal|"NAME"
decl_stmt|;
DECL|field|JOURNALS_MARK
specifier|private
specifier|static
specifier|final
name|String
name|JOURNALS_MARK
init|=
literal|"JOURNALS"
decl_stmt|;
DECL|field|DEFAULT_MARK
specifier|private
specifier|static
specifier|final
name|String
name|DEFAULT_MARK
init|=
literal|"default"
decl_stmt|;
DECL|field|BRACKET_AFTER_IN_LIST
specifier|private
specifier|static
specifier|final
name|String
name|BRACKET_AFTER_IN_LIST
init|=
literal|"BracketAfterInList"
decl_stmt|;
DECL|field|BRACKET_BEFORE_IN_LIST
specifier|private
specifier|static
specifier|final
name|String
name|BRACKET_BEFORE_IN_LIST
init|=
literal|"BracketBeforeInList"
decl_stmt|;
DECL|field|UNIQUEFIER_SEPARATOR
specifier|private
specifier|static
specifier|final
name|String
name|UNIQUEFIER_SEPARATOR
init|=
literal|"UniquefierSeparator"
decl_stmt|;
DECL|field|BIBTEX_KEY_CITATIONS
specifier|private
specifier|static
specifier|final
name|String
name|BIBTEX_KEY_CITATIONS
init|=
literal|"BibTeXKeyCitations"
decl_stmt|;
DECL|field|SUBSCRIPT_CITATIONS
specifier|private
specifier|static
specifier|final
name|String
name|SUBSCRIPT_CITATIONS
init|=
literal|"SubscriptCitations"
decl_stmt|;
DECL|field|SUPERSCRIPT_CITATIONS
specifier|private
specifier|static
specifier|final
name|String
name|SUPERSCRIPT_CITATIONS
init|=
literal|"SuperscriptCitations"
decl_stmt|;
DECL|field|BOLD_CITATIONS
specifier|private
specifier|static
specifier|final
name|String
name|BOLD_CITATIONS
init|=
literal|"BoldCitations"
decl_stmt|;
DECL|field|ITALIC_CITATIONS
specifier|private
specifier|static
specifier|final
name|String
name|ITALIC_CITATIONS
init|=
literal|"ItalicCitations"
decl_stmt|;
DECL|field|CITATION_CHARACTER_FORMAT
specifier|private
specifier|static
specifier|final
name|String
name|CITATION_CHARACTER_FORMAT
init|=
literal|"CitationCharacterFormat"
decl_stmt|;
DECL|field|FORMAT_CITATIONS
specifier|private
specifier|static
specifier|final
name|String
name|FORMAT_CITATIONS
init|=
literal|"FormatCitations"
decl_stmt|;
DECL|field|GROUPED_NUMBERS_SEPARATOR
specifier|private
specifier|static
specifier|final
name|String
name|GROUPED_NUMBERS_SEPARATOR
init|=
literal|"GroupedNumbersSeparator"
decl_stmt|;
DECL|field|PAGE_INFO_SEPARATOR
specifier|private
specifier|static
specifier|final
name|String
name|PAGE_INFO_SEPARATOR
init|=
literal|"PageInfoSeparator"
decl_stmt|;
DECL|field|CITATION_SEPARATOR
specifier|private
specifier|static
specifier|final
name|String
name|CITATION_SEPARATOR
init|=
literal|"CitationSeparator"
decl_stmt|;
DECL|field|IN_TEXT_YEAR_SEPARATOR
specifier|private
specifier|static
specifier|final
name|String
name|IN_TEXT_YEAR_SEPARATOR
init|=
literal|"InTextYearSeparator"
decl_stmt|;
DECL|field|MAX_AUTHORS
specifier|private
specifier|static
specifier|final
name|String
name|MAX_AUTHORS
init|=
literal|"MaxAuthors"
decl_stmt|;
DECL|field|YEAR_FIELD
specifier|private
specifier|static
specifier|final
name|String
name|YEAR_FIELD
init|=
literal|"YearField"
decl_stmt|;
DECL|field|AUTHOR_FIELD
specifier|private
specifier|static
specifier|final
name|String
name|AUTHOR_FIELD
init|=
literal|"AuthorField"
decl_stmt|;
DECL|field|BRACKET_AFTER
specifier|private
specifier|static
specifier|final
name|String
name|BRACKET_AFTER
init|=
literal|"BracketAfter"
decl_stmt|;
DECL|field|BRACKET_BEFORE
specifier|private
specifier|static
specifier|final
name|String
name|BRACKET_BEFORE
init|=
literal|"BracketBefore"
decl_stmt|;
DECL|field|IS_NUMBER_ENTRIES
specifier|private
specifier|static
specifier|final
name|String
name|IS_NUMBER_ENTRIES
init|=
literal|"IsNumberEntries"
decl_stmt|;
DECL|field|IS_SORT_BY_POSITION
specifier|private
specifier|static
specifier|final
name|String
name|IS_SORT_BY_POSITION
init|=
literal|"IsSortByPosition"
decl_stmt|;
DECL|field|SORT_ALGORITHM
specifier|private
specifier|static
specifier|final
name|String
name|SORT_ALGORITHM
init|=
literal|"SortAlgorithm"
decl_stmt|;
DECL|field|OXFORD_COMMA
specifier|private
specifier|static
specifier|final
name|String
name|OXFORD_COMMA
init|=
literal|"OxfordComma"
decl_stmt|;
DECL|field|YEAR_SEPARATOR
specifier|private
specifier|static
specifier|final
name|String
name|YEAR_SEPARATOR
init|=
literal|"YearSeparator"
decl_stmt|;
DECL|field|AUTHOR_LAST_SEPARATOR_IN_TEXT
specifier|private
specifier|static
specifier|final
name|String
name|AUTHOR_LAST_SEPARATOR_IN_TEXT
init|=
literal|"AuthorLastSeparatorInText"
decl_stmt|;
DECL|field|AUTHOR_LAST_SEPARATOR
specifier|private
specifier|static
specifier|final
name|String
name|AUTHOR_LAST_SEPARATOR
init|=
literal|"AuthorLastSeparator"
decl_stmt|;
DECL|field|AUTHOR_SEPARATOR
specifier|private
specifier|static
specifier|final
name|String
name|AUTHOR_SEPARATOR
init|=
literal|"AuthorSeparator"
decl_stmt|;
DECL|field|QUOTED
specifier|private
specifier|static
specifier|final
name|Pattern
name|QUOTED
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\".*\""
argument_list|)
decl_stmt|;
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|OOBibStyle
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|name
specifier|private
name|String
name|name
init|=
literal|""
decl_stmt|;
DECL|field|journals
specifier|private
specifier|final
name|SortedSet
argument_list|<
name|String
argument_list|>
name|journals
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Formatter to be run on fields before they are used as part of citation marker:
DECL|field|fieldFormatter
specifier|private
specifier|final
name|LayoutFormatter
name|fieldFormatter
init|=
operator|new
name|OOPreFormatter
argument_list|()
decl_stmt|;
DECL|field|defaultBibLayout
specifier|private
name|Layout
name|defaultBibLayout
decl_stmt|;
comment|// reference layout mapped from entry type number:
DECL|field|bibLayout
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Layout
argument_list|>
name|bibLayout
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|properties
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|properties
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|citProperties
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|citProperties
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|valid
specifier|private
name|boolean
name|valid
decl_stmt|;
DECL|field|fromResource
specifier|private
specifier|final
name|boolean
name|fromResource
decl_stmt|;
DECL|field|path
specifier|private
specifier|final
name|String
name|path
decl_stmt|;
DECL|enum|BibStyleMode
enum|enum
name|BibStyleMode
block|{
DECL|enumConstant|NONE
name|NONE
block|,
DECL|enumConstant|LAYOUT
name|LAYOUT
block|,
DECL|enumConstant|PROPERTIES
name|PROPERTIES
block|,
DECL|enumConstant|CITATION
name|CITATION
block|,
DECL|enumConstant|NAME
name|NAME
block|,
DECL|enumConstant|JOURNALS
name|JOURNALS
block|}
DECL|field|styleFile
specifier|private
name|File
name|styleFile
decl_stmt|;
DECL|field|encoding
specifier|private
specifier|final
name|Charset
name|encoding
decl_stmt|;
DECL|field|styleFileModificationTime
specifier|private
name|long
name|styleFileModificationTime
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
DECL|field|localCopy
specifier|private
name|String
name|localCopy
decl_stmt|;
DECL|field|prefs
specifier|private
specifier|final
name|LayoutFormatterPreferences
name|prefs
decl_stmt|;
DECL|method|OOBibStyle (File styleFile, LayoutFormatterPreferences prefs, Charset encoding)
specifier|public
name|OOBibStyle
parameter_list|(
name|File
name|styleFile
parameter_list|,
name|LayoutFormatterPreferences
name|prefs
parameter_list|,
name|Charset
name|encoding
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|prefs
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|prefs
argument_list|)
expr_stmt|;
name|this
operator|.
name|styleFile
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|styleFile
argument_list|)
expr_stmt|;
name|this
operator|.
name|encoding
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
name|setDefaultProperties
argument_list|()
expr_stmt|;
name|reload
argument_list|()
expr_stmt|;
name|fromResource
operator|=
literal|false
expr_stmt|;
name|path
operator|=
name|styleFile
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
DECL|method|OOBibStyle (String resourcePath, LayoutFormatterPreferences prefs)
specifier|public
name|OOBibStyle
parameter_list|(
name|String
name|resourcePath
parameter_list|,
name|LayoutFormatterPreferences
name|prefs
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|prefs
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|prefs
argument_list|)
expr_stmt|;
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|resourcePath
argument_list|)
expr_stmt|;
name|this
operator|.
name|encoding
operator|=
name|StandardCharsets
operator|.
name|UTF_8
expr_stmt|;
name|setDefaultProperties
argument_list|()
expr_stmt|;
name|initialize
argument_list|(
name|OOBibStyle
operator|.
name|class
operator|.
name|getResourceAsStream
argument_list|(
name|resourcePath
argument_list|)
argument_list|)
expr_stmt|;
name|fromResource
operator|=
literal|true
expr_stmt|;
name|path
operator|=
name|resourcePath
expr_stmt|;
block|}
DECL|method|setDefaultProperties ()
specifier|private
name|void
name|setDefaultProperties
parameter_list|()
block|{
comment|// Set default property values:
name|properties
operator|.
name|put
argument_list|(
name|TITLE
argument_list|,
literal|"Bibliography"
argument_list|)
expr_stmt|;
name|properties
operator|.
name|put
argument_list|(
name|SORT_ALGORITHM
argument_list|,
literal|"alphanumeric"
argument_list|)
expr_stmt|;
name|properties
operator|.
name|put
argument_list|(
name|IS_SORT_BY_POSITION
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|properties
operator|.
name|put
argument_list|(
name|IS_NUMBER_ENTRIES
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|properties
operator|.
name|put
argument_list|(
name|BRACKET_BEFORE
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
name|properties
operator|.
name|put
argument_list|(
name|BRACKET_AFTER
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
name|properties
operator|.
name|put
argument_list|(
name|REFERENCE_PARAGRAPH_FORMAT
argument_list|,
literal|"Default"
argument_list|)
expr_stmt|;
name|properties
operator|.
name|put
argument_list|(
name|REFERENCE_HEADER_PARAGRAPH_FORMAT
argument_list|,
literal|"Heading 1"
argument_list|)
expr_stmt|;
comment|// Set default properties for the citation marker:
name|citProperties
operator|.
name|put
argument_list|(
name|AUTHOR_FIELD
argument_list|,
name|FieldName
operator|.
name|orFields
argument_list|(
name|FieldName
operator|.
name|AUTHOR
argument_list|,
name|FieldName
operator|.
name|EDITOR
argument_list|)
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|YEAR_FIELD
argument_list|,
name|FieldName
operator|.
name|YEAR
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|MAX_AUTHORS
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|MAX_AUTHORS_FIRST
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|AUTHOR_SEPARATOR
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|AUTHOR_LAST_SEPARATOR
argument_list|,
literal|"& "
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|AUTHOR_LAST_SEPARATOR_IN_TEXT
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|ET_AL_STRING
argument_list|,
literal|" et al."
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|YEAR_SEPARATOR
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|IN_TEXT_YEAR_SEPARATOR
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|BRACKET_BEFORE
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|BRACKET_AFTER
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|CITATION_SEPARATOR
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|PAGE_INFO_SEPARATOR
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|GROUPED_NUMBERS_SEPARATOR
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|MINIMUM_GROUPING_COUNT
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|FORMAT_CITATIONS
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|CITATION_CHARACTER_FORMAT
argument_list|,
literal|"Default"
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|ITALIC_CITATIONS
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|BOLD_CITATIONS
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|SUPERSCRIPT_CITATIONS
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|SUBSCRIPT_CITATIONS
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|MULTI_CITE_CHRONOLOGICAL
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|BIBTEX_KEY_CITATIONS
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|ITALIC_ET_AL
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
name|OXFORD_COMMA
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|method|getPath ()
specifier|public
name|String
name|getPath
parameter_list|()
block|{
return|return
name|path
return|;
block|}
DECL|method|getFile ()
specifier|public
name|File
name|getFile
parameter_list|()
block|{
return|return
name|styleFile
return|;
block|}
DECL|method|getJournals ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getJournals
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|journals
argument_list|)
return|;
block|}
DECL|method|initialize (InputStream stream)
specifier|private
name|void
name|initialize
parameter_list|(
name|InputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|stream
argument_list|)
expr_stmt|;
try|try
init|(
name|Reader
name|reader
init|=
operator|new
name|InputStreamReader
argument_list|(
name|stream
argument_list|,
name|encoding
argument_list|)
init|)
block|{
name|readFormatFile
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * If this style was initialized from a file on disk, reload the style      * if the file has been modified since it was read.      *      * @throws IOException      */
DECL|method|ensureUpToDate ()
specifier|public
name|void
name|ensureUpToDate
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isUpToDate
argument_list|()
condition|)
block|{
name|reload
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * If this style was initialized from a file on disk, reload the style      * information.      *      * @throws IOException      */
DECL|method|reload ()
specifier|private
name|void
name|reload
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|styleFile
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|styleFileModificationTime
operator|=
name|styleFile
operator|.
name|lastModified
argument_list|()
expr_stmt|;
try|try
init|(
name|InputStream
name|stream
init|=
operator|new
name|FileInputStream
argument_list|(
name|styleFile
argument_list|)
init|)
block|{
name|initialize
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * If this style was initialized from a file on disk, check whether the file      * is unmodified since initialization.      *      * @return true if the file has not been modified, false otherwise.      */
DECL|method|isUpToDate ()
specifier|private
name|boolean
name|isUpToDate
parameter_list|()
block|{
if|if
condition|(
name|styleFile
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
name|styleFile
operator|.
name|lastModified
argument_list|()
operator|==
name|this
operator|.
name|styleFileModificationTime
return|;
block|}
block|}
DECL|method|readFormatFile (Reader in)
specifier|private
name|void
name|readFormatFile
parameter_list|(
name|Reader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|// First read all the contents of the file:
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|in
operator|.
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
comment|// Store a local copy for viewing
name|localCopy
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
comment|// Break into separate lines:
name|String
index|[]
name|lines
init|=
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|"\n"
argument_list|)
decl_stmt|;
name|BibStyleMode
name|mode
init|=
name|BibStyleMode
operator|.
name|NONE
decl_stmt|;
for|for
control|(
name|String
name|line1
range|:
name|lines
control|)
block|{
name|String
name|line
init|=
name|line1
decl_stmt|;
if|if
condition|(
operator|!
name|line
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|line
operator|.
name|charAt
argument_list|(
name|line
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'\r'
operator|)
condition|)
block|{
name|line
operator|=
name|line
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|line
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Check for empty line or comment:
if|if
condition|(
name|line
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|(
name|line
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'#'
operator|)
condition|)
block|{
continue|continue;
block|}
comment|// Check if we should change mode:
switch|switch
condition|(
name|line
condition|)
block|{
case|case
name|NAME_MARK
case|:
name|mode
operator|=
name|BibStyleMode
operator|.
name|NAME
expr_stmt|;
continue|continue;
case|case
name|LAYOUT_MRK
case|:
name|mode
operator|=
name|BibStyleMode
operator|.
name|LAYOUT
expr_stmt|;
continue|continue;
case|case
name|PROPERTIES_MARK
case|:
name|mode
operator|=
name|BibStyleMode
operator|.
name|PROPERTIES
expr_stmt|;
continue|continue;
case|case
name|CITATION_MARK
case|:
name|mode
operator|=
name|BibStyleMode
operator|.
name|CITATION
expr_stmt|;
continue|continue;
case|case
name|JOURNALS_MARK
case|:
name|mode
operator|=
name|BibStyleMode
operator|.
name|JOURNALS
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|NAME
case|:
if|if
condition|(
operator|!
name|line
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|name
operator|=
name|line
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|LAYOUT
case|:
name|handleStructureLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROPERTIES
case|:
name|handlePropertiesLine
argument_list|(
name|line
argument_list|,
name|properties
argument_list|)
expr_stmt|;
break|break;
case|case
name|CITATION
case|:
name|handlePropertiesLine
argument_list|(
name|line
argument_list|,
name|citProperties
argument_list|)
expr_stmt|;
break|break;
case|case
name|JOURNALS
case|:
name|handleJournalsLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|// Set validity boolean based on whether we found anything interesting
comment|// in the file:
if|if
condition|(
name|mode
operator|!=
name|BibStyleMode
operator|.
name|NONE
condition|)
block|{
name|valid
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**      * After initializing this style from a file, this method can be used to check      * whether the file appeared to be a proper style file.      *      * @return true if the file could be parsed as a style file, false otherwise.      */
DECL|method|isValid ()
specifier|public
name|boolean
name|isValid
parameter_list|()
block|{
return|return
name|valid
return|;
block|}
comment|/**      * Parse a line providing bibliography structure information for an entry type.      *      * @param line The string containing the structure description.      * @throws IOException      */
DECL|method|handleStructureLine (String line)
specifier|private
name|void
name|handleStructureLine
parameter_list|(
name|String
name|line
parameter_list|)
block|{
name|int
name|index
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|index
operator|>
literal|0
operator|)
operator|&&
operator|(
name|index
operator|<
operator|(
name|line
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|String
name|formatString
init|=
name|line
operator|.
name|substring
argument_list|(
name|index
operator|+
literal|1
argument_list|)
decl_stmt|;
name|boolean
name|setDefault
init|=
name|line
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
operator|.
name|equals
argument_list|(
name|OOBibStyle
operator|.
name|DEFAULT_MARK
argument_list|)
decl_stmt|;
name|String
name|type
init|=
name|line
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
decl_stmt|;
try|try
block|{
name|Layout
name|layout
init|=
operator|new
name|LayoutHelper
argument_list|(
operator|new
name|StringReader
argument_list|(
name|formatString
argument_list|)
argument_list|,
name|this
operator|.
name|prefs
argument_list|)
operator|.
name|getLayoutFromText
argument_list|()
decl_stmt|;
if|if
condition|(
name|setDefault
condition|)
block|{
name|defaultBibLayout
operator|=
name|layout
expr_stmt|;
block|}
else|else
block|{
name|bibLayout
operator|.
name|put
argument_list|(
name|type
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
argument_list|,
name|layout
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Cannot parse bibliography structure"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Parse a line providing a property name and value.      *      * @param line The line containing the formatter names.      * @throws IOException      */
DECL|method|handlePropertiesLine (String line, Map<String, Object> map)
specifier|private
name|void
name|handlePropertiesLine
parameter_list|(
name|String
name|line
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
parameter_list|)
block|{
name|int
name|index
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|index
operator|>
literal|0
operator|)
operator|&&
operator|(
name|index
operator|<=
operator|(
name|line
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|String
name|propertyName
init|=
name|line
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
name|value
init|=
name|line
operator|.
name|substring
argument_list|(
name|index
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|value
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|)
operator|&&
name|QUOTED
operator|.
name|matcher
argument_list|(
name|value
operator|.
name|trim
argument_list|()
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|value
operator|=
name|value
operator|.
name|trim
argument_list|()
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|value
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|Object
name|toSet
init|=
name|value
decl_stmt|;
if|if
condition|(
name|NUM_PATTERN
operator|.
name|matcher
argument_list|(
name|value
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|toSet
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"true"
operator|.
name|equalsIgnoreCase
argument_list|(
name|value
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
block|{
name|toSet
operator|=
name|Boolean
operator|.
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"false"
operator|.
name|equalsIgnoreCase
argument_list|(
name|value
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
block|{
name|toSet
operator|=
name|Boolean
operator|.
name|FALSE
expr_stmt|;
block|}
name|map
operator|.
name|put
argument_list|(
name|propertyName
argument_list|,
name|toSet
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Parse a line providing a journal name for which this style is valid.      *      * @param line      * @throws IOException      */
DECL|method|handleJournalsLine (String line)
specifier|private
name|void
name|handleJournalsLine
parameter_list|(
name|String
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|line
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|journals
operator|.
name|add
argument_list|(
name|line
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getReferenceFormat (String type)
specifier|public
name|Layout
name|getReferenceFormat
parameter_list|(
name|String
name|type
parameter_list|)
block|{
name|Layout
name|l
init|=
name|bibLayout
operator|.
name|get
argument_list|(
name|type
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|==
literal|null
condition|)
block|{
return|return
name|defaultBibLayout
return|;
block|}
else|else
block|{
return|return
name|l
return|;
block|}
block|}
comment|/**      * Format a number-based citation marker for the given number.      *      * @param number The citation numbers.      * @return The text for the citation.      */
DECL|method|getNumCitationMarker (List<Integer> number, int minGroupingCount, boolean inList)
specifier|public
name|String
name|getNumCitationMarker
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|number
parameter_list|,
name|int
name|minGroupingCount
parameter_list|,
name|boolean
name|inList
parameter_list|)
block|{
name|String
name|bracketBefore
init|=
name|getStringCitProperty
argument_list|(
name|BRACKET_BEFORE
argument_list|)
decl_stmt|;
if|if
condition|(
name|inList
operator|&&
operator|(
name|citProperties
operator|.
name|containsKey
argument_list|(
name|BRACKET_BEFORE_IN_LIST
argument_list|)
operator|)
condition|)
block|{
name|bracketBefore
operator|=
name|getStringCitProperty
argument_list|(
name|BRACKET_BEFORE_IN_LIST
argument_list|)
expr_stmt|;
block|}
name|String
name|bracketAfter
init|=
name|getStringCitProperty
argument_list|(
name|BRACKET_AFTER
argument_list|)
decl_stmt|;
if|if
condition|(
name|inList
operator|&&
operator|(
name|citProperties
operator|.
name|containsKey
argument_list|(
name|BRACKET_AFTER_IN_LIST
argument_list|)
operator|)
condition|)
block|{
name|bracketAfter
operator|=
name|getStringCitProperty
argument_list|(
name|BRACKET_AFTER_IN_LIST
argument_list|)
expr_stmt|;
block|}
comment|// Sort the numbers:
name|List
argument_list|<
name|Integer
argument_list|>
name|lNum
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|number
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|lNum
argument_list|)
expr_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|bracketBefore
argument_list|)
decl_stmt|;
name|int
name|combineFrom
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|written
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lNum
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|i1
init|=
name|lNum
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|combineFrom
operator|<
literal|0
condition|)
block|{
comment|// Check if next entry is the next in the ref list:
if|if
condition|(
operator|(
name|i
operator|<
operator|(
name|lNum
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|lNum
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
operator|(
name|i1
operator|+
literal|1
operator|)
operator|)
operator|&&
operator|(
name|i1
operator|>
literal|0
operator|)
condition|)
block|{
name|combineFrom
operator|=
name|i1
expr_stmt|;
block|}
else|else
block|{
comment|// Add single entry:
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|getStringCitProperty
argument_list|(
name|CITATION_SEPARATOR
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|lNum
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|>
literal|0
condition|?
name|String
operator|.
name|valueOf
argument_list|(
name|lNum
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
else|:
name|OOBibStyle
operator|.
name|UNDEFINED_CITATION_MARKER
argument_list|)
expr_stmt|;
name|written
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// We are building a list of combined entries.
comment|// Check if it ends here:
if|if
condition|(
operator|(
name|i
operator|==
operator|(
name|lNum
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|lNum
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|!=
operator|(
name|i1
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|written
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|getStringCitProperty
argument_list|(
name|CITATION_SEPARATOR
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|minGroupingCount
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|i1
operator|+
literal|1
operator|)
operator|-
name|combineFrom
operator|)
operator|>=
name|minGroupingCount
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|combineFrom
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getStringCitProperty
argument_list|(
name|GROUPED_NUMBERS_SEPARATOR
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|i1
argument_list|)
expr_stmt|;
name|written
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// Either we should never group, or there aren't enough
comment|// entries in this case to group. Output all:
for|for
control|(
name|int
name|jj
init|=
name|combineFrom
init|;
name|jj
operator|<=
name|i1
condition|;
name|jj
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|jj
argument_list|)
expr_stmt|;
if|if
condition|(
name|jj
operator|<
name|i1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|getStringCitProperty
argument_list|(
name|CITATION_SEPARATOR
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|written
operator|++
expr_stmt|;
block|}
block|}
name|combineFrom
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|// If it doesn't end here, just keep iterating.
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
name|bracketAfter
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Format the marker for the in-text citation according to this BIB style. Uniquefier letters are added as      * provided by the uniquefiers argument. If successive entries within the citation are uniquefied from each other,      * this method will perform a grouping of these entries.      *      * @param entries       The list of JabRef BibEntry providing the data.      * @param database      A map of BibEntry-BibDatabase pairs.      * @param inParenthesis Signals whether a parenthesized citation or an in-text citation is wanted.      * @param uniquefiers   Strings to add behind the year for each entry in case it's needed to separate similar      *                      entries.      * @param unlimAuthors  Boolean for each entry. If true, we should not use "et al" formatting regardless      *                      of the number of authors. Can be null to indicate that no entries should have unlimited names.      * @return The formatted citation.      */
DECL|method|getCitationMarker (List<BibEntry> entries, Map<BibEntry, BibDatabase> database, boolean inParenthesis, String[] uniquefiers, int[] unlimAuthors)
specifier|public
name|String
name|getCitationMarker
parameter_list|(
name|List
argument_list|<
name|BibEntry
argument_list|>
name|entries
parameter_list|,
name|Map
argument_list|<
name|BibEntry
argument_list|,
name|BibDatabase
argument_list|>
name|database
parameter_list|,
name|boolean
name|inParenthesis
parameter_list|,
name|String
index|[]
name|uniquefiers
parameter_list|,
name|int
index|[]
name|unlimAuthors
parameter_list|)
block|{
comment|// Look for groups of uniquefied entries that should be combined in the output.
comment|// E.g. (Olsen, 2005a, b) should be output instead of (Olsen, 2005a; Olsen, 2005b).
name|int
name|piv
init|=
operator|-
literal|1
decl_stmt|;
name|String
name|tmpMarker
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|uniquefiers
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|uniquefiers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|uniquefiers
index|[
name|i
index|]
operator|==
literal|null
operator|)
operator|||
name|uniquefiers
index|[
name|i
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// This entry has no uniquefier.
comment|// Check if we just passed a group of more than one entry with uniquefier:
if|if
condition|(
operator|(
name|piv
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|(
name|i
operator|>
operator|(
name|piv
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
comment|// Do the grouping:
name|group
argument_list|(
name|entries
argument_list|,
name|uniquefiers
argument_list|,
name|piv
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|piv
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|BibEntry
name|currentEntry
init|=
name|entries
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|piv
operator|==
operator|-
literal|1
condition|)
block|{
name|piv
operator|=
name|i
expr_stmt|;
name|tmpMarker
operator|=
name|getAuthorYearParenthesisMarker
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|currentEntry
argument_list|)
argument_list|,
name|database
argument_list|,
literal|null
argument_list|,
name|unlimAuthors
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// See if this entry can go into a group with the previous one:
name|String
name|thisMarker
init|=
name|getAuthorYearParenthesisMarker
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|currentEntry
argument_list|)
argument_list|,
name|database
argument_list|,
literal|null
argument_list|,
name|unlimAuthors
argument_list|)
decl_stmt|;
name|String
name|authorField
init|=
name|getStringCitProperty
argument_list|(
name|AUTHOR_FIELD
argument_list|)
decl_stmt|;
name|int
name|maxAuthors
init|=
name|getIntCitProperty
argument_list|(
name|MAX_AUTHORS
argument_list|)
decl_stmt|;
name|String
name|author
init|=
name|getCitationMarkerField
argument_list|(
name|currentEntry
argument_list|,
name|database
operator|.
name|get
argument_list|(
name|currentEntry
argument_list|)
argument_list|,
name|authorField
argument_list|)
decl_stmt|;
name|AuthorList
name|al
init|=
name|AuthorList
operator|.
name|parse
argument_list|(
name|author
argument_list|)
decl_stmt|;
name|int
name|prevALim
init|=
name|unlimAuthors
index|[
name|i
operator|-
literal|1
index|]
decl_stmt|;
comment|// i always at least 1 here
if|if
condition|(
operator|!
name|thisMarker
operator|.
name|equals
argument_list|(
name|tmpMarker
argument_list|)
operator|||
operator|(
operator|(
name|al
operator|.
name|getNumberOfAuthors
argument_list|()
operator|>
name|maxAuthors
operator|)
operator|&&
operator|(
name|unlimAuthors
index|[
name|i
index|]
operator|!=
name|prevALim
operator|)
operator|)
condition|)
block|{
comment|// No match. Update piv to exclude the previous entry. But first check if the
comment|// previous entry was part of a group:
if|if
condition|(
operator|(
name|piv
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|(
name|i
operator|>
operator|(
name|piv
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
comment|// Do the grouping:
name|group
argument_list|(
name|entries
argument_list|,
name|uniquefiers
argument_list|,
name|piv
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|tmpMarker
operator|=
name|thisMarker
expr_stmt|;
name|piv
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Finished with the loop. See if the last entries form a group:
if|if
condition|(
name|piv
operator|>=
literal|0
condition|)
block|{
comment|// Do the grouping:
name|group
argument_list|(
name|entries
argument_list|,
name|uniquefiers
argument_list|,
name|piv
argument_list|,
name|uniquefiers
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|inParenthesis
condition|)
block|{
return|return
name|getAuthorYearParenthesisMarker
argument_list|(
name|entries
argument_list|,
name|database
argument_list|,
name|uniquefiers
argument_list|,
name|unlimAuthors
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|getAuthorYearInTextMarker
argument_list|(
name|entries
argument_list|,
name|database
argument_list|,
name|uniquefiers
argument_list|,
name|unlimAuthors
argument_list|)
return|;
block|}
block|}
comment|/**      * Modify entry and uniquefier arrays to facilitate a grouped presentation of uniquefied entries.      *      * @param entries     The entry array.      * @param uniquefiers The uniquefier array.      * @param from        The first index to group (inclusive)      * @param to          The last index to group (inclusive)      */
DECL|method|group (List<BibEntry> entries, String[] uniquefiers, int from, int to)
specifier|private
name|void
name|group
parameter_list|(
name|List
argument_list|<
name|BibEntry
argument_list|>
name|entries
parameter_list|,
name|String
index|[]
name|uniquefiers
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|String
name|separator
init|=
name|getStringCitProperty
argument_list|(
name|UNIQUEFIER_SEPARATOR
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|uniquefiers
index|[
name|from
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|from
operator|+
literal|1
init|;
name|i
operator|<=
name|to
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|separator
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|uniquefiers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|entries
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|uniquefiers
index|[
name|from
index|]
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
comment|/**      * This method produces (Author, year) style citation strings in many different forms.      *      * @param entries           The list of BibEntry to get fields from.      * @param database          A map of BibEntry-BibDatabase pairs.      * @param uniquifiers       Optional parameter to separate similar citations. Elements can be null if not needed.      * @return The formatted citation.      */
DECL|method|getAuthorYearParenthesisMarker (List<BibEntry> entries, Map<BibEntry, BibDatabase> database, String[] uniquifiers, int[] unlimAuthors)
specifier|private
name|String
name|getAuthorYearParenthesisMarker
parameter_list|(
name|List
argument_list|<
name|BibEntry
argument_list|>
name|entries
parameter_list|,
name|Map
argument_list|<
name|BibEntry
argument_list|,
name|BibDatabase
argument_list|>
name|database
parameter_list|,
name|String
index|[]
name|uniquifiers
parameter_list|,
name|int
index|[]
name|unlimAuthors
parameter_list|)
block|{
name|String
name|authorField
init|=
name|getStringCitProperty
argument_list|(
name|AUTHOR_FIELD
argument_list|)
decl_stmt|;
comment|// The bibtex field providing author names, e.g. "author" or "editor".
name|int
name|maxA
init|=
name|getIntCitProperty
argument_list|(
name|MAX_AUTHORS
argument_list|)
decl_stmt|;
comment|// The maximum number of authors to write out in full without using etal. Set to
comment|// -1 to always write out all authors.
name|String
name|yearSep
init|=
name|getStringCitProperty
argument_list|(
name|YEAR_SEPARATOR
argument_list|)
decl_stmt|;
comment|// The String to separate authors from year, e.g. "; ".
name|String
name|startBrace
init|=
name|getStringCitProperty
argument_list|(
name|BRACKET_BEFORE
argument_list|)
decl_stmt|;
comment|// The opening parenthesis.
name|String
name|endBrace
init|=
name|getStringCitProperty
argument_list|(
name|BRACKET_AFTER
argument_list|)
decl_stmt|;
comment|// The closing parenthesis.
name|String
name|citationSeparator
init|=
name|getStringCitProperty
argument_list|(
name|CITATION_SEPARATOR
argument_list|)
decl_stmt|;
comment|// The String to separate citations from each other.
name|String
name|yearField
init|=
name|getStringCitProperty
argument_list|(
name|YEAR_FIELD
argument_list|)
decl_stmt|;
comment|// The bibtex field providing the year, e.g. "year".
name|String
name|andString
init|=
name|getStringCitProperty
argument_list|(
name|AUTHOR_LAST_SEPARATOR
argument_list|)
decl_stmt|;
comment|// The String to add between the two last author names, e.g. "& ".
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|startBrace
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|entries
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|BibEntry
name|currentEntry
init|=
name|entries
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
comment|// Check if this entry has been nulled due to grouping with the previous entry(ies):
if|if
condition|(
name|currentEntry
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|citationSeparator
argument_list|)
expr_stmt|;
block|}
name|BibDatabase
name|currentDatabase
init|=
name|database
operator|.
name|get
argument_list|(
name|currentEntry
argument_list|)
decl_stmt|;
name|int
name|unlimA
init|=
name|unlimAuthors
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|unlimAuthors
index|[
name|j
index|]
decl_stmt|;
name|int
name|maxAuthors
init|=
name|unlimA
operator|>
literal|0
condition|?
name|unlimA
else|:
name|maxA
decl_stmt|;
name|String
name|author
init|=
name|getCitationMarkerField
argument_list|(
name|currentEntry
argument_list|,
name|currentDatabase
argument_list|,
name|authorField
argument_list|)
decl_stmt|;
name|String
name|authorString
init|=
name|createAuthorList
argument_list|(
name|author
argument_list|,
name|maxAuthors
argument_list|,
name|andString
argument_list|,
name|yearSep
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|authorString
argument_list|)
expr_stmt|;
name|String
name|year
init|=
name|getCitationMarkerField
argument_list|(
name|currentEntry
argument_list|,
name|currentDatabase
argument_list|,
name|yearField
argument_list|)
decl_stmt|;
if|if
condition|(
name|year
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|year
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|uniquifiers
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|uniquifiers
index|[
name|j
index|]
operator|!=
literal|null
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|uniquifiers
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
name|endBrace
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This method produces "Author (year)" style citation strings in many different forms.      *      * @param entries     The list of BibEntry to get fields from.      * @param database    A map of BibEntry-BibDatabase pairs.      * @param uniquefiers Optional parameters to separate similar citations. Can be null if not needed.      * @return The formatted citation.      */
DECL|method|getAuthorYearInTextMarker (List<BibEntry> entries, Map<BibEntry, BibDatabase> database, String[] uniquefiers, int[] unlimAuthors)
specifier|private
name|String
name|getAuthorYearInTextMarker
parameter_list|(
name|List
argument_list|<
name|BibEntry
argument_list|>
name|entries
parameter_list|,
name|Map
argument_list|<
name|BibEntry
argument_list|,
name|BibDatabase
argument_list|>
name|database
parameter_list|,
name|String
index|[]
name|uniquefiers
parameter_list|,
name|int
index|[]
name|unlimAuthors
parameter_list|)
block|{
name|String
name|authorField
init|=
name|getStringCitProperty
argument_list|(
name|AUTHOR_FIELD
argument_list|)
decl_stmt|;
comment|// The bibtex field providing author names, e.g. "author" or "editor".
name|int
name|maxA
init|=
name|getIntCitProperty
argument_list|(
name|MAX_AUTHORS
argument_list|)
decl_stmt|;
comment|// The maximum number of authors to write out in full without using etal. Set to
comment|// -1 to always write out all authors.
name|String
name|yearSep
init|=
name|getStringCitProperty
argument_list|(
name|IN_TEXT_YEAR_SEPARATOR
argument_list|)
decl_stmt|;
comment|// The String to separate authors from year, e.g. "; ".
name|String
name|startBrace
init|=
name|getStringCitProperty
argument_list|(
name|BRACKET_BEFORE
argument_list|)
decl_stmt|;
comment|// The opening parenthesis.
name|String
name|endBrace
init|=
name|getStringCitProperty
argument_list|(
name|BRACKET_AFTER
argument_list|)
decl_stmt|;
comment|// The closing parenthesis.
name|String
name|citationSeparator
init|=
name|getStringCitProperty
argument_list|(
name|CITATION_SEPARATOR
argument_list|)
decl_stmt|;
comment|// The String to separate citations from each other.
name|String
name|yearField
init|=
name|getStringCitProperty
argument_list|(
name|YEAR_FIELD
argument_list|)
decl_stmt|;
comment|// The bibtex field providing the year, e.g. "year".
name|String
name|andString
init|=
name|getStringCitProperty
argument_list|(
name|AUTHOR_LAST_SEPARATOR_IN_TEXT
argument_list|)
decl_stmt|;
comment|// The String to add between the two last author names, e.g. "& ".
if|if
condition|(
name|andString
operator|==
literal|null
condition|)
block|{
comment|// Use the default one if no explicit separator for text is defined
name|andString
operator|=
name|getStringCitProperty
argument_list|(
name|AUTHOR_LAST_SEPARATOR
argument_list|)
expr_stmt|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|entries
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|BibEntry
name|currentEntry
init|=
name|entries
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Check if this entry has been nulled due to grouping with the previous entry(ies):
if|if
condition|(
name|currentEntry
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|BibDatabase
name|currentDatabase
init|=
name|database
operator|.
name|get
argument_list|(
name|currentEntry
argument_list|)
decl_stmt|;
name|int
name|unlimA
init|=
name|unlimAuthors
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|unlimAuthors
index|[
name|i
index|]
decl_stmt|;
name|int
name|maxAuthors
init|=
name|unlimA
operator|>
literal|0
condition|?
name|unlimA
else|:
name|maxA
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|citationSeparator
argument_list|)
expr_stmt|;
block|}
name|String
name|author
init|=
name|getCitationMarkerField
argument_list|(
name|currentEntry
argument_list|,
name|currentDatabase
argument_list|,
name|authorField
argument_list|)
decl_stmt|;
name|String
name|authorString
init|=
name|createAuthorList
argument_list|(
name|author
argument_list|,
name|maxAuthors
argument_list|,
name|andString
argument_list|,
name|yearSep
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|authorString
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|startBrace
argument_list|)
expr_stmt|;
name|String
name|year
init|=
name|getCitationMarkerField
argument_list|(
name|currentEntry
argument_list|,
name|currentDatabase
argument_list|,
name|yearField
argument_list|)
decl_stmt|;
if|if
condition|(
name|year
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|year
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|uniquefiers
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|uniquefiers
index|[
name|i
index|]
operator|!=
literal|null
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|uniquefiers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|endBrace
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This method looks up a field for an entry in a database. Any number of backup fields can be used      * if the primary field is empty.      *      * @param entry    The entry.      * @param database The database the entry belongs to.      * @param field    The field, or succession of fields, to look up. If backup fields are needed, separate      *                 field names by /. E.g. to use "author" with "editor" as backup, specify FieldName.orFields(FieldName.AUTHOR, FieldName.EDITOR).      * @return The resolved field content, or an empty string if the field(s) were empty.      */
DECL|method|getCitationMarkerField (BibEntry entry, BibDatabase database, String field)
specifier|private
name|String
name|getCitationMarkerField
parameter_list|(
name|BibEntry
name|entry
parameter_list|,
name|BibDatabase
name|database
parameter_list|,
name|String
name|field
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|entry
argument_list|,
literal|"Entry cannot be null"
argument_list|)
expr_stmt|;
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|database
argument_list|,
literal|"database cannot be null"
argument_list|)
expr_stmt|;
name|String
name|authorField
init|=
name|getStringCitProperty
argument_list|(
name|AUTHOR_FIELD
argument_list|)
decl_stmt|;
name|String
index|[]
name|fields
init|=
name|field
operator|.
name|split
argument_list|(
name|FieldName
operator|.
name|FIELD_SEPARATOR
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|fields
control|)
block|{
name|Optional
argument_list|<
name|String
argument_list|>
name|content
init|=
name|entry
operator|.
name|getResolvedFieldOrAlias
argument_list|(
name|s
argument_list|,
name|database
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|content
operator|.
name|isPresent
argument_list|()
operator|)
operator|&&
operator|!
name|content
operator|.
name|get
argument_list|()
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
name|authorField
argument_list|)
operator|&&
name|StringUtil
operator|.
name|isInCurlyBrackets
argument_list|(
name|content
operator|.
name|get
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|"{"
operator|+
name|fieldFormatter
operator|.
name|format
argument_list|(
name|content
operator|.
name|get
argument_list|()
argument_list|)
operator|+
literal|"}"
return|;
block|}
return|return
name|fieldFormatter
operator|.
name|format
argument_list|(
name|content
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|// No luck? Return an empty string:
return|return
literal|""
return|;
block|}
comment|/**      * Look up the nth author and return the proper last name for citation markers.      *      * @param al     The author list.      * @param number The number of the author to return.      * @return The author name, or an empty String if inapplicable.      */
DECL|method|getAuthorLastName (AuthorList al, int number)
specifier|private
name|String
name|getAuthorLastName
parameter_list|(
name|AuthorList
name|al
parameter_list|,
name|int
name|number
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|al
operator|.
name|getNumberOfAuthors
argument_list|()
operator|>
name|number
condition|)
block|{
name|Author
name|a
init|=
name|al
operator|.
name|getAuthor
argument_list|(
name|number
argument_list|)
decl_stmt|;
name|a
operator|.
name|getVon
argument_list|()
operator|.
name|filter
argument_list|(
name|von
lambda|->
operator|!
name|von
operator|.
name|isEmpty
argument_list|()
argument_list|)
operator|.
name|ifPresent
argument_list|(
name|von
lambda|->
name|sb
operator|.
name|append
argument_list|(
name|von
argument_list|)
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|a
operator|.
name|getLast
argument_list|()
operator|.
name|orElse
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Take a finished citation and insert a string at the end (but inside the end bracket)      * separated by "PageInfoSeparator"      *      * @param citation      * @param pageInfo      * @return      */
DECL|method|insertPageInfo (String citation, String pageInfo)
specifier|public
name|String
name|insertPageInfo
parameter_list|(
name|String
name|citation
parameter_list|,
name|String
name|pageInfo
parameter_list|)
block|{
name|String
name|bracketAfter
init|=
name|getStringCitProperty
argument_list|(
name|BRACKET_AFTER
argument_list|)
decl_stmt|;
if|if
condition|(
name|citation
operator|.
name|endsWith
argument_list|(
name|bracketAfter
argument_list|)
condition|)
block|{
name|String
name|first
init|=
name|citation
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|citation
operator|.
name|length
argument_list|()
operator|-
name|bracketAfter
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|first
operator|+
name|getStringCitProperty
argument_list|(
name|PAGE_INFO_SEPARATOR
argument_list|)
operator|+
name|pageInfo
operator|+
name|bracketAfter
return|;
block|}
else|else
block|{
return|return
name|citation
operator|+
name|getStringCitProperty
argument_list|(
name|PAGE_INFO_SEPARATOR
argument_list|)
operator|+
name|pageInfo
return|;
block|}
block|}
comment|/**      * Convenience method for checking the property for whether we use number citations or      * author-year citations.      *      * @return true if we use numbered citations, false otherwise.      */
DECL|method|isNumberEntries ()
specifier|public
name|boolean
name|isNumberEntries
parameter_list|()
block|{
return|return
operator|(
name|Boolean
operator|)
name|getProperty
argument_list|(
name|IS_NUMBER_ENTRIES
argument_list|)
return|;
block|}
comment|/**      * Convenience method for checking the property for whether we sort the bibliography      * according to their order of appearance in the text.      *      * @return true to sort by appearance, false to sort alphabetically.      */
DECL|method|isSortByPosition ()
specifier|public
name|boolean
name|isSortByPosition
parameter_list|()
block|{
return|return
operator|(
name|Boolean
operator|)
name|getProperty
argument_list|(
name|IS_SORT_BY_POSITION
argument_list|)
return|;
block|}
comment|/**      * Convenience method for checking whether citation markers should be italicized.      * Will only be relevant if isFormatCitations() returns true.      *      * @return true to indicate that citations should be in italics.      */
DECL|method|isItalicCitations ()
specifier|public
name|boolean
name|isItalicCitations
parameter_list|()
block|{
return|return
operator|(
name|Boolean
operator|)
name|citProperties
operator|.
name|get
argument_list|(
name|ITALIC_CITATIONS
argument_list|)
return|;
block|}
comment|/**      * Convenience method for checking whether citation markers should be bold.      * Will only be relevant if isFormatCitations() returns true.      *      * @return true to indicate that citations should be in bold.      */
DECL|method|isBoldCitations ()
specifier|public
name|boolean
name|isBoldCitations
parameter_list|()
block|{
return|return
operator|(
name|Boolean
operator|)
name|citProperties
operator|.
name|get
argument_list|(
name|BOLD_CITATIONS
argument_list|)
return|;
block|}
comment|/**      * Convenience method for checking whether citation markers formatted      * according to the results of the isItalicCitations() and      * isBoldCitations() methods.      *      * @return true to indicate that citations should be in italics.      */
DECL|method|isFormatCitations ()
specifier|public
name|boolean
name|isFormatCitations
parameter_list|()
block|{
return|return
operator|(
name|Boolean
operator|)
name|citProperties
operator|.
name|get
argument_list|(
name|FORMAT_CITATIONS
argument_list|)
return|;
block|}
DECL|method|isBibtexKeyCiteMarkers ()
specifier|public
name|boolean
name|isBibtexKeyCiteMarkers
parameter_list|()
block|{
return|return
operator|(
name|Boolean
operator|)
name|citProperties
operator|.
name|get
argument_list|(
name|BIBTEX_KEY_CITATIONS
argument_list|)
return|;
block|}
comment|/**      * Get boolean property.      *      * @param key The property key      * @return the value      */
DECL|method|getBooleanCitProperty (String key)
specifier|public
name|boolean
name|getBooleanCitProperty
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
operator|(
name|Boolean
operator|)
name|citProperties
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|getIntCitProperty (String key)
specifier|public
name|int
name|getIntCitProperty
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
operator|(
name|Integer
operator|)
name|citProperties
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|getStringCitProperty (String key)
specifier|public
name|String
name|getStringCitProperty
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|getCitationCharacterFormat ()
specifier|public
name|String
name|getCitationCharacterFormat
parameter_list|()
block|{
return|return
name|getStringCitProperty
argument_list|(
name|CITATION_CHARACTER_FORMAT
argument_list|)
return|;
block|}
comment|/**      * Get a style property.      *      * @param propName The property name.      * @return The property value, or null if it doesn't exist.      */
DECL|method|getProperty (String propName)
specifier|public
name|Object
name|getProperty
parameter_list|(
name|String
name|propName
parameter_list|)
block|{
return|return
name|properties
operator|.
name|get
argument_list|(
name|propName
argument_list|)
return|;
block|}
comment|/**      * Indicate if it is an internal style      *      * @return True if an internal style      */
DECL|method|isFromResource ()
specifier|public
name|boolean
name|isFromResource
parameter_list|()
block|{
return|return
name|fromResource
return|;
block|}
DECL|method|getLocalCopy ()
specifier|public
name|String
name|getLocalCopy
parameter_list|()
block|{
return|return
name|localCopy
return|;
block|}
annotation|@
name|Override
DECL|method|compareTo (OOBibStyle other)
specifier|public
name|int
name|compareTo
parameter_list|(
name|OOBibStyle
name|other
parameter_list|)
block|{
return|return
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|other
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|o
operator|instanceof
name|OOBibStyle
condition|)
block|{
name|OOBibStyle
name|otherStyle
init|=
operator|(
name|OOBibStyle
operator|)
name|o
decl_stmt|;
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|path
argument_list|,
name|otherStyle
operator|.
name|path
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|name
argument_list|,
name|otherStyle
operator|.
name|name
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|citProperties
argument_list|,
name|otherStyle
operator|.
name|citProperties
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|properties
argument_list|,
name|otherStyle
operator|.
name|properties
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
name|citProperties
argument_list|,
name|properties
argument_list|)
return|;
block|}
DECL|method|createAuthorList (String author, int maxAuthors, String andString, String yearSep)
specifier|private
name|String
name|createAuthorList
parameter_list|(
name|String
name|author
parameter_list|,
name|int
name|maxAuthors
parameter_list|,
name|String
name|andString
parameter_list|,
name|String
name|yearSep
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|author
argument_list|)
expr_stmt|;
name|String
name|etAlString
init|=
name|getStringCitProperty
argument_list|(
name|ET_AL_STRING
argument_list|)
decl_stmt|;
comment|//  The String to represent authors that are not mentioned, e.g. " et al."
name|String
name|authorSep
init|=
name|getStringCitProperty
argument_list|(
name|AUTHOR_SEPARATOR
argument_list|)
decl_stmt|;
comment|// The String to add between author names except the last two, e.g. ", ".
name|String
name|oxfordComma
init|=
name|getStringCitProperty
argument_list|(
name|OXFORD_COMMA
argument_list|)
decl_stmt|;
comment|// The String to put after the second to last author in case of three or more authors
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|AuthorList
name|al
init|=
name|AuthorList
operator|.
name|parse
argument_list|(
name|author
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|al
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|getAuthorLastName
argument_list|(
name|al
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|al
operator|.
name|getNumberOfAuthors
argument_list|()
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|(
name|al
operator|.
name|getNumberOfAuthors
argument_list|()
operator|<=
name|maxAuthors
operator|)
operator|||
operator|(
name|maxAuthors
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|int
name|j
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|j
operator|<
operator|(
name|al
operator|.
name|getNumberOfAuthors
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|authorSep
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getAuthorLastName
argument_list|(
name|al
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|al
operator|.
name|getNumberOfAuthors
argument_list|()
operator|>
literal|2
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|oxfordComma
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|andString
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getAuthorLastName
argument_list|(
name|al
argument_list|,
name|al
operator|.
name|getNumberOfAuthors
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|al
operator|.
name|getNumberOfAuthors
argument_list|()
operator|>
name|maxAuthors
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|etAlString
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|yearSep
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

