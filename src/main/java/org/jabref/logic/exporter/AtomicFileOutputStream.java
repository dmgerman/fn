begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.jabref.logic.exporter
package|package
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|exporter
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|OverlappingFileLockException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|StandardCopyOption
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|attribute
operator|.
name|PosixFilePermission
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|util
operator|.
name|io
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * A file output stream that is similar to the standard {@link FileOutputStream}, except that all writes are first  * redirected to a temporary file. When the stream is closed, the temporary file (atomically) replaces the target file.  *  * In detail, the strategy is to:  *<ol>  *<li>Write to a temporary file (with .tmp suffix) in the same directory as the destination file.</li>  *<li>Create a backup (with .bak suffix) of the original file (if it exists) in the same directory.</li>  *<li>Move the temporary file to the correct place, overwriting any file that already exists at that location.</li>  *<li>Delete the backup file (if configured to do so).</li>  *</ol>  * If all goes well, no temporary or backup files will remain on disk after closing the stream.  *  * Errors are handled as follows:  *<ol>  *<li>If anything goes wrong while writing to the temporary file, the temporary file will be deleted (leaving the  * original file untouched).</li>  *<li>If anything goes wrong while copying the temporary file to the target file, the backup of the original file is  * kept.</li>  *</ol>  *  * Implementation inspired by code from<a href="https://github.com/martylamb/atomicfileoutputstream/blob/master/src/main/java/com/martiansoftware/io/AtomicFileOutputStream.java">Marty  * Lamb</a> and<a href="https://github.com/apache/zookeeper/blob/master/src/java/main/org/apache/zookeeper/common/AtomicFileOutputStream.java">Apache</a>.  */
end_comment

begin_class
DECL|class|AtomicFileOutputStream
specifier|public
class|class
name|AtomicFileOutputStream
extends|extends
name|FilterOutputStream
block|{
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AtomicFileOutputStream
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TEMPORARY_EXTENSION
specifier|private
specifier|static
specifier|final
name|String
name|TEMPORARY_EXTENSION
init|=
literal|".tmp"
decl_stmt|;
DECL|field|BACKUP_EXTENSION
specifier|private
specifier|static
specifier|final
name|String
name|BACKUP_EXTENSION
init|=
literal|".bak"
decl_stmt|;
comment|/**      * The file we want to create/replace.      */
DECL|field|targetFile
specifier|private
specifier|final
name|Path
name|targetFile
decl_stmt|;
comment|/**      * The file to which writes are redirected to.      */
DECL|field|temporaryFile
specifier|private
specifier|final
name|Path
name|temporaryFile
decl_stmt|;
DECL|field|temporaryFileLock
specifier|private
specifier|final
name|FileLock
name|temporaryFileLock
decl_stmt|;
comment|/**      * A backup of the target file (if it exists), created when the stream is closed      */
DECL|field|backupFile
specifier|private
specifier|final
name|Path
name|backupFile
decl_stmt|;
DECL|field|keepBackup
specifier|private
specifier|final
name|boolean
name|keepBackup
decl_stmt|;
comment|/**      * Creates a new output stream to write to or replace the file at the specified path.      *      * @param path the path of the file to write to or replace      * @param keepBackup whether to keep the backup file after a successful write process      */
DECL|method|AtomicFileOutputStream (Path path, boolean keepBackup)
specifier|public
name|AtomicFileOutputStream
parameter_list|(
name|Path
name|path
parameter_list|,
name|boolean
name|keepBackup
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|Files
operator|.
name|newOutputStream
argument_list|(
name|getPathOfTemporaryFile
argument_list|(
name|path
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|targetFile
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|temporaryFile
operator|=
name|getPathOfTemporaryFile
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|this
operator|.
name|backupFile
operator|=
name|getPathOfBackupFile
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|this
operator|.
name|keepBackup
operator|=
name|keepBackup
expr_stmt|;
try|try
block|{
comment|// Lock files (so that at least not another JabRef instance writes at the same time to the same tmp file)
if|if
condition|(
name|out
operator|instanceof
name|FileOutputStream
condition|)
block|{
name|temporaryFileLock
operator|=
operator|(
operator|(
name|FileOutputStream
operator|)
name|out
operator|)
operator|.
name|getChannel
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|temporaryFileLock
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OverlappingFileLockException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not obtain write access to "
operator|+
name|temporaryFile
operator|+
literal|". Maybe another instance of JabRef is currently writing to the same file?"
argument_list|,
name|exception
argument_list|)
throw|;
block|}
block|}
comment|/**      * Creates a new output stream to write to or replace the file at the specified path. The backup file is deleted      * when the write was successful.      *      * @param path the path of the file to write to or replace      */
DECL|method|AtomicFileOutputStream (Path path)
specifier|public
name|AtomicFileOutputStream
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|getPathOfTemporaryFile (Path targetFile)
specifier|private
specifier|static
name|Path
name|getPathOfTemporaryFile
parameter_list|(
name|Path
name|targetFile
parameter_list|)
block|{
return|return
name|FileUtil
operator|.
name|addExtension
argument_list|(
name|targetFile
argument_list|,
name|TEMPORARY_EXTENSION
argument_list|)
return|;
block|}
DECL|method|getPathOfBackupFile (Path targetFile)
specifier|private
specifier|static
name|Path
name|getPathOfBackupFile
parameter_list|(
name|Path
name|targetFile
parameter_list|)
block|{
return|return
name|FileUtil
operator|.
name|addExtension
argument_list|(
name|targetFile
argument_list|,
name|BACKUP_EXTENSION
argument_list|)
return|;
block|}
comment|/**      * Returns the path of the backup copy of the original file (may not exist)      */
DECL|method|getBackup ()
specifier|public
name|Path
name|getBackup
parameter_list|()
block|{
return|return
name|backupFile
return|;
block|}
comment|/**      * Override for performance reasons.      */
annotation|@
name|Override
DECL|method|write (byte b[], int off, int len)
specifier|public
name|void
name|write
parameter_list|(
name|byte
name|b
index|[]
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|out
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
throw|throw
name|exception
throw|;
block|}
block|}
comment|/**      * Closes the write process to the temporary file but does not commit to the target file.      */
DECL|method|abort ()
specifier|public
name|void
name|abort
parameter_list|()
block|{
try|try
block|{
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
name|Files
operator|.
name|deleteIfExists
argument_list|(
name|temporaryFile
argument_list|)
expr_stmt|;
name|Files
operator|.
name|deleteIfExists
argument_list|(
name|backupFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Unable to abort writing to file "
operator|+
name|temporaryFile
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|cleanup ()
specifier|private
name|void
name|cleanup
parameter_list|()
block|{
try|try
block|{
name|Files
operator|.
name|deleteIfExists
argument_list|(
name|temporaryFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Unable to delete file "
operator|+
name|temporaryFile
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|temporaryFileLock
operator|!=
literal|null
condition|)
block|{
name|temporaryFileLock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Unable to release lock on file "
operator|+
name|temporaryFile
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
comment|// perform the final operations to move the temporary file to its final destination
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
try|try
block|{
comment|// Make sure we have written everything to the temporary file
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|out
operator|instanceof
name|FileOutputStream
condition|)
block|{
operator|(
operator|(
name|FileOutputStream
operator|)
name|out
operator|)
operator|.
name|getFD
argument_list|()
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
comment|// Try to close nonetheless
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
throw|throw
name|exception
throw|;
block|}
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// We successfully wrote everything to the temporary file, lets copy it to the correct place
comment|// First, make backup of original file and try to save file permissions to restore them later (by default: 664)
name|Set
argument_list|<
name|PosixFilePermission
argument_list|>
name|oldFilePermissions
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|PosixFilePermission
operator|.
name|OWNER_READ
argument_list|,
name|PosixFilePermission
operator|.
name|OWNER_WRITE
argument_list|,
name|PosixFilePermission
operator|.
name|GROUP_READ
argument_list|,
name|PosixFilePermission
operator|.
name|GROUP_WRITE
argument_list|,
name|PosixFilePermission
operator|.
name|OTHERS_READ
argument_list|)
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|targetFile
argument_list|)
condition|)
block|{
name|Files
operator|.
name|copy
argument_list|(
name|targetFile
argument_list|,
name|backupFile
argument_list|,
name|StandardCopyOption
operator|.
name|REPLACE_EXISTING
argument_list|)
expr_stmt|;
if|if
condition|(
name|FileUtil
operator|.
name|IS_POSIX_COMPILANT
condition|)
block|{
try|try
block|{
name|oldFilePermissions
operator|=
name|Files
operator|.
name|getPosixFilePermissions
argument_list|(
name|targetFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Error getting file permissions for file {}."
argument_list|,
name|targetFile
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Move temporary file (replace original if it exists)
name|Files
operator|.
name|move
argument_list|(
name|temporaryFile
argument_list|,
name|targetFile
argument_list|,
name|StandardCopyOption
operator|.
name|ATOMIC_MOVE
argument_list|,
name|StandardCopyOption
operator|.
name|REPLACE_EXISTING
argument_list|)
expr_stmt|;
comment|// Restore file permissions
if|if
condition|(
name|FileUtil
operator|.
name|IS_POSIX_COMPILANT
condition|)
block|{
try|try
block|{
name|Files
operator|.
name|setPosixFilePermissions
argument_list|(
name|targetFile
argument_list|,
name|oldFilePermissions
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Error writing file permissions to file {}."
argument_list|,
name|targetFile
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|keepBackup
condition|)
block|{
comment|// Remove backup file
name|Files
operator|.
name|deleteIfExists
argument_list|(
name|backupFile
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// Remove temporary file (but not the backup!)
name|cleanup
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|flush ()
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|super
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
throw|throw
name|exception
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|write (int b)
specifier|public
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|super
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
throw|throw
name|exception
throw|;
block|}
block|}
block|}
end_class

end_unit

