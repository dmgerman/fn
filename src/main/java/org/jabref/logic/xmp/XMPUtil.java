begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.jabref.logic.xmp
package|package
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|xmp
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|StandardOpenOption
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|TransformerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|TypedBibEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabaseMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|Author
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|AuthorList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|BibEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|FieldName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|Month
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|strings
operator|.
name|StringUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jempbox
operator|.
name|impl
operator|.
name|DateConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jempbox
operator|.
name|impl
operator|.
name|XMLUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jempbox
operator|.
name|xmp
operator|.
name|XMPMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jempbox
operator|.
name|xmp
operator|.
name|XMPSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jempbox
operator|.
name|xmp
operator|.
name|XMPSchemaDublinCore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|COSVisitorException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|CryptographyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocumentCatalog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocumentInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|BadSecurityHandlerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|StandardDecryptionMaterial
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import

begin_comment
comment|/**  * XMPUtils provide support for reading and writing BibTex data as XMP-Metadata  * in PDF-documents.  */
end_comment

begin_class
DECL|class|XMPUtil
specifier|public
class|class
name|XMPUtil
block|{
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Log
name|LOGGER
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|XMPUtil
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|XMPUtil ()
specifier|private
name|XMPUtil
parameter_list|()
block|{     }
comment|/**      * Convenience method for readXMP(File).      *      * @param filename The filename from which to open the file.      * @return BibtexEntryies found in the PDF or an empty list      */
DECL|method|readXMP (String filename, XMPPreferences xmpPreferences)
specifier|public
specifier|static
name|List
argument_list|<
name|BibEntry
argument_list|>
name|readXMP
parameter_list|(
name|String
name|filename
parameter_list|,
name|XMPPreferences
name|xmpPreferences
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|XMPUtil
operator|.
name|readXMP
argument_list|(
operator|new
name|File
argument_list|(
name|filename
argument_list|)
argument_list|,
name|xmpPreferences
argument_list|)
return|;
block|}
comment|/**      * Try to write the given BibTexEntry in the XMP-stream of the given      * PDF-file.      *      * Throws an IOException if the file cannot be read or written, so the user      * can remove a lock or cancel the operation.      *      * The method will overwrite existing BibTeX-XMP-data, but keep other      * existing metadata.      *      * This is a convenience method for writeXMP(File, BibEntry).      *      * @param filename The filename from which to open the file.      * @param entry    The entry to write.      * @param database maybenull An optional database which the given bibtex entries belong to, which will be used to      *                 resolve strings. If the database is null the strings will not be resolved.      * @throws TransformerException If the entry was malformed or unsupported.      * @throws IOException          If the file could not be written to or could not be found.      */
DECL|method|writeXMP (String fileName, BibEntry entry, BibDatabase database, XMPPreferences xmpPreferences)
specifier|public
specifier|static
name|void
name|writeXMP
parameter_list|(
name|String
name|fileName
parameter_list|,
name|BibEntry
name|entry
parameter_list|,
name|BibDatabase
name|database
parameter_list|,
name|XMPPreferences
name|xmpPreferences
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
name|XMPUtil
operator|.
name|writeXMP
argument_list|(
operator|new
name|File
argument_list|(
name|fileName
argument_list|)
argument_list|,
name|entry
argument_list|,
name|database
argument_list|,
name|xmpPreferences
argument_list|)
expr_stmt|;
block|}
comment|/**      * Try to read the BibTexEntries from the XMP-stream of the given PDF-file.      *      * @param file The file to read from.      * @throws IOException Throws an IOException if the file cannot be read, so the user than remove a lock or cancel      *                     the operation.      */
DECL|method|readXMP (File file, XMPPreferences xmpPreferences)
specifier|public
specifier|static
name|List
argument_list|<
name|BibEntry
argument_list|>
name|readXMP
parameter_list|(
name|File
name|file
parameter_list|,
name|XMPPreferences
name|xmpPreferences
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|BibEntry
argument_list|>
name|result
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
try|try
init|(
name|FileInputStream
name|inputStream
init|=
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
init|)
block|{
name|result
operator|=
name|XMPUtil
operator|.
name|readXMP
argument_list|(
name|inputStream
argument_list|,
name|xmpPreferences
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|loadWithAutomaticDecryption (InputStream inputStream)
specifier|public
specifier|static
name|PDDocument
name|loadWithAutomaticDecryption
parameter_list|(
name|InputStream
name|inputStream
parameter_list|)
throws|throws
name|IOException
block|{
name|PDDocument
name|doc
init|=
name|PDDocument
operator|.
name|load
argument_list|(
name|inputStream
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|.
name|isEncrypted
argument_list|()
condition|)
block|{
comment|// try the empty string as user password
name|StandardDecryptionMaterial
name|sdm
init|=
operator|new
name|StandardDecryptionMaterial
argument_list|(
literal|""
argument_list|)
decl_stmt|;
try|try
block|{
name|doc
operator|.
name|openProtection
argument_list|(
name|sdm
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BadSecurityHandlerException
decl||
name|CryptographyException
name|e
parameter_list|)
block|{
name|LOGGER
operator|.
name|error
argument_list|(
literal|"Cannot handle encrypted PDF: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|EncryptedPdfsNotSupportedException
argument_list|()
throw|;
block|}
block|}
return|return
name|doc
return|;
block|}
comment|/**      * Try to read the given BibTexEntry from the XMP-stream of the given      * inputstream containing a PDF-file.      *      * @param inputStream The inputstream to read from.      * @return list of BibEntries retrieved from the stream. May be empty, but never null      * @throws IOException Throws an IOException if the file cannot be read, so the user than remove a lock or cancel      *                     the operation.      */
DECL|method|readXMP (InputStream inputStream, XMPPreferences xmpPreferences)
specifier|public
specifier|static
name|List
argument_list|<
name|BibEntry
argument_list|>
name|readXMP
parameter_list|(
name|InputStream
name|inputStream
parameter_list|,
name|XMPPreferences
name|xmpPreferences
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|BibEntry
argument_list|>
name|result
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
init|(
name|PDDocument
name|document
init|=
name|loadWithAutomaticDecryption
argument_list|(
name|inputStream
argument_list|)
init|)
block|{
name|Optional
argument_list|<
name|XMPMetadata
argument_list|>
name|meta
init|=
name|XMPUtil
operator|.
name|getXMPMetadata
argument_list|(
name|document
argument_list|)
decl_stmt|;
if|if
condition|(
name|meta
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|XMPSchema
argument_list|>
name|schemas
init|=
name|meta
operator|.
name|get
argument_list|()
operator|.
name|getSchemasByNamespaceURI
argument_list|(
name|XMPSchemaBibtex
operator|.
name|NAMESPACE
argument_list|)
decl_stmt|;
for|for
control|(
name|XMPSchema
name|schema
range|:
name|schemas
control|)
block|{
name|XMPSchemaBibtex
name|bib
init|=
operator|(
name|XMPSchemaBibtex
operator|)
name|schema
decl_stmt|;
name|BibEntry
name|entry
init|=
name|bib
operator|.
name|getBibtexEntry
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|getType
argument_list|()
operator|==
literal|null
condition|)
block|{
name|entry
operator|.
name|setType
argument_list|(
name|BibEntry
operator|.
name|DEFAULT_TYPE
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
comment|// If we did not find anything have a look if a Dublin Core exists
if|if
condition|(
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|schemas
operator|=
name|meta
operator|.
name|get
argument_list|()
operator|.
name|getSchemasByNamespaceURI
argument_list|(
name|XMPSchemaDublinCore
operator|.
name|NAMESPACE
argument_list|)
expr_stmt|;
for|for
control|(
name|XMPSchema
name|schema
range|:
name|schemas
control|)
block|{
name|XMPSchemaDublinCore
name|dc
init|=
operator|(
name|XMPSchemaDublinCore
operator|)
name|schema
decl_stmt|;
name|Optional
argument_list|<
name|BibEntry
argument_list|>
name|entry
init|=
name|XMPUtil
operator|.
name|getBibtexEntryFromDublinCore
argument_list|(
name|dc
argument_list|,
name|xmpPreferences
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|isPresent
argument_list|()
condition|)
block|{
if|if
condition|(
name|entry
operator|.
name|get
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
literal|null
condition|)
block|{
name|entry
operator|.
name|get
argument_list|()
operator|.
name|setType
argument_list|(
name|BibEntry
operator|.
name|DEFAULT_TYPE
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|add
argument_list|(
name|entry
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If we did not find any XMP metadata, search for non XMP metadata
name|PDDocumentInformation
name|documentInformation
init|=
name|document
operator|.
name|getDocumentInformation
argument_list|()
decl_stmt|;
name|Optional
argument_list|<
name|BibEntry
argument_list|>
name|entry
init|=
name|XMPUtil
operator|.
name|getBibtexEntryFromDocumentInformation
argument_list|(
name|documentInformation
argument_list|)
decl_stmt|;
name|entry
operator|.
name|ifPresent
argument_list|(
name|result
operator|::
name|add
argument_list|)
expr_stmt|;
block|}
block|}
comment|// return empty list, if no metadata was found
if|if
condition|(
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
return|return
name|result
return|;
block|}
DECL|method|readXMP (Path filePath, XMPPreferences xmpPreferences)
specifier|public
specifier|static
name|Collection
argument_list|<
name|BibEntry
argument_list|>
name|readXMP
parameter_list|(
name|Path
name|filePath
parameter_list|,
name|XMPPreferences
name|xmpPreferences
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|readXMP
argument_list|(
name|filePath
operator|.
name|toFile
argument_list|()
argument_list|,
name|xmpPreferences
argument_list|)
return|;
block|}
comment|/**      * Helper function for retrieving a BibEntry from the      * PDDocumentInformation in a PDF file.      *      * To understand how to get hold of a PDDocumentInformation have a look in      * the test cases for XMPUtil.      *      * The BibEntry is build by mapping individual fields in the document      * information (like author, title, keywords) to fields in a bibtex entry.      *      * @param di The document information from which to build a BibEntry.      * @return The bibtex entry found in the document information.      */
DECL|method|getBibtexEntryFromDocumentInformation ( PDDocumentInformation di)
specifier|public
specifier|static
name|Optional
argument_list|<
name|BibEntry
argument_list|>
name|getBibtexEntryFromDocumentInformation
parameter_list|(
name|PDDocumentInformation
name|di
parameter_list|)
block|{
name|BibEntry
name|entry
init|=
operator|new
name|BibEntry
argument_list|()
decl_stmt|;
name|entry
operator|.
name|setType
argument_list|(
name|BibEntry
operator|.
name|DEFAULT_TYPE
argument_list|)
expr_stmt|;
name|String
name|s
init|=
name|di
operator|.
name|getAuthor
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|FieldName
operator|.
name|AUTHOR
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|di
operator|.
name|getTitle
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|FieldName
operator|.
name|TITLE
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|di
operator|.
name|getKeywords
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|FieldName
operator|.
name|KEYWORDS
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|di
operator|.
name|getSubject
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|FieldName
operator|.
name|ABSTRACT
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|COSDictionary
name|dict
init|=
name|di
operator|.
name|getDictionary
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|COSName
argument_list|,
name|COSBase
argument_list|>
name|o
range|:
name|dict
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|o
operator|.
name|getKey
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|startsWith
argument_list|(
literal|"bibtex/"
argument_list|)
condition|)
block|{
name|String
name|value
init|=
name|dict
operator|.
name|getString
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|key
operator|=
name|key
operator|.
name|substring
argument_list|(
literal|"bibtex/"
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|BibEntry
operator|.
name|TYPE_HEADER
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|entry
operator|.
name|setType
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|.
name|setField
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Return empty Optional if no values were found
return|return
name|entry
operator|.
name|getFieldNames
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
name|Optional
operator|.
name|empty
argument_list|()
else|:
name|Optional
operator|.
name|of
argument_list|(
name|entry
argument_list|)
return|;
block|}
comment|/**      * Helper function for retrieving a BibEntry from the DublinCore metadata      * in a PDF file.      *      * To understand how to get hold of a XMPSchemaDublinCore have a look in the      * test cases for XMPUtil.      *      * The BibEntry is build by mapping individual fields in the dublin core      * (like creator, title, subject) to fields in a bibtex entry.      *      * @param dcSchema The document information from which to build a BibEntry.      * @return The bibtex entry found in the document information.      */
DECL|method|getBibtexEntryFromDublinCore (XMPSchemaDublinCore dcSchema, XMPPreferences xmpPreferences)
specifier|public
specifier|static
name|Optional
argument_list|<
name|BibEntry
argument_list|>
name|getBibtexEntryFromDublinCore
parameter_list|(
name|XMPSchemaDublinCore
name|dcSchema
parameter_list|,
name|XMPPreferences
name|xmpPreferences
parameter_list|)
block|{
name|BibEntry
name|entry
init|=
operator|new
name|BibEntry
argument_list|()
decl_stmt|;
comment|/*          * Contributor -> Editor          */
name|List
argument_list|<
name|String
argument_list|>
name|contributors
init|=
name|dcSchema
operator|.
name|getContributors
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|contributors
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|contributors
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|FieldName
operator|.
name|EDITOR
argument_list|,
name|String
operator|.
name|join
argument_list|(
literal|" and "
argument_list|,
name|contributors
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*          * Author -> Creator          */
name|List
argument_list|<
name|String
argument_list|>
name|creators
init|=
name|dcSchema
operator|.
name|getCreators
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|creators
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|creators
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|FieldName
operator|.
name|AUTHOR
argument_list|,
name|String
operator|.
name|join
argument_list|(
literal|" and "
argument_list|,
name|creators
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*          * Year + Month -> Date          */
name|List
argument_list|<
name|String
argument_list|>
name|dates
init|=
name|dcSchema
operator|.
name|getSequenceList
argument_list|(
literal|"dc:date"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|dates
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|dates
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|date
init|=
name|dates
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|Calendar
name|c
init|=
literal|null
decl_stmt|;
try|try
block|{
name|c
operator|=
name|DateConverter
operator|.
name|toCalendar
argument_list|(
name|date
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{
comment|// Ignored
block|}
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|FieldName
operator|.
name|YEAR
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|c
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
operator|.
name|length
argument_list|()
operator|>
literal|4
condition|)
block|{
name|Optional
argument_list|<
name|Month
argument_list|>
name|month
init|=
name|Month
operator|.
name|getMonthByNumber
argument_list|(
name|c
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|month
operator|.
name|ifPresent
argument_list|(
name|entry
operator|::
name|setMonth
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*          * Abstract -> Description          */
name|String
name|s
init|=
name|dcSchema
operator|.
name|getDescription
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|FieldName
operator|.
name|ABSTRACT
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/*          * Identifier -> DOI          */
name|s
operator|=
name|dcSchema
operator|.
name|getIdentifier
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|FieldName
operator|.
name|DOI
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/*          * Publisher -> Publisher          */
name|List
argument_list|<
name|String
argument_list|>
name|publishers
init|=
name|dcSchema
operator|.
name|getPublishers
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|publishers
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|publishers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|FieldName
operator|.
name|PUBLISHER
argument_list|,
name|String
operator|.
name|join
argument_list|(
literal|" and "
argument_list|,
name|publishers
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*          * Relation -> bibtexkey          *          * We abuse the relationship attribute to store all other values in the          * bibtex document          */
name|List
argument_list|<
name|String
argument_list|>
name|relationships
init|=
name|dcSchema
operator|.
name|getRelationships
argument_list|()
decl_stmt|;
if|if
condition|(
name|relationships
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|r
range|:
name|relationships
control|)
block|{
if|if
condition|(
name|r
operator|.
name|startsWith
argument_list|(
literal|"bibtex/"
argument_list|)
condition|)
block|{
name|r
operator|=
name|r
operator|.
name|substring
argument_list|(
literal|"bibtex/"
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|i
init|=
name|r
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|r
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|r
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*          * Rights -> Rights          */
name|s
operator|=
name|dcSchema
operator|.
name|getRights
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"rights"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/*          * Source -> Source          */
name|s
operator|=
name|dcSchema
operator|.
name|getSource
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"source"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/*          * Subject -> Keywords          */
name|List
argument_list|<
name|String
argument_list|>
name|subjects
init|=
name|dcSchema
operator|.
name|getSubjects
argument_list|()
decl_stmt|;
if|if
condition|(
name|subjects
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|addKeywords
argument_list|(
name|subjects
argument_list|,
name|xmpPreferences
operator|.
name|getKeywordSeparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/*          * Title -> Title          */
name|s
operator|=
name|dcSchema
operator|.
name|getTitle
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|FieldName
operator|.
name|TITLE
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/*          * Type -> Type          */
name|List
argument_list|<
name|String
argument_list|>
name|l
init|=
name|dcSchema
operator|.
name|getTypes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|l
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|l
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|s
operator|=
name|l
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setType
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|entry
operator|.
name|getFieldNames
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
name|Optional
operator|.
name|empty
argument_list|()
else|:
name|Optional
operator|.
name|of
argument_list|(
name|entry
argument_list|)
return|;
block|}
comment|/**      * Try to write the given BibTexEntry in the XMP-stream of the given      * PDF-file.      *      * Throws an IOException if the file cannot be read or written, so the user      * can remove a lock or cancel the operation.      *      * The method will overwrite existing BibTeX-XMP-data, but keep other      * existing metadata.      *      * This is a convenience method for writeXMP(File, Collection).      *      * @param file     The file to write to.      * @param entry    The entry to write.      * @param database maybenull An optional database which the given bibtex entries belong to, which will be used to      *                 resolve strings. If the database is null the strings will not be resolved.      * @throws TransformerException If the entry was malformed or unsupported.      * @throws IOException          If the file could not be written to or could not be found.      * @deprecated use overlood {@link #writeXMP(Path, BibEntry, BibDatabase, XMPPreferences)} instead      */
annotation|@
name|Deprecated
DECL|method|writeXMP (File file, BibEntry entry, BibDatabase database, XMPPreferences xmpPreferences)
specifier|public
specifier|static
name|void
name|writeXMP
parameter_list|(
name|File
name|file
parameter_list|,
name|BibEntry
name|entry
parameter_list|,
name|BibDatabase
name|database
parameter_list|,
name|XMPPreferences
name|xmpPreferences
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
name|List
argument_list|<
name|BibEntry
argument_list|>
name|l
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|l
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|XMPUtil
operator|.
name|writeXMP
argument_list|(
name|file
argument_list|,
name|l
argument_list|,
name|database
argument_list|,
literal|true
argument_list|,
name|xmpPreferences
argument_list|)
expr_stmt|;
block|}
DECL|method|writeXMP (Path file, BibEntry entry, BibDatabase database, XMPPreferences xmpPreferences)
specifier|public
specifier|static
name|void
name|writeXMP
parameter_list|(
name|Path
name|file
parameter_list|,
name|BibEntry
name|entry
parameter_list|,
name|BibDatabase
name|database
parameter_list|,
name|XMPPreferences
name|xmpPreferences
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
name|writeXMP
argument_list|(
name|file
operator|.
name|toFile
argument_list|()
argument_list|,
name|entry
argument_list|,
name|database
argument_list|,
name|xmpPreferences
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write the given BibtexEntries as XMP-metadata text to the given stream.      *      * The text that is written to the stream contains a complete XMP-document.      *      * @param bibtexEntries The BibtexEntries to write XMP-metadata for.      * @param database      maybenull An optional database which the given bibtex entries belong to, which will be used      *                      to resolve strings. If the database is null the strings will not be resolved.      * @throws TransformerException Thrown if the bibtexEntries could not transformed to XMP.      * @throws IOException          Thrown if an IOException occured while writing to the stream.      * @see #toXMP(java.util.Collection, BibDatabase) if you don't need strings to be resolved.      */
DECL|method|toXMP (Collection<BibEntry> bibtexEntries, BibDatabase database, OutputStream outputStream, XMPPreferences xmpPreferences)
specifier|private
specifier|static
name|void
name|toXMP
parameter_list|(
name|Collection
argument_list|<
name|BibEntry
argument_list|>
name|bibtexEntries
parameter_list|,
name|BibDatabase
name|database
parameter_list|,
name|OutputStream
name|outputStream
parameter_list|,
name|XMPPreferences
name|xmpPreferences
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
name|Collection
argument_list|<
name|BibEntry
argument_list|>
name|resolvedEntries
decl_stmt|;
if|if
condition|(
name|database
operator|==
literal|null
condition|)
block|{
name|resolvedEntries
operator|=
name|bibtexEntries
expr_stmt|;
block|}
else|else
block|{
name|resolvedEntries
operator|=
name|database
operator|.
name|resolveForStrings
argument_list|(
name|bibtexEntries
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|XMPMetadata
name|x
init|=
operator|new
name|XMPMetadata
argument_list|()
decl_stmt|;
for|for
control|(
name|BibEntry
name|e
range|:
name|resolvedEntries
control|)
block|{
name|XMPSchemaBibtex
name|schema
init|=
operator|new
name|XMPSchemaBibtex
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|x
operator|.
name|addSchema
argument_list|(
name|schema
argument_list|)
expr_stmt|;
name|schema
operator|.
name|setBibtexEntry
argument_list|(
name|e
argument_list|,
name|xmpPreferences
argument_list|)
expr_stmt|;
block|}
name|x
operator|.
name|save
argument_list|(
name|outputStream
argument_list|)
expr_stmt|;
block|}
comment|/**      * Convenience method for toXMP(Collection<BibEntry>, BibDatabase,      * OutputStream) returning a String containing the XMP-metadata of the given      * collection of BibtexEntries.      *      * The resulting metadata string is wrapped as a complete XMP-document.      *      * @param bibtexEntries The BibtexEntries to return XMP-metadata for.      * @param database      An optional database which the given bibtex entries belong to, which will be used      *                      to resolve strings. If the database is null the strings will not be resolved.      * @return The XMP representation of the given bibtexEntries.      * @throws TransformerException Thrown if the bibtexEntries could not transformed to XMP.      */
DECL|method|toXMP (Collection<BibEntry> bibtexEntries, BibDatabase database, XMPPreferences xmpPreferences)
specifier|public
specifier|static
name|String
name|toXMP
parameter_list|(
name|Collection
argument_list|<
name|BibEntry
argument_list|>
name|bibtexEntries
parameter_list|,
name|BibDatabase
name|database
parameter_list|,
name|XMPPreferences
name|xmpPreferences
parameter_list|)
throws|throws
name|TransformerException
block|{
try|try
block|{
name|ByteArrayOutputStream
name|bs
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|XMPUtil
operator|.
name|toXMP
argument_list|(
name|bibtexEntries
argument_list|,
name|database
argument_list|,
name|bs
argument_list|,
name|xmpPreferences
argument_list|)
expr_stmt|;
return|return
name|bs
operator|.
name|toString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|TransformerException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Will read the XMPMetadata from the given pdf file, closing the file      * afterwards.      *      * @param inputStream The inputStream representing a PDF-file to read the XMPMetadata from.      * @return The XMPMetadata object found in the file      */
DECL|method|readRawXMP (InputStream inputStream)
specifier|private
specifier|static
name|Optional
argument_list|<
name|XMPMetadata
argument_list|>
name|readRawXMP
parameter_list|(
name|InputStream
name|inputStream
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|PDDocument
name|document
init|=
name|loadWithAutomaticDecryption
argument_list|(
name|inputStream
argument_list|)
init|)
block|{
return|return
name|XMPUtil
operator|.
name|getXMPMetadata
argument_list|(
name|document
argument_list|)
return|;
block|}
block|}
comment|/**      * @return empty Optional if no metadata has been found      */
DECL|method|getXMPMetadata (PDDocument document)
specifier|private
specifier|static
name|Optional
argument_list|<
name|XMPMetadata
argument_list|>
name|getXMPMetadata
parameter_list|(
name|PDDocument
name|document
parameter_list|)
throws|throws
name|IOException
block|{
name|PDDocumentCatalog
name|catalog
init|=
name|document
operator|.
name|getDocumentCatalog
argument_list|()
decl_stmt|;
name|PDMetadata
name|metaRaw
init|=
name|catalog
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
if|if
condition|(
name|metaRaw
operator|==
literal|null
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
name|Document
name|parseResult
decl_stmt|;
try|try
init|(
name|InputStream
name|is
init|=
name|metaRaw
operator|.
name|createInputStream
argument_list|()
init|)
block|{
name|parseResult
operator|=
name|XMLUtil
operator|.
name|parse
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
name|XMPMetadata
name|meta
init|=
operator|new
name|XMPMetadata
argument_list|(
name|parseResult
argument_list|)
decl_stmt|;
name|meta
operator|.
name|addXMLNSMapping
argument_list|(
name|XMPSchemaBibtex
operator|.
name|NAMESPACE
argument_list|,
name|XMPSchemaBibtex
operator|.
name|class
argument_list|)
expr_stmt|;
return|return
name|Optional
operator|.
name|of
argument_list|(
name|meta
argument_list|)
return|;
block|}
comment|/**      * Will read the XMPMetadata from the given pdf file, closing the file      * afterwards.      *      * @param file The file to read the XMPMetadata from.      * @return The XMPMetadata object found in the file      */
DECL|method|readRawXMP (File file)
specifier|public
specifier|static
name|Optional
argument_list|<
name|XMPMetadata
argument_list|>
name|readRawXMP
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|FileInputStream
name|inputStream
init|=
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
init|)
block|{
return|return
name|XMPUtil
operator|.
name|readRawXMP
argument_list|(
name|inputStream
argument_list|)
return|;
block|}
block|}
DECL|method|writeToDCSchema (XMPSchemaDublinCore dcSchema, BibEntry entry, BibDatabase database, XMPPreferences xmpPreferences)
specifier|private
specifier|static
name|void
name|writeToDCSchema
parameter_list|(
name|XMPSchemaDublinCore
name|dcSchema
parameter_list|,
name|BibEntry
name|entry
parameter_list|,
name|BibDatabase
name|database
parameter_list|,
name|XMPPreferences
name|xmpPreferences
parameter_list|)
block|{
name|BibEntry
name|resolvedEntry
decl_stmt|;
if|if
condition|(
name|database
operator|==
literal|null
condition|)
block|{
name|resolvedEntry
operator|=
name|entry
expr_stmt|;
block|}
else|else
block|{
name|resolvedEntry
operator|=
name|database
operator|.
name|resolveForStrings
argument_list|(
name|entry
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Query privacy filter settings
name|boolean
name|useXmpPrivacyFilter
init|=
name|xmpPreferences
operator|.
name|isUseXMPPrivacyFilter
argument_list|()
decl_stmt|;
comment|// Fields for which not to write XMP data later on:
name|Set
argument_list|<
name|String
argument_list|>
name|filters
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|xmpPreferences
operator|.
name|getXmpPrivacyFilter
argument_list|()
argument_list|)
decl_stmt|;
comment|// Set all the values including key and entryType
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|field
range|:
name|resolvedEntry
operator|.
name|getFieldMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|useXmpPrivacyFilter
operator|&&
name|filters
operator|.
name|contains
argument_list|(
name|field
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|FieldName
operator|.
name|EDITOR
operator|.
name|equals
argument_list|(
name|field
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|authors
init|=
name|field
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|/*                  * Editor -> Contributor                  *                  * Field: dc:contributor                  *                  * Type: bag ProperName                  *                  * Category: External                  *                  * Description: Contributors to the resource (other than the                  * authors).                  *                  * Bibtex-Fields used: editor                  */
name|AuthorList
name|list
init|=
name|AuthorList
operator|.
name|parse
argument_list|(
name|authors
argument_list|)
decl_stmt|;
for|for
control|(
name|Author
name|author
range|:
name|list
operator|.
name|getAuthors
argument_list|()
control|)
block|{
name|dcSchema
operator|.
name|addContributor
argument_list|(
name|author
operator|.
name|getFirstLast
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/*              * ? -> Coverage              *              * Unmapped              *              * dc:coverage Text External The extent or scope of the resource.              *              * Author -> Creator              *              * Field: dc:creator              *              * Type: seq ProperName              *              * Category: External              *              * Description: The authors of the resource (listed in order of              * precedence, if significant).              *              * Bibtex-Fields used: author              */
if|if
condition|(
name|FieldName
operator|.
name|AUTHOR
operator|.
name|equals
argument_list|(
name|field
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|authors
init|=
name|field
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|AuthorList
name|list
init|=
name|AuthorList
operator|.
name|parse
argument_list|(
name|authors
argument_list|)
decl_stmt|;
for|for
control|(
name|Author
name|author
range|:
name|list
operator|.
name|getAuthors
argument_list|()
control|)
block|{
name|dcSchema
operator|.
name|addCreator
argument_list|(
name|author
operator|.
name|getFirstLast
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|FieldName
operator|.
name|MONTH
operator|.
name|equals
argument_list|(
name|field
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
comment|// Dealt with in year
continue|continue;
block|}
if|if
condition|(
name|FieldName
operator|.
name|YEAR
operator|.
name|equals
argument_list|(
name|field
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
comment|/*                  * Year + Month -> Date                  *                  * Field: dc:date                  *                  * Type: seq Date                  *                  * Category: External                  *                  * Description: Date(s) that something interesting happened to                  * the resource.                  *                  * Bibtex-Fields used: year, month                  */
name|entry
operator|.
name|getPublicationDate
argument_list|()
operator|.
name|ifPresent
argument_list|(
name|publicationDate
lambda|->
name|dcSchema
operator|.
name|addSequenceValue
argument_list|(
literal|"dc:date"
argument_list|,
name|publicationDate
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*              * Abstract -> Description              *              * Field: dc:description              *              * Type: Lang Alt              *              * Category: External              *              * Description: A textual description of the content of the              * resource. Multiple values may be present for different languages.              *              * Bibtex-Fields used: abstract              */
if|if
condition|(
name|FieldName
operator|.
name|ABSTRACT
operator|.
name|equals
argument_list|(
name|field
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|dcSchema
operator|.
name|setDescription
argument_list|(
name|field
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*              * DOI -> identifier              *              * Field: dc:identifier              *              * Type: Text              *              * Category: External              *              * Description: Unique identifier of the resource.              *              * Bibtex-Fields used: doi              */
if|if
condition|(
name|FieldName
operator|.
name|DOI
operator|.
name|equals
argument_list|(
name|field
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|dcSchema
operator|.
name|setIdentifier
argument_list|(
name|field
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*              * ? -> Language              *              * Unmapped              *              * dc:language bag Locale Internal An unordered array specifying the              * languages used in the resource.              */
comment|/*              * Publisher -> Publisher              *              * Field: dc:publisher              *              * Type: bag ProperName              *              * Category: External              *              * Description: Publishers.              *              * Bibtex-Fields used: doi              */
if|if
condition|(
name|FieldName
operator|.
name|PUBLISHER
operator|.
name|equals
argument_list|(
name|field
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|dcSchema
operator|.
name|addPublisher
argument_list|(
name|field
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*              * ? -> Rights              *              * Unmapped              *              * dc:rights Lang Alt External Informal rights statement, selected              * by language.              */
comment|/*              * ? -> Source              *              * Unmapped              *              * dc:source Text External Unique identifier of the work from which              * this resource was derived.              */
comment|/*              * Keywords -> Subject              *              * Field: dc:subject              *              * Type: bag Text              *              * Category: External              *              * Description: An unordered array of descriptive phrases or              * keywords that specify the topic of the content of the resource.              *              * Bibtex-Fields used: doi              */
if|if
condition|(
name|FieldName
operator|.
name|KEYWORDS
operator|.
name|equals
argument_list|(
name|field
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|o
init|=
name|field
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
index|[]
name|keywords
init|=
name|o
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|keyword
range|:
name|keywords
control|)
block|{
name|dcSchema
operator|.
name|addSubject
argument_list|(
name|keyword
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/*              * Title -> Title              *              * Field: dc:title              *              * Type: Lang Alt              *              * Category: External              *              * Description: The title of the document, or the name given to the              * resource. Typically, it will be a name by which the resource is              * formally known.              *              * Bibtex-Fields used: title              */
if|if
condition|(
name|FieldName
operator|.
name|TITLE
operator|.
name|equals
argument_list|(
name|field
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|dcSchema
operator|.
name|setTitle
argument_list|(
name|field
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*              * All others (including the bibtex key) get packaged in the              * relation attribute              */
name|String
name|o
init|=
name|field
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|dcSchema
operator|.
name|addRelation
argument_list|(
literal|"bibtex/"
operator|+
name|field
operator|.
name|getKey
argument_list|()
operator|+
literal|'/'
operator|+
name|o
argument_list|)
expr_stmt|;
block|}
comment|/*          * ? -> Format          *          * Unmapped          *          * dc:format MIMEType Internal The file format used when saving the          * resource. Tools and applications should set this property to the save          * format of the data. It may include appropriate qualifiers.          */
name|dcSchema
operator|.
name|setFormat
argument_list|(
literal|"application/pdf"
argument_list|)
expr_stmt|;
comment|/*          * entrytype -> Type          *          * Field: dc:type          *          * Type: bag open Choice          *          * Category: External          *          * Description: A document type; for example, novel, poem, or working          * paper.          *          * Bibtex-Fields used: entrytype          */
name|TypedBibEntry
name|typedEntry
init|=
operator|new
name|TypedBibEntry
argument_list|(
name|entry
argument_list|,
name|BibDatabaseMode
operator|.
name|BIBTEX
argument_list|)
decl_stmt|;
name|String
name|o
init|=
name|typedEntry
operator|.
name|getTypeForDisplay
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|dcSchema
operator|.
name|addType
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Try to write the given BibTexEntry as a DublinCore XMP Schema      *      * Existing DublinCore schemas in the document are not modified.      *      * @param document The pdf document to write to.      * @param entry    The BibTeX entry that is written as a schema.      * @param database maybenull An optional database which the given BibTeX entries belong to, which will be used to      *                 resolve strings. If the database is null the strings will not be resolved.      */
DECL|method|writeDublinCore (PDDocument document, BibEntry entry, BibDatabase database, XMPPreferences xmpPreferences)
specifier|public
specifier|static
name|void
name|writeDublinCore
parameter_list|(
name|PDDocument
name|document
parameter_list|,
name|BibEntry
name|entry
parameter_list|,
name|BibDatabase
name|database
parameter_list|,
name|XMPPreferences
name|xmpPreferences
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
name|List
argument_list|<
name|BibEntry
argument_list|>
name|entries
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|entries
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|XMPUtil
operator|.
name|writeDublinCore
argument_list|(
name|document
argument_list|,
name|entries
argument_list|,
name|database
argument_list|,
name|xmpPreferences
argument_list|)
expr_stmt|;
block|}
comment|/**      * Try to write the given BibTexEntries as DublinCore XMP Schemas      *      * Existing DublinCore schemas in the document are removed      *      * @param document The pdf document to write to.      * @param entries  The BibTeX entries that are written as schemas      * @param database maybenull An optional database which the given BibTeX entries belong to, which will be used to      *                 resolve strings. If the database is null the strings will not be resolved.      */
DECL|method|writeDublinCore (PDDocument document, Collection<BibEntry> entries, BibDatabase database, XMPPreferences xmpPreferences)
specifier|private
specifier|static
name|void
name|writeDublinCore
parameter_list|(
name|PDDocument
name|document
parameter_list|,
name|Collection
argument_list|<
name|BibEntry
argument_list|>
name|entries
parameter_list|,
name|BibDatabase
name|database
parameter_list|,
name|XMPPreferences
name|xmpPreferences
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
name|Collection
argument_list|<
name|BibEntry
argument_list|>
name|resolvedEntries
decl_stmt|;
if|if
condition|(
name|database
operator|==
literal|null
condition|)
block|{
name|resolvedEntries
operator|=
name|entries
expr_stmt|;
block|}
else|else
block|{
name|resolvedEntries
operator|=
name|database
operator|.
name|resolveForStrings
argument_list|(
name|entries
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|PDDocumentCatalog
name|catalog
init|=
name|document
operator|.
name|getDocumentCatalog
argument_list|()
decl_stmt|;
name|PDMetadata
name|metaRaw
init|=
name|catalog
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|XMPMetadata
name|meta
decl_stmt|;
if|if
condition|(
name|metaRaw
operator|==
literal|null
condition|)
block|{
name|meta
operator|=
operator|new
name|XMPMetadata
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|meta
operator|=
operator|new
name|XMPMetadata
argument_list|(
name|XMLUtil
operator|.
name|parse
argument_list|(
name|metaRaw
operator|.
name|createInputStream
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Remove all current Dublin-Core schemas
name|List
argument_list|<
name|XMPSchema
argument_list|>
name|schemas
init|=
name|meta
operator|.
name|getSchemasByNamespaceURI
argument_list|(
name|XMPSchemaDublinCore
operator|.
name|NAMESPACE
argument_list|)
decl_stmt|;
for|for
control|(
name|XMPSchema
name|schema
range|:
name|schemas
control|)
block|{
name|schema
operator|.
name|getElement
argument_list|()
operator|.
name|getParentNode
argument_list|()
operator|.
name|removeChild
argument_list|(
name|schema
operator|.
name|getElement
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BibEntry
name|entry
range|:
name|resolvedEntries
control|)
block|{
name|XMPSchemaDublinCore
name|dcSchema
init|=
operator|new
name|XMPSchemaDublinCore
argument_list|(
name|meta
argument_list|)
decl_stmt|;
name|XMPUtil
operator|.
name|writeToDCSchema
argument_list|(
name|dcSchema
argument_list|,
name|entry
argument_list|,
literal|null
argument_list|,
name|xmpPreferences
argument_list|)
expr_stmt|;
name|meta
operator|.
name|addSchema
argument_list|(
name|dcSchema
argument_list|)
expr_stmt|;
block|}
comment|// Save to stream and then input that stream to the PDF
name|ByteArrayOutputStream
name|os
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|meta
operator|.
name|save
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|ByteArrayInputStream
name|is
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|os
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|PDMetadata
name|metadataStream
init|=
operator|new
name|PDMetadata
argument_list|(
name|document
argument_list|,
name|is
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|catalog
operator|.
name|setMetadata
argument_list|(
name|metadataStream
argument_list|)
expr_stmt|;
block|}
comment|/**      * Try to write the given BibTexEntry in the Document Information (the      * properties of the pdf).      *      * Existing fields values are overriden if the bibtex entry has the      * corresponding value set.      *      * @param document The pdf document to write to.      * @param entry    The Bibtex entry that is written into the PDF properties. *      * @param database maybenull An optional database which the given bibtex entries belong to, which will be used to      *                 resolve strings. If the database is null the strings will not be resolved.      */
DECL|method|writeDocumentInformation (PDDocument document, BibEntry entry, BibDatabase database, XMPPreferences xmpPreferences)
specifier|private
specifier|static
name|void
name|writeDocumentInformation
parameter_list|(
name|PDDocument
name|document
parameter_list|,
name|BibEntry
name|entry
parameter_list|,
name|BibDatabase
name|database
parameter_list|,
name|XMPPreferences
name|xmpPreferences
parameter_list|)
block|{
name|PDDocumentInformation
name|di
init|=
name|document
operator|.
name|getDocumentInformation
argument_list|()
decl_stmt|;
name|BibEntry
name|resolvedEntry
decl_stmt|;
if|if
condition|(
name|database
operator|==
literal|null
condition|)
block|{
name|resolvedEntry
operator|=
name|entry
expr_stmt|;
block|}
else|else
block|{
name|resolvedEntry
operator|=
name|database
operator|.
name|resolveForStrings
argument_list|(
name|entry
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Query privacy filter settings
name|boolean
name|useXmpPrivacyFilter
init|=
name|xmpPreferences
operator|.
name|isUseXMPPrivacyFilter
argument_list|()
decl_stmt|;
comment|// Fields for which not to write XMP data later on:
name|Set
argument_list|<
name|String
argument_list|>
name|filters
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|xmpPreferences
operator|.
name|getXmpPrivacyFilter
argument_list|()
argument_list|)
decl_stmt|;
comment|// Set all the values including key and entryType
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|field
range|:
name|resolvedEntry
operator|.
name|getFieldMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|fieldName
init|=
name|field
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|fieldContent
init|=
name|field
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|useXmpPrivacyFilter
operator|&&
name|filters
operator|.
name|contains
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
comment|// erase field instead of adding it
if|if
condition|(
name|FieldName
operator|.
name|AUTHOR
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|di
operator|.
name|setAuthor
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FieldName
operator|.
name|TITLE
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|di
operator|.
name|setTitle
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FieldName
operator|.
name|KEYWORDS
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|di
operator|.
name|setKeywords
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FieldName
operator|.
name|ABSTRACT
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|di
operator|.
name|setSubject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|di
operator|.
name|setCustomMetadataValue
argument_list|(
literal|"bibtex/"
operator|+
name|fieldName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|FieldName
operator|.
name|AUTHOR
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|di
operator|.
name|setAuthor
argument_list|(
name|fieldContent
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FieldName
operator|.
name|TITLE
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|di
operator|.
name|setTitle
argument_list|(
name|fieldContent
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FieldName
operator|.
name|KEYWORDS
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|di
operator|.
name|setKeywords
argument_list|(
name|fieldContent
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FieldName
operator|.
name|ABSTRACT
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|di
operator|.
name|setSubject
argument_list|(
name|fieldContent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|di
operator|.
name|setCustomMetadataValue
argument_list|(
literal|"bibtex/"
operator|+
name|fieldName
argument_list|,
name|fieldContent
argument_list|)
expr_stmt|;
block|}
block|}
name|di
operator|.
name|setCustomMetadataValue
argument_list|(
literal|"bibtex/entrytype"
argument_list|,
name|StringUtil
operator|.
name|capitalizeFirst
argument_list|(
name|resolvedEntry
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Try to write the given BibTexEntry in the XMP-stream of the given      * PDF-file.      *      * Throws an IOException if the file cannot be read or written, so the user      * can remove a lock or cancel the operation.      *      * The method will overwrite existing BibTeX-XMP-data, but keep other      * existing metadata.      *      * @param file          The file to write the entries to.      * @param bibtexEntries The entries to write to the file. *      * @param database      maybenull An optional database which the given bibtex entries belong to, which will be used      *                      to resolve strings. If the database is null the strings will not be resolved.      * @param writePDFInfo  Write information also in PDF document properties      * @throws TransformerException If the entry was malformed or unsupported.      * @throws IOException          If the file could not be written to or could not be found.      */
DECL|method|writeXMP (File file, Collection<BibEntry> bibtexEntries, BibDatabase database, boolean writePDFInfo, XMPPreferences xmpPreferences)
specifier|public
specifier|static
name|void
name|writeXMP
parameter_list|(
name|File
name|file
parameter_list|,
name|Collection
argument_list|<
name|BibEntry
argument_list|>
name|bibtexEntries
parameter_list|,
name|BibDatabase
name|database
parameter_list|,
name|boolean
name|writePDFInfo
parameter_list|,
name|XMPPreferences
name|xmpPreferences
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
name|Collection
argument_list|<
name|BibEntry
argument_list|>
name|resolvedEntries
decl_stmt|;
if|if
condition|(
name|database
operator|==
literal|null
condition|)
block|{
name|resolvedEntries
operator|=
name|bibtexEntries
expr_stmt|;
block|}
else|else
block|{
name|resolvedEntries
operator|=
name|database
operator|.
name|resolveForStrings
argument_list|(
name|bibtexEntries
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
try|try
init|(
name|PDDocument
name|document
init|=
name|PDDocument
operator|.
name|load
argument_list|(
name|file
operator|.
name|getAbsoluteFile
argument_list|()
argument_list|)
init|)
block|{
if|if
condition|(
name|document
operator|.
name|isEncrypted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|EncryptedPdfsNotSupportedException
argument_list|()
throw|;
block|}
if|if
condition|(
name|writePDFInfo
operator|&&
operator|(
name|resolvedEntries
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
condition|)
block|{
name|XMPUtil
operator|.
name|writeDocumentInformation
argument_list|(
name|document
argument_list|,
name|resolvedEntries
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|,
literal|null
argument_list|,
name|xmpPreferences
argument_list|)
expr_stmt|;
name|XMPUtil
operator|.
name|writeDublinCore
argument_list|(
name|document
argument_list|,
name|resolvedEntries
argument_list|,
literal|null
argument_list|,
name|xmpPreferences
argument_list|)
expr_stmt|;
block|}
name|PDDocumentCatalog
name|catalog
init|=
name|document
operator|.
name|getDocumentCatalog
argument_list|()
decl_stmt|;
name|PDMetadata
name|metaRaw
init|=
name|catalog
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|XMPMetadata
name|meta
decl_stmt|;
if|if
condition|(
name|metaRaw
operator|==
literal|null
condition|)
block|{
name|meta
operator|=
operator|new
name|XMPMetadata
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|meta
operator|=
operator|new
name|XMPMetadata
argument_list|(
name|XMLUtil
operator|.
name|parse
argument_list|(
name|metaRaw
operator|.
name|createInputStream
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|meta
operator|.
name|addXMLNSMapping
argument_list|(
name|XMPSchemaBibtex
operator|.
name|NAMESPACE
argument_list|,
name|XMPSchemaBibtex
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// Remove all current Bibtex-schemas
name|List
argument_list|<
name|XMPSchema
argument_list|>
name|schemas
init|=
name|meta
operator|.
name|getSchemasByNamespaceURI
argument_list|(
name|XMPSchemaBibtex
operator|.
name|NAMESPACE
argument_list|)
decl_stmt|;
for|for
control|(
name|XMPSchema
name|schema
range|:
name|schemas
control|)
block|{
name|XMPSchemaBibtex
name|bib
init|=
operator|(
name|XMPSchemaBibtex
operator|)
name|schema
decl_stmt|;
name|bib
operator|.
name|getElement
argument_list|()
operator|.
name|getParentNode
argument_list|()
operator|.
name|removeChild
argument_list|(
name|bib
operator|.
name|getElement
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BibEntry
name|e
range|:
name|resolvedEntries
control|)
block|{
name|XMPSchemaBibtex
name|bibtex
init|=
operator|new
name|XMPSchemaBibtex
argument_list|(
name|meta
argument_list|)
decl_stmt|;
name|meta
operator|.
name|addSchema
argument_list|(
name|bibtex
argument_list|)
expr_stmt|;
name|bibtex
operator|.
name|setBibtexEntry
argument_list|(
name|e
argument_list|,
name|xmpPreferences
argument_list|)
expr_stmt|;
block|}
comment|// Save to stream and then input that stream to the PDF
name|ByteArrayOutputStream
name|os
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|meta
operator|.
name|save
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|ByteArrayInputStream
name|is
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|os
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|PDMetadata
name|metadataStream
init|=
operator|new
name|PDMetadata
argument_list|(
name|document
argument_list|,
name|is
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|catalog
operator|.
name|setMetadata
argument_list|(
name|metadataStream
argument_list|)
expr_stmt|;
comment|// Save
try|try
block|{
name|document
operator|.
name|save
argument_list|(
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|COSVisitorException
name|e
parameter_list|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Could not write XMP metadata"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|TransformerException
argument_list|(
literal|"Could not write XMP metadata: "
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * see XMPUtil.hasMetadata(InputStream)      */
DECL|method|hasMetadata (Path path, XMPPreferences xmpPreferences)
specifier|public
specifier|static
name|boolean
name|hasMetadata
parameter_list|(
name|Path
name|path
parameter_list|,
name|XMPPreferences
name|xmpPreferences
parameter_list|)
block|{
try|try
init|(
name|InputStream
name|inputStream
init|=
name|Files
operator|.
name|newInputStream
argument_list|(
name|path
argument_list|,
name|StandardOpenOption
operator|.
name|READ
argument_list|)
init|)
block|{
return|return
name|hasMetadata
argument_list|(
name|inputStream
argument_list|,
name|xmpPreferences
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOGGER
operator|.
name|error
argument_list|(
literal|"XMP reading failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Will try to read XMP metadata from the given file, returning whether      * metadata was found.      *      * Caution: This method is as expensive as it is reading the actual metadata      * itself from the PDF.      *      * @param inputStream The inputStream to read the PDF from.      * @return whether a BibEntry was found in the given PDF.      */
DECL|method|hasMetadata (InputStream inputStream, XMPPreferences xmpPreferences)
specifier|public
specifier|static
name|boolean
name|hasMetadata
parameter_list|(
name|InputStream
name|inputStream
parameter_list|,
name|XMPPreferences
name|xmpPreferences
parameter_list|)
block|{
try|try
block|{
name|List
argument_list|<
name|BibEntry
argument_list|>
name|bibEntries
init|=
name|XMPUtil
operator|.
name|readXMP
argument_list|(
name|inputStream
argument_list|,
name|xmpPreferences
argument_list|)
decl_stmt|;
return|return
operator|!
name|bibEntries
operator|.
name|isEmpty
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|EncryptedPdfsNotSupportedException
name|ex
parameter_list|)
block|{
name|LOGGER
operator|.
name|info
argument_list|(
literal|"Encryption not supported by XMPUtil"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOGGER
operator|.
name|error
argument_list|(
literal|"XMP reading failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
end_class

end_unit

