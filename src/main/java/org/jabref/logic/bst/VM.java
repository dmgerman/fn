begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.jabref.logic.bst
package|package
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|bst
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|AuthorList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|BibEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|FieldName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|ANTLRFileStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|ANTLRStringStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|CharStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|CommonTokenStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|RecognitionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|CommonTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|Tree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  *  * A Bibtex Virtual machine that can execute .bst files.  *  * Documentation can be found in the original bibtex distribution:  *  * https://www.ctan.org/pkg/bibtex  *  */
end_comment

begin_class
DECL|class|VM
specifier|public
class|class
name|VM
implements|implements
name|Warn
block|{
DECL|field|FALSE
specifier|public
specifier|static
specifier|final
name|Integer
name|FALSE
init|=
literal|0
decl_stmt|;
DECL|field|TRUE
specifier|public
specifier|static
specifier|final
name|Integer
name|TRUE
init|=
literal|1
decl_stmt|;
DECL|field|ADD_PERIOD_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|ADD_PERIOD_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"([^\\.\\?\\!\\}\\s])(\\}|\\s)*$"
argument_list|)
decl_stmt|;
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|VM
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|entries
specifier|private
name|List
argument_list|<
name|BstEntry
argument_list|>
name|entries
decl_stmt|;
DECL|field|strings
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|strings
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|integers
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|integers
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|functions
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|BstFunction
argument_list|>
name|functions
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|stack
specifier|private
name|Stack
argument_list|<
name|Object
argument_list|>
name|stack
init|=
operator|new
name|Stack
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|buildInFunctions
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|BstFunction
argument_list|>
name|buildInFunctions
decl_stmt|;
DECL|field|file
specifier|private
name|File
name|file
decl_stmt|;
DECL|field|tree
specifier|private
specifier|final
name|CommonTree
name|tree
decl_stmt|;
DECL|field|bbl
specifier|private
name|StringBuilder
name|bbl
decl_stmt|;
DECL|field|preamble
specifier|private
name|String
name|preamble
init|=
literal|""
decl_stmt|;
DECL|class|Identifier
specifier|public
specifier|static
class|class
name|Identifier
block|{
DECL|field|name
specifier|public
specifier|final
name|String
name|name
decl_stmt|;
DECL|method|Identifier (String name)
specifier|public
name|Identifier
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
block|}
DECL|class|Variable
specifier|public
specifier|static
class|class
name|Variable
block|{
DECL|field|name
specifier|public
specifier|final
name|String
name|name
decl_stmt|;
DECL|method|Variable (String name)
specifier|public
name|Variable
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
block|}
annotation|@
name|FunctionalInterface
DECL|interface|BstFunction
specifier|public
interface|interface
name|BstFunction
block|{
DECL|method|execute (BstEntry context)
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
function_decl|;
block|}
DECL|method|VM (File f)
specifier|public
name|VM
parameter_list|(
name|File
name|f
parameter_list|)
throws|throws
name|RecognitionException
throws|,
name|IOException
block|{
name|this
argument_list|(
operator|new
name|ANTLRFileStream
argument_list|(
name|f
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|file
operator|=
name|f
expr_stmt|;
block|}
DECL|method|VM (String s)
specifier|public
name|VM
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|RecognitionException
block|{
name|this
argument_list|(
operator|new
name|ANTLRStringStream
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|VM (CharStream bst)
specifier|private
name|VM
parameter_list|(
name|CharStream
name|bst
parameter_list|)
throws|throws
name|RecognitionException
block|{
name|this
argument_list|(
name|VM
operator|.
name|charStream2CommonTree
argument_list|(
name|bst
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|VM (CommonTree tree)
specifier|private
name|VM
parameter_list|(
name|CommonTree
name|tree
parameter_list|)
block|{
name|this
operator|.
name|tree
operator|=
name|tree
expr_stmt|;
name|this
operator|.
name|buildInFunctions
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
literal|37
argument_list|)
expr_stmt|;
comment|/**          * Pops the top two (integer) literals, compares them, and pushes          * the integer 1 if the second is greater than the first, 0          * otherwise.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|">"
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation>"
argument_list|)
throw|;
block|}
name|Object
name|o2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|o1
operator|instanceof
name|Integer
operator|)
operator|&&
operator|(
name|o2
operator|instanceof
name|Integer
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only compare two integers with>"
argument_list|)
throw|;
block|}
name|stack
operator|.
name|push
argument_list|(
operator|(
operator|(
name|Integer
operator|)
name|o1
operator|)
operator|.
name|compareTo
argument_list|(
operator|(
name|Integer
operator|)
name|o2
argument_list|)
operator|>
literal|0
condition|?
name|VM
operator|.
name|TRUE
else|:
name|VM
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|/** Analogous. */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"<"
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation<"
argument_list|)
throw|;
block|}
name|Object
name|o2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|o1
operator|instanceof
name|Integer
operator|)
operator|&&
operator|(
name|o2
operator|instanceof
name|Integer
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only compare two integers with<"
argument_list|)
throw|;
block|}
name|stack
operator|.
name|push
argument_list|(
operator|(
operator|(
name|Integer
operator|)
name|o1
operator|)
operator|.
name|compareTo
argument_list|(
operator|(
name|Integer
operator|)
name|o2
argument_list|)
operator|<
literal|0
condition|?
name|VM
operator|.
name|TRUE
else|:
name|VM
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|/**          * Pops the top two (both integer or both string) literals, compares          * them, and pushes the integer 1 if they're equal, 0 otherwise.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"="
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation ="
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|o2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|o1
operator|==
literal|null
operator|)
operator|^
operator|(
name|o2
operator|==
literal|null
operator|)
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|o1
operator|==
literal|null
operator|)
operator|&&
operator|(
name|o2
operator|==
literal|null
operator|)
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|stack
operator|.
name|push
argument_list|(
name|o1
operator|.
name|equals
argument_list|(
name|o2
argument_list|)
condition|?
name|VM
operator|.
name|TRUE
else|:
name|VM
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|/** Pops the top two (integer) literals and pushes their sum. */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"+"
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation +"
argument_list|)
throw|;
block|}
name|Object
name|o2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|o1
operator|instanceof
name|Integer
operator|)
operator|&&
operator|(
name|o2
operator|instanceof
name|Integer
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only compare two integers with +"
argument_list|)
throw|;
block|}
name|stack
operator|.
name|push
argument_list|(
operator|(
name|Integer
operator|)
name|o1
operator|+
operator|(
name|Integer
operator|)
name|o2
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|/**          * Pops the top two (integer) literals and pushes their difference          * (the first subtracted from the second).          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"-"
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation -"
argument_list|)
throw|;
block|}
name|Object
name|o2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|o1
operator|instanceof
name|Integer
operator|)
operator|&&
operator|(
name|o2
operator|instanceof
name|Integer
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only subtract two integers with -"
argument_list|)
throw|;
block|}
name|stack
operator|.
name|push
argument_list|(
operator|(
name|Integer
operator|)
name|o1
operator|-
operator|(
name|Integer
operator|)
name|o2
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|/**          * Pops the top two (string) literals, concatenates them (in reverse          * order, that is, the order in which pushed), and pushes the          * resulting string.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"*"
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation *"
argument_list|)
throw|;
block|}
name|Object
name|o2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|o1
operator|instanceof
name|String
operator|)
operator|&&
operator|(
name|o2
operator|instanceof
name|String
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only concatenate two String with *"
argument_list|)
throw|;
block|}
name|stack
operator|.
name|push
argument_list|(
name|o1
operator|.
name|toString
argument_list|()
operator|+
name|o2
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|/**          * Pops the top two literals and assigns to the first (which must be          * a global or entry variable) the value of the second.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|":="
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Invalid call to operation :="
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|o2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|assign
argument_list|(
name|context
argument_list|,
name|o1
argument_list|,
name|o2
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|/**          * Pops the top (string) literal, adds a `.' to it if the last non          * '}' character isn't a `.', `?', or `!', and pushes this resulting          * string.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"add.period$"
argument_list|,
name|context
lambda|->
name|addPeriodFunction
argument_list|()
argument_list|)
expr_stmt|;
comment|/**          * Executes the function whose name is the entry type of an entry.          * For example if an entry is of type book, this function executes          * the book function. When given as an argument to the ITERATE          * command, call.type$ actually produces the output for the entries.          * For an entry with an unknown type, it executes the function          * default.type. Thus you should define (before the READ command)          * one function for each standard entry type as well as a          * default.type function.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"call.type$"
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Call.type$ can only be called from within a context (ITERATE or REVERSE)."
argument_list|)
throw|;
block|}
name|VM
operator|.
name|this
operator|.
name|execute
argument_list|(
name|context
operator|.
name|getBibtexEntry
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"change.case$"
argument_list|,
operator|new
name|ChangeCaseFunction
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
comment|/**          * Pops the top (string) literal, makes sure it's a single          * character, converts it to the corresponding ASCII integer, and          * pushes this integer.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"chr.to.int$"
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation chr.to.int$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|o1
operator|instanceof
name|String
operator|)
operator|&&
operator|(
operator|(
operator|(
name|String
operator|)
name|o1
operator|)
operator|.
name|length
argument_list|()
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only perform chr.to.int$ on string with length 1"
argument_list|)
throw|;
block|}
name|String
name|s
init|=
operator|(
name|String
operator|)
name|o1
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|(
name|int
operator|)
name|s
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|/**          * Pushes the string that was the \cite-command argument for this          * entry.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"cite$"
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Must have an entry to cite$"
argument_list|)
throw|;
block|}
name|stack
operator|.
name|push
argument_list|(
name|context
operator|.
name|getBibtexEntry
argument_list|()
operator|.
name|getCiteKeyOptional
argument_list|()
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|/**          * Pops the top literal from the stack and pushes two copies of it.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"duplicate$"
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation duplicate$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|o1
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|o1
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|/**          * Pops the top literal and pushes the integer 1 if it's a missing          * field or a string having no non-white-space characters, 0          * otherwise.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"empty$"
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation empty$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|o1
operator|==
literal|null
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|String
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Operand does not match function empty$"
argument_list|)
throw|;
block|}
name|String
name|s
init|=
operator|(
name|String
operator|)
name|o1
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
literal|""
operator|.
name|equals
argument_list|(
name|s
operator|.
name|trim
argument_list|()
argument_list|)
condition|?
name|VM
operator|.
name|TRUE
else|:
name|VM
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"format.name$"
argument_list|,
operator|new
name|FormatNameFunction
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
comment|/**          * Pops the top three literals (they are two function literals and          * an integer literal, in that order); if the integer is greater          * than 0, it executes the second literal, else it executes the          * first.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"if$"
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|3
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation ="
argument_list|)
throw|;
block|}
name|Object
name|f1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|f2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|i
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|f1
operator|instanceof
name|Identifier
operator|)
operator|||
operator|(
name|f1
operator|instanceof
name|Tree
operator|)
operator|)
operator|&&
operator|(
operator|(
name|f2
operator|instanceof
name|Identifier
operator|)
operator|||
operator|(
name|f2
operator|instanceof
name|Tree
operator|)
operator|)
operator|&&
operator|(
name|i
operator|instanceof
name|Integer
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Expecting two functions and an integer for if$."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|Integer
operator|)
name|i
operator|>
literal|0
condition|)
block|{
name|VM
operator|.
name|this
operator|.
name|executeInContext
argument_list|(
name|f2
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VM
operator|.
name|this
operator|.
name|executeInContext
argument_list|(
name|f1
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|/**          * Pops the top (integer) literal, interpreted as the ASCII integer          * value of a single character, converts it to the corresponding          * single-character string, and pushes this string.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"int.to.chr$"
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation int.to.chr$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|Integer
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only perform operation int.to.chr$ on an Integer"
argument_list|)
throw|;
block|}
name|Integer
name|i
init|=
operator|(
name|Integer
operator|)
name|o1
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
operator|(
name|char
operator|)
name|i
operator|.
name|intValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|/**          * Pops the top (integer) literal, converts it to its (unique)          * string equivalent, and pushes this string.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"int.to.str$"
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation int.to.str$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|Integer
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only transform an integer to an string using int.to.str$"
argument_list|)
throw|;
block|}
name|stack
operator|.
name|push
argument_list|(
name|o1
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|/**          * Pops the top literal and pushes the integer 1 if it's a missing          * field, 0 otherwise.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"missing$"
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation missing$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|o1
operator|==
literal|null
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|String
operator|)
condition|)
block|{
name|warn
argument_list|(
literal|"Not a string or missing field in operation missing$"
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|VM
operator|.
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|stack
operator|.
name|push
argument_list|(
name|VM
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|/**          * Writes onto the bbl file what is accumulated in the output buffer.          * It writes a blank line if and only if the output buffer is empty.          * Since write$ does reasonable line breaking, you should use this          * function only when you want a blank line or an explicit line          * break.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"newline$"
argument_list|,
name|context
lambda|->
name|VM
operator|.
name|this
operator|.
name|bbl
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
expr_stmt|;
comment|/**          * Pops the top (string) literal and pushes the number of names the          * string represents one plus the number of occurrences of the          * substring "and" (ignoring case differences) surrounded by          * non-null white-space at the top brace level.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"num.names$"
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation num.names$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|String
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Need a string at the top of the stack for num.names$"
argument_list|)
throw|;
block|}
name|String
name|s
init|=
operator|(
name|String
operator|)
name|o1
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|AuthorList
operator|.
name|parse
argument_list|(
name|s
argument_list|)
operator|.
name|getNumberOfAuthors
argument_list|()
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|/**          * Pops the top of the stack but doesn't print it; this gets rid of          * an unwanted stack literal.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"pop$"
argument_list|,
name|context
lambda|->
name|stack
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
comment|/**          * The |built_in| function {\.{preamble\$}} pushes onto the stack          * the concatenation of all the \.{preamble} strings read from the          * database files. (or the empty string if there where none)          *          * @PREAMBLE strings read from the database files.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"preamble$"
argument_list|,
name|context
lambda|->
block|{
name|stack
operator|.
name|push
argument_list|(
name|preamble
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|/**          * Pops the top (string) literal, removes nonalphanumeric characters          * except for white-space characters and hyphens and ties (these all get          * converted to a space), removes certain alphabetic characters          * contained in the control sequences associated with a \special          * character", and pushes the resulting string.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"purify$"
argument_list|,
operator|new
name|PurifyFunction
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
comment|/**          * Pushes the string consisting of the double-quote character.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"quote$"
argument_list|,
name|context
lambda|->
name|stack
operator|.
name|push
argument_list|(
literal|"\""
argument_list|)
argument_list|)
expr_stmt|;
comment|/**          * Is a no-op.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"skip$"
argument_list|,
name|context
lambda|->
block|{
comment|// Nothing to do! Yeah!
block|}
argument_list|)
expr_stmt|;
comment|/**          * Pops and prints the whole stack; it's meant to be used for style          * designers while debugging.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"stack$"
argument_list|,
name|context
lambda|->
block|{
while|while
condition|(
operator|!
name|stack
operator|.
name|empty
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Stack entry"
argument_list|,
name|stack
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|/**          * Pops the top three literals (they are the two integers literals          * len and start, and a string literal, in that order). It pushes          * the substring of the (at most) len consecutive characters          * starting at the startth character (assuming 1-based indexing) if          * start is positive, and ending at the start-th character          * (including) from the end if start is negative (where the first          * character from the end is the last character).          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"substring$"
argument_list|,
name|context
lambda|->
name|substringFunction
argument_list|()
argument_list|)
expr_stmt|;
comment|/**          * Swaps the top two literals on the stack. text.length$ Pops the          * top (string) literal, and pushes the number of text characters          * it contains, where an accented character (more precisely, a          * \special character", defined in Section 4) counts as a single          * text character, even if it's missing its matching right brace,          * and where braces don't count as text characters.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"swap$"
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation swap$"
argument_list|)
throw|;
block|}
name|Object
name|f1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|f2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|f1
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|f2
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|/**          * text.length$ Pops the top (string) literal, and pushes the number          * of text characters it contains, where an accented character (more          * precisely, a "special character", defined in Section 4) counts as          * a single text character, even if it's missing its matching right          * brace, and where braces don't count as text characters.          *          * From BibTeXing: For the purposes of counting letters in labels,          * BibTEX considers everything contained inside the braces as a          * single letter.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"text.length$"
argument_list|,
name|context
lambda|->
name|textLengthFunction
argument_list|()
argument_list|)
expr_stmt|;
comment|/**          * Pops the top two literals (the integer literal len and a string          * literal, in that order). It pushes the substring of the (at most) len          * consecutive text characters starting from the beginning of the          * string. This function is similar to substring$, but this one          * considers a \special character", even if it's missing its matching          * right brace, to be a single text character (rather than however many          * ASCII characters it actually comprises), and this function doesn't          * consider braces to be text characters; furthermore, this function          * appends any needed matching right braces.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"text.prefix$"
argument_list|,
operator|new
name|TextPrefixFunction
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
comment|/**          * Pops and prints the top of the stack to the log file. It's useful for debugging.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"top$"
argument_list|,
name|context
lambda|->
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Stack entry"
argument_list|,
name|stack
operator|.
name|pop
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/**          * Pushes the current entry's type (book, article, etc.), but pushes          * the null string if the type is either unknown or undefined.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"type$"
argument_list|,
name|context
lambda|->
block|{
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"type$ need a context."
argument_list|)
throw|;
block|}
name|stack
operator|.
name|push
argument_list|(
name|context
operator|.
name|getBibtexEntry
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|/**          * Pops the top (string) literal and prints it following a warning          * message. This also increments a count of the number of warning          * messages issued.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"warning$"
argument_list|,
operator|new
name|BstFunction
argument_list|()
block|{
name|int
name|warning
init|=
literal|1
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Warning (#"
operator|+
operator|(
name|warning
operator|++
operator|)
operator|+
literal|"): "
operator|+
name|stack
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|/**          * Pops the top two (function) literals, and keeps executing the          * second as long as the (integer) literal left on the stack by          * executing the first is greater than 0.          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"while$"
argument_list|,
name|this
operator|::
name|whileFunction
argument_list|)
expr_stmt|;
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"width$"
argument_list|,
operator|new
name|WidthFunction
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
comment|/**          * Pops the top (string) literal and writes it on the output buffer          * (which will result in stuff being written onto the bbl file when          * the buffer fills up).          */
name|buildInFunctions
operator|.
name|put
argument_list|(
literal|"write$"
argument_list|,
name|context
lambda|->
block|{
name|String
name|s
init|=
operator|(
name|String
operator|)
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|VM
operator|.
name|this
operator|.
name|bbl
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|textLengthFunction ()
specifier|private
name|void
name|textLengthFunction
parameter_list|()
block|{
if|if
condition|(
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation text.length$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|String
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only perform operation on a string text.length$"
argument_list|)
throw|;
block|}
name|String
name|s
init|=
operator|(
name|String
operator|)
name|o1
decl_stmt|;
name|char
index|[]
name|c
init|=
name|s
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|// Comments from bibtex.web:
comment|// sp_ptr := str_start[pop_lit1];
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|// sp_end := str_start[pop_lit1+1];
name|int
name|n
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// sp_brace_level := 0;
name|int
name|braceLevel
init|=
literal|0
decl_stmt|;
comment|// while (sp_ptr< sp_end) do begin
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
comment|// incr(sp_ptr);
name|i
operator|++
expr_stmt|;
comment|// if (str_pool[sp_ptr-1] = left_brace) then
comment|// begin
if|if
condition|(
name|c
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'{'
condition|)
block|{
comment|// incr(sp_brace_level);
name|braceLevel
operator|++
expr_stmt|;
comment|// if ((sp_brace_level = 1) and (sp_ptr< sp_end)) then
if|if
condition|(
operator|(
name|braceLevel
operator|==
literal|1
operator|)
operator|&&
operator|(
name|i
operator|<
name|n
operator|)
condition|)
block|{
comment|// if (str_pool[sp_ptr] = backslash) then
comment|// begin
if|if
condition|(
name|c
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
comment|// incr(sp_ptr); {skip over the |backslash|}
name|i
operator|++
expr_stmt|;
comment|// skip over backslash
comment|// while ((sp_ptr< sp_end) and (sp_brace_level
comment|//> 0)) do begin
while|while
condition|(
operator|(
name|i
operator|<
name|n
operator|)
operator|&&
operator|(
name|braceLevel
operator|>
literal|0
operator|)
condition|)
block|{
comment|// if (str_pool[sp_ptr] = right_brace) then
if|if
condition|(
name|c
index|[
name|i
index|]
operator|==
literal|'}'
condition|)
block|{
comment|// decr(sp_brace_level)
name|braceLevel
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
index|[
name|i
index|]
operator|==
literal|'{'
condition|)
block|{
comment|// incr(sp_brace_level);
name|braceLevel
operator|++
expr_stmt|;
block|}
comment|// incr(sp_ptr);
name|i
operator|++
expr_stmt|;
comment|// end;
block|}
comment|// incr(num_text_chars);
name|result
operator|++
expr_stmt|;
comment|// end;
block|}
comment|// end
block|}
block|}
comment|// else if (str_pool[sp_ptr-1] = right_brace) then
comment|// begin
elseif|else
if|if
condition|(
name|c
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
comment|// if (sp_brace_level> 0) then
if|if
condition|(
name|braceLevel
operator|>
literal|0
condition|)
block|{
comment|// decr(sp_brace_level);
name|braceLevel
operator|--
expr_stmt|;
comment|// end
block|}
block|}
else|else
block|{
comment|// else
comment|// incr(num_text_chars);
name|result
operator|++
expr_stmt|;
block|}
block|}
name|stack
operator|.
name|push
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|whileFunction (BstEntry context)
specifier|private
name|void
name|whileFunction
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation while$"
argument_list|)
throw|;
block|}
name|Object
name|f2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|f1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|f1
operator|instanceof
name|Identifier
operator|)
operator|||
operator|(
name|f1
operator|instanceof
name|Tree
operator|)
operator|)
operator|&&
operator|(
operator|(
name|f2
operator|instanceof
name|Identifier
operator|)
operator|||
operator|(
name|f2
operator|instanceof
name|Tree
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Expecting two functions for while$."
argument_list|)
throw|;
block|}
do|do
block|{
name|VM
operator|.
name|this
operator|.
name|executeInContext
argument_list|(
name|f1
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|Object
name|i
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|instanceof
name|Integer
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"First parameter to while has to return an integer but was "
operator|+
name|i
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|Integer
operator|)
name|i
operator|<=
literal|0
condition|)
block|{
break|break;
block|}
name|VM
operator|.
name|this
operator|.
name|executeInContext
argument_list|(
name|f2
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|true
condition|)
do|;
block|}
DECL|method|substringFunction ()
specifier|private
name|void
name|substringFunction
parameter_list|()
block|{
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<
literal|3
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation substring$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|o2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Object
name|o3
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|o1
operator|instanceof
name|Integer
operator|)
operator|&&
operator|(
name|o2
operator|instanceof
name|Integer
operator|)
operator|&&
operator|(
name|o3
operator|instanceof
name|String
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Expecting two integers and a string for substring$"
argument_list|)
throw|;
block|}
name|Integer
name|len
init|=
operator|(
name|Integer
operator|)
name|o1
decl_stmt|;
name|Integer
name|start
init|=
operator|(
name|Integer
operator|)
name|o2
decl_stmt|;
name|int
name|lenI
init|=
name|len
decl_stmt|;
name|int
name|startI
init|=
name|start
decl_stmt|;
if|if
condition|(
name|lenI
operator|>
operator|(
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|2
operator|)
condition|)
block|{
name|lenI
operator|=
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|startI
operator|>
operator|(
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|2
operator|)
condition|)
block|{
name|startI
operator|=
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|startI
operator|<
operator|(
name|Integer
operator|.
name|MIN_VALUE
operator|/
literal|2
operator|)
condition|)
block|{
name|startI
operator|=
operator|-
name|Integer
operator|.
name|MIN_VALUE
operator|/
literal|2
expr_stmt|;
block|}
name|String
name|s
init|=
operator|(
name|String
operator|)
name|o3
decl_stmt|;
if|if
condition|(
name|startI
operator|<
literal|0
condition|)
block|{
name|startI
operator|+=
name|s
operator|.
name|length
argument_list|()
operator|+
literal|1
expr_stmt|;
name|startI
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
operator|(
name|startI
operator|+
literal|1
operator|)
operator|-
name|lenI
argument_list|)
expr_stmt|;
block|}
name|stack
operator|.
name|push
argument_list|(
name|s
operator|.
name|substring
argument_list|(
name|startI
operator|-
literal|1
argument_list|,
name|Math
operator|.
name|min
argument_list|(
operator|(
name|startI
operator|-
literal|1
operator|)
operator|+
name|lenI
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|addPeriodFunction ()
specifier|private
name|void
name|addPeriodFunction
parameter_list|()
block|{
if|if
condition|(
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Not enough operands on stack for operation add.period$"
argument_list|)
throw|;
block|}
name|Object
name|o1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|String
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Can only add a period to a string for add.period$"
argument_list|)
throw|;
block|}
name|String
name|s
init|=
operator|(
name|String
operator|)
name|o1
decl_stmt|;
name|Matcher
name|m
init|=
name|ADD_PERIOD_PATTERN
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|m
operator|.
name|appendReplacement
argument_list|(
name|sb
argument_list|,
name|m
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|String
name|group2
init|=
name|m
operator|.
name|group
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|group2
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|m
operator|.
name|group
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stack
operator|.
name|push
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stack
operator|.
name|push
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|charStream2CommonTree (CharStream bst)
specifier|private
specifier|static
name|CommonTree
name|charStream2CommonTree
parameter_list|(
name|CharStream
name|bst
parameter_list|)
throws|throws
name|RecognitionException
block|{
name|BstLexer
name|lex
init|=
operator|new
name|BstLexer
argument_list|(
name|bst
argument_list|)
decl_stmt|;
name|CommonTokenStream
name|tokens
init|=
operator|new
name|CommonTokenStream
argument_list|(
name|lex
argument_list|)
decl_stmt|;
name|BstParser
name|parser
init|=
operator|new
name|BstParser
argument_list|(
name|tokens
argument_list|)
decl_stmt|;
name|BstParser
operator|.
name|program_return
name|r
init|=
name|parser
operator|.
name|program
argument_list|()
decl_stmt|;
return|return
operator|(
name|CommonTree
operator|)
name|r
operator|.
name|getTree
argument_list|()
return|;
block|}
DECL|method|assign (BstEntry context, Object o1, Object o2)
specifier|private
name|boolean
name|assign
parameter_list|(
name|BstEntry
name|context
parameter_list|,
name|Object
name|o1
parameter_list|,
name|Object
name|o2
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o1
operator|instanceof
name|Identifier
operator|)
operator|||
operator|!
operator|(
operator|(
name|o2
operator|instanceof
name|String
operator|)
operator|||
operator|(
name|o2
operator|instanceof
name|Integer
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|VMException
argument_list|(
literal|"Invalid parameters"
argument_list|)
throw|;
block|}
name|String
name|name
init|=
operator|(
operator|(
name|Identifier
operator|)
name|o1
operator|)
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|o2
operator|instanceof
name|String
condition|)
block|{
if|if
condition|(
operator|(
name|context
operator|!=
literal|null
operator|)
operator|&&
name|context
operator|.
name|localStrings
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|context
operator|.
name|localStrings
operator|.
name|put
argument_list|(
name|name
argument_list|,
operator|(
name|String
operator|)
name|o2
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|strings
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|strings
operator|.
name|put
argument_list|(
name|name
argument_list|,
operator|(
name|String
operator|)
name|o2
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|(
name|context
operator|!=
literal|null
operator|)
operator|&&
name|context
operator|.
name|localIntegers
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|context
operator|.
name|localIntegers
operator|.
name|put
argument_list|(
name|name
argument_list|,
operator|(
name|Integer
operator|)
name|o2
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|integers
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|integers
operator|.
name|put
argument_list|(
name|name
argument_list|,
operator|(
name|Integer
operator|)
name|o2
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|run (BibDatabase db)
specifier|public
name|String
name|run
parameter_list|(
name|BibDatabase
name|db
parameter_list|)
block|{
name|preamble
operator|=
name|db
operator|.
name|getPreamble
argument_list|()
operator|.
name|orElse
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
name|run
argument_list|(
name|db
operator|.
name|getEntries
argument_list|()
argument_list|)
return|;
block|}
DECL|method|run (Collection<BibEntry> bibtex)
specifier|public
name|String
name|run
parameter_list|(
name|Collection
argument_list|<
name|BibEntry
argument_list|>
name|bibtex
parameter_list|)
block|{
comment|// Reset
name|bbl
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
name|strings
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|integers
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|integers
operator|.
name|put
argument_list|(
literal|"entry.max$"
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|integers
operator|.
name|put
argument_list|(
literal|"global.max$"
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|functions
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|functions
operator|.
name|putAll
argument_list|(
name|buildInFunctions
argument_list|)
expr_stmt|;
name|stack
operator|=
operator|new
name|Stack
argument_list|<>
argument_list|()
expr_stmt|;
comment|// Create entries
name|entries
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|bibtex
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|ListIterator
argument_list|<
name|BstEntry
argument_list|>
name|listIter
init|=
name|entries
operator|.
name|listIterator
argument_list|()
decl_stmt|;
for|for
control|(
name|BibEntry
name|entry
range|:
name|bibtex
control|)
block|{
name|listIter
operator|.
name|add
argument_list|(
operator|new
name|BstEntry
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Go
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tree
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Tree
name|child
init|=
name|tree
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|BstParser
operator|.
name|STRINGS
case|:
name|strings
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|INTEGERS
case|:
name|integers
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|FUNCTION
case|:
name|function
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|EXECUTE
case|:
name|execute
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|SORT
case|:
name|sort
argument_list|()
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|ITERATE
case|:
name|iterate
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|REVERSE
case|:
name|reverse
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|ENTRY
case|:
name|entry
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|READ
case|:
name|read
argument_list|()
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|MACRO
case|:
name|macro
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LOGGER
operator|.
name|info
argument_list|(
literal|"Unknown type: "
operator|+
name|child
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|bbl
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Dredges up from the database file the field values for each entry in the      * list. It has no arguments. If a database entry doesn't have a value for a      * field (and probably no database entry will have a value for every field),      * that field variable is marked as missing for the entry.      *      * We use null for the missing entry designator.      */
DECL|method|read ()
specifier|private
name|void
name|read
parameter_list|()
block|{
for|for
control|(
name|BstEntry
name|e
range|:
name|entries
control|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mEntry
range|:
name|e
operator|.
name|getFields
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|fieldValue
init|=
name|e
operator|.
name|getBibtexEntry
argument_list|()
operator|.
name|getField
argument_list|(
name|mEntry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|mEntry
operator|.
name|setValue
argument_list|(
name|fieldValue
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|BstEntry
name|e
range|:
name|entries
control|)
block|{
if|if
condition|(
operator|!
name|e
operator|.
name|getFields
argument_list|()
operator|.
name|containsKey
argument_list|(
name|FieldName
operator|.
name|CROSSREF
argument_list|)
condition|)
block|{
name|e
operator|.
name|getFields
argument_list|()
operator|.
name|put
argument_list|(
name|FieldName
operator|.
name|CROSSREF
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Defines a string macro. It has two arguments; the first is the macro's      * name, which is treated like any other variable or function name, and the      * second is its definition, which must be double-quote-delimited. You must      * have one for each three-letter month abbreviation; in addition, you      * should have one for common journal names. The user's database may      * override any definition you define using this command. If you want to      * define a string the user can't touch, use the FUNCTION command, which has      * a compatible syntax.      *      * @param child      */
DECL|method|macro (Tree child)
specifier|private
name|void
name|macro
parameter_list|(
name|Tree
name|child
parameter_list|)
block|{
name|String
name|name
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
name|replacement
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|functions
operator|.
name|put
argument_list|(
name|name
argument_list|,
operator|new
name|MacroFunction
argument_list|(
name|replacement
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|class|MacroFunction
specifier|public
class|class
name|MacroFunction
implements|implements
name|BstFunction
block|{
DECL|field|replacement
specifier|private
specifier|final
name|String
name|replacement
decl_stmt|;
DECL|method|MacroFunction (String replacement)
specifier|public
name|MacroFunction
parameter_list|(
name|String
name|replacement
parameter_list|)
block|{
name|this
operator|.
name|replacement
operator|=
name|replacement
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|execute (BstEntry context)
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
name|VM
operator|.
name|this
operator|.
name|push
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Declares the fields and entry variables. It has three arguments, each a      * (possibly empty) list of variable names. The three lists are of: fields,      * integer entry variables, and string entry variables. There is an      * additional field that BibTEX automatically declares, crossref, used for      * cross referencing. And there is an additional string entry variable      * automatically declared, sort.key$, used by the SORT command. Each of      * these variables has a value for each entry on the list.      */
DECL|method|entry (Tree child)
specifier|private
name|void
name|entry
parameter_list|(
name|Tree
name|child
parameter_list|)
block|{
comment|// Fields first
name|Tree
name|t
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|t
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|t
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
for|for
control|(
name|BstEntry
name|entry
range|:
name|entries
control|)
block|{
name|entry
operator|.
name|getFields
argument_list|()
operator|.
name|put
argument_list|(
name|name
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Integers
name|t
operator|=
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|t
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|t
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
for|for
control|(
name|BstEntry
name|entry
range|:
name|entries
control|)
block|{
name|entry
operator|.
name|localIntegers
operator|.
name|put
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Strings
name|t
operator|=
name|child
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|t
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|t
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
for|for
control|(
name|BstEntry
name|entry
range|:
name|entries
control|)
block|{
name|entry
operator|.
name|localStrings
operator|.
name|put
argument_list|(
name|name
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|BstEntry
name|entry
range|:
name|entries
control|)
block|{
name|entry
operator|.
name|localStrings
operator|.
name|put
argument_list|(
literal|"sort.key$"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|reverse (Tree child)
specifier|private
name|void
name|reverse
parameter_list|(
name|Tree
name|child
parameter_list|)
block|{
name|BstFunction
name|f
init|=
name|functions
operator|.
name|get
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|ListIterator
argument_list|<
name|BstEntry
argument_list|>
name|i
init|=
name|entries
operator|.
name|listIterator
argument_list|(
name|entries
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasPrevious
argument_list|()
condition|)
block|{
name|f
operator|.
name|execute
argument_list|(
name|i
operator|.
name|previous
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|iterate (Tree child)
specifier|private
name|void
name|iterate
parameter_list|(
name|Tree
name|child
parameter_list|)
block|{
name|BstFunction
name|f
init|=
name|functions
operator|.
name|get
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|BstEntry
name|entry
range|:
name|entries
control|)
block|{
name|f
operator|.
name|execute
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Sorts the entry list using the values of the string entry variable sort.key$. It has no arguments.      */
DECL|method|sort ()
specifier|private
name|void
name|sort
parameter_list|()
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|entries
argument_list|,
parameter_list|(
name|o1
parameter_list|,
name|o2
parameter_list|)
lambda|->
operator|(
name|o1
operator|.
name|localStrings
operator|.
name|get
argument_list|(
literal|"sort.key$"
argument_list|)
operator|)
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|localStrings
operator|.
name|get
argument_list|(
literal|"sort.key$"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|executeInContext (Object o, BstEntry context)
specifier|private
name|void
name|executeInContext
parameter_list|(
name|Object
name|o
parameter_list|,
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Tree
condition|)
block|{
name|Tree
name|t
init|=
operator|(
name|Tree
operator|)
name|o
decl_stmt|;
operator|new
name|StackFunction
argument_list|(
name|t
argument_list|)
operator|.
name|execute
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Identifier
condition|)
block|{
name|execute
argument_list|(
operator|(
operator|(
name|Identifier
operator|)
name|o
operator|)
operator|.
name|getName
argument_list|()
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|execute (Tree child)
specifier|private
name|void
name|execute
parameter_list|(
name|Tree
name|child
parameter_list|)
block|{
name|execute
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|class|StackFunction
specifier|public
class|class
name|StackFunction
implements|implements
name|BstFunction
block|{
DECL|field|localTree
specifier|private
specifier|final
name|Tree
name|localTree
decl_stmt|;
DECL|method|StackFunction (Tree stack)
specifier|public
name|StackFunction
parameter_list|(
name|Tree
name|stack
parameter_list|)
block|{
name|localTree
operator|=
name|stack
expr_stmt|;
block|}
DECL|method|getTree ()
specifier|public
name|Tree
name|getTree
parameter_list|()
block|{
return|return
name|localTree
return|;
block|}
annotation|@
name|Override
DECL|method|execute (BstEntry context)
specifier|public
name|void
name|execute
parameter_list|(
name|BstEntry
name|context
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|localTree
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Tree
name|c
init|=
name|localTree
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
try|try
block|{
switch|switch
condition|(
name|c
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|BstParser
operator|.
name|STRING
case|:
name|String
name|s
init|=
name|c
operator|.
name|getText
argument_list|()
decl_stmt|;
name|push
argument_list|(
name|s
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|INTEGER
case|:
name|push
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|c
operator|.
name|getText
argument_list|()
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|QUOTED
case|:
name|push
argument_list|(
operator|new
name|Identifier
argument_list|(
name|c
operator|.
name|getText
argument_list|()
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BstParser
operator|.
name|STACK
case|:
name|push
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
name|VM
operator|.
name|this
operator|.
name|execute
argument_list|(
name|c
operator|.
name|getText
argument_list|()
argument_list|,
name|context
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|VMException
name|e
parameter_list|)
block|{
if|if
condition|(
name|file
operator|==
literal|null
condition|)
block|{
name|LOGGER
operator|.
name|error
argument_list|(
literal|"ERROR "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|" ("
operator|+
name|c
operator|.
name|getLine
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOGGER
operator|.
name|error
argument_list|(
literal|"ERROR "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|" ("
operator|+
name|file
operator|.
name|getPath
argument_list|()
operator|+
literal|":"
operator|+
name|c
operator|.
name|getLine
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
block|}
block|}
DECL|method|push (Tree t)
specifier|private
name|void
name|push
parameter_list|(
name|Tree
name|t
parameter_list|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
DECL|method|execute (String name, BstEntry context)
specifier|private
name|void
name|execute
parameter_list|(
name|String
name|name
parameter_list|,
name|BstEntry
name|context
parameter_list|)
block|{
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|getFields
argument_list|()
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|context
operator|.
name|getFields
argument_list|()
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|context
operator|.
name|localStrings
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|context
operator|.
name|localStrings
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|context
operator|.
name|localIntegers
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|context
operator|.
name|localIntegers
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|strings
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|strings
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|integers
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|integers
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|functions
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|// OK to have a null context
name|functions
operator|.
name|get
argument_list|(
name|name
argument_list|)
operator|.
name|execute
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return;
block|}
throw|throw
operator|new
name|VMException
argument_list|(
literal|"No matching identifier found: "
operator|+
name|name
argument_list|)
throw|;
block|}
DECL|method|function (Tree child)
specifier|private
name|void
name|function
parameter_list|(
name|Tree
name|child
parameter_list|)
block|{
name|String
name|name
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|Tree
name|localStack
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|functions
operator|.
name|put
argument_list|(
name|name
argument_list|,
operator|new
name|StackFunction
argument_list|(
name|localStack
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Declares global integer variables. It has one argument, a list of      * variable names. There are two such automatically-declared variables,      * entry.max$ and global.max$, used for limiting the lengths of string vari-      * ables. You may have any number of these commands, but a variable's      * declaration must precede its use.      *      * @param child      */
DECL|method|integers (Tree child)
specifier|private
name|void
name|integers
parameter_list|(
name|Tree
name|child
parameter_list|)
block|{
name|Tree
name|t
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|t
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|t
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|integers
operator|.
name|put
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Declares global string variables. It has one argument, a list of variable      * names. You may have any number of these commands, but a variable's      * declaration must precede its use.      *      * @param child      */
DECL|method|strings (Tree child)
specifier|private
name|void
name|strings
parameter_list|(
name|Tree
name|child
parameter_list|)
block|{
name|Tree
name|t
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|t
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|t
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|strings
operator|.
name|put
argument_list|(
name|name
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|BstEntry
specifier|public
specifier|static
class|class
name|BstEntry
block|{
DECL|field|entry
specifier|private
specifier|final
name|BibEntry
name|entry
decl_stmt|;
DECL|field|localStrings
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|localStrings
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|fields
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|fields
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|localIntegers
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|localIntegers
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|BstEntry (BibEntry e)
specifier|public
name|BstEntry
parameter_list|(
name|BibEntry
name|e
parameter_list|)
block|{
name|this
operator|.
name|entry
operator|=
name|e
expr_stmt|;
block|}
DECL|method|getFields ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getFields
parameter_list|()
block|{
return|return
name|fields
return|;
block|}
DECL|method|getBibtexEntry ()
specifier|public
name|BibEntry
name|getBibtexEntry
parameter_list|()
block|{
return|return
name|entry
return|;
block|}
block|}
DECL|method|push (Integer integer)
specifier|private
name|void
name|push
parameter_list|(
name|Integer
name|integer
parameter_list|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|integer
argument_list|)
expr_stmt|;
block|}
DECL|method|push (String string)
specifier|private
name|void
name|push
parameter_list|(
name|String
name|string
parameter_list|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
DECL|method|push (Identifier identifier)
specifier|private
name|void
name|push
parameter_list|(
name|Identifier
name|identifier
parameter_list|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
block|}
DECL|method|getStrings ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getStrings
parameter_list|()
block|{
return|return
name|strings
return|;
block|}
DECL|method|getIntegers ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|getIntegers
parameter_list|()
block|{
return|return
name|integers
return|;
block|}
DECL|method|getEntries ()
specifier|public
name|List
argument_list|<
name|BstEntry
argument_list|>
name|getEntries
parameter_list|()
block|{
return|return
name|entries
return|;
block|}
DECL|method|getFunctions ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|BstFunction
argument_list|>
name|getFunctions
parameter_list|()
block|{
return|return
name|functions
return|;
block|}
DECL|method|getStack ()
specifier|public
name|Stack
argument_list|<
name|Object
argument_list|>
name|getStack
parameter_list|()
block|{
return|return
name|stack
return|;
block|}
annotation|@
name|Override
DECL|method|warn (String string)
specifier|public
name|void
name|warn
parameter_list|(
name|String
name|string
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

