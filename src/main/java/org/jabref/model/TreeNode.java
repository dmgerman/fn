begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.jabref.model
package|package
name|org
operator|.
name|jabref
operator|.
name|model
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|javafx
operator|.
name|collections
operator|.
name|FXCollections
import|;
end_import

begin_import
import|import
name|javafx
operator|.
name|collections
operator|.
name|ObservableList
import|;
end_import

begin_comment
comment|/**  * Represents a node in a tree.  *<p>  * Usually, tree nodes have a value property which allows access to the value stored in the node.  * In contrast to this approach, the TreeNode<T> class is designed to be used as a base class which provides the  * tree traversing functionality via inheritance.  *<p>  * Example usage:  * private class BasicTreeNode extends TreeNode<BasicTreeNode> {  * public BasicTreeNode() {  * super(BasicTreeNode.class);  * }  * }  *<p>  * This class started out as a copy of javax.swing.tree.DefaultMutableTreeNode.  *  * @param<T> the type of the class  */
end_comment

begin_comment
comment|// We use some explicit casts of the form "(T) this". The constructor ensures that this cast is valid.
end_comment

begin_class
DECL|class|TreeNode
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|abstract
class|class
name|TreeNode
parameter_list|<
name|T
extends|extends
name|TreeNode
parameter_list|<
name|T
parameter_list|>
parameter_list|>
block|{
comment|/**      * Array of children, may be empty if this node has no children (but never null)      */
DECL|field|children
specifier|private
specifier|final
name|ObservableList
argument_list|<
name|T
argument_list|>
name|children
decl_stmt|;
comment|/**      * This node's parent, or null if this node has no parent      */
DECL|field|parent
specifier|private
name|T
name|parent
decl_stmt|;
comment|/**      * The function which is invoked when something changed in the subtree.      */
DECL|field|onDescendantChanged
specifier|private
name|Consumer
argument_list|<
name|T
argument_list|>
name|onDescendantChanged
init|=
name|t
lambda|->
block|{
comment|/* Do nothing */
block|}
decl_stmt|;
comment|/**      * Constructs a tree node without parent and no children.      *      * @param derivingClass class deriving from TreeNode<T>. It should always be "T.class".      *                      We need this parameter since it is hard to get this information by other means.      */
DECL|method|TreeNode (Class<T> derivingClass)
specifier|public
name|TreeNode
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|derivingClass
parameter_list|)
block|{
name|parent
operator|=
literal|null
expr_stmt|;
name|children
operator|=
name|FXCollections
operator|.
name|observableArrayList
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|derivingClass
operator|.
name|isInstance
argument_list|(
name|this
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"The class extending TreeNode<T> has to derive from T"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Get the path from the root node to this node.      *<p>      * The elements in the returned list represent the child index of each node in the path, starting at the root.      * If this node is the root node, the returned list has zero elements.      *      * @return a list of numbers which represent an indexed path from the root node to this node      */
DECL|method|getIndexedPathFromRoot ()
specifier|public
name|List
argument_list|<
name|Integer
argument_list|>
name|getIndexedPathFromRoot
parameter_list|()
block|{
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|()
return|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|path
init|=
name|parent
operator|.
name|getIndexedPathFromRoot
argument_list|()
decl_stmt|;
name|path
operator|.
name|add
argument_list|(
name|getPositionInParent
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
comment|/**      * Get the descendant of this node as indicated by the indexedPath.      *<p>      * If the path could not be traversed completely (i.e. one of the child indices did not exist),      * an empty Optional will be returned.      *      * @param indexedPath sequence of child indices that describe a path from this node to one of its descendants.      *                    Be aware that if indexedPath was obtained by getIndexedPathFromRoot(), this node should      *                    usually be the root node.      * @return descendant found by evaluating indexedPath      */
DECL|method|getDescendant (List<Integer> indexedPath)
specifier|public
name|Optional
argument_list|<
name|T
argument_list|>
name|getDescendant
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|indexedPath
parameter_list|)
block|{
name|T
name|cursor
init|=
operator|(
name|T
operator|)
name|this
decl_stmt|;
for|for
control|(
name|int
name|index
range|:
name|indexedPath
control|)
block|{
name|Optional
argument_list|<
name|T
argument_list|>
name|child
init|=
name|cursor
operator|.
name|getChildAt
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|cursor
operator|=
name|child
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
else|else
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
block|}
return|return
name|Optional
operator|.
name|of
argument_list|(
name|cursor
argument_list|)
return|;
block|}
comment|/**      * Get the child index of this node in its parent.      *<p>      * If this node is a root, then an UnsupportedOperationException is thrown.      * Use the isRoot method to check for this case.      *      * @return the child index of this node in its parent      */
DECL|method|getPositionInParent ()
specifier|public
name|int
name|getPositionInParent
parameter_list|()
block|{
return|return
name|getParent
argument_list|()
operator|.
name|orElseThrow
argument_list|(
parameter_list|()
lambda|->
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Roots have no position in parent"
argument_list|)
argument_list|)
operator|.
name|getIndexOfChild
argument_list|(
operator|(
name|T
operator|)
name|this
argument_list|)
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**      * Gets the index of the specified child in this node's child list.      *<p>      * If the specified node is not a child of this node, returns an empty Optional.      * This method performs a linear search and is O(n) where n is the number of children.      *      * @param childNode the node to search for among this node's children      * @return an integer giving the index of the node in this node's child list      * or an empty Optional if the specified node is a not a child of this node      * @throws NullPointerException if childNode is null      */
DECL|method|getIndexOfChild (T childNode)
specifier|public
name|Optional
argument_list|<
name|Integer
argument_list|>
name|getIndexOfChild
parameter_list|(
name|T
name|childNode
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|childNode
argument_list|)
expr_stmt|;
name|int
name|index
init|=
name|children
operator|.
name|indexOf
argument_list|(
name|childNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|Optional
operator|.
name|of
argument_list|(
name|index
argument_list|)
return|;
block|}
block|}
comment|/**      * Gets the number of levels above this node, i.e. the distance from the root to this node.      *<p>      * If this node is the root, returns 0.      *      * @return an int giving the number of levels above this node      */
DECL|method|getLevel ()
specifier|public
name|int
name|getLevel
parameter_list|()
block|{
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|parent
operator|.
name|getLevel
argument_list|()
operator|+
literal|1
return|;
block|}
comment|/**      * Returns the number of children of this node.      *      * @return an int giving the number of children of this node      */
DECL|method|getNumberOfChildren ()
specifier|public
name|int
name|getNumberOfChildren
parameter_list|()
block|{
return|return
name|children
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Removes this node from its parent and makes it a child of the specified node      * by adding it to the end of children list.      * In this way the whole subtree based at this node is moved to the given node.      *      * @param target the new parent      * @throws NullPointerException           if target is null      * @throws ArrayIndexOutOfBoundsException if targetIndex is out of bounds      * @throws UnsupportedOperationException  if target is an descendant of this node      */
DECL|method|moveTo (T target)
specifier|public
name|void
name|moveTo
parameter_list|(
name|T
name|target
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|Optional
argument_list|<
name|T
argument_list|>
name|oldParent
init|=
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldParent
operator|.
name|isPresent
argument_list|()
operator|&&
operator|(
name|oldParent
operator|.
name|get
argument_list|()
operator|==
name|target
operator|)
condition|)
block|{
name|this
operator|.
name|moveTo
argument_list|(
name|target
argument_list|,
name|target
operator|.
name|getNumberOfChildren
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|moveTo
argument_list|(
name|target
argument_list|,
name|target
operator|.
name|getNumberOfChildren
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns the path from the root, to get to this node. The last element in the path is this node.      *      * @return a list of nodes giving the path, where the first element in the path is the root      * and the last element is this node.      */
DECL|method|getPathFromRoot ()
specifier|public
name|List
argument_list|<
name|T
argument_list|>
name|getPathFromRoot
parameter_list|()
block|{
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|pathToMe
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|pathToMe
operator|.
name|add
argument_list|(
operator|(
name|T
operator|)
name|this
argument_list|)
expr_stmt|;
return|return
name|pathToMe
return|;
block|}
name|List
argument_list|<
name|T
argument_list|>
name|path
init|=
name|parent
operator|.
name|getPathFromRoot
argument_list|()
decl_stmt|;
name|path
operator|.
name|add
argument_list|(
operator|(
name|T
operator|)
name|this
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
comment|/**      * Returns the next sibling of this node in the parent's children list.      * Returns an empty Optional if this node has no parent or if it is the parent's last child.      *<p>      * This method performs a linear search that is O(n) where n is the number of children.      * To traverse the entire children collection, use the parent's getChildren() instead.      *      * @return the sibling of this node that immediately follows this node      * @see #getChildren      */
DECL|method|getNextSibling ()
specifier|public
name|Optional
argument_list|<
name|T
argument_list|>
name|getNextSibling
parameter_list|()
block|{
return|return
name|getRelativeSibling
argument_list|(
operator|+
literal|1
argument_list|)
return|;
block|}
comment|/**      * Returns the previous sibling of this node in the parent's children list.      * Returns an empty Optional if this node has no parent or is the parent's first child.      *<p>      * This method performs a linear search that is O(n) where n is the number of children.      *      * @return the sibling of this node that immediately precedes this node      * @see #getChildren      */
DECL|method|getPreviousSibling ()
specifier|public
name|Optional
argument_list|<
name|T
argument_list|>
name|getPreviousSibling
parameter_list|()
block|{
return|return
name|getRelativeSibling
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**      * Returns the sibling which is shiftIndex away from this node.      */
DECL|method|getRelativeSibling (int shiftIndex)
specifier|private
name|Optional
argument_list|<
name|T
argument_list|>
name|getRelativeSibling
parameter_list|(
name|int
name|shiftIndex
parameter_list|)
block|{
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
else|else
block|{
name|int
name|indexInParent
init|=
name|getPositionInParent
argument_list|()
decl_stmt|;
name|int
name|indexTarget
init|=
name|indexInParent
operator|+
name|shiftIndex
decl_stmt|;
if|if
condition|(
name|parent
operator|.
name|childIndexExists
argument_list|(
name|indexTarget
argument_list|)
condition|)
block|{
return|return
name|parent
operator|.
name|getChildAt
argument_list|(
name|indexTarget
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
block|}
block|}
comment|/**      * Returns this node's parent or an empty Optional if this node has no parent.      *      * @return this node's parent T, or an empty Optional if this node has no parent      */
DECL|method|getParent ()
specifier|public
name|Optional
argument_list|<
name|T
argument_list|>
name|getParent
parameter_list|()
block|{
return|return
name|Optional
operator|.
name|ofNullable
argument_list|(
name|parent
argument_list|)
return|;
block|}
comment|/**      * Sets the parent node of this node.      *<p>      * This method does not add this node to the children collection of the new parent nor does it remove this node      * from the old parent. You should probably call moveTo or remove to change the tree.      *      * @param parent the new parent      */
DECL|method|setParent (T parent)
specifier|protected
name|void
name|setParent
parameter_list|(
name|T
name|parent
parameter_list|)
block|{
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
block|}
comment|/**      * Returns the child at the specified index in this node's children collection.      *      * @param index an index into this node's children collection      * @return the node in this node's children collection at the specified index,      * or an empty Optional if the index does not point to a child      */
DECL|method|getChildAt (int index)
specifier|public
name|Optional
argument_list|<
name|T
argument_list|>
name|getChildAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|childIndexExists
argument_list|(
name|index
argument_list|)
condition|?
name|Optional
operator|.
name|of
argument_list|(
name|children
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
else|:
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/**      * Returns whether the specified index is a valid index for a child.      *      * @param index the index to be tested      * @return returns true when index is at least 0 and less then the count of children      */
DECL|method|childIndexExists (int index)
specifier|protected
name|boolean
name|childIndexExists
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
operator|(
name|index
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|index
operator|<
name|children
operator|.
name|size
argument_list|()
operator|)
return|;
block|}
comment|/**      * Returns true if this node is the root of the tree.      * The root is the only node in the tree with an empty parent; every tree has exactly one root.      *      * @return true if this node is the root of its tree      */
DECL|method|isRoot ()
specifier|public
name|boolean
name|isRoot
parameter_list|()
block|{
return|return
name|parent
operator|==
literal|null
return|;
block|}
comment|/**      * Returns true if this node is an ancestor of the given node.      *<p>      * A node is considered an ancestor of itself.      *      * @param anotherNode node to test      * @return true if anotherNode is a descendant of this node      * @throws NullPointerException if anotherNode is null      * @see #isNodeDescendant      */
DECL|method|isAncestorOf (T anotherNode)
specifier|public
name|boolean
name|isAncestorOf
parameter_list|(
name|T
name|anotherNode
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|anotherNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|anotherNode
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
for|for
control|(
name|T
name|child
range|:
name|children
control|)
block|{
if|if
condition|(
name|child
operator|.
name|isAncestorOf
argument_list|(
name|anotherNode
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Returns the root of the tree that contains this node. The root is the ancestor with an empty parent.      * Thus a node without a parent is considered its own root.      *      * @return the root of the tree that contains this node      */
DECL|method|getRoot ()
specifier|public
name|T
name|getRoot
parameter_list|()
block|{
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
return|return
operator|(
name|T
operator|)
name|this
return|;
block|}
else|else
block|{
return|return
name|parent
operator|.
name|getRoot
argument_list|()
return|;
block|}
block|}
comment|/**      * Returns true if this node has no children.      *      * @return true if this node has no children      */
DECL|method|isLeaf ()
specifier|public
name|boolean
name|isLeaf
parameter_list|()
block|{
return|return
operator|(
name|getNumberOfChildren
argument_list|()
operator|==
literal|0
operator|)
return|;
block|}
comment|/**      * Removes the subtree rooted at this node from the tree, giving this node an empty parent.      * Does nothing if this node is the root of it tree.      */
DECL|method|removeFromParent ()
specifier|public
name|void
name|removeFromParent
parameter_list|()
block|{
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|removeChild
argument_list|(
operator|(
name|T
operator|)
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Removes all of this node's children, setting their parents to empty.      * If this node has no children, this method does nothing.      */
DECL|method|removeAllChildren ()
specifier|public
name|void
name|removeAllChildren
parameter_list|()
block|{
while|while
condition|(
name|getNumberOfChildren
argument_list|()
operator|>
literal|0
condition|)
block|{
name|removeChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns this node's first child if it exists (otherwise returns an empty Optional).      *      * @return the first child of this node      */
DECL|method|getFirstChild ()
specifier|public
name|Optional
argument_list|<
name|T
argument_list|>
name|getFirstChild
parameter_list|()
block|{
return|return
name|getChildAt
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**      * Returns this node's last child if it exists (otherwise returns an empty Optional).      *      * @return the last child of this node      */
DECL|method|getLastChild ()
specifier|public
name|Optional
argument_list|<
name|T
argument_list|>
name|getLastChild
parameter_list|()
block|{
return|return
name|getChildAt
argument_list|(
name|children
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**      * Returns true if anotherNode is a descendant of this node      * -- if it is this node, one of this node's children, or a descendant of one of this node's children.      * Note that a node is considered a descendant of itself.      *<p>      * If anotherNode is null, an exception is thrown.      *      * @param anotherNode node to test as descendant of this node      * @return true if this node is an ancestor of anotherNode      * @see #isAncestorOf      */
DECL|method|isNodeDescendant (T anotherNode)
specifier|public
name|boolean
name|isNodeDescendant
parameter_list|(
name|T
name|anotherNode
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|anotherNode
argument_list|)
expr_stmt|;
return|return
name|this
operator|.
name|isAncestorOf
argument_list|(
name|anotherNode
argument_list|)
return|;
block|}
comment|/**      * Gets a forward-order list of this node's children.      *<p>      * The returned list is unmodifiable - use the add and remove methods to modify the nodes children.      * However, changing the nodes children (for example by calling moveTo) is reflected in a change of      * the list returned by getChildren. In other words, getChildren provides a read-only view on the children but      * not a copy.      *      * @return a list of this node's children      */
DECL|method|getChildren ()
specifier|public
name|ObservableList
argument_list|<
name|T
argument_list|>
name|getChildren
parameter_list|()
block|{
return|return
name|FXCollections
operator|.
name|unmodifiableObservableList
argument_list|(
name|children
argument_list|)
return|;
block|}
comment|/**      * Removes the given child from this node's child list, giving it an empty parent.      *      * @param child a child of this node to remove      */
DECL|method|removeChild (T child)
specifier|public
name|void
name|removeChild
parameter_list|(
name|T
name|child
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|children
operator|.
name|remove
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|child
operator|.
name|setParent
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|notifyAboutDescendantChange
argument_list|(
operator|(
name|T
operator|)
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes the child at the specified index from this node's children and sets that node's parent to empty.      *<p>      * Does nothing if the index does not point to a child.      *      * @param childIndex the index in this node's child array of the child to remove      */
DECL|method|removeChild (int childIndex)
specifier|public
name|void
name|removeChild
parameter_list|(
name|int
name|childIndex
parameter_list|)
block|{
name|Optional
argument_list|<
name|T
argument_list|>
name|child
init|=
name|getChildAt
argument_list|(
name|childIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|children
operator|.
name|remove
argument_list|(
name|childIndex
argument_list|)
expr_stmt|;
name|child
operator|.
name|get
argument_list|()
operator|.
name|setParent
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|notifyAboutDescendantChange
argument_list|(
operator|(
name|T
operator|)
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds the node at the end the children collection. Also sets the parent of the given node to this node.      * The given node is not allowed to already be in a tree (i.e. it has to have no parent).      *      * @param child the node to add      * @return the child node      */
DECL|method|addChild (T child)
specifier|public
name|T
name|addChild
parameter_list|(
name|T
name|child
parameter_list|)
block|{
return|return
name|addChild
argument_list|(
name|child
argument_list|,
name|children
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Adds the node at the given position in the children collection. Also sets the parent of the given node to this node.      * The given node is not allowed to already be in a tree (i.e. it has to have no parent).      *      * @param child the node to add      * @param index the position where the node should be added      * @return the child node      * @throws IndexOutOfBoundsException if the index is out of range      */
DECL|method|addChild (T child, int index)
specifier|public
name|T
name|addChild
parameter_list|(
name|T
name|child
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getParent
argument_list|()
operator|.
name|isPresent
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot add a node which already has a parent, use moveTo instead"
argument_list|)
throw|;
block|}
name|child
operator|.
name|setParent
argument_list|(
operator|(
name|T
operator|)
name|this
argument_list|)
expr_stmt|;
name|children
operator|.
name|add
argument_list|(
name|index
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|notifyAboutDescendantChange
argument_list|(
operator|(
name|T
operator|)
name|this
argument_list|)
expr_stmt|;
return|return
name|child
return|;
block|}
comment|/**      * Removes all children from this node and makes them a child of the specified node      * by adding it to the specified position in the children list.      *      * @param target      the new parent      * @param targetIndex the position where the children should be inserted      * @throws NullPointerException           if target is null      * @throws ArrayIndexOutOfBoundsException if targetIndex is out of bounds      * @throws UnsupportedOperationException  if target is an descendant of one of the children of this node      */
DECL|method|moveAllChildrenTo (T target, int targetIndex)
specifier|public
name|void
name|moveAllChildrenTo
parameter_list|(
name|T
name|target
parameter_list|,
name|int
name|targetIndex
parameter_list|)
block|{
while|while
condition|(
name|getNumberOfChildren
argument_list|()
operator|>
literal|0
condition|)
block|{
name|getLastChild
argument_list|()
operator|.
name|get
argument_list|()
operator|.
name|moveTo
argument_list|(
name|target
argument_list|,
name|targetIndex
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Sorts the list of children according to the order induced by the specified {@link Comparator}.      *<p>      * All children must be mutually comparable using the specified comparator      * (that is, {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}      * for any children {@code e1} and {@code e2} in the list).      *      * @param comparator the comparator used to compare the child nodes      * @param recursive  if true the whole subtree is sorted      * @throws NullPointerException if the comparator is null      */
DECL|method|sortChildren (Comparator<? super T> comparator, boolean recursive)
specifier|public
name|void
name|sortChildren
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|T
argument_list|>
name|comparator
parameter_list|,
name|boolean
name|recursive
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|isLeaf
argument_list|()
condition|)
block|{
return|return;
comment|// nothing to sort
block|}
name|int
name|j
init|=
name|getNumberOfChildren
argument_list|()
operator|-
literal|1
decl_stmt|;
name|int
name|lastModified
decl_stmt|;
while|while
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|lastModified
operator|=
name|j
operator|+
literal|1
expr_stmt|;
name|j
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|lastModified
condition|;
operator|++
name|i
control|)
block|{
name|T
name|child1
init|=
name|getChildAt
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|get
argument_list|()
decl_stmt|;
name|T
name|child2
init|=
name|getChildAt
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|comparator
operator|.
name|compare
argument_list|(
name|child1
argument_list|,
name|child2
argument_list|)
operator|>
literal|0
condition|)
block|{
name|child1
operator|.
name|moveTo
argument_list|(
operator|(
name|T
operator|)
name|this
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|recursive
condition|)
block|{
for|for
control|(
name|T
name|child
range|:
name|getChildren
argument_list|()
control|)
block|{
name|child
operator|.
name|sortChildren
argument_list|(
name|comparator
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Removes this node from its parent and makes it a child of the specified node      * by adding it to the specified position in the children list.      * In this way the whole subtree based at this node is moved to the given node.      *      * @param target      the new parent      * @param targetIndex the position where the children should be inserted      * @throws NullPointerException           if target is null      * @throws ArrayIndexOutOfBoundsException if targetIndex is out of bounds      * @throws UnsupportedOperationException  if target is an descendant of this node      */
DECL|method|moveTo (T target, int targetIndex)
specifier|public
name|void
name|moveTo
parameter_list|(
name|T
name|target
parameter_list|,
name|int
name|targetIndex
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|// Check that the target node is not an ancestor of this node, because this would create loops in the tree
if|if
condition|(
name|this
operator|.
name|isAncestorOf
argument_list|(
name|target
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"the target cannot be a descendant of this node"
argument_list|)
throw|;
block|}
comment|// Remove from previous parent
name|Optional
argument_list|<
name|T
argument_list|>
name|oldParent
init|=
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldParent
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|oldParent
operator|.
name|get
argument_list|()
operator|.
name|removeChild
argument_list|(
operator|(
name|T
operator|)
name|this
argument_list|)
expr_stmt|;
block|}
comment|// Add as child
name|target
operator|.
name|addChild
argument_list|(
operator|(
name|T
operator|)
name|this
argument_list|,
name|targetIndex
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a deep copy of this node and all of its children.      *      * @return a deep copy of the subtree      */
DECL|method|copySubtree ()
specifier|public
name|T
name|copySubtree
parameter_list|()
block|{
name|T
name|copy
init|=
name|copyNode
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|child
range|:
name|getChildren
argument_list|()
control|)
block|{
name|child
operator|.
name|copySubtree
argument_list|()
operator|.
name|moveTo
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
return|return
name|copy
return|;
block|}
comment|/**      * Creates a copy of this node, completely separated from the tree (i.e. no children and no parent)      *      * @return a deep copy of this node      */
DECL|method|copyNode ()
specifier|public
specifier|abstract
name|T
name|copyNode
parameter_list|()
function_decl|;
comment|/**      * Adds the given function to the list of subscribers which are notified when something changes in the subtree.      *      * The following events are supported (the text in parentheses specifies which node is passed as the source):      *  - addChild (new parent)      *  - removeChild (old parent)      *  - move (old parent and new parent)      * @param subscriber function to be invoked upon a change      */
DECL|method|subscribeToDescendantChanged (Consumer<T> subscriber)
specifier|public
name|void
name|subscribeToDescendantChanged
parameter_list|(
name|Consumer
argument_list|<
name|T
argument_list|>
name|subscriber
parameter_list|)
block|{
name|onDescendantChanged
operator|=
name|onDescendantChanged
operator|.
name|andThen
argument_list|(
name|subscriber
argument_list|)
expr_stmt|;
block|}
comment|/**      * Helper method which notifies all subscribers about a change in the subtree and bubbles the event to all parents.      * @param source the node which changed      */
DECL|method|notifyAboutDescendantChange (T source)
specifier|protected
name|void
name|notifyAboutDescendantChange
parameter_list|(
name|T
name|source
parameter_list|)
block|{
name|onDescendantChanged
operator|.
name|accept
argument_list|(
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isRoot
argument_list|()
condition|)
block|{
name|parent
operator|.
name|notifyAboutDescendantChange
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

