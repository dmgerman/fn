begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.jabref.model.entry
package|package
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|javafx
operator|.
name|beans
operator|.
name|Observable
import|;
end_import

begin_import
import|import
name|javafx
operator|.
name|beans
operator|.
name|binding
operator|.
name|Bindings
import|;
end_import

begin_import
import|import
name|javafx
operator|.
name|beans
operator|.
name|binding
operator|.
name|ObjectBinding
import|;
end_import

begin_import
import|import
name|javafx
operator|.
name|collections
operator|.
name|FXCollections
import|;
end_import

begin_import
import|import
name|javafx
operator|.
name|collections
operator|.
name|ObservableMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|EntryTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|FieldChange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabaseMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|event
operator|.
name|EntryEventSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|event
operator|.
name|FieldAddedOrRemovedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|event
operator|.
name|FieldChangedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|identifier
operator|.
name|DOI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|strings
operator|.
name|LatexToUnicodeAdapter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|strings
operator|.
name|StringUtil
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|eventbus
operator|.
name|EventBus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
DECL|class|BibEntry
specifier|public
class|class
name|BibEntry
implements|implements
name|Cloneable
block|{
DECL|field|TYPE_HEADER
specifier|public
specifier|static
specifier|final
name|String
name|TYPE_HEADER
init|=
literal|"entrytype"
decl_stmt|;
DECL|field|OBSOLETE_TYPE_HEADER
specifier|public
specifier|static
specifier|final
name|String
name|OBSOLETE_TYPE_HEADER
init|=
literal|"bibtextype"
decl_stmt|;
DECL|field|KEY_FIELD
specifier|public
specifier|static
specifier|final
name|String
name|KEY_FIELD
init|=
literal|"bibtexkey"
decl_stmt|;
DECL|field|DEFAULT_TYPE
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_TYPE
init|=
literal|"misc"
decl_stmt|;
DECL|field|ID_FIELD
specifier|protected
specifier|static
specifier|final
name|String
name|ID_FIELD
init|=
literal|"id"
decl_stmt|;
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|BibEntry
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|REMOVE_TRAILING_WHITESPACE
specifier|private
specifier|static
specifier|final
name|Pattern
name|REMOVE_TRAILING_WHITESPACE
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\s+$"
argument_list|)
decl_stmt|;
DECL|field|sharedBibEntryData
specifier|private
specifier|final
name|SharedBibEntryData
name|sharedBibEntryData
decl_stmt|;
comment|/**      * Map to store the words in every field      */
DECL|field|fieldsAsWords
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|fieldsAsWords
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * Cache that stores latex free versions of fields.      */
DECL|field|latexFreeFields
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|latexFreeFields
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|eventBus
specifier|private
specifier|final
name|EventBus
name|eventBus
init|=
operator|new
name|EventBus
argument_list|()
decl_stmt|;
DECL|field|id
specifier|private
name|String
name|id
decl_stmt|;
DECL|field|type
specifier|private
name|String
name|type
decl_stmt|;
DECL|field|fields
specifier|private
name|ObservableMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|fields
init|=
name|FXCollections
operator|.
name|observableMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
comment|// Search and grouping status is stored in boolean fields for quick reference:
DECL|field|searchHit
specifier|private
name|boolean
name|searchHit
decl_stmt|;
DECL|field|groupHit
specifier|private
name|boolean
name|groupHit
decl_stmt|;
DECL|field|parsedSerialization
specifier|private
name|String
name|parsedSerialization
decl_stmt|;
DECL|field|commentsBeforeEntry
specifier|private
name|String
name|commentsBeforeEntry
init|=
literal|""
decl_stmt|;
comment|/**      * Marks whether the complete serialization, which was read from file, should be used.      *      * Is set to false, if parts of the entry change. This causes the entry to be serialized based on the internal state (and not based on the old serialization)      */
DECL|field|changed
specifier|private
name|boolean
name|changed
decl_stmt|;
comment|/**      * Constructs a new BibEntry. The internal ID is set to IdGenerator.next()      */
DECL|method|BibEntry ()
specifier|public
name|BibEntry
parameter_list|()
block|{
name|this
argument_list|(
name|IdGenerator
operator|.
name|next
argument_list|()
argument_list|,
name|DEFAULT_TYPE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs a new BibEntry with the given type      *      * @param type The type to set. May be null or empty. In that case, DEFAULT_TYPE is used.      */
DECL|method|BibEntry (String type)
specifier|public
name|BibEntry
parameter_list|(
name|String
name|type
parameter_list|)
block|{
name|this
argument_list|(
name|IdGenerator
operator|.
name|next
argument_list|()
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs a new BibEntry with the given ID and given type      *      * @param id   The ID to be used      * @param type The type to set. May be null or empty. In that case, DEFAULT_TYPE is used.      */
DECL|method|BibEntry (String id, String type)
specifier|private
name|BibEntry
parameter_list|(
name|String
name|id
parameter_list|,
name|String
name|type
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|id
argument_list|,
literal|"Every BibEntry must have an ID"
argument_list|)
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|this
operator|.
name|sharedBibEntryData
operator|=
operator|new
name|SharedBibEntryData
argument_list|()
expr_stmt|;
block|}
DECL|method|setMonth (Month parsedMonth)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|setMonth
parameter_list|(
name|Month
name|parsedMonth
parameter_list|)
block|{
return|return
name|setField
argument_list|(
name|FieldName
operator|.
name|MONTH
argument_list|,
name|parsedMonth
operator|.
name|getJabRefFormat
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns the text stored in the given field of the given bibtex entry      * which belongs to the given database.      *<p>      * If a database is given, this function will try to resolve any string      * references in the field-value.      * Also, if a database is given, this function will try to find values for      * unset fields in the entry linked by the "crossref" field, if any.      *      * @param field    The field to return the value of.      * @param database maybenull      *                 The database of the bibtex entry.      * @return The resolved field value or null if not found.      */
DECL|method|getResolvedFieldOrAlias (String field, BibDatabase database)
specifier|public
name|Optional
argument_list|<
name|String
argument_list|>
name|getResolvedFieldOrAlias
parameter_list|(
name|String
name|field
parameter_list|,
name|BibDatabase
name|database
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|this
argument_list|,
literal|"entry cannot be null"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HEADER
operator|.
name|equals
argument_list|(
name|field
argument_list|)
operator|||
name|OBSOLETE_TYPE_HEADER
operator|.
name|equals
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|Optional
argument_list|<
name|EntryType
argument_list|>
name|entryType
init|=
name|EntryTypes
operator|.
name|getType
argument_list|(
name|getType
argument_list|()
argument_list|,
name|BibDatabaseMode
operator|.
name|BIBLATEX
argument_list|)
decl_stmt|;
if|if
condition|(
name|entryType
operator|.
name|isPresent
argument_list|()
condition|)
block|{
return|return
name|Optional
operator|.
name|of
argument_list|(
name|entryType
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Optional
operator|.
name|of
argument_list|(
name|StringUtil
operator|.
name|capitalizeFirst
argument_list|(
name|getType
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|KEY_FIELD
operator|.
name|equals
argument_list|(
name|field
argument_list|)
condition|)
block|{
return|return
name|getCiteKeyOptional
argument_list|()
return|;
block|}
name|Optional
argument_list|<
name|String
argument_list|>
name|result
init|=
name|getFieldOrAlias
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|// If this field is not set, and the entry has a crossref, try to look up the
comment|// field in the referred entry: Do not do this for the bibtex key.
if|if
condition|(
operator|!
name|result
operator|.
name|isPresent
argument_list|()
operator|&&
operator|(
name|database
operator|!=
literal|null
operator|)
condition|)
block|{
name|Optional
argument_list|<
name|BibEntry
argument_list|>
name|referred
init|=
name|database
operator|.
name|getReferencedEntry
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|result
operator|=
name|referred
operator|.
name|flatMap
argument_list|(
name|entry
lambda|->
name|entry
operator|.
name|getFieldOrAlias
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|.
name|map
argument_list|(
name|resultText
lambda|->
name|BibDatabase
operator|.
name|getText
argument_list|(
name|resultText
argument_list|,
name|database
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Returns this entry's ID.      */
DECL|method|getId ()
specifier|public
name|String
name|getId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
comment|/**      * Sets this entry's ID, provided the database containing it      * doesn't veto the change.      *      * @param id The ID to be used      */
DECL|method|setId (String id)
specifier|public
name|void
name|setId
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|id
argument_list|,
literal|"Every BibEntry must have an ID"
argument_list|)
expr_stmt|;
name|String
name|oldId
init|=
name|this
operator|.
name|id
decl_stmt|;
name|eventBus
operator|.
name|post
argument_list|(
operator|new
name|FieldChangedEvent
argument_list|(
name|this
argument_list|,
name|BibEntry
operator|.
name|ID_FIELD
argument_list|,
name|id
argument_list|,
name|oldId
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * Returns the cite key AKA citation key AKA BibTeX key, or null if it is not set.      * Note: this is<emph>not</emph> the internal Id of this entry. The internal Id is always present, whereas the BibTeX key might not be present.      */
annotation|@
name|Deprecated
DECL|method|getCiteKey ()
specifier|public
name|String
name|getCiteKey
parameter_list|()
block|{
return|return
name|fields
operator|.
name|get
argument_list|(
name|KEY_FIELD
argument_list|)
return|;
block|}
comment|/**      * Sets the cite key AKA citation key AKA BibTeX key. Note: This is<emph>not</emph> the internal Id of this entry.      * The internal Id is always present, whereas the BibTeX key might not be present.      *      * @param newCiteKey The cite key to set. Must not be null; use {@link #clearCiteKey()} to remove the cite key.      */
DECL|method|setCiteKey (String newCiteKey)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|setCiteKey
parameter_list|(
name|String
name|newCiteKey
parameter_list|)
block|{
return|return
name|setField
argument_list|(
name|KEY_FIELD
argument_list|,
name|newCiteKey
argument_list|)
return|;
block|}
DECL|method|getCiteKeyOptional ()
specifier|public
name|Optional
argument_list|<
name|String
argument_list|>
name|getCiteKeyOptional
parameter_list|()
block|{
return|return
name|Optional
operator|.
name|ofNullable
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|KEY_FIELD
argument_list|)
argument_list|)
return|;
block|}
DECL|method|hasCiteKey ()
specifier|public
name|boolean
name|hasCiteKey
parameter_list|()
block|{
return|return
operator|!
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|getCiteKey
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns this entry's type.      */
DECL|method|getType ()
specifier|public
name|String
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
comment|/**      * Sets this entry's type.      */
DECL|method|setType (EntryType type)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|setType
parameter_list|(
name|EntryType
name|type
parameter_list|)
block|{
return|return
name|this
operator|.
name|setType
argument_list|(
name|type
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Sets this entry's type.      */
DECL|method|setType (String type)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|setType
parameter_list|(
name|String
name|type
parameter_list|)
block|{
return|return
name|setType
argument_list|(
name|type
argument_list|,
name|EntryEventSource
operator|.
name|LOCAL
argument_list|)
return|;
block|}
comment|/**      * Sets this entry's type.      */
DECL|method|setType (String type, EntryEventSource eventSource)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|setType
parameter_list|(
name|String
name|type
parameter_list|,
name|EntryEventSource
name|eventSource
parameter_list|)
block|{
name|String
name|newType
decl_stmt|;
if|if
condition|(
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|newType
operator|=
name|DEFAULT_TYPE
expr_stmt|;
block|}
else|else
block|{
name|newType
operator|=
name|type
expr_stmt|;
block|}
name|String
name|oldType
init|=
name|getField
argument_list|(
name|TYPE_HEADER
argument_list|)
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|newType
operator|.
name|equals
argument_list|(
name|oldType
argument_list|)
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
name|this
operator|.
name|type
operator|=
name|newType
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
name|FieldChange
name|change
init|=
operator|new
name|FieldChange
argument_list|(
name|this
argument_list|,
name|TYPE_HEADER
argument_list|,
name|oldType
argument_list|,
name|newType
argument_list|)
decl_stmt|;
name|eventBus
operator|.
name|post
argument_list|(
operator|new
name|FieldChangedEvent
argument_list|(
name|change
argument_list|,
name|eventSource
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Optional
operator|.
name|of
argument_list|(
name|change
argument_list|)
return|;
block|}
comment|/**      * Returns an set containing the names of all fields that are      * set for this particular entry.      *      * @return a set of existing field names      */
DECL|method|getFieldNames ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getFieldNames
parameter_list|()
block|{
return|return
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|fields
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns the contents of the given field as an Optional.      */
DECL|method|getField (String name)
specifier|public
name|Optional
argument_list|<
name|String
argument_list|>
name|getField
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|Optional
operator|.
name|ofNullable
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|toLowerCase
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Returns true if the entry has the given field, or false if it is not set.      */
DECL|method|hasField (String name)
specifier|public
name|boolean
name|hasField
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|fields
operator|.
name|containsKey
argument_list|(
name|toLowerCase
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
DECL|method|toLowerCase (String fieldName)
specifier|private
name|String
name|toLowerCase
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|fieldName
argument_list|,
literal|"field name must not be null"
argument_list|)
expr_stmt|;
return|return
name|fieldName
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
return|;
block|}
comment|/**      * Internal method used to get the content of a field (or its alias)      *      * Used by {@link #getFieldOrAlias(String)} and {@link #getFieldOrAliasLatexFree(String)}      *      * @param name name of the field      * @param getFieldInterface      *      * @return determined field value      */
DECL|method|genericGetFieldOrAlias (String name, GetFieldInterface getFieldInterface)
specifier|private
name|Optional
argument_list|<
name|String
argument_list|>
name|genericGetFieldOrAlias
parameter_list|(
name|String
name|name
parameter_list|,
name|GetFieldInterface
name|getFieldInterface
parameter_list|)
block|{
name|Optional
argument_list|<
name|String
argument_list|>
name|fieldValue
init|=
name|getFieldInterface
operator|.
name|getValueForField
argument_list|(
name|toLowerCase
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldValue
operator|.
name|isPresent
argument_list|()
operator|&&
operator|!
name|fieldValue
operator|.
name|get
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|fieldValue
return|;
block|}
comment|// No value of this field found, so look at the alias
name|String
name|aliasForField
init|=
name|EntryConverter
operator|.
name|FIELD_ALIASES
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|aliasForField
operator|!=
literal|null
condition|)
block|{
return|return
name|getFieldInterface
operator|.
name|getValueForField
argument_list|(
name|aliasForField
argument_list|)
return|;
block|}
comment|// Finally, handle dates
if|if
condition|(
name|FieldName
operator|.
name|DATE
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|Optional
argument_list|<
name|Date
argument_list|>
name|date
init|=
name|Date
operator|.
name|parse
argument_list|(
name|getFieldInterface
operator|.
name|getValueForField
argument_list|(
name|FieldName
operator|.
name|YEAR
argument_list|)
argument_list|,
name|getFieldInterface
operator|.
name|getValueForField
argument_list|(
name|FieldName
operator|.
name|MONTH
argument_list|)
argument_list|,
name|getFieldInterface
operator|.
name|getValueForField
argument_list|(
name|FieldName
operator|.
name|DAY
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|date
operator|.
name|map
argument_list|(
name|Date
operator|::
name|getNormalized
argument_list|)
return|;
block|}
if|if
condition|(
name|FieldName
operator|.
name|YEAR
operator|.
name|equals
argument_list|(
name|name
argument_list|)
operator|||
name|FieldName
operator|.
name|MONTH
operator|.
name|equals
argument_list|(
name|name
argument_list|)
operator|||
name|FieldName
operator|.
name|DAY
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|Optional
argument_list|<
name|String
argument_list|>
name|date
init|=
name|getFieldInterface
operator|.
name|getValueForField
argument_list|(
name|FieldName
operator|.
name|DATE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|date
operator|.
name|isPresent
argument_list|()
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
name|Optional
argument_list|<
name|Date
argument_list|>
name|parsedDate
init|=
name|Date
operator|.
name|parse
argument_list|(
name|date
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|parsedDate
operator|.
name|isPresent
argument_list|()
condition|)
block|{
if|if
condition|(
name|FieldName
operator|.
name|YEAR
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|parsedDate
operator|.
name|get
argument_list|()
operator|.
name|getYear
argument_list|()
operator|.
name|map
argument_list|(
name|Object
operator|::
name|toString
argument_list|)
return|;
block|}
if|if
condition|(
name|FieldName
operator|.
name|MONTH
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|parsedDate
operator|.
name|get
argument_list|()
operator|.
name|getMonth
argument_list|()
operator|.
name|map
argument_list|(
name|Month
operator|::
name|getJabRefFormat
argument_list|)
return|;
block|}
if|if
condition|(
name|FieldName
operator|.
name|DAY
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|parsedDate
operator|.
name|get
argument_list|()
operator|.
name|getDay
argument_list|()
operator|.
name|map
argument_list|(
name|Object
operator|::
name|toString
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Could not parse date "
operator|+
name|date
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
comment|// Date field not in valid format
block|}
block|}
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
DECL|method|getDOI ()
specifier|public
name|Optional
argument_list|<
name|DOI
argument_list|>
name|getDOI
parameter_list|()
block|{
return|return
name|getField
argument_list|(
name|FieldName
operator|.
name|DOI
argument_list|)
operator|.
name|flatMap
argument_list|(
name|DOI
operator|::
name|parse
argument_list|)
return|;
block|}
comment|/**      * Return the LaTeX-free contents of the given field or its alias an an Optional      *      * For details see also {@link #getFieldOrAlias(String)}      *      * @param name the name of the field      * @return  the stored latex-free content of the field (or its alias)      */
DECL|method|getFieldOrAliasLatexFree (String name)
specifier|public
name|Optional
argument_list|<
name|String
argument_list|>
name|getFieldOrAliasLatexFree
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|genericGetFieldOrAlias
argument_list|(
name|name
argument_list|,
name|this
operator|::
name|getLatexFreeField
argument_list|)
return|;
block|}
comment|/**      * Returns the contents of the given field or its alias as an Optional      *<p>      * The following aliases are considered (old bibtex<-> new biblatex) based      * on the biblatex documentation, chapter 2.2.5:<br>      * address<-> location<br>      * annote<-> annotation<br>      * archiveprefix<-> eprinttype<br>      * journal<-> journaltitle<br>      * key<-> sortkey<br>      * pdf<-> file<br      * primaryclass<-> eprintclass<br>      * school<-> institution<br>      * These work bidirectional.<br>      *</p>      *      *<p>      * Special attention is paid to dates: (see the biblatex documentation,      * chapter 2.3.8)      * The fields 'year' and 'month' are used if the 'date'      * field is empty. Conversely, getFieldOrAlias("year") also tries to      * extract the year from the 'date' field (analogously for 'month').      *</p>      */
DECL|method|getFieldOrAlias (String name)
specifier|public
name|Optional
argument_list|<
name|String
argument_list|>
name|getFieldOrAlias
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|genericGetFieldOrAlias
argument_list|(
name|name
argument_list|,
name|this
operator|::
name|getField
argument_list|)
return|;
block|}
comment|/**      * Sets a number of fields simultaneously. The given HashMap contains field      * names as keys, each mapped to the value to set.      */
DECL|method|setField (Map<String, String> fields)
specifier|public
name|void
name|setField
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|fields
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|fields
argument_list|,
literal|"fields must not be null"
argument_list|)
expr_stmt|;
name|fields
operator|.
name|forEach
argument_list|(
name|this
operator|::
name|setField
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set a field, and notify listeners about the change.      *      * @param name        The field to set      * @param value       The value to set      * @param eventSource Source the event is sent from      */
DECL|method|setField (String name, String value, EntryEventSource eventSource)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|setField
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|EntryEventSource
name|eventSource
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|name
argument_list|,
literal|"field name must not be null"
argument_list|)
expr_stmt|;
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|value
argument_list|,
literal|"field value must not be null"
argument_list|)
expr_stmt|;
name|String
name|fieldName
init|=
name|toLowerCase
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|clearField
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
name|String
name|oldValue
init|=
name|getField
argument_list|(
name|fieldName
argument_list|)
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|boolean
name|isNewField
init|=
name|oldValue
operator|==
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|equals
argument_list|(
name|oldValue
argument_list|)
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
if|if
condition|(
name|BibEntry
operator|.
name|ID_FIELD
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The field name '"
operator|+
name|name
operator|+
literal|"' is reserved"
argument_list|)
throw|;
block|}
name|changed
operator|=
literal|true
expr_stmt|;
name|fields
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
name|value
operator|.
name|intern
argument_list|()
argument_list|)
expr_stmt|;
name|invalidateFieldCache
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
name|FieldChange
name|change
init|=
operator|new
name|FieldChange
argument_list|(
name|this
argument_list|,
name|fieldName
argument_list|,
name|oldValue
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|isNewField
condition|)
block|{
name|eventBus
operator|.
name|post
argument_list|(
operator|new
name|FieldAddedOrRemovedEvent
argument_list|(
name|change
argument_list|,
name|eventSource
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eventBus
operator|.
name|post
argument_list|(
operator|new
name|FieldChangedEvent
argument_list|(
name|change
argument_list|,
name|eventSource
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Optional
operator|.
name|of
argument_list|(
name|change
argument_list|)
return|;
block|}
DECL|method|setField (String name, Optional<String> value, EntryEventSource eventSource)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|setField
parameter_list|(
name|String
name|name
parameter_list|,
name|Optional
argument_list|<
name|String
argument_list|>
name|value
parameter_list|,
name|EntryEventSource
name|eventSource
parameter_list|)
block|{
if|if
condition|(
name|value
operator|.
name|isPresent
argument_list|()
condition|)
block|{
return|return
name|setField
argument_list|(
name|name
argument_list|,
name|value
operator|.
name|get
argument_list|()
argument_list|,
name|eventSource
argument_list|)
return|;
block|}
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/**      * Set a field, and notify listeners about the change.      *      * @param name  The field to set.      * @param value The value to set.      */
DECL|method|setField (String name, String value)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|setField
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|)
block|{
return|return
name|setField
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|EntryEventSource
operator|.
name|LOCAL
argument_list|)
return|;
block|}
comment|/**      * Remove the mapping for the field name, and notify listeners about      * the change.      *      * @param name The field to clear.      */
DECL|method|clearField (String name)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|clearField
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|clearField
argument_list|(
name|name
argument_list|,
name|EntryEventSource
operator|.
name|LOCAL
argument_list|)
return|;
block|}
comment|/**      * Remove the mapping for the field name, and notify listeners about      * the change including the {@link EntryEventSource}.      *      * @param name        The field to clear.      * @param eventSource the source a new {@link FieldChangedEvent} should be posten from.      */
DECL|method|clearField (String name, EntryEventSource eventSource)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|clearField
parameter_list|(
name|String
name|name
parameter_list|,
name|EntryEventSource
name|eventSource
parameter_list|)
block|{
name|String
name|fieldName
init|=
name|toLowerCase
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|BibEntry
operator|.
name|ID_FIELD
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The field name '"
operator|+
name|name
operator|+
literal|"' is reserved"
argument_list|)
throw|;
block|}
name|Optional
argument_list|<
name|String
argument_list|>
name|oldValue
init|=
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|oldValue
operator|.
name|isPresent
argument_list|()
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
name|changed
operator|=
literal|true
expr_stmt|;
name|fields
operator|.
name|remove
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
name|invalidateFieldCache
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
name|FieldChange
name|change
init|=
operator|new
name|FieldChange
argument_list|(
name|this
argument_list|,
name|fieldName
argument_list|,
name|oldValue
operator|.
name|get
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|eventBus
operator|.
name|post
argument_list|(
operator|new
name|FieldAddedOrRemovedEvent
argument_list|(
name|change
argument_list|,
name|eventSource
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Optional
operator|.
name|of
argument_list|(
name|change
argument_list|)
return|;
block|}
comment|/**      * Determines whether this entry has all the given fields present. If a non-null      * database argument is given, this method will try to look up missing fields in      * entries linked by the "crossref" field, if any.      *      * @param allFields An array of field names to be checked.      * @param database  The database in which to look up crossref'd entries, if any. This      *                  argument can be null, meaning that no attempt will be made to follow crossrefs.      * @return true if all fields are set or could be resolved, false otherwise.      */
DECL|method|allFieldsPresent (Collection<String> allFields, BibDatabase database)
specifier|public
name|boolean
name|allFieldsPresent
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|allFields
parameter_list|,
name|BibDatabase
name|database
parameter_list|)
block|{
for|for
control|(
name|String
name|field
range|:
name|allFields
control|)
block|{
name|String
name|fieldName
init|=
name|toLowerCase
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|// OR fields
if|if
condition|(
name|fieldName
operator|.
name|contains
argument_list|(
name|FieldName
operator|.
name|FIELD_SEPARATOR
argument_list|)
condition|)
block|{
name|String
index|[]
name|altFields
init|=
name|field
operator|.
name|split
argument_list|(
name|FieldName
operator|.
name|FIELD_SEPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|atLeastOnePresent
argument_list|(
name|altFields
argument_list|,
name|database
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|getResolvedFieldOrAlias
argument_list|(
name|fieldName
argument_list|,
name|database
argument_list|)
operator|.
name|isPresent
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|atLeastOnePresent (String[] fieldsToCheck, BibDatabase database)
specifier|private
name|boolean
name|atLeastOnePresent
parameter_list|(
name|String
index|[]
name|fieldsToCheck
parameter_list|,
name|BibDatabase
name|database
parameter_list|)
block|{
for|for
control|(
name|String
name|field
range|:
name|fieldsToCheck
control|)
block|{
name|String
name|fieldName
init|=
name|toLowerCase
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|Optional
argument_list|<
name|String
argument_list|>
name|value
init|=
name|this
operator|.
name|getResolvedFieldOrAlias
argument_list|(
name|fieldName
argument_list|,
name|database
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|value
operator|.
name|isPresent
argument_list|()
operator|)
operator|&&
operator|!
name|value
operator|.
name|get
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Returns a clone of this entry. Useful for copying.      * This will set a new ID for the cloned entry to be able to distinguish both copies.      */
annotation|@
name|Override
DECL|method|clone ()
specifier|public
name|Object
name|clone
parameter_list|()
block|{
name|BibEntry
name|clone
init|=
operator|new
name|BibEntry
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|clone
operator|.
name|fields
operator|=
name|FXCollections
operator|.
name|observableMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|(
name|fields
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|clone
return|;
block|}
comment|/**      * This returns a canonical BibTeX serialization. Special characters such as "{" or "&" are NOT escaped, but written      * as is      *<p>      * Serializes all fields, even the JabRef internal ones. Does NOT serialize "KEY_FIELD" as field, but as key      */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|CanonicalBibtexEntry
operator|.
name|getCanonicalRepresentation
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|method|isSearchHit ()
specifier|public
name|boolean
name|isSearchHit
parameter_list|()
block|{
return|return
name|searchHit
return|;
block|}
DECL|method|setSearchHit (boolean searchHit)
specifier|public
name|void
name|setSearchHit
parameter_list|(
name|boolean
name|searchHit
parameter_list|)
block|{
name|this
operator|.
name|searchHit
operator|=
name|searchHit
expr_stmt|;
block|}
DECL|method|isGroupHit ()
specifier|public
name|boolean
name|isGroupHit
parameter_list|()
block|{
return|return
name|groupHit
return|;
block|}
DECL|method|setGroupHit (boolean groupHit)
specifier|public
name|void
name|setGroupHit
parameter_list|(
name|boolean
name|groupHit
parameter_list|)
block|{
name|this
operator|.
name|groupHit
operator|=
name|groupHit
expr_stmt|;
block|}
comment|/**      * @param maxCharacters The maximum number of characters (additional      *                      characters are replaced with "..."). Set to 0 to disable truncation.      * @return A short textual description of the entry in the format:      * Author1, Author2: Title (Year)      */
DECL|method|getAuthorTitleYear (int maxCharacters)
specifier|public
name|String
name|getAuthorTitleYear
parameter_list|(
name|int
name|maxCharacters
parameter_list|)
block|{
name|String
index|[]
name|s
init|=
operator|new
name|String
index|[]
block|{
name|getField
argument_list|(
name|FieldName
operator|.
name|AUTHOR
argument_list|)
operator|.
name|orElse
argument_list|(
literal|"N/A"
argument_list|)
block|,
name|getField
argument_list|(
name|FieldName
operator|.
name|TITLE
argument_list|)
operator|.
name|orElse
argument_list|(
literal|"N/A"
argument_list|)
block|,
name|getField
argument_list|(
name|FieldName
operator|.
name|YEAR
argument_list|)
operator|.
name|orElse
argument_list|(
literal|"N/A"
argument_list|)
block|}
decl_stmt|;
name|String
name|text
init|=
name|s
index|[
literal|0
index|]
operator|+
literal|": \""
operator|+
name|s
index|[
literal|1
index|]
operator|+
literal|"\" ("
operator|+
name|s
index|[
literal|2
index|]
operator|+
literal|')'
decl_stmt|;
if|if
condition|(
operator|(
name|maxCharacters
operator|<=
literal|0
operator|)
operator|||
operator|(
name|text
operator|.
name|length
argument_list|()
operator|<=
name|maxCharacters
operator|)
condition|)
block|{
return|return
name|text
return|;
block|}
return|return
name|text
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|maxCharacters
operator|+
literal|1
argument_list|)
operator|+
literal|"..."
return|;
block|}
comment|/**      * Returns the title of the given BibTeX entry as an Optional.      *      * @return an Optional containing the title of a BibTeX entry in case it exists, otherwise return an empty Optional.      */
DECL|method|getTitle ()
specifier|public
name|Optional
argument_list|<
name|String
argument_list|>
name|getTitle
parameter_list|()
block|{
return|return
name|getField
argument_list|(
name|FieldName
operator|.
name|TITLE
argument_list|)
return|;
block|}
comment|/**      * Will return the publication date of the given bibtex entry conforming to ISO 8601, i.e. either YYYY or YYYY-MM.      *      * @return will return the publication date of the entry or null if no year was found.      */
DECL|method|getPublicationDate ()
specifier|public
name|Optional
argument_list|<
name|Date
argument_list|>
name|getPublicationDate
parameter_list|()
block|{
return|return
name|getFieldOrAlias
argument_list|(
name|FieldName
operator|.
name|DATE
argument_list|)
operator|.
name|flatMap
argument_list|(
name|Date
operator|::
name|parse
argument_list|)
return|;
block|}
DECL|method|getParsedSerialization ()
specifier|public
name|String
name|getParsedSerialization
parameter_list|()
block|{
return|return
name|parsedSerialization
return|;
block|}
DECL|method|setParsedSerialization (String parsedSerialization)
specifier|public
name|void
name|setParsedSerialization
parameter_list|(
name|String
name|parsedSerialization
parameter_list|)
block|{
name|changed
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|parsedSerialization
operator|=
name|parsedSerialization
expr_stmt|;
block|}
DECL|method|setCommentsBeforeEntry (String parsedComments)
specifier|public
name|void
name|setCommentsBeforeEntry
parameter_list|(
name|String
name|parsedComments
parameter_list|)
block|{
comment|// delete trailing whitespaces (between entry and text)
name|this
operator|.
name|commentsBeforeEntry
operator|=
name|REMOVE_TRAILING_WHITESPACE
operator|.
name|matcher
argument_list|(
name|parsedComments
argument_list|)
operator|.
name|replaceFirst
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
DECL|method|hasChanged ()
specifier|public
name|boolean
name|hasChanged
parameter_list|()
block|{
return|return
name|changed
return|;
block|}
DECL|method|setChanged (boolean changed)
specifier|public
name|void
name|setChanged
parameter_list|(
name|boolean
name|changed
parameter_list|)
block|{
name|this
operator|.
name|changed
operator|=
name|changed
expr_stmt|;
block|}
DECL|method|putKeywords (List<String> keywords, Character delimiter)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|putKeywords
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|keywords
parameter_list|,
name|Character
name|delimiter
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|delimiter
argument_list|)
expr_stmt|;
return|return
name|putKeywords
argument_list|(
operator|new
name|KeywordList
argument_list|(
name|keywords
argument_list|)
argument_list|,
name|delimiter
argument_list|)
return|;
block|}
DECL|method|putKeywords (KeywordList keywords, Character delimiter)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|putKeywords
parameter_list|(
name|KeywordList
name|keywords
parameter_list|,
name|Character
name|delimiter
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|keywords
argument_list|)
expr_stmt|;
name|Optional
argument_list|<
name|String
argument_list|>
name|oldValue
init|=
name|this
operator|.
name|getField
argument_list|(
name|FieldName
operator|.
name|KEYWORDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|keywords
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Clear keyword field
if|if
condition|(
name|oldValue
operator|.
name|isPresent
argument_list|()
condition|)
block|{
return|return
name|this
operator|.
name|clearField
argument_list|(
name|FieldName
operator|.
name|KEYWORDS
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
block|}
comment|// Set new keyword field
name|String
name|newValue
init|=
name|keywords
operator|.
name|getAsString
argument_list|(
name|delimiter
argument_list|)
decl_stmt|;
return|return
name|this
operator|.
name|setField
argument_list|(
name|FieldName
operator|.
name|KEYWORDS
argument_list|,
name|newValue
argument_list|)
return|;
block|}
comment|/**      * Check if a keyword already exists (case insensitive), if not: add it      *      * @param keyword Keyword to add      */
DECL|method|addKeyword (String keyword, Character delimiter)
specifier|public
name|void
name|addKeyword
parameter_list|(
name|String
name|keyword
parameter_list|,
name|Character
name|delimiter
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|keyword
argument_list|,
literal|"keyword must not be null"
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyword
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|addKeyword
argument_list|(
operator|new
name|Keyword
argument_list|(
name|keyword
argument_list|)
argument_list|,
name|delimiter
argument_list|)
expr_stmt|;
block|}
DECL|method|addKeyword (Keyword keyword, Character delimiter)
specifier|public
name|void
name|addKeyword
parameter_list|(
name|Keyword
name|keyword
parameter_list|,
name|Character
name|delimiter
parameter_list|)
block|{
name|KeywordList
name|keywords
init|=
name|this
operator|.
name|getKeywords
argument_list|(
name|delimiter
argument_list|)
decl_stmt|;
name|keywords
operator|.
name|add
argument_list|(
name|keyword
argument_list|)
expr_stmt|;
name|this
operator|.
name|putKeywords
argument_list|(
name|keywords
argument_list|,
name|delimiter
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add multiple keywords to entry      *      * @param keywords Keywords to add      */
DECL|method|addKeywords (Collection<String> keywords, Character delimiter)
specifier|public
name|void
name|addKeywords
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|keywords
parameter_list|,
name|Character
name|delimiter
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|keywords
argument_list|)
expr_stmt|;
name|keywords
operator|.
name|forEach
argument_list|(
name|keyword
lambda|->
name|addKeyword
argument_list|(
name|keyword
argument_list|,
name|delimiter
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getKeywords (Character delimiter)
specifier|public
name|KeywordList
name|getKeywords
parameter_list|(
name|Character
name|delimiter
parameter_list|)
block|{
name|Optional
argument_list|<
name|String
argument_list|>
name|keywordsContent
init|=
name|getField
argument_list|(
name|FieldName
operator|.
name|KEYWORDS
argument_list|)
decl_stmt|;
return|return
name|KeywordList
operator|.
name|parse
argument_list|(
name|keywordsContent
argument_list|,
name|delimiter
argument_list|)
return|;
block|}
DECL|method|getResolvedKeywords (Character delimiter, BibDatabase database)
specifier|public
name|KeywordList
name|getResolvedKeywords
parameter_list|(
name|Character
name|delimiter
parameter_list|,
name|BibDatabase
name|database
parameter_list|)
block|{
name|Optional
argument_list|<
name|String
argument_list|>
name|keywordsContent
init|=
name|getResolvedFieldOrAlias
argument_list|(
name|FieldName
operator|.
name|KEYWORDS
argument_list|,
name|database
argument_list|)
decl_stmt|;
return|return
name|KeywordList
operator|.
name|parse
argument_list|(
name|keywordsContent
argument_list|,
name|delimiter
argument_list|)
return|;
block|}
DECL|method|removeKeywords (KeywordList keywordsToRemove, Character keywordDelimiter)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|removeKeywords
parameter_list|(
name|KeywordList
name|keywordsToRemove
parameter_list|,
name|Character
name|keywordDelimiter
parameter_list|)
block|{
name|KeywordList
name|keywordList
init|=
name|getKeywords
argument_list|(
name|keywordDelimiter
argument_list|)
decl_stmt|;
name|keywordList
operator|.
name|removeAll
argument_list|(
name|keywordsToRemove
argument_list|)
expr_stmt|;
return|return
name|putKeywords
argument_list|(
name|keywordList
argument_list|,
name|keywordDelimiter
argument_list|)
return|;
block|}
DECL|method|replaceKeywords (KeywordList keywordsToReplace, Keyword newValue, Character keywordDelimiter)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|replaceKeywords
parameter_list|(
name|KeywordList
name|keywordsToReplace
parameter_list|,
name|Keyword
name|newValue
parameter_list|,
name|Character
name|keywordDelimiter
parameter_list|)
block|{
name|KeywordList
name|keywordList
init|=
name|getKeywords
argument_list|(
name|keywordDelimiter
argument_list|)
decl_stmt|;
name|keywordList
operator|.
name|replaceAll
argument_list|(
name|keywordsToReplace
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
return|return
name|putKeywords
argument_list|(
name|keywordList
argument_list|,
name|keywordDelimiter
argument_list|)
return|;
block|}
DECL|method|getFieldValues ()
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getFieldValues
parameter_list|()
block|{
return|return
name|fields
operator|.
name|values
argument_list|()
return|;
block|}
DECL|method|getFieldMap ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getFieldMap
parameter_list|()
block|{
return|return
name|fields
return|;
block|}
DECL|method|getSharedBibEntryData ()
specifier|public
name|SharedBibEntryData
name|getSharedBibEntryData
parameter_list|()
block|{
return|return
name|sharedBibEntryData
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|(
name|o
operator|==
literal|null
operator|)
operator|||
operator|(
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|BibEntry
name|entry
init|=
operator|(
name|BibEntry
operator|)
name|o
decl_stmt|;
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|type
argument_list|,
name|entry
operator|.
name|type
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|fields
argument_list|,
name|entry
operator|.
name|fields
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|commentsBeforeEntry
argument_list|,
name|entry
operator|.
name|commentsBeforeEntry
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|type
argument_list|,
name|fields
argument_list|)
return|;
block|}
DECL|method|registerListener (Object object)
specifier|public
name|void
name|registerListener
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
name|this
operator|.
name|eventBus
operator|.
name|register
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
DECL|method|unregisterListener (Object object)
specifier|public
name|void
name|unregisterListener
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|eventBus
operator|.
name|unregister
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// occurs if the event source has not been registered, should not prevent shutdown
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Problem unregistering"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|withField (String field, String value)
specifier|public
name|BibEntry
name|withField
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|setField
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/*     * Returns user comments (arbitrary text before the entry), if they exist. If not, returns the empty String      */
DECL|method|getUserComments ()
specifier|public
name|String
name|getUserComments
parameter_list|()
block|{
return|return
name|commentsBeforeEntry
return|;
block|}
DECL|method|getEntryLinkList (String fieldName, BibDatabase database)
specifier|public
name|List
argument_list|<
name|ParsedEntryLink
argument_list|>
name|getEntryLinkList
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|BibDatabase
name|database
parameter_list|)
block|{
return|return
name|getField
argument_list|(
name|fieldName
argument_list|)
operator|.
name|map
argument_list|(
name|fieldValue
lambda|->
name|EntryLinkList
operator|.
name|parse
argument_list|(
name|fieldValue
argument_list|,
name|database
argument_list|)
argument_list|)
operator|.
name|orElse
argument_list|(
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
return|;
block|}
DECL|method|setEntryLinkList (String fieldName, List<ParsedEntryLink> list)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|setEntryLinkList
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|List
argument_list|<
name|ParsedEntryLink
argument_list|>
name|list
parameter_list|)
block|{
return|return
name|setField
argument_list|(
name|fieldName
argument_list|,
name|EntryLinkList
operator|.
name|serialize
argument_list|(
name|list
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getFieldAsWords (String field)
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getFieldAsWords
parameter_list|(
name|String
name|field
parameter_list|)
block|{
name|String
name|fieldName
init|=
name|toLowerCase
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|storedList
init|=
name|fieldsAsWords
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedList
operator|!=
literal|null
condition|)
block|{
return|return
name|storedList
return|;
block|}
else|else
block|{
name|String
name|fieldValue
init|=
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldValue
operator|==
literal|null
condition|)
block|{
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
else|else
block|{
name|HashSet
argument_list|<
name|String
argument_list|>
name|words
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|StringUtil
operator|.
name|getStringAsWords
argument_list|(
name|fieldValue
argument_list|)
argument_list|)
decl_stmt|;
name|fieldsAsWords
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
name|words
argument_list|)
expr_stmt|;
return|return
name|words
return|;
block|}
block|}
block|}
DECL|method|clearCiteKey ()
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|clearCiteKey
parameter_list|()
block|{
return|return
name|clearField
argument_list|(
name|KEY_FIELD
argument_list|)
return|;
block|}
DECL|method|invalidateFieldCache (String fieldName)
specifier|private
name|void
name|invalidateFieldCache
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|latexFreeFields
operator|.
name|remove
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
name|fieldsAsWords
operator|.
name|remove
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
block|}
DECL|method|getLatexFreeField (String name)
specifier|public
name|Optional
argument_list|<
name|String
argument_list|>
name|getLatexFreeField
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasField
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|latexFreeFields
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|Optional
operator|.
name|ofNullable
argument_list|(
name|latexFreeFields
operator|.
name|get
argument_list|(
name|toLowerCase
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|KEY_FIELD
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|// the key field should not be converted
name|Optional
argument_list|<
name|String
argument_list|>
name|citeKey
init|=
name|getCiteKeyOptional
argument_list|()
decl_stmt|;
name|latexFreeFields
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|citeKey
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|citeKey
return|;
block|}
else|else
block|{
name|String
name|latexFreeField
init|=
name|LatexToUnicodeAdapter
operator|.
name|format
argument_list|(
name|getField
argument_list|(
name|name
argument_list|)
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|intern
argument_list|()
decl_stmt|;
name|latexFreeFields
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|latexFreeField
argument_list|)
expr_stmt|;
return|return
name|Optional
operator|.
name|of
argument_list|(
name|latexFreeField
argument_list|)
return|;
block|}
block|}
DECL|method|setFiles (List<LinkedFile> files)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|setFiles
parameter_list|(
name|List
argument_list|<
name|LinkedFile
argument_list|>
name|files
parameter_list|)
block|{
name|Optional
argument_list|<
name|String
argument_list|>
name|oldValue
init|=
name|this
operator|.
name|getField
argument_list|(
name|FieldName
operator|.
name|FILE
argument_list|)
decl_stmt|;
name|String
name|newValue
init|=
name|FileFieldWriter
operator|.
name|getStringRepresentation
argument_list|(
name|files
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldValue
operator|.
name|isPresent
argument_list|()
operator|&&
name|oldValue
operator|.
name|get
argument_list|()
operator|.
name|equals
argument_list|(
name|newValue
argument_list|)
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
return|return
name|this
operator|.
name|setField
argument_list|(
name|FieldName
operator|.
name|FILE
argument_list|,
name|newValue
argument_list|)
return|;
block|}
comment|/**      * Gets a list of linked files.      *      * @return the list of linked files, is never null but can be empty.      * Changes to the underlying list will have no effect on the entry itself. Use {@link #addFile(LinkedFile)}      */
DECL|method|getFiles ()
specifier|public
name|List
argument_list|<
name|LinkedFile
argument_list|>
name|getFiles
parameter_list|()
block|{
comment|//Extract the path
name|Optional
argument_list|<
name|String
argument_list|>
name|oldValue
init|=
name|getField
argument_list|(
name|FieldName
operator|.
name|FILE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|oldValue
operator|.
name|isPresent
argument_list|()
condition|)
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|()
return|;
comment|//Return new ArrayList because emptyList is immutable
block|}
return|return
name|FileFieldParser
operator|.
name|parse
argument_list|(
name|oldValue
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
DECL|method|setDate (Date date)
specifier|public
name|void
name|setDate
parameter_list|(
name|Date
name|date
parameter_list|)
block|{
name|date
operator|.
name|getYear
argument_list|()
operator|.
name|ifPresent
argument_list|(
name|year
lambda|->
name|setField
argument_list|(
name|FieldName
operator|.
name|YEAR
argument_list|,
name|year
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|date
operator|.
name|getMonth
argument_list|()
operator|.
name|ifPresent
argument_list|(
name|this
operator|::
name|setMonth
argument_list|)
expr_stmt|;
name|date
operator|.
name|getDay
argument_list|()
operator|.
name|ifPresent
argument_list|(
name|day
lambda|->
name|setField
argument_list|(
name|FieldName
operator|.
name|DAY
argument_list|,
name|day
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getMonth ()
specifier|public
name|Optional
argument_list|<
name|Month
argument_list|>
name|getMonth
parameter_list|()
block|{
return|return
name|getFieldOrAlias
argument_list|(
name|FieldName
operator|.
name|MONTH
argument_list|)
operator|.
name|flatMap
argument_list|(
name|Month
operator|::
name|parse
argument_list|)
return|;
block|}
DECL|method|getFieldBinding (String fieldName)
specifier|public
name|ObjectBinding
argument_list|<
name|String
argument_list|>
name|getFieldBinding
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
name|Bindings
operator|.
name|valueAt
argument_list|(
name|fields
argument_list|,
name|fieldName
argument_list|)
return|;
block|}
DECL|method|addFile (LinkedFile file)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|addFile
parameter_list|(
name|LinkedFile
name|file
parameter_list|)
block|{
name|List
argument_list|<
name|LinkedFile
argument_list|>
name|linkedFiles
init|=
name|getFiles
argument_list|()
decl_stmt|;
name|linkedFiles
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|setFiles
argument_list|(
name|linkedFiles
argument_list|)
return|;
block|}
DECL|method|getFieldsObservable ()
specifier|public
name|ObservableMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getFieldsObservable
parameter_list|()
block|{
return|return
name|fields
return|;
block|}
comment|/**      * Returns a list of observables that represent the data of the entry.      */
DECL|method|getObservables ()
specifier|public
name|Observable
index|[]
name|getObservables
parameter_list|()
block|{
return|return
operator|new
name|Observable
index|[]
block|{
name|fields
block|}
return|;
block|}
DECL|interface|GetFieldInterface
specifier|private
interface|interface
name|GetFieldInterface
block|{
DECL|method|getValueForField (String fieldName)
name|Optional
argument_list|<
name|String
argument_list|>
name|getValueForField
parameter_list|(
name|String
name|fieldName
parameter_list|)
function_decl|;
block|}
block|}
end_class

end_unit

