begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.jabref.gui.groups
package|package
name|org
operator|.
name|jabref
operator|.
name|gui
operator|.
name|groups
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JTree
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|ToolTipManager
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|tree
operator|.
name|TreePath
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|tree
operator|.
name|TreeSelectionModel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|groups
operator|.
name|GroupTreeNode
import|;
end_import

begin_class
DECL|class|GroupsTree
specifier|public
class|class
name|GroupsTree
extends|extends
name|JTree
block|{
DECL|field|localCellRenderer
specifier|private
specifier|final
name|GroupTreeCellRenderer
name|localCellRenderer
init|=
operator|new
name|GroupTreeCellRenderer
argument_list|()
decl_stmt|;
comment|/**      * @param groupSelector the parent UI component      */
DECL|method|GroupsTree (GroupSelector groupSelector)
specifier|public
name|GroupsTree
parameter_list|(
name|GroupSelector
name|groupSelector
parameter_list|)
block|{
name|setCellRenderer
argument_list|(
name|localCellRenderer
argument_list|)
expr_stmt|;
name|setFocusable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|setToggleClickCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ToolTipManager
operator|.
name|sharedInstance
argument_list|()
operator|.
name|registerComponent
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|setShowsRootHandles
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|getSelectionModel
argument_list|()
operator|.
name|setSelectionMode
argument_list|(
name|TreeSelectionModel
operator|.
name|DISCONTIGUOUS_TREE_SELECTION
argument_list|)
expr_stmt|;
name|this
operator|.
name|setFocusable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** Returns the first selected node, or null if nothing is selected. */
DECL|method|getSelectedNode ()
specifier|private
name|GroupTreeNodeViewModel
name|getSelectedNode
parameter_list|()
block|{
name|TreePath
name|selectionPath
init|=
name|getSelectionPath
argument_list|()
decl_stmt|;
return|return
name|selectionPath
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|GroupTreeNodeViewModel
operator|)
name|selectionPath
operator|.
name|getLastPathComponent
argument_list|()
return|;
block|}
comment|/**      * Refresh paths that may have become invalid due to node movements within      * the tree. This method creates new paths to the last path components      * (which must still exist) of the specified paths.      *      * @param paths      *            Paths that may have become invalid.      * @return Refreshed paths that are all valid.      */
DECL|method|refreshPaths (Enumeration<TreePath> paths)
specifier|public
name|Enumeration
argument_list|<
name|TreePath
argument_list|>
name|refreshPaths
parameter_list|(
name|Enumeration
argument_list|<
name|TreePath
argument_list|>
name|paths
parameter_list|)
block|{
if|if
condition|(
name|paths
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|Vector
argument_list|<
name|TreePath
argument_list|>
argument_list|()
operator|.
name|elements
argument_list|()
return|;
block|}
name|Vector
argument_list|<
name|TreePath
argument_list|>
name|freshPaths
init|=
operator|new
name|Vector
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|paths
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|freshPaths
operator|.
name|add
argument_list|(
operator|(
operator|(
name|GroupTreeNodeViewModel
operator|)
name|paths
operator|.
name|nextElement
argument_list|()
operator|.
name|getLastPathComponent
argument_list|()
operator|)
operator|.
name|getTreePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|freshPaths
operator|.
name|elements
argument_list|()
return|;
block|}
comment|/**      * Refresh paths that may have become invalid due to node movements within      * the tree. This method creates new paths to the last path components      * (which must still exist) of the specified paths.      *      * @param paths      *            Paths that may have become invalid.      * @return Refreshed paths that are all valid.      */
DECL|method|refreshPaths (TreePath[] paths)
specifier|public
name|TreePath
index|[]
name|refreshPaths
parameter_list|(
name|TreePath
index|[]
name|paths
parameter_list|)
block|{
name|TreePath
index|[]
name|freshPaths
init|=
operator|new
name|TreePath
index|[
name|paths
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paths
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|freshPaths
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|GroupTreeNodeViewModel
operator|)
name|paths
index|[
name|i
index|]
operator|.
name|getLastPathComponent
argument_list|()
operator|)
operator|.
name|getTreePath
argument_list|()
expr_stmt|;
block|}
return|return
name|freshPaths
return|;
block|}
comment|/**      * Highlights the specified groups in red      **/
DECL|method|setOverlappingGroups (List<GroupTreeNode> nodes)
specifier|public
name|void
name|setOverlappingGroups
parameter_list|(
name|List
argument_list|<
name|GroupTreeNode
argument_list|>
name|nodes
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
name|localCellRenderer
operator|.
name|setOverlappingGroups
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
block|}
comment|/**      * Highlights the specified groups by underlining      **/
DECL|method|setMatchingGroups (List<GroupTreeNode> nodes)
specifier|public
name|void
name|setMatchingGroups
parameter_list|(
name|List
argument_list|<
name|GroupTreeNode
argument_list|>
name|nodes
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
name|localCellRenderer
operator|.
name|setMatchingGroups
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
block|}
comment|/** Highlights the specified cell or disables highlight if cell == null */
DECL|method|setHighlightBorderCell (GroupTreeNodeViewModel node)
specifier|public
name|void
name|setHighlightBorderCell
parameter_list|(
name|GroupTreeNodeViewModel
name|node
parameter_list|)
block|{
name|localCellRenderer
operator|.
name|setHighlightBorderCell
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
block|}
comment|/** Sort immediate children of the specified node alphabetically. */
DECL|method|sort (GroupTreeNodeViewModel node, boolean recursive)
specifier|public
name|void
name|sort
parameter_list|(
name|GroupTreeNodeViewModel
name|node
parameter_list|,
name|boolean
name|recursive
parameter_list|)
block|{
name|node
operator|.
name|sortChildrenByName
argument_list|(
name|recursive
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns true if the node specified by path has at least one descendant      * that is currently expanded.      */
DECL|method|hasExpandedDescendant (TreePath path)
specifier|public
name|boolean
name|hasExpandedDescendant
parameter_list|(
name|TreePath
name|path
parameter_list|)
block|{
name|GroupTreeNodeViewModel
name|node
init|=
operator|(
name|GroupTreeNodeViewModel
operator|)
name|path
operator|.
name|getLastPathComponent
argument_list|()
decl_stmt|;
for|for
control|(
name|GroupTreeNodeViewModel
name|child
range|:
name|node
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|.
name|isLeaf
argument_list|()
condition|)
block|{
continue|continue;
comment|// don't care about this case
block|}
name|TreePath
name|pathToChild
init|=
name|path
operator|.
name|pathByAddingChild
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|isExpanded
argument_list|(
name|pathToChild
argument_list|)
operator|||
name|hasExpandedDescendant
argument_list|(
name|pathToChild
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Returns true if the node specified by path has at least one descendant      * that is currently collapsed.      */
DECL|method|hasCollapsedDescendant (TreePath path)
specifier|public
name|boolean
name|hasCollapsedDescendant
parameter_list|(
name|TreePath
name|path
parameter_list|)
block|{
name|GroupTreeNodeViewModel
name|node
init|=
operator|(
name|GroupTreeNodeViewModel
operator|)
name|path
operator|.
name|getLastPathComponent
argument_list|()
decl_stmt|;
for|for
control|(
name|GroupTreeNodeViewModel
name|child
range|:
name|node
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|.
name|isLeaf
argument_list|()
condition|)
block|{
continue|continue;
comment|// don't care about this case
block|}
name|TreePath
name|pathToChild
init|=
name|path
operator|.
name|pathByAddingChild
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|isCollapsed
argument_list|(
name|pathToChild
argument_list|)
operator|||
name|hasCollapsedDescendant
argument_list|(
name|pathToChild
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

