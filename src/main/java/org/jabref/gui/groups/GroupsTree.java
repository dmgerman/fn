begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.jabref.gui.groups
package|package
name|org
operator|.
name|jabref
operator|.
name|gui
operator|.
name|groups
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Point
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|dnd
operator|.
name|DnDConstants
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|dnd
operator|.
name|DragGestureEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|dnd
operator|.
name|DragGestureListener
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|dnd
operator|.
name|DragGestureRecognizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|dnd
operator|.
name|DragSource
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|dnd
operator|.
name|DragSourceDragEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|dnd
operator|.
name|DragSourceDropEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|dnd
operator|.
name|DragSourceEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|dnd
operator|.
name|DragSourceListener
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|dnd
operator|.
name|DropTarget
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|dnd
operator|.
name|DropTargetDragEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|dnd
operator|.
name|DropTargetDropEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|dnd
operator|.
name|DropTargetEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|dnd
operator|.
name|DropTargetListener
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|InputEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JTree
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|ToolTipManager
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|tree
operator|.
name|TreePath
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|tree
operator|.
name|TreeSelectionModel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|groups
operator|.
name|GroupTreeNode
import|;
end_import

begin_class
DECL|class|GroupsTree
specifier|public
class|class
name|GroupsTree
extends|extends
name|JTree
implements|implements
name|DragSourceListener
implements|,
name|DropTargetListener
implements|,
name|DragGestureListener
block|{
comment|/** distance from component borders from which on autoscrolling starts. */
DECL|field|DRAG_SCROLL_ACTIVATION_MARGIN
specifier|private
specifier|static
specifier|final
name|int
name|DRAG_SCROLL_ACTIVATION_MARGIN
init|=
literal|10
decl_stmt|;
comment|/** number of pixels to scroll each time handler is called. */
DECL|field|DRAG_SCROLL_DISTANCE
specifier|private
specifier|static
specifier|final
name|int
name|DRAG_SCROLL_DISTANCE
init|=
literal|5
decl_stmt|;
comment|/** minimum interval between two autoscroll events (for limiting speed). */
DECL|field|MIN_AUTOSCROLL_INTERVAL
specifier|private
specifier|static
specifier|final
name|long
name|MIN_AUTOSCROLL_INTERVAL
init|=
literal|50L
decl_stmt|;
comment|/** max. distance cursor may move in x or y direction while idling. */
DECL|field|IDLE_MARGIN
specifier|private
specifier|static
specifier|final
name|int
name|IDLE_MARGIN
init|=
literal|1
decl_stmt|;
comment|/** idle time after which the node below is expanded. */
DECL|field|IDLE_TIME_TO_EXPAND_NODE
specifier|private
specifier|static
specifier|final
name|long
name|IDLE_TIME_TO_EXPAND_NODE
init|=
literal|1000L
decl_stmt|;
comment|/**      * time of last autoscroll event (for limiting speed).      */
DECL|field|lastDragAutoscroll
specifier|private
specifier|static
name|long
name|lastDragAutoscroll
decl_stmt|;
DECL|field|groupSelector
specifier|private
specifier|final
name|GroupSelector
name|groupSelector
decl_stmt|;
DECL|field|localCellRenderer
specifier|private
specifier|final
name|GroupTreeCellRenderer
name|localCellRenderer
init|=
operator|new
name|GroupTreeCellRenderer
argument_list|()
decl_stmt|;
comment|/**      * the point on which the cursor is currently idling during a drag      * operation.      */
DECL|field|idlePoint
specifier|private
name|Point
name|idlePoint
decl_stmt|;
comment|/**      * time since which cursor is idling.      */
DECL|field|idleStartTime
specifier|private
name|long
name|idleStartTime
decl_stmt|;
DECL|field|dragNode
specifier|private
name|GroupTreeNodeViewModel
name|dragNode
decl_stmt|;
comment|/**      * @param groupSelector the parent UI component      */
DECL|method|GroupsTree (GroupSelector groupSelector)
specifier|public
name|GroupsTree
parameter_list|(
name|GroupSelector
name|groupSelector
parameter_list|)
block|{
name|this
operator|.
name|groupSelector
operator|=
name|groupSelector
expr_stmt|;
name|DragGestureRecognizer
name|dgr
init|=
name|DragSource
operator|.
name|getDefaultDragSource
argument_list|()
operator|.
name|createDefaultDragGestureRecognizer
argument_list|(
name|this
argument_list|,
name|DnDConstants
operator|.
name|ACTION_MOVE
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|dgr
operator|!=
literal|null
condition|)
block|{
comment|// Eliminates right mouse clicks as valid actions
name|dgr
operator|.
name|setSourceActions
argument_list|(
name|dgr
operator|.
name|getSourceActions
argument_list|()
operator|&
operator|~
name|InputEvent
operator|.
name|BUTTON3_MASK
argument_list|)
expr_stmt|;
block|}
operator|new
name|DropTarget
argument_list|(
name|this
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|setCellRenderer
argument_list|(
name|localCellRenderer
argument_list|)
expr_stmt|;
name|setFocusable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|setToggleClickCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ToolTipManager
operator|.
name|sharedInstance
argument_list|()
operator|.
name|registerComponent
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|setShowsRootHandles
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|getSelectionModel
argument_list|()
operator|.
name|setSelectionMode
argument_list|(
name|TreeSelectionModel
operator|.
name|DISCONTIGUOUS_TREE_SELECTION
argument_list|)
expr_stmt|;
name|this
operator|.
name|setFocusable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|dragEnter (DragSourceDragEvent dsde)
specifier|public
name|void
name|dragEnter
parameter_list|(
name|DragSourceDragEvent
name|dsde
parameter_list|)
block|{
comment|// ignore
block|}
comment|/** This is for moving of nodes within myself */
annotation|@
name|Override
DECL|method|dragOver (DragSourceDragEvent dsde)
specifier|public
name|void
name|dragOver
parameter_list|(
name|DragSourceDragEvent
name|dsde
parameter_list|)
block|{     }
annotation|@
name|Override
DECL|method|dropActionChanged (DragSourceDragEvent dsde)
specifier|public
name|void
name|dropActionChanged
parameter_list|(
name|DragSourceDragEvent
name|dsde
parameter_list|)
block|{
comment|// ignore
block|}
annotation|@
name|Override
DECL|method|dragDropEnd (DragSourceDropEvent dsde)
specifier|public
name|void
name|dragDropEnd
parameter_list|(
name|DragSourceDropEvent
name|dsde
parameter_list|)
block|{
name|dragNode
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|dragExit (DragSourceEvent dse)
specifier|public
name|void
name|dragExit
parameter_list|(
name|DragSourceEvent
name|dse
parameter_list|)
block|{
comment|// ignore
block|}
annotation|@
name|Override
DECL|method|dragEnter (DropTargetDragEvent dtde)
specifier|public
name|void
name|dragEnter
parameter_list|(
name|DropTargetDragEvent
name|dtde
parameter_list|)
block|{
comment|// ignore
block|}
comment|/** This handles dragging of nodes (from myself) or entries (from the table) */
annotation|@
name|Override
DECL|method|dragOver (DropTargetDragEvent dtde)
specifier|public
name|void
name|dragOver
parameter_list|(
name|DropTargetDragEvent
name|dtde
parameter_list|)
block|{
comment|/*         // accept or reject             if (dtde                 .isDataFlavorSupported(TransferableEntrySelection.FLAVOR_INTERNAL)) {             // check if node accepts explicit assignment             if (target == null) {                 dtde.rejectDrag();             } else {                 // this would be the place to check if the dragging entries                 // maybe are in this group already, but I think that's not                 // worth the bother (DropTargetDragEvent does not provide                 // access to the drag object)...                 // it might even be irritating to the user.                 if (target.getNode().getGroup() instanceof GroupEntryChanger) {                     // accept: assignment from EntryTable                     dtde.acceptDrag(DnDConstants.ACTION_LINK);                 } else {                     dtde.rejectDrag();                 }             }         } else {             dtde.rejectDrag();         }         */
block|}
annotation|@
name|Override
DECL|method|dropActionChanged (DropTargetDragEvent dtde)
specifier|public
name|void
name|dropActionChanged
parameter_list|(
name|DropTargetDragEvent
name|dtde
parameter_list|)
block|{
comment|// ignore
block|}
annotation|@
name|Override
DECL|method|drop (DropTargetDropEvent dtde)
specifier|public
name|void
name|drop
parameter_list|(
name|DropTargetDropEvent
name|dtde
parameter_list|)
block|{
comment|/*         try {              final GroupTreeNodeViewModel target = (GroupTreeNodeViewModel) path                     .getLastPathComponent();             // check supported flavors             final Transferable transferable = dtde.getTransferable();               } else if (transferable                     .isDataFlavorSupported(TransferableEntrySelection.FLAVOR_INTERNAL)) {                 final AbstractGroup group = target.getNode().getGroup();                 if (!(target.getNode().getGroup() instanceof GroupEntryChanger)) {                     // this should never happen, because the same condition                     // is checked in dragOver already                     dtde.rejectDrop();                     return;                 }                 final TransferableEntrySelection selection = (TransferableEntrySelection) transferable                         .getTransferData(TransferableEntrySelection.FLAVOR_INTERNAL);                 final List<BibEntry> entries = selection.getSelection();                 int assignedEntries = 0;                 for (BibEntry entry : entries) {                     if (!target.getNode().getGroup().contains(entry)) {                         ++assignedEntries;                     }                 }                  // warn if assignment has undesired side effects (modifies a                 // field != keywords)                 if (!WarnAssignmentSideEffects.warnAssignmentSideEffects(group, groupSelector.frame))                  {                     return; // user aborted operation                 }                  // if an editor is showing, its fields must be updated                 // after the assignment, and before that, the current                 // edit has to be stored:                 groupSelector.getActiveBasePanel().storeCurrentEdit();                  List<FieldChange> undo = target.addEntriesToGroup(selection.getSelection());                 if (!undo.isEmpty()) {                     dtde.getDropTargetContext().dropComplete(true);                     groupSelector.concludeAssignment(UndoableChangeEntriesOfGroup.getUndoableEdit(target, undo),                             target.getNode(), assignedEntries);                 }             } else {                 dtde.rejectDrop();             }         } catch (IOException | UnsupportedFlavorException ioe) {             // ignore         }         */
block|}
annotation|@
name|Override
DECL|method|dragExit (DropTargetEvent dte)
specifier|public
name|void
name|dragExit
parameter_list|(
name|DropTargetEvent
name|dte
parameter_list|)
block|{
name|setHighlight1Cell
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|dragGestureRecognized (DragGestureEvent dge)
specifier|public
name|void
name|dragGestureRecognized
parameter_list|(
name|DragGestureEvent
name|dge
parameter_list|)
block|{     }
comment|/** Returns the first selected node, or null if nothing is selected. */
DECL|method|getSelectedNode ()
specifier|private
name|GroupTreeNodeViewModel
name|getSelectedNode
parameter_list|()
block|{
name|TreePath
name|selectionPath
init|=
name|getSelectionPath
argument_list|()
decl_stmt|;
return|return
name|selectionPath
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|GroupTreeNodeViewModel
operator|)
name|selectionPath
operator|.
name|getLastPathComponent
argument_list|()
return|;
block|}
comment|/**      * Refresh paths that may have become invalid due to node movements within      * the tree. This method creates new paths to the last path components      * (which must still exist) of the specified paths.      *      * @param paths      *            Paths that may have become invalid.      * @return Refreshed paths that are all valid.      */
DECL|method|refreshPaths (Enumeration<TreePath> paths)
specifier|public
name|Enumeration
argument_list|<
name|TreePath
argument_list|>
name|refreshPaths
parameter_list|(
name|Enumeration
argument_list|<
name|TreePath
argument_list|>
name|paths
parameter_list|)
block|{
if|if
condition|(
name|paths
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|Vector
argument_list|<
name|TreePath
argument_list|>
argument_list|()
operator|.
name|elements
argument_list|()
return|;
block|}
name|Vector
argument_list|<
name|TreePath
argument_list|>
name|freshPaths
init|=
operator|new
name|Vector
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|paths
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|freshPaths
operator|.
name|add
argument_list|(
operator|(
operator|(
name|GroupTreeNodeViewModel
operator|)
name|paths
operator|.
name|nextElement
argument_list|()
operator|.
name|getLastPathComponent
argument_list|()
operator|)
operator|.
name|getTreePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|freshPaths
operator|.
name|elements
argument_list|()
return|;
block|}
comment|/**      * Refresh paths that may have become invalid due to node movements within      * the tree. This method creates new paths to the last path components      * (which must still exist) of the specified paths.      *      * @param paths      *            Paths that may have become invalid.      * @return Refreshed paths that are all valid.      */
DECL|method|refreshPaths (TreePath[] paths)
specifier|public
name|TreePath
index|[]
name|refreshPaths
parameter_list|(
name|TreePath
index|[]
name|paths
parameter_list|)
block|{
name|TreePath
index|[]
name|freshPaths
init|=
operator|new
name|TreePath
index|[
name|paths
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paths
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|freshPaths
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|GroupTreeNodeViewModel
operator|)
name|paths
index|[
name|i
index|]
operator|.
name|getLastPathComponent
argument_list|()
operator|)
operator|.
name|getTreePath
argument_list|()
expr_stmt|;
block|}
return|return
name|freshPaths
return|;
block|}
comment|/** Highlights the specified cell or disables highlight if cell == null */
DECL|method|setHighlight1Cell (Object cell)
specifier|private
name|void
name|setHighlight1Cell
parameter_list|(
name|Object
name|cell
parameter_list|)
block|{
name|localCellRenderer
operator|.
name|setHighlight1Cell
argument_list|(
name|cell
argument_list|)
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
block|}
comment|/**      * Highlights the specified groups in red      **/
DECL|method|setOverlappingGroups (List<GroupTreeNode> nodes)
specifier|public
name|void
name|setOverlappingGroups
parameter_list|(
name|List
argument_list|<
name|GroupTreeNode
argument_list|>
name|nodes
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
name|localCellRenderer
operator|.
name|setOverlappingGroups
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
block|}
comment|/**      * Highlights the specified groups by underlining      **/
DECL|method|setMatchingGroups (List<GroupTreeNode> nodes)
specifier|public
name|void
name|setMatchingGroups
parameter_list|(
name|List
argument_list|<
name|GroupTreeNode
argument_list|>
name|nodes
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
name|localCellRenderer
operator|.
name|setMatchingGroups
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
block|}
comment|/** Highlights the specified cell or disables highlight if cell == null */
DECL|method|setHighlightBorderCell (GroupTreeNodeViewModel node)
specifier|public
name|void
name|setHighlightBorderCell
parameter_list|(
name|GroupTreeNodeViewModel
name|node
parameter_list|)
block|{
name|localCellRenderer
operator|.
name|setHighlightBorderCell
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
block|}
comment|/** Sort immediate children of the specified node alphabetically. */
DECL|method|sort (GroupTreeNodeViewModel node, boolean recursive)
specifier|public
name|void
name|sort
parameter_list|(
name|GroupTreeNodeViewModel
name|node
parameter_list|,
name|boolean
name|recursive
parameter_list|)
block|{
name|node
operator|.
name|sortChildrenByName
argument_list|(
name|recursive
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns true if the node specified by path has at least one descendant      * that is currently expanded.      */
DECL|method|hasExpandedDescendant (TreePath path)
specifier|public
name|boolean
name|hasExpandedDescendant
parameter_list|(
name|TreePath
name|path
parameter_list|)
block|{
name|GroupTreeNodeViewModel
name|node
init|=
operator|(
name|GroupTreeNodeViewModel
operator|)
name|path
operator|.
name|getLastPathComponent
argument_list|()
decl_stmt|;
for|for
control|(
name|GroupTreeNodeViewModel
name|child
range|:
name|node
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|.
name|isLeaf
argument_list|()
condition|)
block|{
continue|continue;
comment|// don't care about this case
block|}
name|TreePath
name|pathToChild
init|=
name|path
operator|.
name|pathByAddingChild
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|isExpanded
argument_list|(
name|pathToChild
argument_list|)
operator|||
name|hasExpandedDescendant
argument_list|(
name|pathToChild
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Returns true if the node specified by path has at least one descendant      * that is currently collapsed.      */
DECL|method|hasCollapsedDescendant (TreePath path)
specifier|public
name|boolean
name|hasCollapsedDescendant
parameter_list|(
name|TreePath
name|path
parameter_list|)
block|{
name|GroupTreeNodeViewModel
name|node
init|=
operator|(
name|GroupTreeNodeViewModel
operator|)
name|path
operator|.
name|getLastPathComponent
argument_list|()
decl_stmt|;
for|for
control|(
name|GroupTreeNodeViewModel
name|child
range|:
name|node
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|.
name|isLeaf
argument_list|()
condition|)
block|{
continue|continue;
comment|// don't care about this case
block|}
name|TreePath
name|pathToChild
init|=
name|path
operator|.
name|pathByAddingChild
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|isCollapsed
argument_list|(
name|pathToChild
argument_list|)
operator|||
name|hasCollapsedDescendant
argument_list|(
name|pathToChild
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

