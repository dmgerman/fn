begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.jabref.gui.maintable
package|package
name|org
operator|.
name|jabref
operator|.
name|gui
operator|.
name|maintable
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|FocusEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|FocusListener
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|KeyEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|KeyListener
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|MouseEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|MouseListener
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JPopupMenu
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|Timer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|gui
operator|.
name|BasePanel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|gui
operator|.
name|BasePanelMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|gui
operator|.
name|PreviewPanel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|gui
operator|.
name|entryeditor
operator|.
name|EntryEditor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|BibEntry
import|;
end_import

begin_import
import|import
name|ca
operator|.
name|odell
operator|.
name|glazedlists
operator|.
name|BasicEventList
import|;
end_import

begin_import
import|import
name|ca
operator|.
name|odell
operator|.
name|glazedlists
operator|.
name|EventList
import|;
end_import

begin_import
import|import
name|ca
operator|.
name|odell
operator|.
name|glazedlists
operator|.
name|event
operator|.
name|ListEvent
import|;
end_import

begin_import
import|import
name|ca
operator|.
name|odell
operator|.
name|glazedlists
operator|.
name|event
operator|.
name|ListEventListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * List event, mouse, key and focus listener for the main table that makes up the  * most part of the BasePanel for a single BIB database.  */
end_comment

begin_class
DECL|class|MainTableSelectionListener
specifier|public
class|class
name|MainTableSelectionListener
implements|implements
name|ListEventListener
argument_list|<
name|BibEntry
argument_list|>
implements|,
name|MouseListener
implements|,
name|KeyListener
implements|,
name|FocusListener
block|{
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MainTableSelectionListener
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|table
specifier|private
specifier|final
name|MainTable
name|table
decl_stmt|;
DECL|field|panel
specifier|private
specifier|final
name|BasePanel
name|panel
decl_stmt|;
DECL|field|tableRows
specifier|private
specifier|final
name|EventList
argument_list|<
name|BibEntry
argument_list|>
name|tableRows
decl_stmt|;
comment|// Register the last character pressed to quick jump in the table. Together
comment|// with storing the last row number jumped to, this is used to let multiple
comment|// key strokes cycle between all entries starting with the same letter:
DECL|field|lastPressed
specifier|private
specifier|final
name|int
index|[]
name|lastPressed
init|=
operator|new
name|int
index|[
literal|20
index|]
decl_stmt|;
DECL|field|preview
specifier|private
name|PreviewPanel
name|preview
decl_stmt|;
DECL|field|workingOnPreview
specifier|private
name|boolean
name|workingOnPreview
decl_stmt|;
DECL|field|enabled
specifier|private
name|boolean
name|enabled
init|=
literal|true
decl_stmt|;
DECL|field|lastPressedCount
specifier|private
name|int
name|lastPressedCount
decl_stmt|;
DECL|field|lastPressedTime
specifier|private
name|long
name|lastPressedTime
decl_stmt|;
DECL|method|MainTableSelectionListener (BasePanel panel, MainTable table)
specifier|public
name|MainTableSelectionListener
parameter_list|(
name|BasePanel
name|panel
parameter_list|,
name|MainTable
name|table
parameter_list|)
block|{
name|this
operator|.
name|table
operator|=
name|table
expr_stmt|;
name|this
operator|.
name|panel
operator|=
name|panel
expr_stmt|;
name|this
operator|.
name|tableRows
operator|=
operator|new
name|BasicEventList
argument_list|<>
argument_list|()
expr_stmt|;
name|preview
operator|=
name|panel
operator|.
name|getPreviewPanel
argument_list|()
expr_stmt|;
block|}
DECL|method|setEnabled (boolean enabled)
specifier|public
name|void
name|setEnabled
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
name|this
operator|.
name|enabled
operator|=
name|enabled
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|listChanged (ListEvent<BibEntry> e)
specifier|public
name|void
name|listChanged
parameter_list|(
name|ListEvent
argument_list|<
name|BibEntry
argument_list|>
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|enabled
condition|)
block|{
return|return;
block|}
name|EventList
argument_list|<
name|BibEntry
argument_list|>
name|selected
init|=
name|e
operator|.
name|getSourceList
argument_list|()
decl_stmt|;
if|if
condition|(
name|selected
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
specifier|final
name|BibEntry
name|newSelected
init|=
name|selected
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|panel
operator|.
name|getMode
argument_list|()
operator|==
name|BasePanelMode
operator|.
name|SHOWING_EDITOR
operator|||
name|panel
operator|.
name|getMode
argument_list|()
operator|==
name|BasePanelMode
operator|.
name|WILL_SHOW_EDITOR
operator|)
operator|&&
name|panel
operator|.
name|getEntryEditor
argument_list|()
operator|!=
literal|null
operator|&&
name|newSelected
operator|==
name|panel
operator|.
name|getEntryEditor
argument_list|()
operator|.
name|getEntry
argument_list|()
condition|)
block|{
comment|// entry already selected and currently editing it, do not steal the focus from the selected textfield
return|return;
block|}
if|if
condition|(
name|newSelected
operator|!=
literal|null
condition|)
block|{
comment|// TODO: Update entry editor / preview on selection change
comment|/*             final BasePanelMode mode = panel.getMode(); // What is the panel already showing?             if ((mode == BasePanelMode.WILL_SHOW_EDITOR) || (mode == BasePanelMode.SHOWING_EDITOR)) {                 panel.showAndEdit(newSelected);                 SwingUtilities.invokeLater(() -> table.ensureVisible(table.getSelectedRow()));             } else if (panel.getMode() == BasePanelMode.SHOWING_NOTHING || panel.getMode() == BasePanelMode.SHOWING_PREVIEW) {                 // Either nothing or a preview was shown. Update the preview.                 updatePreview(newSelected);             }             */
block|}
block|}
DECL|method|updatePreview (final BibEntry toShow)
specifier|private
name|void
name|updatePreview
parameter_list|(
specifier|final
name|BibEntry
name|toShow
parameter_list|)
block|{
name|updatePreview
argument_list|(
name|toShow
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|updatePreview (final BibEntry toShow, int repeats)
specifier|private
name|void
name|updatePreview
parameter_list|(
specifier|final
name|BibEntry
name|toShow
parameter_list|,
name|int
name|repeats
parameter_list|)
block|{
if|if
condition|(
name|workingOnPreview
condition|)
block|{
if|if
condition|(
name|repeats
operator|>
literal|0
condition|)
block|{
return|return;
comment|// We've already waited once. Give up on this selection.
block|}
name|Timer
name|t
init|=
operator|new
name|Timer
argument_list|(
literal|50
argument_list|,
name|actionEvent
lambda|->
name|updatePreview
argument_list|(
name|toShow
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|t
operator|.
name|setRepeats
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/*         EventList<BibEntry> list = table.getSelected();         // Check if the entry to preview is still selected:         if ((list.size() != 1) || (list.get(0) != toShow)) {             return;         }         workingOnPreview = true;         SwingUtilities.invokeLater(() -> {             panel.showPreview(toShow);             workingOnPreview = false;         });         */
block|}
annotation|@
name|Override
DECL|method|mouseReleased (MouseEvent e)
specifier|public
name|void
name|mouseReleased
parameter_list|(
name|MouseEvent
name|e
parameter_list|)
block|{
comment|// TODO: Right-click menu for special columns
comment|/*         // Check if the user has right-clicked. If so, open the right-click menu.         if (e.isPopupTrigger() || (e.getButton() == MouseEvent.BUTTON3)) {             if ((modelColumn == null) || !modelColumn.isIconColumn()) {                 // show normal right click menu                 processPopupTrigger(e, row);             } else {                 // show right click menu for icon columns                 showIconRightClickMenu(e, row, modelColumn);             }         }         */
block|}
annotation|@
name|Override
DECL|method|mousePressed (MouseEvent e)
specifier|public
name|void
name|mousePressed
parameter_list|(
name|MouseEvent
name|e
parameter_list|)
block|{
comment|// all handling is done in "mouseReleased"
block|}
annotation|@
name|Override
DECL|method|mouseClicked (MouseEvent e)
specifier|public
name|void
name|mouseClicked
parameter_list|(
name|MouseEvent
name|e
parameter_list|)
block|{
comment|/*         // First find the column on which the user has clicked.         final int row = table.rowAtPoint(e.getPoint());          // A double click on an entry should open the entry's editor.         if (e.getClickCount() == 2) {             BibEntry toShow = tableRows.get(row);             panel.showAndEdit(toShow);             return;         }          final int col = table.columnAtPoint(e.getPoint());         // get the MainTableColumn which is currently visible at col         int modelIndex = table.getColumnModel().getColumn(col).getModelIndex();         MainTableColumn modelColumn = table.getMainTableColumn(modelIndex);          // Workaround for Windows. Right-click is not popup trigger on mousePressed, but         // on mouseReleased. Therefore we need to avoid taking action at this point, because         // action will be taken when the button is released:         if (OS.WINDOWS&& (modelColumn.isIconColumn())&& (e.getButton() != MouseEvent.BUTTON1)) {             return;         }          // Check if the clicked colum is a specialfield column         if (modelColumn.isIconColumn()&& (SpecialField.isSpecialField(modelColumn.getColumnName()))) {             // handle specialfield             handleSpecialFieldLeftClick(e, modelColumn.getColumnName());         } else if (modelColumn.isIconColumn()) { // left click on icon field              Object value = table.getValueAt(row, col);             if (value == null) {                 return; // No icon here, so we do nothing.             }              final BibEntry entry = tableRows.get(row);              final List<String> fieldNames = modelColumn.getBibtexFields();              // Open it now. We do this in a thread, so the program won't freeze during the wait.             JabRefExecutorService.INSTANCE.execute(() -> {                 panel.output(Localization.lang("External viewer called") + '.');                 // check for all field names whether a link is present                 // (is relevant for combinations such as "url/doi")                 for (String fieldName : fieldNames) {                     // Check if field is present, if not skip this field                     if (entry.hasField(fieldName)) {                         String link = entry.getField(fieldName).get();                          // See if this is a simple file link field, or if it is a file-list                         // field that can specify a list of links:                         if (fieldName.equals(FieldName.FILE)) {                              // We use a FileListTableModel to parse the field content:                             FileListTableModel fileList = new FileListTableModel();                             fileList.setContent(link);                              FileListEntry flEntry = null;                             // If there are one or more links of the correct type, open the first one:                             if (modelColumn.isFileFilter()) {                                 for (int i = 0; i< fileList.getRowCount(); i++) {                                     if (fileList.getEntry(i).getType().toString().equals(modelColumn.getColumnName())) {                                         flEntry = fileList.getEntry(i);                                         break;                                     }                                 }                             } else if (fileList.getRowCount()> 0) {                                 //If there are no file types specified open the first file                                 flEntry = fileList.getEntry(0);                             }                             if (flEntry != null) {                                 ExternalFileMenuItem item = new ExternalFileMenuItem(panel.frame(), entry, "",                                         flEntry.getLink(), flEntry.getType().map(ExternalFileType::getIcon).orElse(null),                                         panel.getBibDatabaseContext(), flEntry.getType());                                 item.doClick();                             }                         } else {                             try {                                 JabRefDesktop.openExternalViewer(panel.getBibDatabaseContext(), link, fieldName);                             } catch (IOException ex) {                                 panel.output(Localization.lang("Unable to open link."));                                 LOGGER.info("Unable to open link", ex);                             }                         }                         break; // only open the first link                     }                 }             });         } else if (modelColumn.getBibtexFields().contains(FieldName.CROSSREF)) { // Clicking on crossref column             tableRows.get(row).getField(FieldName.CROSSREF)                     .ifPresent(crossref -> panel.getDatabase().getEntryByKey(crossref).ifPresent(entry -> panel.highlightEntry(entry)));         }         panel.frame().updateEnabledState();         */
block|}
comment|/**      * Method to handle a single left click on one the special fields (e.g., ranking, quality, ...)      * Shows either a popup to select/clear a value or simply toggles the functionality to set/unset the special field      *      * @param e MouseEvent used to determine the position of the popups      * @param columnName the name of the specialfield column      */
DECL|method|handleSpecialFieldLeftClick (MouseEvent e, String columnName)
specifier|private
name|void
name|handleSpecialFieldLeftClick
parameter_list|(
name|MouseEvent
name|e
parameter_list|,
name|String
name|columnName
parameter_list|)
block|{
comment|/*         if ((e.getClickCount() == 1)) {             SpecialField.getSpecialFieldInstanceFromFieldName(columnName).ifPresent(field -> {                 // special field found                 if (field.isSingleValueField()) {                     // directly execute toggle action instead of showing a menu with one action                     new SpecialFieldViewModel(field).getSpecialFieldAction(field.getValues().get(0), panel.frame()).action();                 } else {                     JPopupMenu menu = new JPopupMenu();                     for (SpecialFieldValue val : field.getValues()) {                         menu.add(new SpecialFieldMenuAction(new SpecialFieldValueViewModel(val), panel.frame()));                     }                     menu.show(table, e.getX(), e.getY());                 }             });         }         */
block|}
comment|/**      * Process general right-click events on the table. Show the table context menu at      * the position where the user right-clicked.      * @param e The mouse event defining the popup trigger.      * @param row The row where the event occurred.      */
DECL|method|processPopupTrigger (MouseEvent e, int row)
specifier|private
name|void
name|processPopupTrigger
parameter_list|(
name|MouseEvent
name|e
parameter_list|,
name|int
name|row
parameter_list|)
block|{
comment|/*         int selRow = table.getSelectedRow();         if ((selRow == -1) || !table.isRowSelected(table.rowAtPoint(e.getPoint()))) {             table.setRowSelectionInterval(row, row);         }         RightClickMenu rightClickMenu = new RightClickMenu(JabRefGUI.getMainFrame(), panel);         rightClickMenu.show(table, e.getX(), e.getY());         */
block|}
comment|/**      * Process popup trigger events occurring on an icon cell in the table. Show a menu where the user can choose which      * external resource to open for the entry. If no relevant external resources exist, let the normal popup trigger      * handler do its thing instead.      *      * @param e The mouse event defining this popup trigger.      * @param row The row where the event occurred.      * @param column the MainTableColumn associated with this table cell.      */
DECL|method|showIconRightClickMenu (MouseEvent e, int row, MainTableColumn column)
specifier|private
name|void
name|showIconRightClickMenu
parameter_list|(
name|MouseEvent
name|e
parameter_list|,
name|int
name|row
parameter_list|,
name|MainTableColumn
name|column
parameter_list|)
block|{
name|BibEntry
name|entry
init|=
name|tableRows
operator|.
name|get
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|JPopupMenu
name|menu
init|=
operator|new
name|JPopupMenu
argument_list|()
decl_stmt|;
name|boolean
name|showDefaultPopup
init|=
literal|true
decl_stmt|;
comment|/*         // See if this is a simple file link field, or if it is a file-list         // field that can specify a list of links:         if (!column.getBibtexFields().isEmpty()) {             for (String field : column.getBibtexFields()) {                 if (FieldName.FILE.equals(field)) {                     // We use a FileListTableModel to parse the field content:                     FileListTableModel fileList = new FileListTableModel();                     entry.getField(field).ifPresent(fileList::setContent);                     for (int i = 0; i< fileList.getRowCount(); i++) {                         FileListEntry flEntry = fileList.getEntry(i);                         if (column.isFileFilter()&& (!flEntry.getType().get().getName().equalsIgnoreCase(column.getColumnName()))) {                             continue;                         }                         String description = flEntry.getDescription();                         if ((description == null) || (description.trim().isEmpty())) {                             description = flEntry.getLink();                         }                         menu.add(new ExternalFileMenuItem(panel.frame(), entry, description, flEntry.getLink(),                                 flEntry.getType().get().getIcon(), panel.getBibDatabaseContext(),                                 flEntry.getType()));                         showDefaultPopup = false;                     }                 } else {                     if (SpecialField.isSpecialField(column.getColumnName())) {                         // full pop should be shown as left click already shows short popup                         showDefaultPopup = true;                     } else {                         Optional<String> content = entry.getField(field);                         if (content.isPresent()) {                             Icon icon;                             JLabel iconLabel = GUIGlobals.getTableIcon(field);                             if (iconLabel == null) {                                 icon = IconTheme.JabRefIcon.FILE.getIcon();                             } else {                                 icon = iconLabel.getIcon();                             }                             menu.add(new ExternalFileMenuItem(panel.frame(), entry, content.get(), content.get(), icon,                                     panel.getBibDatabaseContext(), field));                             if (field.equals(FieldName.DOI)) {                                 menu.add(new CopyDoiUrlAction(content.get()));                             }                             showDefaultPopup = false;                         }                     }                 }             }             if (showDefaultPopup) {                 processPopupTrigger(e, row);             } else {                 menu.show(table, e.getX(), e.getY());             }         }         */
block|}
DECL|method|entryEditorClosing (EntryEditor editor)
specifier|public
name|void
name|entryEditorClosing
parameter_list|(
name|EntryEditor
name|editor
parameter_list|)
block|{
comment|/*         if (Globals.prefs.getPreviewPreferences().isPreviewPanelEnabled()) {             panel.showPreview(editor.getEntry());         } else {             panel.hideBottomComponent();             panel.adjustSplitter();         }         table.requestFocus();         */
block|}
annotation|@
name|Override
DECL|method|mouseEntered (MouseEvent e)
specifier|public
name|void
name|mouseEntered
parameter_list|(
name|MouseEvent
name|e
parameter_list|)
block|{
comment|// Do nothing
block|}
annotation|@
name|Override
DECL|method|mouseExited (MouseEvent e)
specifier|public
name|void
name|mouseExited
parameter_list|(
name|MouseEvent
name|e
parameter_list|)
block|{
comment|// Do nothing
block|}
comment|/**      * Receive key event on the main table. If the key is a letter or a digit,      * we should select the first entry in the table which starts with the given      * letter in the column by which the table is sorted.      * @param e The KeyEvent      */
annotation|@
name|Override
DECL|method|keyTyped (KeyEvent e)
specifier|public
name|void
name|keyTyped
parameter_list|(
name|KeyEvent
name|e
parameter_list|)
block|{
comment|/*         if ((!e.isActionKey())&& Character.isLetterOrDigit(e.getKeyChar())&& (e.getModifiers() == 0)) {             long time = System.currentTimeMillis();             final long QUICK_JUMP_TIMEOUT = 2000;             if ((time - lastPressedTime)> QUICK_JUMP_TIMEOUT) {                 lastPressedCount = 0; // Reset last pressed character             }             // Update timestamp:             lastPressedTime = time;             // Add the new char to the search array:             int c = e.getKeyChar();             if (lastPressedCount< lastPressed.length) {                 lastPressed[lastPressedCount] = c;                 lastPressedCount++;             }              int sortingColumn = table.getSortingColumn(0);             if (sortingColumn == -1) {                 return; // No sorting? TODO: look up by author, etc.?             }             // TODO: the following lookup should be done by a faster algorithm,             // such as binary search. But the table may not be sorted properly,             // due to marked entries, search etc., which rules out the binary search.              for (int i = 0; i< table.getRowCount(); i++) {                 Object o = table.getValueAt(i, sortingColumn);                 if (o == null) {                     continue;                 }                 String s = o.toString().toLowerCase(Locale.ROOT);                 if (s.length()>= lastPressedCount) {                     for (int j = 0; j< lastPressedCount; j++) {                         if (s.charAt(j) != lastPressed[j]) {                             break; // Escape the loop immediately when we find a mismatch                         } else if (j == (lastPressedCount - 1)) {                             // We found a match:                             table.setRowSelectionInterval(i, i);                             table.ensureVisible(i);                             return;                         }                     }                 }             }          } else if (e.getKeyChar() == KeyEvent.VK_ESCAPE) {             lastPressedCount = 0;         }         panel.frame().updateEnabledState();         */
block|}
annotation|@
name|Override
DECL|method|keyReleased (KeyEvent e)
specifier|public
name|void
name|keyReleased
parameter_list|(
name|KeyEvent
name|e
parameter_list|)
block|{
comment|// Do nothing
block|}
annotation|@
name|Override
DECL|method|keyPressed (KeyEvent e)
specifier|public
name|void
name|keyPressed
parameter_list|(
name|KeyEvent
name|e
parameter_list|)
block|{
comment|// Do nothing
block|}
annotation|@
name|Override
DECL|method|focusGained (FocusEvent e)
specifier|public
name|void
name|focusGained
parameter_list|(
name|FocusEvent
name|e
parameter_list|)
block|{
comment|// Do nothing
block|}
annotation|@
name|Override
DECL|method|focusLost (FocusEvent e)
specifier|public
name|void
name|focusLost
parameter_list|(
name|FocusEvent
name|e
parameter_list|)
block|{
name|lastPressedCount
operator|=
literal|0
expr_stmt|;
comment|// Reset quick jump when focus is lost.
block|}
DECL|method|getPreview ()
specifier|public
name|PreviewPanel
name|getPreview
parameter_list|()
block|{
return|return
name|preview
return|;
block|}
block|}
end_class

end_unit

