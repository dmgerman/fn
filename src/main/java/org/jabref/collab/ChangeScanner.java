begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.jabref.collab
package|package
name|org
operator|.
name|jabref
operator|.
name|collab
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JOptionPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|SwingUtilities
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|tree
operator|.
name|DefaultMutableTreeNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|Globals
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|JabRefExecutorService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|gui
operator|.
name|BasePanel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|gui
operator|.
name|JabRefFrame
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|bibtex
operator|.
name|DuplicateCheck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|bibtex
operator|.
name|comparator
operator|.
name|EntryComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|exporter
operator|.
name|BibDatabaseWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|exporter
operator|.
name|BibtexDatabaseWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|exporter
operator|.
name|FileSaveSession
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|exporter
operator|.
name|SaveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|exporter
operator|.
name|SavePreferences
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|exporter
operator|.
name|SaveSession
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|importer
operator|.
name|ImportFormatPreferences
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|importer
operator|.
name|OpenDatabase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|importer
operator|.
name|ParserResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|logic
operator|.
name|l10n
operator|.
name|Localization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|Defaults
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabaseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|EntrySorter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|BibEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|BibtexString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|FieldName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|groups
operator|.
name|GroupTreeNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jabref
operator|.
name|model
operator|.
name|metadata
operator|.
name|MetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_class
DECL|class|ChangeScanner
specifier|public
class|class
name|ChangeScanner
implements|implements
name|Runnable
block|{
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Log
name|LOGGER
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ChangeScanner
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|SORT_BY
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|SORT_BY
init|=
operator|new
name|String
index|[]
block|{
name|FieldName
operator|.
name|YEAR
block|,
name|FieldName
operator|.
name|AUTHOR
block|,
name|FieldName
operator|.
name|TITLE
block|}
decl_stmt|;
DECL|field|MATCH_THRESHOLD
specifier|private
specifier|static
specifier|final
name|double
name|MATCH_THRESHOLD
init|=
literal|0.4
decl_stmt|;
DECL|field|file
specifier|private
specifier|final
name|File
name|file
decl_stmt|;
DECL|field|databaseInMemory
specifier|private
specifier|final
name|BibDatabase
name|databaseInMemory
decl_stmt|;
DECL|field|metadataInMemory
specifier|private
specifier|final
name|MetaData
name|metadataInMemory
decl_stmt|;
DECL|field|panel
specifier|private
specifier|final
name|BasePanel
name|panel
decl_stmt|;
DECL|field|frame
specifier|private
specifier|final
name|JabRefFrame
name|frame
decl_stmt|;
DECL|field|databaseInTemp
specifier|private
name|BibDatabase
name|databaseInTemp
decl_stmt|;
DECL|field|metadataInTemp
specifier|private
name|MetaData
name|metadataInTemp
decl_stmt|;
comment|/**      * We create an ArrayList to hold the changes we find. These will be added in the form      * of UndoEdit objects. We instantiate these so that the changes found in the file on disk      * can be reproduced in memory by calling redo() on them. REDO, not UNDO!      */
DECL|field|changes
specifier|private
specifier|final
name|DefaultMutableTreeNode
name|changes
init|=
operator|new
name|DefaultMutableTreeNode
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"External changes"
argument_list|)
argument_list|)
decl_stmt|;
comment|//  NamedCompound edit = new NamedCompound("Merged external changes")
DECL|method|ChangeScanner (JabRefFrame frame, BasePanel bp, File file)
specifier|public
name|ChangeScanner
parameter_list|(
name|JabRefFrame
name|frame
parameter_list|,
name|BasePanel
name|bp
parameter_list|,
name|File
name|file
parameter_list|)
block|{
name|this
operator|.
name|panel
operator|=
name|bp
expr_stmt|;
name|this
operator|.
name|frame
operator|=
name|frame
expr_stmt|;
name|this
operator|.
name|databaseInMemory
operator|=
name|bp
operator|.
name|getDatabase
argument_list|()
expr_stmt|;
name|this
operator|.
name|metadataInMemory
operator|=
name|bp
operator|.
name|getBibDatabaseContext
argument_list|()
operator|.
name|getMetaData
argument_list|()
expr_stmt|;
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
comment|// Parse the temporary file.
name|Path
name|tempFile
init|=
name|Globals
operator|.
name|getFileUpdateMonitor
argument_list|()
operator|.
name|getTempFile
argument_list|(
name|panel
operator|.
name|fileMonitorHandle
argument_list|()
argument_list|)
decl_stmt|;
name|ImportFormatPreferences
name|importFormatPreferences
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getImportFormatPreferences
argument_list|()
decl_stmt|;
name|ParserResult
name|result
init|=
name|OpenDatabase
operator|.
name|loadDatabase
argument_list|(
name|tempFile
operator|.
name|toFile
argument_list|()
argument_list|,
name|importFormatPreferences
argument_list|)
decl_stmt|;
name|databaseInTemp
operator|=
name|result
operator|.
name|getDatabase
argument_list|()
expr_stmt|;
name|metadataInTemp
operator|=
name|result
operator|.
name|getMetaData
argument_list|()
expr_stmt|;
comment|// Parse the modified file.
name|result
operator|=
name|OpenDatabase
operator|.
name|loadDatabase
argument_list|(
name|file
argument_list|,
name|importFormatPreferences
argument_list|)
expr_stmt|;
name|BibDatabase
name|databaseOnDisk
init|=
name|result
operator|.
name|getDatabase
argument_list|()
decl_stmt|;
name|MetaData
name|metadataOnDisk
init|=
name|result
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
comment|// Sort both databases according to a common sort key.
name|EntryComparator
name|comparator
init|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|SORT_BY
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|comparator
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|SORT_BY
index|[
literal|1
index|]
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
name|comparator
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|SORT_BY
index|[
literal|0
index|]
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
name|EntrySorter
name|sorterInTemp
init|=
name|databaseInTemp
operator|.
name|getSorter
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
name|comparator
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|SORT_BY
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|comparator
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|SORT_BY
index|[
literal|1
index|]
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
name|comparator
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|SORT_BY
index|[
literal|0
index|]
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
name|EntrySorter
name|sorterOnDisk
init|=
name|databaseOnDisk
operator|.
name|getSorter
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
name|comparator
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|SORT_BY
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|comparator
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|SORT_BY
index|[
literal|1
index|]
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
name|comparator
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|SORT_BY
index|[
literal|0
index|]
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
name|EntrySorter
name|sorterInMem
init|=
name|databaseInMemory
operator|.
name|getSorter
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
comment|// Start looking at changes.
name|scanMetaData
argument_list|(
name|metadataInMemory
argument_list|,
name|metadataInTemp
argument_list|,
name|metadataOnDisk
argument_list|)
expr_stmt|;
name|scanPreamble
argument_list|(
name|databaseInMemory
argument_list|,
name|databaseInTemp
argument_list|,
name|databaseOnDisk
argument_list|)
expr_stmt|;
name|scanStrings
argument_list|(
name|databaseInMemory
argument_list|,
name|databaseInTemp
argument_list|,
name|databaseOnDisk
argument_list|)
expr_stmt|;
name|scanEntries
argument_list|(
name|sorterInMem
argument_list|,
name|sorterInTemp
argument_list|,
name|sorterOnDisk
argument_list|)
expr_stmt|;
name|scanGroups
argument_list|(
name|metadataInTemp
argument_list|,
name|metadataOnDisk
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Problem running"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|changesFound ()
specifier|public
name|boolean
name|changesFound
parameter_list|()
block|{
return|return
name|changes
operator|.
name|getChildCount
argument_list|()
operator|>
literal|0
return|;
block|}
DECL|method|displayResult (final DisplayResultCallback fup)
specifier|public
name|void
name|displayResult
parameter_list|(
specifier|final
name|DisplayResultCallback
name|fup
parameter_list|)
block|{
if|if
condition|(
name|changes
operator|.
name|getChildCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|SwingUtilities
operator|.
name|invokeLater
argument_list|(
parameter_list|()
lambda|->
block|{
name|ChangeDisplayDialog
name|changeDialog
init|=
operator|new
name|ChangeDisplayDialog
argument_list|(
name|frame
argument_list|,
name|panel
argument_list|,
name|databaseInTemp
argument_list|,
name|changes
argument_list|)
decl_stmt|;
name|changeDialog
operator|.
name|setLocationRelativeTo
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|changeDialog
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|fup
operator|.
name|scanResultsResolved
argument_list|(
name|changeDialog
operator|.
name|isOkPressed
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|changeDialog
operator|.
name|isOkPressed
argument_list|()
condition|)
block|{
comment|// Overwrite the temp database:
name|storeTempDatabase
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|JOptionPane
operator|.
name|showMessageDialog
argument_list|(
name|frame
argument_list|,
name|Localization
operator|.
name|lang
argument_list|(
literal|"No actual changes found."
argument_list|)
argument_list|,
name|Localization
operator|.
name|lang
argument_list|(
literal|"External changes"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|INFORMATION_MESSAGE
argument_list|)
expr_stmt|;
name|fup
operator|.
name|scanResultsResolved
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|storeTempDatabase ()
specifier|private
name|void
name|storeTempDatabase
parameter_list|()
block|{
name|JabRefExecutorService
operator|.
name|INSTANCE
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
name|SavePreferences
name|prefs
init|=
name|SavePreferences
operator|.
name|loadForSaveFromPreferences
argument_list|(
name|Globals
operator|.
name|prefs
argument_list|)
operator|.
name|withMakeBackup
argument_list|(
literal|false
argument_list|)
operator|.
name|withEncoding
argument_list|(
name|panel
operator|.
name|getBibDatabaseContext
argument_list|()
operator|.
name|getMetaData
argument_list|()
operator|.
name|getEncoding
argument_list|()
operator|.
name|orElse
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|getDefaultEncoding
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Defaults
name|defaults
init|=
operator|new
name|Defaults
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|getDefaultBibDatabaseMode
argument_list|()
argument_list|)
decl_stmt|;
name|BibDatabaseWriter
argument_list|<
name|SaveSession
argument_list|>
name|databaseWriter
init|=
operator|new
name|BibtexDatabaseWriter
argument_list|<>
argument_list|(
name|FileSaveSession
operator|::
operator|new
argument_list|)
decl_stmt|;
name|SaveSession
name|ss
init|=
name|databaseWriter
operator|.
name|saveDatabase
argument_list|(
operator|new
name|BibDatabaseContext
argument_list|(
name|databaseInTemp
argument_list|,
name|metadataInTemp
argument_list|,
name|defaults
argument_list|)
argument_list|,
name|prefs
argument_list|)
decl_stmt|;
name|ss
operator|.
name|commit
argument_list|(
name|Globals
operator|.
name|getFileUpdateMonitor
argument_list|()
operator|.
name|getTempFile
argument_list|(
name|panel
operator|.
name|fileMonitorHandle
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SaveException
name|ex
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Problem updating tmp file after accepting external changes"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|scanMetaData (MetaData inMemory, MetaData onTmp, MetaData onDisk)
specifier|private
name|void
name|scanMetaData
parameter_list|(
name|MetaData
name|inMemory
parameter_list|,
name|MetaData
name|onTmp
parameter_list|,
name|MetaData
name|onDisk
parameter_list|)
block|{
if|if
condition|(
operator|!
name|onTmp
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|inMemory
operator|.
name|equals
argument_list|(
name|onDisk
argument_list|)
condition|)
block|{
name|changes
operator|.
name|add
argument_list|(
operator|new
name|MetaDataChange
argument_list|(
name|inMemory
argument_list|,
name|onDisk
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|onDisk
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|onTmp
operator|.
name|equals
argument_list|(
name|onDisk
argument_list|)
condition|)
block|{
name|changes
operator|.
name|add
argument_list|(
operator|new
name|MetaDataChange
argument_list|(
name|inMemory
argument_list|,
name|onDisk
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|scanEntries (EntrySorter memorySorter, EntrySorter tmpSorter, EntrySorter diskSorter)
specifier|private
name|void
name|scanEntries
parameter_list|(
name|EntrySorter
name|memorySorter
parameter_list|,
name|EntrySorter
name|tmpSorter
parameter_list|,
name|EntrySorter
name|diskSorter
parameter_list|)
block|{
comment|// Create pointers that are incremented as the entries of each base are used in
comment|// successive order from the beginning. Entries "further down" in the "disk" base
comment|// can also be matched.
name|int
name|piv1
decl_stmt|;
name|int
name|piv2
init|=
literal|0
decl_stmt|;
comment|// Create a HashSet where we can put references to entry numbers in the "disk"
comment|// database that we have matched. This is to avoid matching them twice.
name|Set
argument_list|<
name|String
argument_list|>
name|used
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|diskSorter
operator|.
name|getEntryCount
argument_list|()
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|notMatched
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|tmpSorter
operator|.
name|getEntryCount
argument_list|()
argument_list|)
decl_stmt|;
comment|// Loop through the entries of the "tmp" database, looking for exact matches in the "disk" one.
comment|// We must finish scanning for exact matches before looking for near matches, to avoid an exact
comment|// match being "stolen" from another entry.
name|mainLoop
label|:
for|for
control|(
name|piv1
operator|=
literal|0
init|;
name|piv1
operator|<
name|tmpSorter
operator|.
name|getEntryCount
argument_list|()
condition|;
name|piv1
operator|++
control|)
block|{
comment|// First check if the similarly placed entry in the other base matches exactly.
name|double
name|comp
init|=
operator|-
literal|1
decl_stmt|;
comment|// (if there are not any entries left in the "disk" database, comp will stay at -1,
comment|// and this entry will be marked as nonmatched).
if|if
condition|(
operator|!
name|used
operator|.
name|contains
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|piv2
argument_list|)
argument_list|)
operator|&&
operator|(
name|piv2
operator|<
name|diskSorter
operator|.
name|getEntryCount
argument_list|()
operator|)
condition|)
block|{
name|comp
operator|=
name|DuplicateCheck
operator|.
name|compareEntriesStrictly
argument_list|(
name|tmpSorter
operator|.
name|getEntryAt
argument_list|(
name|piv1
argument_list|)
argument_list|,
name|diskSorter
operator|.
name|getEntryAt
argument_list|(
name|piv2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comp
operator|>
literal|1
condition|)
block|{
name|used
operator|.
name|add
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|piv2
argument_list|)
argument_list|)
expr_stmt|;
name|piv2
operator|++
expr_stmt|;
continue|continue;
block|}
comment|// No? Then check if another entry matches exactly.
if|if
condition|(
name|piv2
operator|<
operator|(
name|diskSorter
operator|.
name|getEntryCount
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|piv2
operator|+
literal|1
init|;
name|i
operator|<
name|diskSorter
operator|.
name|getEntryCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|used
operator|.
name|contains
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|comp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|comp
operator|=
name|DuplicateCheck
operator|.
name|compareEntriesStrictly
argument_list|(
name|tmpSorter
operator|.
name|getEntryAt
argument_list|(
name|piv1
argument_list|)
argument_list|,
name|diskSorter
operator|.
name|getEntryAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comp
operator|>
literal|1
condition|)
block|{
name|used
operator|.
name|add
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
continue|continue
name|mainLoop
continue|;
block|}
block|}
block|}
comment|// No? Add this entry to the list of nonmatched entries.
name|notMatched
operator|.
name|add
argument_list|(
name|piv1
argument_list|)
expr_stmt|;
block|}
comment|// Now we've found all exact matches, look through the remaining entries, looking
comment|// for close matches.
if|if
condition|(
operator|!
name|notMatched
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|it
init|=
name|notMatched
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|piv1
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
comment|// These two variables will keep track of which entry most closely matches the
comment|// one we're looking at, in case none matches completely.
name|int
name|bestMatchI
init|=
operator|-
literal|1
decl_stmt|;
name|double
name|bestMatch
init|=
literal|0
decl_stmt|;
name|double
name|comp
decl_stmt|;
if|if
condition|(
name|piv2
operator|<
operator|(
name|diskSorter
operator|.
name|getEntryCount
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|piv2
init|;
name|i
operator|<
name|diskSorter
operator|.
name|getEntryCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|used
operator|.
name|contains
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|comp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|comp
operator|=
name|DuplicateCheck
operator|.
name|compareEntriesStrictly
argument_list|(
name|tmpSorter
operator|.
name|getEntryAt
argument_list|(
name|piv1
argument_list|)
argument_list|,
name|diskSorter
operator|.
name|getEntryAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comp
operator|>
name|bestMatch
condition|)
block|{
name|bestMatch
operator|=
name|comp
expr_stmt|;
name|bestMatchI
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bestMatch
operator|>
name|MATCH_THRESHOLD
condition|)
block|{
name|used
operator|.
name|add
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|bestMatchI
argument_list|)
argument_list|)
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|changes
operator|.
name|add
argument_list|(
operator|new
name|EntryChange
argument_list|(
name|bestFit
argument_list|(
name|tmpSorter
argument_list|,
name|memorySorter
argument_list|,
name|piv1
argument_list|)
argument_list|,
name|tmpSorter
operator|.
name|getEntryAt
argument_list|(
name|piv1
argument_list|)
argument_list|,
name|diskSorter
operator|.
name|getEntryAt
argument_list|(
name|bestMatchI
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|changes
operator|.
name|add
argument_list|(
operator|new
name|EntryDeleteChange
argument_list|(
name|bestFit
argument_list|(
name|tmpSorter
argument_list|,
name|memorySorter
argument_list|,
name|piv1
argument_list|)
argument_list|,
name|tmpSorter
operator|.
name|getEntryAt
argument_list|(
name|piv1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Finally, look if there are still untouched entries in the disk database. These
comment|// may have been added.
if|if
condition|(
name|used
operator|.
name|size
argument_list|()
operator|<
name|diskSorter
operator|.
name|getEntryCount
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|diskSorter
operator|.
name|getEntryCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|used
operator|.
name|contains
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
comment|// See if there is an identical dupe in the mem database:
name|boolean
name|hasAlready
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|memorySorter
operator|.
name|getEntryCount
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|DuplicateCheck
operator|.
name|compareEntriesStrictly
argument_list|(
name|memorySorter
operator|.
name|getEntryAt
argument_list|(
name|j
argument_list|)
argument_list|,
name|diskSorter
operator|.
name|getEntryAt
argument_list|(
name|i
argument_list|)
argument_list|)
operator|>=
literal|1
condition|)
block|{
name|hasAlready
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|hasAlready
condition|)
block|{
name|changes
operator|.
name|add
argument_list|(
operator|new
name|EntryAddChange
argument_list|(
name|diskSorter
operator|.
name|getEntryAt
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * Finds the entry in neu best fitting the specified entry in old. If no entries get a score      * above zero, an entry is still returned.      *      * @param oldSorter   EntrySorter      * @param newSorter   EntrySorter      * @param index int      * @return BibEntry      */
DECL|method|bestFit (EntrySorter oldSorter, EntrySorter newSorter, int index)
specifier|private
specifier|static
name|BibEntry
name|bestFit
parameter_list|(
name|EntrySorter
name|oldSorter
parameter_list|,
name|EntrySorter
name|newSorter
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|double
name|comp
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newSorter
operator|.
name|getEntryCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|double
name|res
init|=
name|DuplicateCheck
operator|.
name|compareEntriesStrictly
argument_list|(
name|oldSorter
operator|.
name|getEntryAt
argument_list|(
name|index
argument_list|)
argument_list|,
name|newSorter
operator|.
name|getEntryAt
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|>
name|comp
condition|)
block|{
name|comp
operator|=
name|res
expr_stmt|;
name|found
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|comp
operator|>
literal|1
condition|)
block|{
break|break;
block|}
block|}
return|return
name|newSorter
operator|.
name|getEntryAt
argument_list|(
name|found
argument_list|)
return|;
block|}
DECL|method|scanPreamble (BibDatabase inMemory, BibDatabase onTmp, BibDatabase onDisk)
specifier|private
name|void
name|scanPreamble
parameter_list|(
name|BibDatabase
name|inMemory
parameter_list|,
name|BibDatabase
name|onTmp
parameter_list|,
name|BibDatabase
name|onDisk
parameter_list|)
block|{
name|String
name|mem
init|=
name|inMemory
operator|.
name|getPreamble
argument_list|()
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Optional
argument_list|<
name|String
argument_list|>
name|tmp
init|=
name|onTmp
operator|.
name|getPreamble
argument_list|()
decl_stmt|;
name|Optional
argument_list|<
name|String
argument_list|>
name|disk
init|=
name|onDisk
operator|.
name|getPreamble
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|disk
operator|.
name|ifPresent
argument_list|(
name|diskContent
lambda|->
name|changes
operator|.
name|add
argument_list|(
operator|new
name|PreambleChange
argument_list|(
name|mem
argument_list|,
name|diskContent
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|disk
operator|.
name|isPresent
argument_list|()
operator|||
operator|!
name|tmp
operator|.
name|equals
argument_list|(
name|disk
argument_list|)
condition|)
block|{
name|changes
operator|.
name|add
argument_list|(
operator|new
name|PreambleChange
argument_list|(
name|mem
argument_list|,
name|disk
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|scanStrings (BibDatabase inMem1, BibDatabase inTmp, BibDatabase onDisk)
specifier|private
name|void
name|scanStrings
parameter_list|(
name|BibDatabase
name|inMem1
parameter_list|,
name|BibDatabase
name|inTmp
parameter_list|,
name|BibDatabase
name|onDisk
parameter_list|)
block|{
if|if
condition|(
name|inTmp
operator|.
name|hasNoStrings
argument_list|()
operator|&&
name|onDisk
operator|.
name|hasNoStrings
argument_list|()
condition|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|Object
argument_list|>
name|used
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Object
argument_list|>
name|usedInMem
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|notMatched
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|inTmp
operator|.
name|getStringCount
argument_list|()
argument_list|)
decl_stmt|;
comment|// First try to match by string names.
name|mainLoop
label|:
for|for
control|(
name|String
name|key
range|:
name|inTmp
operator|.
name|getStringKeySet
argument_list|()
control|)
block|{
name|BibtexString
name|tmp
init|=
name|inTmp
operator|.
name|getString
argument_list|(
name|key
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|diskId
range|:
name|onDisk
operator|.
name|getStringKeySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|used
operator|.
name|contains
argument_list|(
name|diskId
argument_list|)
condition|)
block|{
name|BibtexString
name|disk
init|=
name|onDisk
operator|.
name|getString
argument_list|(
name|diskId
argument_list|)
decl_stmt|;
if|if
condition|(
name|disk
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|tmp
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
comment|// We have found a string with a matching name.
if|if
condition|(
operator|!
name|Objects
operator|.
name|equals
argument_list|(
name|tmp
operator|.
name|getContent
argument_list|()
argument_list|,
name|disk
operator|.
name|getContent
argument_list|()
argument_list|)
condition|)
block|{
comment|// But they have nonmatching contents, so we've found a change.
name|Optional
argument_list|<
name|BibtexString
argument_list|>
name|mem
init|=
name|findString
argument_list|(
name|inMem1
argument_list|,
name|tmp
operator|.
name|getName
argument_list|()
argument_list|,
name|usedInMem
argument_list|)
decl_stmt|;
if|if
condition|(
name|mem
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|changes
operator|.
name|add
argument_list|(
operator|new
name|StringChange
argument_list|(
name|mem
operator|.
name|get
argument_list|()
argument_list|,
name|tmp
argument_list|,
name|tmp
operator|.
name|getName
argument_list|()
argument_list|,
name|mem
operator|.
name|get
argument_list|()
operator|.
name|getContent
argument_list|()
argument_list|,
name|disk
operator|.
name|getContent
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|changes
operator|.
name|add
argument_list|(
operator|new
name|StringChange
argument_list|(
literal|null
argument_list|,
name|tmp
argument_list|,
name|tmp
operator|.
name|getName
argument_list|()
argument_list|,
literal|null
argument_list|,
name|disk
operator|.
name|getContent
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|used
operator|.
name|add
argument_list|(
name|diskId
argument_list|)
expr_stmt|;
continue|continue
name|mainLoop
continue|;
block|}
block|}
block|}
comment|// If we get here, there was no match for this string.
name|notMatched
operator|.
name|add
argument_list|(
name|tmp
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// See if we can detect a name change for those entries that we couldn't match.
if|if
condition|(
operator|!
name|notMatched
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|i
init|=
name|notMatched
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BibtexString
name|tmp
init|=
name|inTmp
operator|.
name|getString
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
comment|// If we get to this point, we found no string with matching name. See if we
comment|// can find one with matching content.
for|for
control|(
name|String
name|diskId
range|:
name|onDisk
operator|.
name|getStringKeySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|used
operator|.
name|contains
argument_list|(
name|diskId
argument_list|)
condition|)
block|{
name|BibtexString
name|disk
init|=
name|onDisk
operator|.
name|getString
argument_list|(
name|diskId
argument_list|)
decl_stmt|;
if|if
condition|(
name|disk
operator|.
name|getContent
argument_list|()
operator|.
name|equals
argument_list|(
name|tmp
operator|.
name|getContent
argument_list|()
argument_list|)
condition|)
block|{
comment|// We have found a string with the same content. It cannot have the same
comment|// name, or we would have found it above.
comment|// Try to find the matching one in memory:
name|BibtexString
name|bsMem
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|memId
range|:
name|inMem1
operator|.
name|getStringKeySet
argument_list|()
control|)
block|{
name|BibtexString
name|bsMemCandidate
init|=
name|inMem1
operator|.
name|getString
argument_list|(
name|memId
argument_list|)
decl_stmt|;
if|if
condition|(
name|bsMemCandidate
operator|.
name|getContent
argument_list|()
operator|.
name|equals
argument_list|(
name|disk
operator|.
name|getContent
argument_list|()
argument_list|)
operator|&&
operator|!
name|usedInMem
operator|.
name|contains
argument_list|(
name|memId
argument_list|)
condition|)
block|{
name|usedInMem
operator|.
name|add
argument_list|(
name|memId
argument_list|)
expr_stmt|;
name|bsMem
operator|=
name|bsMemCandidate
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bsMem
operator|!=
literal|null
condition|)
block|{
name|changes
operator|.
name|add
argument_list|(
operator|new
name|StringNameChange
argument_list|(
name|bsMem
argument_list|,
name|tmp
argument_list|,
name|bsMem
operator|.
name|getName
argument_list|()
argument_list|,
name|tmp
operator|.
name|getName
argument_list|()
argument_list|,
name|disk
operator|.
name|getName
argument_list|()
argument_list|,
name|tmp
operator|.
name|getContent
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
name|used
operator|.
name|add
argument_list|(
name|diskId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|notMatched
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Still one or more non-matched strings. So they must have been removed.
for|for
control|(
name|String
name|notMatchedId
range|:
name|notMatched
control|)
block|{
name|BibtexString
name|tmp
init|=
name|inTmp
operator|.
name|getString
argument_list|(
name|notMatchedId
argument_list|)
decl_stmt|;
comment|// The removed string is not removed from the mem version.
name|findString
argument_list|(
name|inMem1
argument_list|,
name|tmp
operator|.
name|getName
argument_list|()
argument_list|,
name|usedInMem
argument_list|)
operator|.
name|ifPresent
argument_list|(
name|x
lambda|->
name|changes
operator|.
name|add
argument_list|(
operator|new
name|StringRemoveChange
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Finally, see if there are remaining strings in the disk database. They
comment|// must have been added.
for|for
control|(
name|String
name|diskId
range|:
name|onDisk
operator|.
name|getStringKeySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|used
operator|.
name|contains
argument_list|(
name|diskId
argument_list|)
condition|)
block|{
name|BibtexString
name|disk
init|=
name|onDisk
operator|.
name|getString
argument_list|(
name|diskId
argument_list|)
decl_stmt|;
name|used
operator|.
name|add
argument_list|(
name|diskId
argument_list|)
expr_stmt|;
name|changes
operator|.
name|add
argument_list|(
operator|new
name|StringAddChange
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|findString (BibDatabase base, String name, Set<Object> used)
specifier|private
specifier|static
name|Optional
argument_list|<
name|BibtexString
argument_list|>
name|findString
parameter_list|(
name|BibDatabase
name|base
parameter_list|,
name|String
name|name
parameter_list|,
name|Set
argument_list|<
name|Object
argument_list|>
name|used
parameter_list|)
block|{
if|if
condition|(
operator|!
name|base
operator|.
name|hasStringLabel
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
for|for
control|(
name|String
name|key
range|:
name|base
operator|.
name|getStringKeySet
argument_list|()
control|)
block|{
name|BibtexString
name|bs
init|=
name|base
operator|.
name|getString
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|bs
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|used
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|used
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|Optional
operator|.
name|of
argument_list|(
name|bs
argument_list|)
return|;
block|}
block|}
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/**      * This method only detects whether a change took place or not. It does not determine the type of change. This would      * be possible, but difficult to do properly, so I rather only report the change.      */
DECL|method|scanGroups (MetaData inTemp, MetaData onDisk)
specifier|private
name|void
name|scanGroups
parameter_list|(
name|MetaData
name|inTemp
parameter_list|,
name|MetaData
name|onDisk
parameter_list|)
block|{
specifier|final
name|Optional
argument_list|<
name|GroupTreeNode
argument_list|>
name|groupsTmp
init|=
name|inTemp
operator|.
name|getGroups
argument_list|()
decl_stmt|;
specifier|final
name|Optional
argument_list|<
name|GroupTreeNode
argument_list|>
name|groupsDisk
init|=
name|onDisk
operator|.
name|getGroups
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|groupsTmp
operator|.
name|isPresent
argument_list|()
operator|&&
operator|!
name|groupsDisk
operator|.
name|isPresent
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|groupsTmp
operator|.
name|isPresent
argument_list|()
operator|&&
operator|!
name|groupsDisk
operator|.
name|isPresent
argument_list|()
operator|)
operator|||
operator|!
name|groupsTmp
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|changes
operator|.
name|add
argument_list|(
operator|new
name|GroupChange
argument_list|(
name|groupsDisk
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
argument_list|,
name|groupsTmp
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Both present here
if|if
condition|(
operator|!
name|groupsTmp
operator|.
name|equals
argument_list|(
name|groupsDisk
argument_list|)
condition|)
block|{
name|changes
operator|.
name|add
argument_list|(
operator|new
name|GroupChange
argument_list|(
name|groupsDisk
operator|.
name|get
argument_list|()
argument_list|,
name|groupsTmp
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|FunctionalInterface
DECL|interface|DisplayResultCallback
specifier|public
interface|interface
name|DisplayResultCallback
block|{
DECL|method|scanResultsResolved (boolean resolved)
name|void
name|scanResultsResolved
parameter_list|(
name|boolean
name|resolved
parameter_list|)
function_decl|;
block|}
block|}
end_class

end_unit

