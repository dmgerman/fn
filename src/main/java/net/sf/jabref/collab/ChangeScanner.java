begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003-2015 JabRef contributors.     This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License along     with this program; if not, write to the Free Software Foundation, Inc.,     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.  */
end_comment

begin_package
DECL|package|net.sf.jabref.collab
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|collab
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JOptionPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|SwingUtilities
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|tree
operator|.
name|DefaultMutableTreeNode
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibDatabaseContext
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|Defaults
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|Globals
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|JabRefExecutorService
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|MetaData
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|BasePanel
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|JabRefFrame
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|importer
operator|.
name|OpenDatabaseAction
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|importer
operator|.
name|ParserResult
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|bibtex
operator|.
name|comparator
operator|.
name|EntryComparator
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|exporter
operator|.
name|BibDatabaseWriter
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|exporter
operator|.
name|BibtexDatabaseWriter
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|exporter
operator|.
name|FileSaveSession
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|exporter
operator|.
name|SaveException
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|exporter
operator|.
name|SavePreferences
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|exporter
operator|.
name|SaveSession
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|groups
operator|.
name|GroupTreeNode
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|l10n
operator|.
name|Localization
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|DuplicateCheck
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabase
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabaseMode
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|EntrySorter
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|BibEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|BibtexString
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|FieldName
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|preferences
operator|.
name|JabRefPreferences
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_class
DECL|class|ChangeScanner
specifier|public
class|class
name|ChangeScanner
implements|implements
name|Runnable
block|{
DECL|field|SORT_BY
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|SORT_BY
init|=
operator|new
name|String
index|[]
block|{
name|FieldName
operator|.
name|YEAR
block|,
name|FieldName
operator|.
name|AUTHOR
block|,
name|FieldName
operator|.
name|TITLE
block|}
decl_stmt|;
DECL|field|f
specifier|private
specifier|final
name|File
name|f
decl_stmt|;
DECL|field|inMem
specifier|private
specifier|final
name|BibDatabase
name|inMem
decl_stmt|;
DECL|field|mdInMem
specifier|private
specifier|final
name|MetaData
name|mdInMem
decl_stmt|;
DECL|field|panel
specifier|private
specifier|final
name|BasePanel
name|panel
decl_stmt|;
DECL|field|frame
specifier|private
specifier|final
name|JabRefFrame
name|frame
decl_stmt|;
DECL|field|inTemp
specifier|private
name|BibDatabase
name|inTemp
decl_stmt|;
DECL|field|mdInTemp
specifier|private
name|MetaData
name|mdInTemp
decl_stmt|;
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Log
name|LOGGER
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ChangeScanner
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|MATCH_THRESHOLD
specifier|private
specifier|static
specifier|final
name|double
name|MATCH_THRESHOLD
init|=
literal|0.4
decl_stmt|;
comment|/**      * We create an ArrayList to hold the changes we find. These will be added in the form      * of UndoEdit objects. We instantiate these so that the changes found in the file on disk      * can be reproduced in memory by calling redo() on them. REDO, not UNDO!      */
DECL|field|changes
specifier|private
specifier|final
name|DefaultMutableTreeNode
name|changes
init|=
operator|new
name|DefaultMutableTreeNode
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"External changes"
argument_list|)
argument_list|)
decl_stmt|;
comment|//  NamedCompound edit = new NamedCompound("Merged external changes")
DECL|method|ChangeScanner (JabRefFrame frame, BasePanel bp, File file)
specifier|public
name|ChangeScanner
parameter_list|(
name|JabRefFrame
name|frame
parameter_list|,
name|BasePanel
name|bp
parameter_list|,
name|File
name|file
parameter_list|)
block|{
name|this
operator|.
name|panel
operator|=
name|bp
expr_stmt|;
name|this
operator|.
name|frame
operator|=
name|frame
expr_stmt|;
name|this
operator|.
name|inMem
operator|=
name|bp
operator|.
name|getDatabase
argument_list|()
expr_stmt|;
name|this
operator|.
name|mdInMem
operator|=
name|bp
operator|.
name|getBibDatabaseContext
argument_list|()
operator|.
name|getMetaData
argument_list|()
expr_stmt|;
name|this
operator|.
name|f
operator|=
name|file
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
comment|// Parse the temporary file.
name|Path
name|tempFile
init|=
name|Globals
operator|.
name|getFileUpdateMonitor
argument_list|()
operator|.
name|getTempFile
argument_list|(
name|panel
operator|.
name|fileMonitorHandle
argument_list|()
argument_list|)
decl_stmt|;
name|ParserResult
name|pr
init|=
name|OpenDatabaseAction
operator|.
name|loadDatabase
argument_list|(
name|tempFile
operator|.
name|toFile
argument_list|()
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|getDefaultEncoding
argument_list|()
argument_list|)
decl_stmt|;
name|inTemp
operator|=
name|pr
operator|.
name|getDatabase
argument_list|()
expr_stmt|;
name|mdInTemp
operator|=
name|pr
operator|.
name|getMetaData
argument_list|()
expr_stmt|;
comment|// Parse the modified file.
name|pr
operator|=
name|OpenDatabaseAction
operator|.
name|loadDatabase
argument_list|(
name|f
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|getDefaultEncoding
argument_list|()
argument_list|)
expr_stmt|;
name|BibDatabase
name|onDisk
init|=
name|pr
operator|.
name|getDatabase
argument_list|()
decl_stmt|;
name|MetaData
name|mdOnDisk
init|=
name|pr
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
comment|// Sort both databases according to a common sort key.
name|EntryComparator
name|comp
init|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|SORT_BY
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|comp
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|SORT_BY
index|[
literal|1
index|]
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|comp
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|SORT_BY
index|[
literal|0
index|]
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|EntrySorter
name|sInTemp
init|=
name|inTemp
operator|.
name|getSorter
argument_list|(
name|comp
argument_list|)
decl_stmt|;
name|comp
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|SORT_BY
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|comp
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|SORT_BY
index|[
literal|1
index|]
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|comp
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|SORT_BY
index|[
literal|0
index|]
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|EntrySorter
name|sOnDisk
init|=
name|onDisk
operator|.
name|getSorter
argument_list|(
name|comp
argument_list|)
decl_stmt|;
name|comp
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|SORT_BY
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|comp
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|SORT_BY
index|[
literal|1
index|]
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|comp
operator|=
operator|new
name|EntryComparator
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|SORT_BY
index|[
literal|0
index|]
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|EntrySorter
name|sInMem
init|=
name|inMem
operator|.
name|getSorter
argument_list|(
name|comp
argument_list|)
decl_stmt|;
comment|// Start looking at changes.
name|scanMetaData
argument_list|(
name|mdInMem
argument_list|,
name|mdInTemp
argument_list|,
name|mdOnDisk
argument_list|)
expr_stmt|;
name|scanPreamble
argument_list|(
name|inMem
argument_list|,
name|inTemp
argument_list|,
name|onDisk
argument_list|)
expr_stmt|;
name|scanStrings
argument_list|(
name|inMem
argument_list|,
name|inTemp
argument_list|,
name|onDisk
argument_list|)
expr_stmt|;
name|scanEntries
argument_list|(
name|sInMem
argument_list|,
name|sInTemp
argument_list|,
name|sOnDisk
argument_list|)
expr_stmt|;
name|scanGroups
argument_list|(
name|mdInTemp
argument_list|,
name|mdOnDisk
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Problem running"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|changesFound ()
specifier|public
name|boolean
name|changesFound
parameter_list|()
block|{
return|return
name|changes
operator|.
name|getChildCount
argument_list|()
operator|>
literal|0
return|;
block|}
DECL|method|displayResult (final DisplayResultCallback fup)
specifier|public
name|void
name|displayResult
parameter_list|(
specifier|final
name|DisplayResultCallback
name|fup
parameter_list|)
block|{
if|if
condition|(
name|changes
operator|.
name|getChildCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|SwingUtilities
operator|.
name|invokeLater
argument_list|(
parameter_list|()
lambda|->
block|{
name|ChangeDisplayDialog
name|dial
init|=
operator|new
name|ChangeDisplayDialog
argument_list|(
name|frame
argument_list|,
name|panel
argument_list|,
name|inTemp
argument_list|,
name|changes
argument_list|)
decl_stmt|;
name|dial
operator|.
name|setLocationRelativeTo
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|dial
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|fup
operator|.
name|scanResultsResolved
argument_list|(
name|dial
operator|.
name|isOkPressed
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|dial
operator|.
name|isOkPressed
argument_list|()
condition|)
block|{
comment|// Overwrite the temp database:
name|storeTempDatabase
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|JOptionPane
operator|.
name|showMessageDialog
argument_list|(
name|frame
argument_list|,
name|Localization
operator|.
name|lang
argument_list|(
literal|"No actual changes found."
argument_list|)
argument_list|,
name|Localization
operator|.
name|lang
argument_list|(
literal|"External changes"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|INFORMATION_MESSAGE
argument_list|)
expr_stmt|;
name|fup
operator|.
name|scanResultsResolved
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|storeTempDatabase ()
specifier|private
name|void
name|storeTempDatabase
parameter_list|()
block|{
name|JabRefExecutorService
operator|.
name|INSTANCE
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
name|SavePreferences
name|prefs
init|=
name|SavePreferences
operator|.
name|loadForSaveFromPreferences
argument_list|(
name|Globals
operator|.
name|prefs
argument_list|)
operator|.
name|withMakeBackup
argument_list|(
literal|false
argument_list|)
operator|.
name|withEncoding
argument_list|(
name|panel
operator|.
name|getBibDatabaseContext
argument_list|()
operator|.
name|getMetaData
argument_list|()
operator|.
name|getEncoding
argument_list|()
argument_list|)
decl_stmt|;
name|Defaults
name|defaults
init|=
operator|new
name|Defaults
argument_list|(
name|BibDatabaseMode
operator|.
name|fromPreference
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|BIBLATEX_DEFAULT_MODE
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|BibDatabaseWriter
name|databaseWriter
init|=
operator|new
name|BibtexDatabaseWriter
argument_list|(
name|FileSaveSession
operator|::
operator|new
argument_list|)
decl_stmt|;
name|SaveSession
name|ss
init|=
name|databaseWriter
operator|.
name|saveDatabase
argument_list|(
operator|new
name|BibDatabaseContext
argument_list|(
name|inTemp
argument_list|,
name|mdInTemp
argument_list|,
name|defaults
argument_list|)
argument_list|,
name|prefs
argument_list|)
decl_stmt|;
name|ss
operator|.
name|commit
argument_list|(
name|Globals
operator|.
name|getFileUpdateMonitor
argument_list|()
operator|.
name|getTempFile
argument_list|(
name|panel
operator|.
name|fileMonitorHandle
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SaveException
name|ex
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Problem updating tmp file after accepting external changes"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|scanMetaData (MetaData inMem1, MetaData inTemp1, MetaData onDisk)
specifier|private
name|void
name|scanMetaData
parameter_list|(
name|MetaData
name|inMem1
parameter_list|,
name|MetaData
name|inTemp1
parameter_list|,
name|MetaData
name|onDisk
parameter_list|)
block|{
name|MetaDataChange
name|mdc
init|=
operator|new
name|MetaDataChange
argument_list|(
name|inMem1
argument_list|,
name|inTemp1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|handledOnDisk
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Loop through the metadata entries of the "tmp" database, looking for
comment|// matches
for|for
control|(
name|String
name|key
range|:
name|inTemp1
control|)
block|{
comment|// See if the key is missing in the disk database:
name|List
argument_list|<
name|String
argument_list|>
name|vod
init|=
name|onDisk
operator|.
name|getData
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|vod
operator|==
literal|null
condition|)
block|{
name|mdc
operator|.
name|insertMetaDataRemoval
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Both exist. Check if they are different:
name|List
argument_list|<
name|String
argument_list|>
name|vit
init|=
name|inTemp1
operator|.
name|getData
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vod
operator|.
name|equals
argument_list|(
name|vit
argument_list|)
condition|)
block|{
name|mdc
operator|.
name|insertMetaDataChange
argument_list|(
name|key
argument_list|,
name|vod
argument_list|)
expr_stmt|;
block|}
comment|// Remember that we've handled this one:
name|handledOnDisk
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
comment|// See if there are unhandled keys in the disk database:
for|for
control|(
name|String
name|key
range|:
name|onDisk
control|)
block|{
if|if
condition|(
operator|!
name|handledOnDisk
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|mdc
operator|.
name|insertMetaDataAddition
argument_list|(
name|key
argument_list|,
name|onDisk
operator|.
name|getData
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mdc
operator|.
name|getChangeCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|changes
operator|.
name|add
argument_list|(
name|mdc
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|scanEntries (EntrySorter mem, EntrySorter tmp, EntrySorter disk)
specifier|private
name|void
name|scanEntries
parameter_list|(
name|EntrySorter
name|mem
parameter_list|,
name|EntrySorter
name|tmp
parameter_list|,
name|EntrySorter
name|disk
parameter_list|)
block|{
comment|// Create pointers that are incremented as the entries of each base are used in
comment|// successive order from the beginning. Entries "further down" in the "disk" base
comment|// can also be matched.
name|int
name|piv1
decl_stmt|;
name|int
name|piv2
init|=
literal|0
decl_stmt|;
comment|// Create a HashSet where we can put references to entry numbers in the "disk"
comment|// database that we have matched. This is to avoid matching them twice.
name|Set
argument_list|<
name|String
argument_list|>
name|used
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|disk
operator|.
name|getEntryCount
argument_list|()
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|notMatched
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|tmp
operator|.
name|getEntryCount
argument_list|()
argument_list|)
decl_stmt|;
comment|// Loop through the entries of the "tmp" database, looking for exact matches in the "disk" one.
comment|// We must finish scanning for exact matches before looking for near matches, to avoid an exact
comment|// match being "stolen" from another entry.
name|mainLoop
label|:
for|for
control|(
name|piv1
operator|=
literal|0
init|;
name|piv1
operator|<
name|tmp
operator|.
name|getEntryCount
argument_list|()
condition|;
name|piv1
operator|++
control|)
block|{
comment|// First check if the similarly placed entry in the other base matches exactly.
name|double
name|comp
init|=
operator|-
literal|1
decl_stmt|;
comment|// (if there are not any entries left in the "disk" database, comp will stay at -1,
comment|// and this entry will be marked as nonmatched).
if|if
condition|(
operator|!
name|used
operator|.
name|contains
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|piv2
argument_list|)
argument_list|)
operator|&&
operator|(
name|piv2
operator|<
name|disk
operator|.
name|getEntryCount
argument_list|()
operator|)
condition|)
block|{
name|comp
operator|=
name|DuplicateCheck
operator|.
name|compareEntriesStrictly
argument_list|(
name|tmp
operator|.
name|getEntryAt
argument_list|(
name|piv1
argument_list|)
argument_list|,
name|disk
operator|.
name|getEntryAt
argument_list|(
name|piv2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comp
operator|>
literal|1
condition|)
block|{
name|used
operator|.
name|add
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|piv2
argument_list|)
argument_list|)
expr_stmt|;
name|piv2
operator|++
expr_stmt|;
continue|continue;
block|}
comment|// No? Then check if another entry matches exactly.
if|if
condition|(
name|piv2
operator|<
operator|(
name|disk
operator|.
name|getEntryCount
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|piv2
operator|+
literal|1
init|;
name|i
operator|<
name|disk
operator|.
name|getEntryCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|used
operator|.
name|contains
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|comp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|comp
operator|=
name|DuplicateCheck
operator|.
name|compareEntriesStrictly
argument_list|(
name|tmp
operator|.
name|getEntryAt
argument_list|(
name|piv1
argument_list|)
argument_list|,
name|disk
operator|.
name|getEntryAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comp
operator|>
literal|1
condition|)
block|{
name|used
operator|.
name|add
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
continue|continue
name|mainLoop
continue|;
block|}
block|}
block|}
comment|// No? Add this entry to the list of nonmatched entries.
name|notMatched
operator|.
name|add
argument_list|(
name|piv1
argument_list|)
expr_stmt|;
block|}
comment|// Now we've found all exact matches, look through the remaining entries, looking
comment|// for close matches.
if|if
condition|(
operator|!
name|notMatched
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|it
init|=
name|notMatched
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|piv1
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
comment|// These two variables will keep track of which entry most closely matches the
comment|// one we're looking at, in case none matches completely.
name|int
name|bestMatchI
init|=
operator|-
literal|1
decl_stmt|;
name|double
name|bestMatch
init|=
literal|0
decl_stmt|;
name|double
name|comp
decl_stmt|;
if|if
condition|(
name|piv2
operator|<
operator|(
name|disk
operator|.
name|getEntryCount
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|piv2
init|;
name|i
operator|<
name|disk
operator|.
name|getEntryCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|used
operator|.
name|contains
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|comp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|comp
operator|=
name|DuplicateCheck
operator|.
name|compareEntriesStrictly
argument_list|(
name|tmp
operator|.
name|getEntryAt
argument_list|(
name|piv1
argument_list|)
argument_list|,
name|disk
operator|.
name|getEntryAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comp
operator|>
name|bestMatch
condition|)
block|{
name|bestMatch
operator|=
name|comp
expr_stmt|;
name|bestMatchI
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bestMatch
operator|>
name|MATCH_THRESHOLD
condition|)
block|{
name|used
operator|.
name|add
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|bestMatchI
argument_list|)
argument_list|)
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|EntryChange
name|ec
init|=
operator|new
name|EntryChange
argument_list|(
name|bestFit
argument_list|(
name|tmp
argument_list|,
name|mem
argument_list|,
name|piv1
argument_list|)
argument_list|,
name|tmp
operator|.
name|getEntryAt
argument_list|(
name|piv1
argument_list|)
argument_list|,
name|disk
operator|.
name|getEntryAt
argument_list|(
name|bestMatchI
argument_list|)
argument_list|)
decl_stmt|;
name|changes
operator|.
name|add
argument_list|(
name|ec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EntryDeleteChange
name|ec
init|=
operator|new
name|EntryDeleteChange
argument_list|(
name|bestFit
argument_list|(
name|tmp
argument_list|,
name|mem
argument_list|,
name|piv1
argument_list|)
argument_list|,
name|tmp
operator|.
name|getEntryAt
argument_list|(
name|piv1
argument_list|)
argument_list|)
decl_stmt|;
name|changes
operator|.
name|add
argument_list|(
name|ec
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Finally, look if there are still untouched entries in the disk database. These
comment|// may have been added.
if|if
condition|(
name|used
operator|.
name|size
argument_list|()
operator|<
name|disk
operator|.
name|getEntryCount
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|disk
operator|.
name|getEntryCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|used
operator|.
name|contains
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
comment|// See if there is an identical dupe in the mem database:
name|boolean
name|hasAlready
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|mem
operator|.
name|getEntryCount
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|DuplicateCheck
operator|.
name|compareEntriesStrictly
argument_list|(
name|mem
operator|.
name|getEntryAt
argument_list|(
name|j
argument_list|)
argument_list|,
name|disk
operator|.
name|getEntryAt
argument_list|(
name|i
argument_list|)
argument_list|)
operator|>=
literal|1
condition|)
block|{
name|hasAlready
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|hasAlready
condition|)
block|{
name|EntryAddChange
name|ec
init|=
operator|new
name|EntryAddChange
argument_list|(
name|disk
operator|.
name|getEntryAt
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|changes
operator|.
name|add
argument_list|(
name|ec
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * Finds the entry in neu best fitting the specified entry in old. If no entries get a score      * above zero, an entry is still returned.      *      * @param old   EntrySorter      * @param neu   EntrySorter      * @param index int      * @return BibEntry      */
DECL|method|bestFit (EntrySorter old, EntrySorter neu, int index)
specifier|private
specifier|static
name|BibEntry
name|bestFit
parameter_list|(
name|EntrySorter
name|old
parameter_list|,
name|EntrySorter
name|neu
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|double
name|comp
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|neu
operator|.
name|getEntryCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|double
name|res
init|=
name|DuplicateCheck
operator|.
name|compareEntriesStrictly
argument_list|(
name|old
operator|.
name|getEntryAt
argument_list|(
name|index
argument_list|)
argument_list|,
name|neu
operator|.
name|getEntryAt
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|>
name|comp
condition|)
block|{
name|comp
operator|=
name|res
expr_stmt|;
name|found
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|comp
operator|>
literal|1
condition|)
block|{
break|break;
block|}
block|}
return|return
name|neu
operator|.
name|getEntryAt
argument_list|(
name|found
argument_list|)
return|;
block|}
DECL|method|scanPreamble (BibDatabase inMem1, BibDatabase onTmp, BibDatabase onDisk)
specifier|private
name|void
name|scanPreamble
parameter_list|(
name|BibDatabase
name|inMem1
parameter_list|,
name|BibDatabase
name|onTmp
parameter_list|,
name|BibDatabase
name|onDisk
parameter_list|)
block|{
name|String
name|mem
init|=
name|inMem1
operator|.
name|getPreamble
argument_list|()
decl_stmt|;
name|String
name|tmp
init|=
name|onTmp
operator|.
name|getPreamble
argument_list|()
decl_stmt|;
name|String
name|disk
init|=
name|onDisk
operator|.
name|getPreamble
argument_list|()
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|disk
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|disk
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|changes
operator|.
name|add
argument_list|(
operator|new
name|PreambleChange
argument_list|(
name|mem
argument_list|,
name|disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|disk
operator|==
literal|null
operator|)
operator|||
operator|!
name|tmp
operator|.
name|equals
argument_list|(
name|disk
argument_list|)
condition|)
block|{
name|changes
operator|.
name|add
argument_list|(
operator|new
name|PreambleChange
argument_list|(
name|mem
argument_list|,
name|disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|scanStrings (BibDatabase inMem1, BibDatabase onTmp, BibDatabase onDisk)
specifier|private
name|void
name|scanStrings
parameter_list|(
name|BibDatabase
name|inMem1
parameter_list|,
name|BibDatabase
name|onTmp
parameter_list|,
name|BibDatabase
name|onDisk
parameter_list|)
block|{
if|if
condition|(
name|onTmp
operator|.
name|hasNoStrings
argument_list|()
operator|&&
name|onDisk
operator|.
name|hasNoStrings
argument_list|()
condition|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|Object
argument_list|>
name|used
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Object
argument_list|>
name|usedInMem
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|notMatched
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|onTmp
operator|.
name|getStringCount
argument_list|()
argument_list|)
decl_stmt|;
comment|// First try to match by string names.
name|mainLoop
label|:
for|for
control|(
name|String
name|key
range|:
name|onTmp
operator|.
name|getStringKeySet
argument_list|()
control|)
block|{
name|BibtexString
name|tmp
init|=
name|onTmp
operator|.
name|getString
argument_list|(
name|key
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|diskId
range|:
name|onDisk
operator|.
name|getStringKeySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|used
operator|.
name|contains
argument_list|(
name|diskId
argument_list|)
condition|)
block|{
name|BibtexString
name|disk
init|=
name|onDisk
operator|.
name|getString
argument_list|(
name|diskId
argument_list|)
decl_stmt|;
if|if
condition|(
name|disk
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|tmp
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
comment|// We have found a string with a matching name.
if|if
condition|(
operator|(
name|tmp
operator|.
name|getContent
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|tmp
operator|.
name|getContent
argument_list|()
operator|.
name|equals
argument_list|(
name|disk
operator|.
name|getContent
argument_list|()
argument_list|)
condition|)
block|{
comment|// But they have nonmatching contents, so we've found a change.
name|Optional
argument_list|<
name|BibtexString
argument_list|>
name|mem
init|=
name|findString
argument_list|(
name|inMem1
argument_list|,
name|tmp
operator|.
name|getName
argument_list|()
argument_list|,
name|usedInMem
argument_list|)
decl_stmt|;
if|if
condition|(
name|mem
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|changes
operator|.
name|add
argument_list|(
operator|new
name|StringChange
argument_list|(
name|mem
operator|.
name|get
argument_list|()
argument_list|,
name|tmp
argument_list|,
name|tmp
operator|.
name|getName
argument_list|()
argument_list|,
name|mem
operator|.
name|get
argument_list|()
operator|.
name|getContent
argument_list|()
argument_list|,
name|disk
operator|.
name|getContent
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|changes
operator|.
name|add
argument_list|(
operator|new
name|StringChange
argument_list|(
literal|null
argument_list|,
name|tmp
argument_list|,
name|tmp
operator|.
name|getName
argument_list|()
argument_list|,
literal|null
argument_list|,
name|disk
operator|.
name|getContent
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|used
operator|.
name|add
argument_list|(
name|diskId
argument_list|)
expr_stmt|;
continue|continue
name|mainLoop
continue|;
block|}
block|}
block|}
comment|// If we get here, there was no match for this string.
name|notMatched
operator|.
name|add
argument_list|(
name|tmp
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// See if we can detect a name change for those entries that we couldn't match.
if|if
condition|(
operator|!
name|notMatched
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|i
init|=
name|notMatched
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BibtexString
name|tmp
init|=
name|onTmp
operator|.
name|getString
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
comment|// If we get to this point, we found no string with matching name. See if we
comment|// can find one with matching content.
for|for
control|(
name|String
name|diskId
range|:
name|onDisk
operator|.
name|getStringKeySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|used
operator|.
name|contains
argument_list|(
name|diskId
argument_list|)
condition|)
block|{
name|BibtexString
name|disk
init|=
name|onDisk
operator|.
name|getString
argument_list|(
name|diskId
argument_list|)
decl_stmt|;
if|if
condition|(
name|disk
operator|.
name|getContent
argument_list|()
operator|.
name|equals
argument_list|(
name|tmp
operator|.
name|getContent
argument_list|()
argument_list|)
condition|)
block|{
comment|// We have found a string with the same content. It cannot have the same
comment|// name, or we would have found it above.
comment|// Try to find the matching one in memory:
name|BibtexString
name|bsMem
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|memId
range|:
name|inMem1
operator|.
name|getStringKeySet
argument_list|()
control|)
block|{
name|BibtexString
name|bsMemCandidate
init|=
name|inMem1
operator|.
name|getString
argument_list|(
name|memId
argument_list|)
decl_stmt|;
if|if
condition|(
name|bsMemCandidate
operator|.
name|getContent
argument_list|()
operator|.
name|equals
argument_list|(
name|disk
operator|.
name|getContent
argument_list|()
argument_list|)
operator|&&
operator|!
name|usedInMem
operator|.
name|contains
argument_list|(
name|memId
argument_list|)
condition|)
block|{
name|usedInMem
operator|.
name|add
argument_list|(
name|memId
argument_list|)
expr_stmt|;
name|bsMem
operator|=
name|bsMemCandidate
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bsMem
operator|!=
literal|null
condition|)
block|{
name|changes
operator|.
name|add
argument_list|(
operator|new
name|StringNameChange
argument_list|(
name|bsMem
argument_list|,
name|tmp
argument_list|,
name|bsMem
operator|.
name|getName
argument_list|()
argument_list|,
name|tmp
operator|.
name|getName
argument_list|()
argument_list|,
name|disk
operator|.
name|getName
argument_list|()
argument_list|,
name|tmp
operator|.
name|getContent
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
name|used
operator|.
name|add
argument_list|(
name|diskId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|notMatched
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Still one or more non-matched strings. So they must have been removed.
for|for
control|(
name|String
name|nmId
range|:
name|notMatched
control|)
block|{
name|BibtexString
name|tmp
init|=
name|onTmp
operator|.
name|getString
argument_list|(
name|nmId
argument_list|)
decl_stmt|;
comment|// The removed string is not removed from the mem version.
name|findString
argument_list|(
name|inMem1
argument_list|,
name|tmp
operator|.
name|getName
argument_list|()
argument_list|,
name|usedInMem
argument_list|)
operator|.
name|ifPresent
argument_list|(
name|x
lambda|->
name|changes
operator|.
name|add
argument_list|(
operator|new
name|StringRemoveChange
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Finally, see if there are remaining strings in the disk database. They
comment|// must have been added.
for|for
control|(
name|String
name|diskId
range|:
name|onDisk
operator|.
name|getStringKeySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|used
operator|.
name|contains
argument_list|(
name|diskId
argument_list|)
condition|)
block|{
name|BibtexString
name|disk
init|=
name|onDisk
operator|.
name|getString
argument_list|(
name|diskId
argument_list|)
decl_stmt|;
name|used
operator|.
name|add
argument_list|(
name|diskId
argument_list|)
expr_stmt|;
name|changes
operator|.
name|add
argument_list|(
operator|new
name|StringAddChange
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|findString (BibDatabase base, String name, Set<Object> used)
specifier|private
specifier|static
name|Optional
argument_list|<
name|BibtexString
argument_list|>
name|findString
parameter_list|(
name|BibDatabase
name|base
parameter_list|,
name|String
name|name
parameter_list|,
name|Set
argument_list|<
name|Object
argument_list|>
name|used
parameter_list|)
block|{
if|if
condition|(
operator|!
name|base
operator|.
name|hasStringLabel
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
for|for
control|(
name|String
name|key
range|:
name|base
operator|.
name|getStringKeySet
argument_list|()
control|)
block|{
name|BibtexString
name|bs
init|=
name|base
operator|.
name|getString
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|bs
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|used
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|used
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|Optional
operator|.
name|of
argument_list|(
name|bs
argument_list|)
return|;
block|}
block|}
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/**      * This method only detects whether a change took place or not. It does not determine the type of change. This would      * be possible, but difficult to do properly, so I rather only report the change.      */
DECL|method|scanGroups (MetaData onTmp, MetaData onDisk)
specifier|private
name|void
name|scanGroups
parameter_list|(
name|MetaData
name|onTmp
parameter_list|,
name|MetaData
name|onDisk
parameter_list|)
block|{
specifier|final
name|GroupTreeNode
name|groupsTmp
init|=
name|onTmp
operator|.
name|getGroups
argument_list|()
decl_stmt|;
specifier|final
name|GroupTreeNode
name|groupsDisk
init|=
name|onDisk
operator|.
name|getGroups
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|groupsTmp
operator|==
literal|null
operator|)
operator|&&
operator|(
name|groupsDisk
operator|==
literal|null
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|groupsTmp
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|groupsDisk
operator|==
literal|null
operator|)
operator|)
operator|||
operator|(
name|groupsTmp
operator|==
literal|null
operator|)
condition|)
block|{
name|changes
operator|.
name|add
argument_list|(
operator|new
name|GroupChange
argument_list|(
name|groupsDisk
argument_list|,
name|groupsTmp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|groupsTmp
operator|.
name|equals
argument_list|(
name|groupsDisk
argument_list|)
condition|)
block|{
name|changes
operator|.
name|add
argument_list|(
operator|new
name|GroupChange
argument_list|(
name|groupsDisk
argument_list|,
name|groupsTmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|FunctionalInterface
DECL|interface|DisplayResultCallback
specifier|public
interface|interface
name|DisplayResultCallback
block|{
DECL|method|scanResultsResolved (boolean resolved)
name|void
name|scanResultsResolved
parameter_list|(
name|boolean
name|resolved
parameter_list|)
function_decl|;
block|}
block|}
end_class

end_unit

