begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|net.sf.jabref.logic.groups
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|groups
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_class
DECL|class|TreeNode
specifier|public
specifier|abstract
class|class
name|TreeNode
block|{
comment|/**      * this node's parent, or null if this node has no parent      */
DECL|field|parent
specifier|private
name|GroupTreeNode
name|parent
decl_stmt|;
comment|/**      * array of children, may be empty if this node has no children (but never null)      */
DECL|field|children
specifier|private
name|List
argument_list|<
name|GroupTreeNode
argument_list|>
name|children
decl_stmt|;
DECL|method|TreeNode ()
specifier|public
name|TreeNode
parameter_list|()
block|{
name|parent
operator|=
literal|null
expr_stmt|;
name|children
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|this
operator|instanceof
name|GroupTreeNode
operator|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"The class extending TreeNode has to derive from GroupTreeNode"
argument_list|)
throw|;
block|}
block|}
comment|/**      * @return An indexed path from the root node to this node. The elements in      * the returned array represent the child index of each node in the      * path. If this node is the root node, the returned array has zero      * elements.      */
DECL|method|getIndexedPath ()
specifier|public
name|List
argument_list|<
name|Integer
argument_list|>
name|getIndexedPath
parameter_list|()
block|{
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|pathToMe
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|pathToMe
operator|.
name|add
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|pathToMe
return|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|path
init|=
name|parent
operator|.
name|getIndexedPath
argument_list|()
decl_stmt|;
name|path
operator|.
name|add
argument_list|(
name|getPositionInParent
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
comment|/**      * Returns the node indicated by the specified indexedPath, which contains      * child indices obtained e.g. by getIndexedPath().      */
DECL|method|getNode (List<Integer> indexedPath)
specifier|public
name|GroupTreeNode
name|getNode
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|indexedPath
parameter_list|)
block|{
name|GroupTreeNode
name|cursor
init|=
operator|(
name|GroupTreeNode
operator|)
name|this
decl_stmt|;
for|for
control|(
name|int
name|anIndexedPath
range|:
name|indexedPath
control|)
block|{
name|cursor
operator|=
name|cursor
operator|.
name|getChildAt
argument_list|(
name|anIndexedPath
argument_list|)
expr_stmt|;
block|}
return|return
name|cursor
return|;
block|}
comment|/**      * @param indexedPath A sequence of child indices that describe a path from this      *                    node to one of its desendants. Be aware that if<b>indexedPath      *</b> was obtained by getIndexedPath(), this node should      *                    usually be the root node.      * @return The descendant found by evaluating<b>indexedPath</b>. If the      * path could not be traversed completely (i.e. one of the child      * indices did not exist), null will be returned.      */
DECL|method|getDescendant (List<Integer> indexedPath)
specifier|public
name|GroupTreeNode
name|getDescendant
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|indexedPath
parameter_list|)
block|{
name|GroupTreeNode
name|cursor
init|=
operator|(
name|GroupTreeNode
operator|)
name|this
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
operator|(
name|i
operator|<
name|indexedPath
operator|.
name|size
argument_list|()
operator|)
operator|&&
operator|(
name|cursor
operator|!=
literal|null
operator|)
condition|;
operator|++
name|i
control|)
block|{
name|cursor
operator|=
name|cursor
operator|.
name|getChildAt
argument_list|(
name|indexedPath
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cursor
return|;
block|}
DECL|method|getPositionInParent ()
specifier|public
name|int
name|getPositionInParent
parameter_list|()
block|{
return|return
name|getParent
argument_list|()
operator|.
name|getIndex
argument_list|(
operator|(
name|GroupTreeNode
operator|)
name|this
argument_list|)
return|;
block|}
comment|/**      * Returns the index of the specified child in this node's child list.      * If the specified node is not a child of this node, returns<code>-1</code>.      * This method performs a linear search and is O(n) where n is the number of children.      *      * @param childNode the GroupTreeNode to search for among this node's children      * @return an int giving the index of the node in this node's child list,      * or<code>-1</code> if the specified node is a not a child of this node      * @throws NullPointerException if<code>aChild</code> is null      */
DECL|method|getIndex (GroupTreeNode childNode)
specifier|public
name|int
name|getIndex
parameter_list|(
name|GroupTreeNode
name|childNode
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|childNode
argument_list|)
expr_stmt|;
return|return
name|children
operator|.
name|indexOf
argument_list|(
name|childNode
argument_list|)
return|;
block|}
comment|/**      * Returns the number of levels above this node -- the distance from the root to this node.      * If this node is the root, returns 0.      *      * @return the number of levels above this node      */
DECL|method|getLevel ()
specifier|public
name|int
name|getLevel
parameter_list|()
block|{
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|parent
operator|.
name|getLevel
argument_list|()
operator|+
literal|1
return|;
block|}
comment|/**      * Returns the number of children of this node.      *      * @return an int giving the number of children of this node      */
DECL|method|getChildCount ()
specifier|public
name|int
name|getChildCount
parameter_list|()
block|{
return|return
name|children
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Removes<code>newChild</code> from its parent and makes it a child of this node      * by adding it to the end of this node's child array.      *      * @param newChild node to add as a child of this node      * @throws NullPointerException if<code>newChild</code> is null      * @see #insert      */
DECL|method|add (GroupTreeNode newChild)
specifier|public
name|void
name|add
parameter_list|(
name|GroupTreeNode
name|newChild
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|newChild
argument_list|)
expr_stmt|;
if|if
condition|(
name|newChild
operator|.
name|getParent
argument_list|()
operator|==
name|this
condition|)
block|{
name|insert
argument_list|(
name|newChild
argument_list|,
name|getChildCount
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insert
argument_list|(
name|newChild
argument_list|,
name|getChildCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns the path from the root, to get to this node. The last element in the path is this node.      *      * @return an array of TreeNode objects giving the path, where the first element in the path is the root      * and the last element is this node.      */
DECL|method|getPath ()
specifier|public
name|List
argument_list|<
name|GroupTreeNode
argument_list|>
name|getPath
parameter_list|()
block|{
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
name|List
argument_list|<
name|GroupTreeNode
argument_list|>
name|pathToMe
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|pathToMe
operator|.
name|add
argument_list|(
operator|(
name|GroupTreeNode
operator|)
name|this
argument_list|)
expr_stmt|;
return|return
name|pathToMe
return|;
block|}
name|List
argument_list|<
name|GroupTreeNode
argument_list|>
name|path
init|=
name|parent
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|path
operator|.
name|add
argument_list|(
operator|(
name|GroupTreeNode
operator|)
name|this
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
comment|/**      * Returns the next sibling of this node in the parent's children list.      * Returns null if this node has no parent or if it is the parent's last child.      *<p>      * This method performs a linear search that is O(n) where n is the number of children;      * to traverse the entire array, use the parent's child enumeration instead.      *      * @return the sibling of this node that immediately follows this node      * @see #children      */
DECL|method|getNextSibling ()
specifier|protected
name|GroupTreeNode
name|getNextSibling
parameter_list|()
block|{
return|return
name|getRelativeSibling
argument_list|(
operator|+
literal|1
argument_list|)
return|;
block|}
DECL|method|getRelativeSibling (int shiftIndex)
specifier|private
name|GroupTreeNode
name|getRelativeSibling
parameter_list|(
name|int
name|shiftIndex
parameter_list|)
block|{
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|int
name|indexInParent
init|=
name|getPositionInParent
argument_list|()
decl_stmt|;
name|int
name|indexTarget
init|=
name|indexInParent
operator|+
name|shiftIndex
decl_stmt|;
if|if
condition|(
name|indexTarget
operator|>=
literal|0
operator|&&
name|indexTarget
operator|<
name|parent
operator|.
name|getChildCount
argument_list|()
condition|)
block|{
return|return
name|parent
operator|.
name|getChildAt
argument_list|(
name|indexTarget
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
comment|/**      * Returns the previous sibling of this node in the parent's children list.      * Returns null if this node has no parent or is the parent's first child.      *<p>      * This method performs a linear search that is O(n) where n is the number of children.      *      * @return the sibling of this node that immediately precedes this node      */
DECL|method|getPreviousSibling ()
specifier|protected
name|GroupTreeNode
name|getPreviousSibling
parameter_list|()
block|{
return|return
name|getRelativeSibling
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**      * Returns this node's parent or null if this node has no parent.      *      * @return this node's parent GroupTreeNode, or null if this node has no parent      */
DECL|method|getParent ()
specifier|public
name|GroupTreeNode
name|getParent
parameter_list|()
block|{
return|return
name|parent
return|;
block|}
DECL|method|setParent (GroupTreeNode parent)
specifier|protected
name|void
name|setParent
parameter_list|(
name|GroupTreeNode
name|parent
parameter_list|)
block|{
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
block|}
comment|/**      * Returns the child at the specified index in this node's child array.      *      * @param index an index into this node's child array      * @return the GroupTreeNode in this node's child array at the specified index      * @throws ArrayIndexOutOfBoundsException if<code>index</code> is out of bounds      */
DECL|method|getChildAt (int index)
specifier|public
name|GroupTreeNode
name|getChildAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|children
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
comment|/**      * Returns true if this node is the root of the tree.      * The root is the only node in the tree with a null parent; every tree has exactl one root.      *      * @return true if this node is the root of its tree      */
DECL|method|isRoot ()
specifier|public
name|boolean
name|isRoot
parameter_list|()
block|{
return|return
name|getParent
argument_list|()
operator|==
literal|null
return|;
block|}
comment|/**      * Removes<code>newChild</code> from its present parent (if it has a      * parent), sets the child's parent to this node, and then adds the child      * to this node's child array at index<code>childIndex</code>.      *<code>newChild</code> must not be null and must not be an ancestor of      * this node.      *      * @param child      the GroupTreeNode to insert under this node      * @param childIndex the index in this node's child array where this node is to be inserted      * @throws ArrayIndexOutOfBoundsException if<code>childIndex</code> is out of bounds      * @throws IllegalArgumentException       if<code>newChild</code> is null or is an ancestor of this node      * @see #isNodeDescendant      */
DECL|method|insert (GroupTreeNode child, int childIndex)
specifier|public
name|void
name|insert
parameter_list|(
name|GroupTreeNode
name|child
parameter_list|,
name|int
name|childIndex
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|isNodeAncestor
argument_list|(
name|child
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"new child is an ancestor"
argument_list|)
throw|;
block|}
comment|// Remove from previous parent
name|GroupTreeNode
name|oldParent
init|=
name|child
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldParent
operator|!=
literal|null
condition|)
block|{
name|oldParent
operator|.
name|remove
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
comment|// Add as child
name|child
operator|.
name|setParent
argument_list|(
operator|(
name|GroupTreeNode
operator|)
name|this
argument_list|)
expr_stmt|;
name|children
operator|.
name|add
argument_list|(
name|childIndex
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns true if<code>anotherNode</code> is an ancestor of this node      * -- if it is this node, this node's parent, or an ancestor of this node's parent.      * (Note that a node is considered an ancestor of itself.)      * If<code>anotherNode</code> is null, this method returns false.      * This operation is at worst O(h) where h is the distance from the root to this node.      *      * @param anotherNode node to test as an ancestor of this node      * @return true if this node is a descendant of<code>anotherNode</code>      * @see #isNodeDescendant      */
DECL|method|isNodeAncestor (GroupTreeNode anotherNode)
specifier|public
name|boolean
name|isNodeAncestor
parameter_list|(
name|GroupTreeNode
name|anotherNode
parameter_list|)
block|{
if|if
condition|(
name|anotherNode
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|anotherNode
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
name|parent
operator|!=
literal|null
operator|&&
name|parent
operator|.
name|isNodeAncestor
argument_list|(
name|anotherNode
argument_list|)
return|;
block|}
block|}
comment|/**      * Returns the root of the tree that contains this node. The root is the ancestor with a null parent.      *      * @return the root of the tree that contains this node      * @see #isNodeAncestor      */
DECL|method|getRoot ()
specifier|public
name|GroupTreeNode
name|getRoot
parameter_list|()
block|{
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
return|return
operator|(
name|GroupTreeNode
operator|)
name|this
return|;
block|}
else|else
block|{
return|return
name|parent
operator|.
name|getRoot
argument_list|()
return|;
block|}
block|}
comment|/**      * Returns true if this node has no children.      *      * @return true if this node has no children      */
DECL|method|isLeaf ()
specifier|public
name|boolean
name|isLeaf
parameter_list|()
block|{
return|return
operator|(
name|getChildCount
argument_list|()
operator|==
literal|0
operator|)
return|;
block|}
comment|/**      * Removes the subtree rooted at this node from the tree, giving this node a null parent.      * Does nothing if this node is the root of it tree.      */
DECL|method|removeFromParent ()
specifier|public
name|void
name|removeFromParent
parameter_list|()
block|{
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|remove
argument_list|(
operator|(
name|GroupTreeNode
operator|)
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Removes all of this node's children, setting their parents to null.      * If this node has no children, this method does nothing.      */
DECL|method|removeAllChildren ()
specifier|public
name|void
name|removeAllChildren
parameter_list|()
block|{
for|for
control|(
name|GroupTreeNode
name|child
range|:
name|children
control|)
block|{
name|remove
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns this node's first child.      *      * @return the first child of this node      */
DECL|method|getFirstChild ()
specifier|public
name|GroupTreeNode
name|getFirstChild
parameter_list|()
block|{
if|if
condition|(
name|children
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
literal|"node has no children"
argument_list|)
throw|;
block|}
return|return
name|getChildAt
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**      * Returns true if<code>anotherNode</code> is a descendant of this node      * -- if it is this node, one of this node's children, or a descendant of one of this node's children.      * Note that a node is considered a descendant of itself.      *<p>      * If<code>anotherNode</code> is null, returns false.      * This operation is at worst O(h) where h is the distance from the root to<code>anotherNode</code>.      *      * @param anotherNode node to test as descendant of this node      * @return true if this node is an ancestor of<code>anotherNode</code>      * @see #isNodeAncestor      */
DECL|method|isNodeDescendant (GroupTreeNode anotherNode)
specifier|public
name|boolean
name|isNodeDescendant
parameter_list|(
name|GroupTreeNode
name|anotherNode
parameter_list|)
block|{
return|return
name|anotherNode
operator|!=
literal|null
operator|&&
name|anotherNode
operator|.
name|isNodeAncestor
argument_list|(
operator|(
name|GroupTreeNode
operator|)
name|this
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a forward-order Iterable of this node's children.      * Modifying this node's child array invalidates any child iterables created before the modification.      *      * @return an Iterable of this node's children      */
DECL|method|children ()
specifier|public
name|Iterable
argument_list|<
name|GroupTreeNode
argument_list|>
name|children
parameter_list|()
block|{
return|return
name|children
return|;
block|}
comment|/**      * Removes<code>child</code> from this node's child array, giving it a null parent.      *      * @param child a child of this node to remove      */
DECL|method|remove (GroupTreeNode child)
specifier|public
name|void
name|remove
parameter_list|(
name|GroupTreeNode
name|child
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|getIndex
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
comment|// linear search
block|}
comment|/**      * Removes the child at the specified index from this node's children and sets that node's parent to null.      *      * @param childIndex the index in this node's child array of the child to remove      * @throws ArrayIndexOutOfBoundsException if<code>childIndex</code> is out of bounds      */
DECL|method|remove (int childIndex)
specifier|public
name|void
name|remove
parameter_list|(
name|int
name|childIndex
parameter_list|)
block|{
name|GroupTreeNode
name|child
init|=
name|getChildAt
argument_list|(
name|childIndex
argument_list|)
decl_stmt|;
name|children
operator|.
name|remove
argument_list|(
name|childIndex
argument_list|)
expr_stmt|;
name|child
operator|.
name|setParent
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param path A sequence of child indices that designate a node relative to      *             this node.      * @return The node designated by the specified path, or null if one or more      * indices in the path could not be resolved.      */
DECL|method|getChildAt (List<Integer> path)
specifier|public
name|GroupTreeNode
name|getChildAt
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|path
parameter_list|)
block|{
name|GroupTreeNode
name|cursor
init|=
operator|(
name|GroupTreeNode
operator|)
name|this
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
operator|(
name|i
operator|<
name|path
operator|.
name|size
argument_list|()
operator|)
operator|&&
operator|(
name|cursor
operator|!=
literal|null
operator|)
condition|;
operator|++
name|i
control|)
block|{
name|cursor
operator|=
name|cursor
operator|.
name|getChildAt
argument_list|(
name|path
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cursor
return|;
block|}
block|}
end_class

end_unit

