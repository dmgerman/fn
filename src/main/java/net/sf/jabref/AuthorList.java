begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003-2011 JabRef contributors.     This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License along     with this program; if not, write to the Free Software Foundation, Inc.,     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */
end_comment

begin_package
DECL|package|net.sf.jabref
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
package|;
end_package

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|format
operator|.
name|CreateDocBookAuthors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|WeakHashMap
import|;
end_import

begin_comment
comment|/**  * This is an immutable class representing information of either<CODE>author</CODE>  * or<CODE>editor</CODE> field in bibtex record.  *<p>  * Constructor performs parsing of raw field text and stores preformatted data.  * Various accessor methods return author/editor field in different formats.  *<p>  * Parsing algorithm is designed to satisfy two requirements: (a) when author's  * name is typed correctly, the result should coincide with the one of BiBTeX;  * (b) for erroneous names, output should be reasonable (but may differ from  * BiBTeX output). The following rules are used:  *<ol>  *<li> 'author field' is a sequence of tokens;  *<ul>  *<li> tokens are separated by sequences of whitespaces (<CODE>Character.isWhitespace(c)==true</CODE>),  * commas (,), dashes (-), and tildas (~);  *<li> every comma separates tokens, while sequences of other separators are  * equivalent to a single separator; for example: "a - b" consists of 2 tokens  * ("a" and "b"), while "a,-,b" consists of 3 tokens ("a", "", and "b")  *<li> anything enclosed in braces belonges to a single token; for example:  * "abc x{a,b,-~ c}x" consists of 2 tokens, while "abc xa,b,-~ cx" consists of 4  * tokens ("abc", "xa","b", and "cx");  *<li> a token followed immediately by a dash is "dash-terminated" token, and  * all other tokens are "space-terminated" tokens; for example: in "a-b- c - d"  * tokens "a" and "b" are dash-terminated and "c" and "d" are space-terminated;  *<li> for the purposes of splitting of 'author name' into parts and  * construction of abbreviation of first name, one needs definitions of first  * latter of a token, case of a token, and abbreviation of a token:  *<ul>  *<li> 'first letter' of a token is the first letter character (<CODE>Character.isLetter(c)==true</CODE>)  * that does not belong to a sequence of letters that immediately follows "\"  * character, with one exception: if "\" is followed by "aa", "AA", "ae", "AE",  * "l", "L", "o", "O", "oe", "OE", "i", or "j" followed by non-letter, the  * 'first letter' of a token is a letter that follows "\"; for example: in  * "a{x}b" 'first letter' is "a", in "{\"{U}}bel" 'first letter' is "U", in  * "{\noopsort{\"o}}xyz" 'first letter' is "o", in "{\AE}x" 'first letter' is  * "A", in "\aex\ijk\Oe\j" 'first letter' is "j"; if there is no letter  * satisfying the above rule, 'first letter' is undefined;  *<li> token is "lower-case" token, if its first letter id defined and is  * lower-case (<CODE>Character.isLowerCase(c)==true</CODE>), and token is  * "upper-case" token otherwise;  *<li> 'abbreviation' of a token is the shortest prefix of the token that (a)  * contains 'first letter' and (b) is braces-balanced; if 'first letter' is  * undefined, 'abbreviation' is the token itself; in the above examples,  * 'abbreviation's are "a", "{\"{U}}", "{\noopsort{\"o}}", "{\AE}",  * "\aex\ijk\Oe\j";  *</ul>  *<li> the behavior based on the above definitions will be erroneous only in  * one case: if the first-name-token is "{\noopsort{A}}john", we abbreviate it  * as "{\noopsort{A}}.", while BiBTeX produces "j."; fixing this problem,  * however, requires processing of the preabmle;  *</ul>  *<li> 'author name's in 'author field' are subsequences of tokens separated by  * token "and" ("and" is case-insensitive); if 'author name' is an empty  * sequence of tokens, it is ignored; for examle, both "John Smith and Peter  * Black" and "and and John Smith and and Peter Black" consists of 2 'author  * name's "Johm Smith" and "Peter Black" (in erroneous situations, this is a bit  * different from BiBTeX behavior);  *<li> 'author name' consists of 'first-part', 'von-part', 'last-part', and  * 'junior-part', each of which is a sequence of tokens; how a sequence of  * tokens has to be splitted into these parts, depends the number of commas:  *<ul>  *<li> no commas, all tokens are upper-case: 'junior-part' and 'von-part' are  * empty, 'last-part' consist of the last token, 'first-part' consists of all  * other tokens ('first-part' is empty, if 'author name' consists of a single  * token); for example, in "John James Smith", 'last-part'="Smith" and  * 'first-part'="John James";  *<li> no commas, there exists lower-case token: 'junior-part' is empty,  * 'first-part' consists of all upper-case tokens before the first lower-case  * token, 'von-part' consists of lower-case tokens starting the first lower-case  * token and ending the lower-case token that is followed by upper-case token,  * 'last-part' consists of the rest of tokens; note that both 'first-part' and  * 'latst-part' may be empty and 'last-part' may contain lower-case tokens; for  * example: in "von der", 'first-part'='last-part'="", 'von-part'="von der"; in  * "Charles Louis Xavier Joseph de la Vall{\'e}e la Poussin",  * 'first-part'="Charles Louis Xavier Joseph", 'von-part'="de la",  * 'last-part'="Vall{\'e}e la Poussin";  *<li> one comma: 'junior-part' is empty, 'first-part' consists of all tokens  * after comma, 'von-part' consists of the longest sequence of lower-case tokens  * in the very beginning, 'last-part' consists of all tokens after 'von-part'  * and before comma; note that any part can be empty; for example: in "de la  * Vall{\'e}e la Poussin, Charles Louis Xavier Joseph", 'first-part'="Charles  * Louis Xavier Joseph", 'von-part'="de la", 'last-part'="Vall{\'e}e la  * Poussin"; in "Joseph de la Vall{\'e}e la Poussin, Charles Louis Xavier",  * 'first-part'="Charles Louis Xavier", 'von-part'="", 'last-part'="Joseph de la  * Vall{\'e}e la Poussin";  *<li> two or more commas (any comma after the second one is ignored; it merely  * separates tokens): 'junior-part' consists of all tokens between first and  * second commas, 'first-part' consists of all tokens after the second comma,  * tokens before the first comma are splitted into 'von-part' and 'last-part'  * similarly to the case of one comma; for example: in "de la Vall{\'e}e  * Poussin, Jr., Charles Louis Xavier Joseph", 'first-part'="Charles Louis  * Xavier Joseph", 'von-part'="de la", 'last-part'="Vall{\'e}e la Poussin", and  * 'junior-part'="Jr.";  *</ul>  *<li> when 'first-part', 'last-part', 'von-part', or 'junior-part' is  * reconstructed from tokens, tokens in a part are separated either by space or  * by dash, depending on whether the token before the separator was  * space-terminated or dash-terminated; for the last token in a part it does not  * matter whether it was dash- or space-terminated;  *<li> when 'first-part' is abbreviated, each token is replaced by its  * abbreviation followed by a period; separators are the same as in the case of  * non-abbreviated name; for example: in "Heinrich-{\"{U}}bel Kurt von Minich",  * 'first-part'="Heinrich-{\"{U}}bel Kurt", and its abbreviation is "H.-{\"{U}}.  * K."  *</ol>  */
end_comment

begin_class
DECL|class|AuthorList
specifier|public
class|class
name|AuthorList
block|{
DECL|field|authors
specifier|private
specifier|final
name|Vector
argument_list|<
name|Author
argument_list|>
name|authors
decl_stmt|;
comment|// Variables for storing computed strings, so they only need be created
comment|// once:
DECL|field|authorsNatbib
DECL|field|authorsFirstFirstAnds
specifier|private
name|String
name|authorsNatbib
init|=
literal|null
decl_stmt|,
name|authorsFirstFirstAnds
init|=
literal|null
decl_stmt|,
DECL|field|authorsAlph
name|authorsAlph
init|=
literal|null
decl_stmt|;
DECL|field|authorsFirstFirst
specifier|private
specifier|final
name|String
index|[]
name|authorsFirstFirst
init|=
operator|new
name|String
index|[
literal|4
index|]
decl_stmt|;
DECL|field|authorsLastOnly
specifier|private
specifier|final
name|String
index|[]
name|authorsLastOnly
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
DECL|field|authorLastFirstAnds
specifier|private
specifier|final
name|String
index|[]
name|authorLastFirstAnds
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
DECL|field|authorsLastFirst
specifier|private
specifier|final
name|String
index|[]
name|authorsLastFirst
init|=
operator|new
name|String
index|[
literal|4
index|]
decl_stmt|;
DECL|field|authorsLastFirstFirstLast
specifier|private
specifier|final
name|String
index|[]
name|authorsLastFirstFirstLast
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
comment|// The following variables are used only during parsing
DECL|field|orig
specifier|private
name|String
name|orig
decl_stmt|;
comment|// the raw bibtex author/editor field
comment|// the following variables are updated by getToken procedure
DECL|field|token_start
specifier|private
name|int
name|token_start
decl_stmt|;
comment|// index in orig
DECL|field|token_end
specifier|private
name|int
name|token_end
decl_stmt|;
comment|// to point 'abc' in ' abc xyz', start=2 and end=5
comment|// the following variables are valid only if getToken returns TOKEN_WORD
DECL|field|token_abbr
specifier|private
name|int
name|token_abbr
decl_stmt|;
comment|// end of token abbreviation (always: token_start<
comment|// token_abbr<= token_end)
DECL|field|token_term
specifier|private
name|char
name|token_term
decl_stmt|;
comment|// either space or dash
DECL|field|token_case
specifier|private
name|boolean
name|token_case
decl_stmt|;
comment|// true if upper-case token, false if lower-case
comment|// token
comment|// Tokens of one author name.
comment|// Each token occupies TGL consecutive entries in this vector (as described
comment|// below)
DECL|field|tokens
specifier|private
name|Vector
argument_list|<
name|Object
argument_list|>
name|tokens
decl_stmt|;
DECL|field|TOKEN_GROUP_LENGTH
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_GROUP_LENGTH
init|=
literal|4
decl_stmt|;
comment|// number of entries for
comment|// a token
comment|// the following are offsets of an entry in a group of entries for one token
DECL|field|OFFSET_TOKEN
specifier|private
specifier|static
specifier|final
name|int
name|OFFSET_TOKEN
init|=
literal|0
decl_stmt|;
comment|// String -- token itself;
DECL|field|OFFSET_TOKEN_ABBR
specifier|private
specifier|static
specifier|final
name|int
name|OFFSET_TOKEN_ABBR
init|=
literal|1
decl_stmt|;
comment|// String -- token
comment|// abbreviation;
DECL|field|OFFSET_TOKEN_TERM
specifier|private
specifier|static
specifier|final
name|int
name|OFFSET_TOKEN_TERM
init|=
literal|2
decl_stmt|;
comment|// Character -- token
comment|// terminator (either " " or
comment|// "-")
comment|// private static final int OFFSET_TOKEN_CASE = 3; // Boolean --
comment|// true=uppercase, false=lowercase
comment|// the following are indices in 'tokens' vector created during parsing of
comment|// author name
comment|// and later used to properly split author name into parts
DECL|field|von_start
name|int
name|von_start
decl_stmt|,
comment|// first lower-case token (-1 if all tokens upper-case)
DECL|field|last_start
name|last_start
decl_stmt|,
comment|// first upper-case token after first lower-case token (-1
comment|// if does not exist)
DECL|field|comma_first
name|comma_first
decl_stmt|,
comment|// token after first comma (-1 if no commas)
DECL|field|comma_second
name|comma_second
decl_stmt|;
comment|// token after second comma (-1 if no commas or only one
comment|// comma)
comment|// Token types (returned by getToken procedure)
DECL|field|TOKEN_EOF
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_EOF
init|=
literal|0
decl_stmt|;
DECL|field|TOKEN_AND
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_AND
init|=
literal|1
decl_stmt|;
DECL|field|TOKEN_COMMA
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_COMMA
init|=
literal|2
decl_stmt|;
DECL|field|TOKEN_WORD
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_WORD
init|=
literal|3
decl_stmt|;
comment|// Constant Hashtable containing names of TeX special characters
DECL|field|tex_names
specifier|private
specifier|static
specifier|final
name|java
operator|.
name|util
operator|.
name|HashSet
argument_list|<
name|String
argument_list|>
name|tex_names
init|=
operator|new
name|java
operator|.
name|util
operator|.
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// and static constructor to initialize it
static|static
block|{
name|tex_names
operator|.
name|add
argument_list|(
literal|"aa"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|add
argument_list|(
literal|"ae"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|add
argument_list|(
literal|"l"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|add
argument_list|(
literal|"o"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|add
argument_list|(
literal|"oe"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|add
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|add
argument_list|(
literal|"AA"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|add
argument_list|(
literal|"AE"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|add
argument_list|(
literal|"L"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|add
argument_list|(
literal|"O"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|add
argument_list|(
literal|"OE"
argument_list|)
expr_stmt|;
name|tex_names
operator|.
name|add
argument_list|(
literal|"j"
argument_list|)
expr_stmt|;
block|}
DECL|field|authorCache
specifier|static
specifier|final
name|WeakHashMap
argument_list|<
name|String
argument_list|,
name|AuthorList
argument_list|>
name|authorCache
init|=
operator|new
name|WeakHashMap
argument_list|<
name|String
argument_list|,
name|AuthorList
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Parses the parameter strings and stores preformatted author information.      *       * Don't call this constructor directly but rather use the getAuthorList()      * method which caches its results.      *       * @param bibtex_authors      *            contents of either<CODE>author</CODE> or<CODE>editor</CODE>      *            bibtex field.      */
DECL|method|AuthorList (String bibtex_authors)
specifier|protected
name|AuthorList
parameter_list|(
name|String
name|bibtex_authors
parameter_list|)
block|{
name|authors
operator|=
operator|new
name|Vector
argument_list|<
name|Author
argument_list|>
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|// 5 seems to be reasonable initial size
name|orig
operator|=
name|bibtex_authors
expr_stmt|;
comment|// initialization
name|token_start
operator|=
literal|0
expr_stmt|;
name|token_end
operator|=
literal|0
expr_stmt|;
comment|// of parser
while|while
condition|(
name|token_start
operator|<
name|orig
operator|.
name|length
argument_list|()
condition|)
block|{
name|Author
name|author
init|=
name|getAuthor
argument_list|()
decl_stmt|;
if|if
condition|(
name|author
operator|!=
literal|null
condition|)
name|authors
operator|.
name|add
argument_list|(
name|author
argument_list|)
expr_stmt|;
block|}
comment|// clean-up
name|orig
operator|=
literal|null
expr_stmt|;
name|tokens
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * Retrieve an AuthorList for the given string of authors or editors.      *       * This function tries to cache AuthorLists by string passed in.      *       * @param authors      *            The string of authors or editors in bibtex format to parse.      * @return An AuthorList object representing the given authors.      */
DECL|method|getAuthorList (String authors)
specifier|public
specifier|static
name|AuthorList
name|getAuthorList
parameter_list|(
name|String
name|authors
parameter_list|)
block|{
name|AuthorList
name|authorList
init|=
name|authorCache
operator|.
name|get
argument_list|(
name|authors
argument_list|)
decl_stmt|;
if|if
condition|(
name|authorList
operator|==
literal|null
condition|)
block|{
name|authorList
operator|=
operator|new
name|AuthorList
argument_list|(
name|authors
argument_list|)
expr_stmt|;
name|authorCache
operator|.
name|put
argument_list|(
name|authors
argument_list|,
name|authorList
argument_list|)
expr_stmt|;
block|}
return|return
name|authorList
return|;
block|}
comment|/**      * This is a convenience method for getAuthorsFirstFirst()      *       * @see net.sf.jabref.AuthorList#getAuthorsFirstFirst      */
DECL|method|fixAuthor_firstNameFirstCommas (String authors, boolean abbr, boolean oxfordComma)
specifier|public
specifier|static
name|String
name|fixAuthor_firstNameFirstCommas
parameter_list|(
name|String
name|authors
parameter_list|,
name|boolean
name|abbr
parameter_list|,
name|boolean
name|oxfordComma
parameter_list|)
block|{
return|return
name|getAuthorList
argument_list|(
name|authors
argument_list|)
operator|.
name|getAuthorsFirstFirst
argument_list|(
name|abbr
argument_list|,
name|oxfordComma
argument_list|)
return|;
block|}
comment|/**      * This is a convenience method for getAuthorsFirstFirstAnds()      *       * @see net.sf.jabref.AuthorList#getAuthorsFirstFirstAnds      */
DECL|method|fixAuthor_firstNameFirst (String authors)
specifier|public
specifier|static
name|String
name|fixAuthor_firstNameFirst
parameter_list|(
name|String
name|authors
parameter_list|)
block|{
return|return
name|getAuthorList
argument_list|(
name|authors
argument_list|)
operator|.
name|getAuthorsFirstFirstAnds
argument_list|()
return|;
block|}
comment|/**      * This is a convenience method for getAuthorsLastFirst()      *       * @see net.sf.jabref.AuthorList#getAuthorsLastFirst      */
DECL|method|fixAuthor_lastNameFirstCommas (String authors, boolean abbr, boolean oxfordComma)
specifier|public
specifier|static
name|String
name|fixAuthor_lastNameFirstCommas
parameter_list|(
name|String
name|authors
parameter_list|,
name|boolean
name|abbr
parameter_list|,
name|boolean
name|oxfordComma
parameter_list|)
block|{
return|return
name|getAuthorList
argument_list|(
name|authors
argument_list|)
operator|.
name|getAuthorsLastFirst
argument_list|(
name|abbr
argument_list|,
name|oxfordComma
argument_list|)
return|;
block|}
comment|/**      * This is a convenience method for getAuthorsLastFirstAnds(true)      *       * @see net.sf.jabref.AuthorList#getAuthorsLastFirstAnds      */
DECL|method|fixAuthor_lastNameFirst (String authors)
specifier|public
specifier|static
name|String
name|fixAuthor_lastNameFirst
parameter_list|(
name|String
name|authors
parameter_list|)
block|{
return|return
name|getAuthorList
argument_list|(
name|authors
argument_list|)
operator|.
name|getAuthorsLastFirstAnds
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|/**      * This is a convenience method for getAuthorsLastFirstAnds()      *       * @see net.sf.jabref.AuthorList#getAuthorsLastFirstAnds      */
DECL|method|fixAuthor_lastNameFirst (String authors, boolean abbreviate)
specifier|public
specifier|static
name|String
name|fixAuthor_lastNameFirst
parameter_list|(
name|String
name|authors
parameter_list|,
name|boolean
name|abbreviate
parameter_list|)
block|{
return|return
name|getAuthorList
argument_list|(
name|authors
argument_list|)
operator|.
name|getAuthorsLastFirstAnds
argument_list|(
name|abbreviate
argument_list|)
return|;
block|}
comment|/**      * This is a convenience method for getAuthorsLastOnly()      *       * @see net.sf.jabref.AuthorList#getAuthorsLastOnly      */
DECL|method|fixAuthor_lastNameOnlyCommas (String authors, boolean oxfordComma)
specifier|public
specifier|static
name|String
name|fixAuthor_lastNameOnlyCommas
parameter_list|(
name|String
name|authors
parameter_list|,
name|boolean
name|oxfordComma
parameter_list|)
block|{
return|return
name|getAuthorList
argument_list|(
name|authors
argument_list|)
operator|.
name|getAuthorsLastOnly
argument_list|(
name|oxfordComma
argument_list|)
return|;
block|}
comment|/**      * This is a convenience method for getAuthorsForAlphabetization()      *       * @see net.sf.jabref.AuthorList#getAuthorsForAlphabetization      */
DECL|method|fixAuthorForAlphabetization (String authors)
specifier|public
specifier|static
name|String
name|fixAuthorForAlphabetization
parameter_list|(
name|String
name|authors
parameter_list|)
block|{
return|return
name|getAuthorList
argument_list|(
name|authors
argument_list|)
operator|.
name|getAuthorsForAlphabetization
argument_list|()
return|;
block|}
comment|/**      * This is a convenience method for getAuthorsNatbib()      *       * @see net.sf.jabref.AuthorList#getAuthorsNatbib      */
DECL|method|fixAuthor_Natbib (String authors)
specifier|public
specifier|static
name|String
name|fixAuthor_Natbib
parameter_list|(
name|String
name|authors
parameter_list|)
block|{
return|return
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|authors
argument_list|)
operator|.
name|getAuthorsNatbib
argument_list|()
return|;
block|}
comment|/**      * Parses one author name and returns preformatted information.      *       * @return Preformatted author name;<CODE>null</CODE> if author name is      *         empty.      */
DECL|method|getAuthor ()
specifier|private
name|Author
name|getAuthor
parameter_list|()
block|{
name|tokens
operator|=
operator|new
name|Vector
argument_list|<
name|Object
argument_list|>
argument_list|()
expr_stmt|;
comment|// initialization
name|von_start
operator|=
operator|-
literal|1
expr_stmt|;
name|last_start
operator|=
operator|-
literal|1
expr_stmt|;
name|comma_first
operator|=
operator|-
literal|1
expr_stmt|;
name|comma_second
operator|=
operator|-
literal|1
expr_stmt|;
comment|// First step: collect tokens in 'tokens' Vector and calculate indices
name|token_loop
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|token
init|=
name|getToken
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|TOKEN_EOF
case|:
case|case
name|TOKEN_AND
case|:
break|break
name|token_loop
break|;
case|case
name|TOKEN_COMMA
case|:
if|if
condition|(
name|comma_first
operator|<
literal|0
condition|)
name|comma_first
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|comma_second
operator|<
literal|0
condition|)
name|comma_second
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
break|break;
case|case
name|TOKEN_WORD
case|:
name|tokens
operator|.
name|add
argument_list|(
name|orig
operator|.
name|substring
argument_list|(
name|token_start
argument_list|,
name|token_end
argument_list|)
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|orig
operator|.
name|substring
argument_list|(
name|token_start
argument_list|,
name|token_abbr
argument_list|)
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|token_term
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|token_case
argument_list|)
expr_stmt|;
if|if
condition|(
name|comma_first
operator|>=
literal|0
condition|)
break|break;
if|if
condition|(
name|last_start
operator|>=
literal|0
condition|)
break|break;
if|if
condition|(
name|von_start
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|token_case
condition|)
block|{
name|von_start
operator|=
name|tokens
operator|.
name|size
argument_list|()
operator|-
name|TOKEN_GROUP_LENGTH
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|last_start
operator|<
literal|0
operator|&&
name|token_case
condition|)
block|{
name|last_start
operator|=
name|tokens
operator|.
name|size
argument_list|()
operator|-
name|TOKEN_GROUP_LENGTH
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// end token_loop
comment|// Second step: split name into parts (here: calculate indices
comment|// of parts in 'tokens' Vector)
if|if
condition|(
name|tokens
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
comment|// no author information
comment|// the following negatives indicate absence of the corresponding part
name|int
name|first_part_start
init|=
operator|-
literal|1
decl_stmt|,
name|von_part_start
init|=
operator|-
literal|1
decl_stmt|,
name|last_part_start
init|=
operator|-
literal|1
decl_stmt|,
name|jr_part_start
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|first_part_end
decl_stmt|,
name|von_part_end
init|=
literal|0
decl_stmt|,
name|last_part_end
init|=
literal|0
decl_stmt|,
name|jr_part_end
init|=
literal|0
decl_stmt|;
name|boolean
name|jrAsFirstname
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|comma_first
operator|<
literal|0
condition|)
block|{
comment|// no commas
if|if
condition|(
name|von_start
operator|<
literal|0
condition|)
block|{
comment|// no 'von part'
name|last_part_end
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
name|last_part_start
operator|=
name|tokens
operator|.
name|size
argument_list|()
operator|-
name|TOKEN_GROUP_LENGTH
expr_stmt|;
name|int
name|index
init|=
name|tokens
operator|.
name|size
argument_list|()
operator|-
literal|2
operator|*
name|TOKEN_GROUP_LENGTH
operator|+
name|OFFSET_TOKEN_TERM
decl_stmt|;
if|if
condition|(
name|index
operator|>
literal|0
condition|)
block|{
name|Character
name|ch
init|=
operator|(
name|Character
operator|)
name|tokens
operator|.
name|elementAt
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'-'
condition|)
name|last_part_start
operator|-=
name|TOKEN_GROUP_LENGTH
expr_stmt|;
block|}
name|first_part_end
operator|=
name|last_part_start
expr_stmt|;
if|if
condition|(
name|first_part_end
operator|>
literal|0
condition|)
block|{
name|first_part_start
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// 'von part' is present
if|if
condition|(
name|last_start
operator|>=
literal|0
condition|)
block|{
name|last_part_end
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
name|last_part_start
operator|=
name|last_start
expr_stmt|;
name|von_part_end
operator|=
name|last_part_start
expr_stmt|;
block|}
else|else
block|{
name|von_part_end
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|von_part_start
operator|=
name|von_start
expr_stmt|;
name|first_part_end
operator|=
name|von_part_start
expr_stmt|;
if|if
condition|(
name|first_part_end
operator|>
literal|0
condition|)
name|first_part_start
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// commas are present: it affects only 'first part' and
comment|// 'junior part'
name|first_part_end
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|comma_second
operator|<
literal|0
condition|)
block|{
comment|// one comma
if|if
condition|(
name|comma_first
operator|<
name|first_part_end
condition|)
block|{
name|first_part_start
operator|=
name|comma_first
expr_stmt|;
comment|//if (((String)tokens.get(first_part_start)).toLowerCase().startsWith("jr."))
comment|//    jrAsFirstname = true;
block|}
block|}
else|else
block|{
comment|// two or more commas
if|if
condition|(
name|comma_second
operator|<
name|first_part_end
condition|)
name|first_part_start
operator|=
name|comma_second
expr_stmt|;
name|jr_part_end
operator|=
name|comma_second
expr_stmt|;
if|if
condition|(
name|comma_first
operator|<
name|jr_part_end
condition|)
name|jr_part_start
operator|=
name|comma_first
expr_stmt|;
block|}
if|if
condition|(
name|von_start
operator|!=
literal|0
condition|)
block|{
comment|// no 'von part'
name|last_part_end
operator|=
name|comma_first
expr_stmt|;
if|if
condition|(
name|last_part_end
operator|>
literal|0
condition|)
name|last_part_start
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// 'von part' is present
if|if
condition|(
name|last_start
operator|<
literal|0
condition|)
block|{
name|von_part_end
operator|=
name|comma_first
expr_stmt|;
block|}
else|else
block|{
name|last_part_end
operator|=
name|comma_first
expr_stmt|;
name|last_part_start
operator|=
name|last_start
expr_stmt|;
name|von_part_end
operator|=
name|last_part_start
expr_stmt|;
block|}
name|von_part_start
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|first_part_start
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|last_part_start
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|von_part_start
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
comment|// There is no first or last name, but we have a von part. This is likely
comment|// to indicate a single-entry name without an initial capital letter, such
comment|// as "unknown".
comment|// We make the von part the last name, to facilitate handling by last-name formatters:
name|last_part_start
operator|=
name|von_part_start
expr_stmt|;
name|last_part_end
operator|=
name|von_part_end
expr_stmt|;
name|von_part_start
operator|=
operator|-
literal|1
expr_stmt|;
name|von_part_end
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|jrAsFirstname
condition|)
block|{
comment|// This variable, if set, indicates that the first name starts with "jr.", which
comment|// is an indication that we may have a name formatted as "Firstname Lastname, Jr."
comment|// which is an acceptable format for BibTeX.
block|}
comment|// Third step: do actual splitting, construct Author object
return|return
operator|new
name|Author
argument_list|(
operator|(
name|first_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|first_part_start
argument_list|,
name|first_part_end
argument_list|,
name|OFFSET_TOKEN
argument_list|,
literal|false
argument_list|)
operator|)
argument_list|,
operator|(
name|first_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|first_part_start
argument_list|,
name|first_part_end
argument_list|,
name|OFFSET_TOKEN_ABBR
argument_list|,
literal|true
argument_list|)
operator|)
argument_list|,
operator|(
name|von_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|von_part_start
argument_list|,
name|von_part_end
argument_list|,
name|OFFSET_TOKEN
argument_list|,
literal|false
argument_list|)
operator|)
argument_list|,
operator|(
name|last_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|last_part_start
argument_list|,
name|last_part_end
argument_list|,
name|OFFSET_TOKEN
argument_list|,
literal|false
argument_list|)
operator|)
argument_list|,
operator|(
name|jr_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|jr_part_start
argument_list|,
name|jr_part_end
argument_list|,
name|OFFSET_TOKEN
argument_list|,
literal|false
argument_list|)
operator|)
argument_list|)
return|;
block|}
comment|/**      * Concatenates list of tokens from 'tokens' Vector. Tokens are separated by      * spaces or dashes, dependeing on stored in 'tokens'. Callers always ensure      * that start< end; thus, there exists at least one token to be      * concatenated.      *       * @param start      *            index of the first token to be concatenated in 'tokens' Vector      *            (always divisible by TOKEN_GROUP_LENGTH).      * @param end      *            index of the first token not to be concatenated in 'tokens'      *            Vector (always divisible by TOKEN_GROUP_LENGTH).      * @param offset      *            offset within token group (used to request concatenation of      *            either full tokens or abbreviation).      * @param dot_after      *<CODE>true</CODE> -- add period after each token,<CODE>false</CODE> --      *            do not add.      * @return the result of concatenation.      */
DECL|method|concatTokens (int start, int end, int offset, boolean dot_after)
specifier|private
name|String
name|concatTokens
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|offset
parameter_list|,
name|boolean
name|dot_after
parameter_list|)
block|{
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// Here we always have start< end
name|res
operator|.
name|append
argument_list|(
operator|(
name|String
operator|)
name|tokens
operator|.
name|get
argument_list|(
name|start
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot_after
condition|)
name|res
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|start
operator|+=
name|TOKEN_GROUP_LENGTH
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|tokens
operator|.
name|get
argument_list|(
name|start
operator|-
name|TOKEN_GROUP_LENGTH
operator|+
name|OFFSET_TOKEN_TERM
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
operator|(
name|String
operator|)
name|tokens
operator|.
name|get
argument_list|(
name|start
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot_after
condition|)
name|res
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|start
operator|+=
name|TOKEN_GROUP_LENGTH
expr_stmt|;
block|}
return|return
name|res
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Parses the next token.      *<p>      * The string being parsed is stored in global variable<CODE>orig</CODE>,      * and position which parsing has to start from is stored in global variable      *<CODE>token_end</CODE>; thus,<CODE>token_end</CODE> has to be set      * to 0 before the first invocation. Procedure updates<CODE>token_end</CODE>;      * thus, subsequent invocations do not require any additional variable      * settings.      *<p>      * The type of the token is returned; if it is<CODE>TOKEN_WORD</CODE>,      * additional information is given in global variables<CODE>token_start</CODE>,      *<CODE>token_end</CODE>,<CODE>token_abbr</CODE>,<CODE>token_term</CODE>,      * and<CODE>token_case</CODE>; namely:<CODE>orig.substring(token_start,token_end)</CODE>      * is the thext of the token,<CODE>orig.substring(token_start,token_abbr)</CODE>      * is the token abbreviation,<CODE>token_term</CODE> contains token      * terminator (space or dash), and<CODE>token_case</CODE> is<CODE>true</CODE>,      * if token is upper-case and<CODE>false</CODE> if token is lower-case.      *       * @return<CODE>TOKEN_EOF</CODE> -- no more tokens,<CODE>TOKEN_COMMA</CODE> --      *         token is comma,<CODE>TOKEN_AND</CODE> -- token is the word      *         "and" (or "And", or "aND", etc.),<CODE>TOKEN_WORD</CODE> --      *         token is a word; additional information is given in global      *         variables<CODE>token_start</CODE>,<CODE>token_end</CODE>,      *<CODE>token_abbr</CODE>,<CODE>token_term</CODE>, and      *<CODE>token_case</CODE>.      */
DECL|method|getToken ()
specifier|private
name|int
name|getToken
parameter_list|()
block|{
name|token_start
operator|=
name|token_end
expr_stmt|;
while|while
condition|(
name|token_start
operator|<
name|orig
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|orig
operator|.
name|charAt
argument_list|(
name|token_start
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|==
literal|'~'
operator|||
name|c
operator|==
literal|'-'
operator|||
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|)
condition|)
break|break;
name|token_start
operator|++
expr_stmt|;
block|}
name|token_end
operator|=
name|token_start
expr_stmt|;
if|if
condition|(
name|token_start
operator|>=
name|orig
operator|.
name|length
argument_list|()
condition|)
return|return
name|TOKEN_EOF
return|;
if|if
condition|(
name|orig
operator|.
name|charAt
argument_list|(
name|token_start
argument_list|)
operator|==
literal|','
condition|)
block|{
name|token_end
operator|++
expr_stmt|;
return|return
name|TOKEN_COMMA
return|;
block|}
name|token_abbr
operator|=
operator|-
literal|1
expr_stmt|;
name|token_term
operator|=
literal|' '
expr_stmt|;
name|token_case
operator|=
literal|true
expr_stmt|;
name|int
name|braces_level
init|=
literal|0
decl_stmt|;
name|int
name|current_backslash
init|=
operator|-
literal|1
decl_stmt|;
name|boolean
name|first_letter_is_found
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|token_end
operator|<
name|orig
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|orig
operator|.
name|charAt
argument_list|(
name|token_end
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
name|braces_level
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|braces_level
operator|>
literal|0
condition|)
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|braces_level
operator|--
expr_stmt|;
if|if
condition|(
name|first_letter_is_found
operator|&&
name|token_abbr
operator|<
literal|0
operator|&&
name|braces_level
operator|==
literal|0
condition|)
name|token_abbr
operator|=
name|token_end
expr_stmt|;
if|if
condition|(
operator|!
name|first_letter_is_found
operator|&&
name|current_backslash
operator|<
literal|0
operator|&&
name|Character
operator|.
name|isLetter
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|braces_level
operator|==
literal|0
condition|)
name|token_case
operator|=
name|Character
operator|.
name|isUpperCase
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
comment|// If this is a particle in braces, always treat it as if it starts with
comment|// an upper case letter. Otherwise a name such as "{van den Bergen}, Hans"
comment|// will not yield a proper last name:
name|token_case
operator|=
literal|true
expr_stmt|;
name|first_letter_is_found
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|current_backslash
operator|>=
literal|0
operator|&&
operator|!
name|Character
operator|.
name|isLetter
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first_letter_is_found
condition|)
block|{
name|String
name|tex_cmd_name
init|=
name|orig
operator|.
name|substring
argument_list|(
name|current_backslash
operator|+
literal|1
argument_list|,
name|token_end
argument_list|)
decl_stmt|;
if|if
condition|(
name|tex_names
operator|.
name|contains
argument_list|(
name|tex_cmd_name
argument_list|)
condition|)
block|{
name|token_case
operator|=
name|Character
operator|.
name|isUpperCase
argument_list|(
name|tex_cmd_name
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|first_letter_is_found
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|current_backslash
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|current_backslash
operator|=
name|token_end
expr_stmt|;
if|if
condition|(
name|braces_level
operator|==
literal|0
condition|)
if|if
condition|(
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|'~'
operator|||
name|c
operator|==
literal|'-'
operator|||
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
comment|// Morten Alver 18 Apr 2006: Removed check for hyphen '-' above to
comment|// prevent
comment|// problems with names like Bailey-Jones getting broken up and
comment|// sorted wrong.
comment|// Aaron Chen 14 Sep 2008: Enable hyphen check for first names like Chang-Chin
name|token_end
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|token_abbr
operator|<
literal|0
condition|)
name|token_abbr
operator|=
name|token_end
expr_stmt|;
if|if
condition|(
name|token_end
operator|<
name|orig
operator|.
name|length
argument_list|()
operator|&&
name|orig
operator|.
name|charAt
argument_list|(
name|token_end
argument_list|)
operator|==
literal|'-'
condition|)
name|token_term
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|orig
operator|.
name|substring
argument_list|(
name|token_start
argument_list|,
name|token_end
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"and"
argument_list|)
condition|)
return|return
name|TOKEN_AND
return|;
else|else
return|return
name|TOKEN_WORD
return|;
block|}
comment|/**      * Returns the number of author names in this object.      *       * @return the number of author names in this object.      */
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|authors
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Returns the<CODE>Author</CODE> object for the i-th author.      *       * @param i      *            Index of the author (from 0 to<CODE>size()-1</CODE>).      * @return the<CODE>Author</CODE> object.      */
DECL|method|getAuthor (int i)
specifier|public
name|Author
name|getAuthor
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|authors
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/**      * Returns the list of authors in "natbib" format.      *<p>      *<ul>      *<li>"John Smith" -> "Smith"</li>      *<li>"John Smith and Black Brown, Peter" ==> "Smith and Black Brown"</li>      *<li>"John von Neumann and John Smith and Black Brown, Peter" ==> "von      * Neumann et al."</li>      *</ul>      *       * @return formatted list of authors.      */
DECL|method|getAuthorsNatbib ()
specifier|public
name|String
name|getAuthorsNatbib
parameter_list|()
block|{
comment|// Check if we've computed this before:
if|if
condition|(
name|authorsNatbib
operator|!=
literal|null
condition|)
return|return
name|authorsNatbib
return|;
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getLastOnly
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|1
argument_list|)
operator|.
name|getLastOnly
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" et al."
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsNatbib
operator|=
name|res
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsNatbib
return|;
block|}
comment|/**      * Returns the list of authors separated by commas with last name only; If      * the list consists of three or more authors, "and" is inserted before the      * last author's name.      *<p>      *       *<ul>      *<li> "John Smith" ==> "Smith"</li>      *<li> "John Smith and Black Brown, Peter" ==> "Smith and Black Brown"</li>      *<li> "John von Neumann and John Smith and Black Brown, Peter" ==> "von      * Neumann, Smith and Black Brown".</li>      *</ul>      *       * @param oxfordComma      *            Whether to put a comma before the and at the end.      *       * @see<a href="http://en.wikipedia.org/wiki/Serial_comma">serial comma for an detailed explaination about the Oxford comma.</a>      *       * @return formatted list of authors.      */
DECL|method|getAuthorsLastOnly (boolean oxfordComma)
specifier|public
name|String
name|getAuthorsLastOnly
parameter_list|(
name|boolean
name|oxfordComma
parameter_list|)
block|{
name|int
name|abbrInt
init|=
operator|(
name|oxfordComma
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
comment|// Check if we've computed this before:
if|if
condition|(
name|authorsLastOnly
index|[
name|abbrInt
index|]
operator|!=
literal|null
condition|)
return|return
name|authorsLastOnly
index|[
name|abbrInt
index|]
return|;
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getLastOnly
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getLastOnly
argument_list|()
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|size
argument_list|()
operator|>
literal|2
operator|&&
name|oxfordComma
condition|)
name|res
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getLastOnly
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsLastOnly
index|[
name|abbrInt
index|]
operator|=
name|res
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsLastOnly
index|[
name|abbrInt
index|]
return|;
block|}
comment|/**      * Returns the list of authors separated by commas with first names after      * last name; first names are abbreviated or not depending on parameter. If      * the list consists of three or more authors, "and" is inserted before the      * last author's name.      *<p>      *       *<ul>      *<li> "John Smith" ==> "Smith, John" or "Smith, J."</li>      *<li> "John Smith and Black Brown, Peter" ==> "Smith, John and Black      * Brown, Peter" or "Smith, J. and Black Brown, P."</li>      *<li> "John von Neumann and John Smith and Black Brown, Peter" ==> "von      * Neumann, John, Smith, John and Black Brown, Peter" or "von Neumann, J.,      * Smith, J. and Black Brown, P.".</li>      *</ul>      *       * @param abbreviate      *            whether to abbreivate first names.      *       * @param oxfordComma      *            Whether to put a comma before the and at the end.      *       * @see<a href="http://en.wikipedia.org/wiki/Serial_comma">serial comma for an detailed explaination about the Oxford comma.</a>      *       * @return formatted list of authors.      */
DECL|method|getAuthorsLastFirst (boolean abbreviate, boolean oxfordComma)
specifier|public
name|String
name|getAuthorsLastFirst
parameter_list|(
name|boolean
name|abbreviate
parameter_list|,
name|boolean
name|oxfordComma
parameter_list|)
block|{
name|int
name|abbrInt
init|=
operator|(
name|abbreviate
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
name|abbrInt
operator|+=
operator|(
name|oxfordComma
condition|?
literal|0
else|:
literal|2
operator|)
expr_stmt|;
comment|// Check if we've computed this before:
if|if
condition|(
name|authorsLastFirst
index|[
name|abbrInt
index|]
operator|!=
literal|null
condition|)
return|return
name|authorsLastFirst
index|[
name|abbrInt
index|]
return|;
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getLastFirst
argument_list|(
name|abbreviate
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getLastFirst
argument_list|(
name|abbreviate
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|size
argument_list|()
operator|>
literal|2
operator|&&
name|oxfordComma
condition|)
name|res
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getLastFirst
argument_list|(
name|abbreviate
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsLastFirst
index|[
name|abbrInt
index|]
operator|=
name|res
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsLastFirst
index|[
name|abbrInt
index|]
return|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getAuthorsLastFirstAnds
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|/**      * Returns the list of authors separated by "and"s with first names after      * last name; first names are not abbreviated.      *<p>      *<ul>      *<li>"John Smith" ==> "Smith, John"</li>      *<li>"John Smith and Black Brown, Peter" ==> "Smith, John and Black      * Brown, Peter"</li>      *<li>"John von Neumann and John Smith and Black Brown, Peter" ==> "von      * Neumann, John and Smith, John and Black Brown, Peter".</li>      *</ul>      *       * @return formatted list of authors.      */
DECL|method|getAuthorsLastFirstAnds (boolean abbreviate)
specifier|public
name|String
name|getAuthorsLastFirstAnds
parameter_list|(
name|boolean
name|abbreviate
parameter_list|)
block|{
name|int
name|abbrInt
init|=
operator|(
name|abbreviate
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
comment|// Check if we've computed this before:
if|if
condition|(
name|authorLastFirstAnds
index|[
name|abbrInt
index|]
operator|!=
literal|null
condition|)
return|return
name|authorLastFirstAnds
index|[
name|abbrInt
index|]
return|;
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getLastFirst
argument_list|(
name|abbreviate
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getLastFirst
argument_list|(
name|abbreviate
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|authorLastFirstAnds
index|[
name|abbrInt
index|]
operator|=
name|res
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorLastFirstAnds
index|[
name|abbrInt
index|]
return|;
block|}
DECL|method|getAuthorsLastFirstFirstLastAnds (boolean abbreviate)
specifier|public
name|String
name|getAuthorsLastFirstFirstLastAnds
parameter_list|(
name|boolean
name|abbreviate
parameter_list|)
block|{
name|int
name|abbrInt
init|=
operator|(
name|abbreviate
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
comment|// Check if we've computed this before:
if|if
condition|(
name|authorsLastFirstFirstLast
index|[
name|abbrInt
index|]
operator|!=
literal|null
condition|)
return|return
name|authorsLastFirstFirstLast
index|[
name|abbrInt
index|]
return|;
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getLastFirst
argument_list|(
name|abbreviate
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getFirstLast
argument_list|(
name|abbreviate
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsLastFirstFirstLast
index|[
name|abbrInt
index|]
operator|=
name|res
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsLastFirstFirstLast
index|[
name|abbrInt
index|]
return|;
block|}
comment|/**      * Returns the list of authors separated by commas with first names before      * last name; first names are abbreviated or not depending on parameter. If      * the list consists of three or more authors, "and" is inserted before the      * last author's name.      *<p>      *<ul>      *<li>"John Smith" ==> "John Smith" or "J. Smith"</li>      *<li>"John Smith and Black Brown, Peter" ==> "John Smith and Peter Black      * Brown" or "J. Smith and P. Black Brown"</li>      *<li> "John von Neumann and John Smith and Black Brown, Peter" ==> "John      * von Neumann, John Smith and Peter Black Brown" or "J. von Neumann, J.      * Smith and P. Black Brown"</li>      *</ul>      *       * @param abbr      *            whether to abbreivate first names.      *       * @param oxfordComma      *            Whether to put a comma before the and at the end.      *       * @see<a href="http://en.wikipedia.org/wiki/Serial_comma">serial comma for an detailed explaination about the Oxford comma.</a>      *       * @return formatted list of authors.      */
DECL|method|getAuthorsFirstFirst (boolean abbr, boolean oxfordComma)
specifier|public
name|String
name|getAuthorsFirstFirst
parameter_list|(
name|boolean
name|abbr
parameter_list|,
name|boolean
name|oxfordComma
parameter_list|)
block|{
name|int
name|abbrInt
init|=
operator|(
name|abbr
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
name|abbrInt
operator|+=
operator|(
name|oxfordComma
condition|?
literal|0
else|:
literal|2
operator|)
expr_stmt|;
comment|// Check if we've computed this before:
if|if
condition|(
name|authorsFirstFirst
index|[
name|abbrInt
index|]
operator|!=
literal|null
condition|)
return|return
name|authorsFirstFirst
index|[
name|abbrInt
index|]
return|;
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getFirstLast
argument_list|(
name|abbr
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getFirstLast
argument_list|(
name|abbr
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|size
argument_list|()
operator|>
literal|2
operator|&&
name|oxfordComma
condition|)
name|res
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getFirstLast
argument_list|(
name|abbr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsFirstFirst
index|[
name|abbrInt
index|]
operator|=
name|res
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsFirstFirst
index|[
name|abbrInt
index|]
return|;
block|}
comment|/**      * Compare this object with the given one.       *       * Will return true iff the other object is an Author and all fields are identical on a string comparison.      */
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|AuthorList
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|AuthorList
name|a
init|=
operator|(
name|AuthorList
operator|)
name|o
decl_stmt|;
return|return
name|this
operator|.
name|authors
operator|.
name|equals
argument_list|(
name|a
operator|.
name|authors
argument_list|)
return|;
block|}
comment|/**      * Returns the list of authors separated by "and"s with first names before      * last name; first names are not abbreviated.      *<p>      *<ul>      *<li>"John Smith" ==> "John Smith"</li>      *<li>"John Smith and Black Brown, Peter" ==> "John Smith and Peter Black      * Brown"</li>      *<li>"John von Neumann and John Smith and Black Brown, Peter" ==> "John      * von Neumann and John Smith and Peter Black Brown"</li>      *</li>      *       * @return formatted list of authors.      */
DECL|method|getAuthorsFirstFirstAnds ()
specifier|public
name|String
name|getAuthorsFirstFirstAnds
parameter_list|()
block|{
comment|// Check if we've computed this before:
if|if
condition|(
name|authorsFirstFirstAnds
operator|!=
literal|null
condition|)
return|return
name|authorsFirstFirstAnds
return|;
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getFirstLast
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getFirstLast
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsFirstFirstAnds
operator|=
name|res
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsFirstFirstAnds
return|;
block|}
comment|/**      * Returns the list of authors in a form suitable for alphabetization. This      * means that last names come first, never preceded by "von" particles, and      * that any braces are removed. First names are abbreviated so the same name      * is treated similarly if abbreviated in one case and not in another. This      * form is not intended to be suitable for presentation, only for sorting.      *       *<p>      *<ul>      *<li>"John Smith" ==> "Smith, J.";</li>      *       *       * @return formatted list of authors      */
DECL|method|getAuthorsForAlphabetization ()
specifier|public
name|String
name|getAuthorsForAlphabetization
parameter_list|()
block|{
if|if
condition|(
name|authorsAlph
operator|!=
literal|null
condition|)
return|return
name|authorsAlph
return|;
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getNameForAlphabetization
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getNameForAlphabetization
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsAlph
operator|=
name|res
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsAlph
return|;
block|}
comment|/**      * This is an immutable class that keeps information regarding single      * author. It is just a container for the information, with very simple      * methods to access it.      *<p>      * Current usage: only methods<code>getLastOnly</code>,      *<code>getFirstLast</code>, and<code>getLastFirst</code> are used;      * all other methods are provided for completeness.      */
DECL|class|Author
specifier|public
specifier|static
class|class
name|Author
block|{
DECL|field|first_part
specifier|private
specifier|final
name|String
name|first_part
decl_stmt|;
DECL|field|first_abbr
specifier|private
specifier|final
name|String
name|first_abbr
decl_stmt|;
DECL|field|von_part
specifier|private
specifier|final
name|String
name|von_part
decl_stmt|;
DECL|field|last_part
specifier|private
specifier|final
name|String
name|last_part
decl_stmt|;
DECL|field|jr_part
specifier|private
specifier|final
name|String
name|jr_part
decl_stmt|;
comment|/**          * Compare this object with the given one.           *           * Will return true iff the other object is an Author and all fields are identical on a string comparison.          */
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Author
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Author
name|a
init|=
operator|(
name|Author
operator|)
name|o
decl_stmt|;
return|return
name|Util
operator|.
name|equals
argument_list|(
name|first_part
argument_list|,
name|a
operator|.
name|first_part
argument_list|)
operator|&&
name|Util
operator|.
name|equals
argument_list|(
name|first_abbr
argument_list|,
name|a
operator|.
name|first_abbr
argument_list|)
operator|&&
name|Util
operator|.
name|equals
argument_list|(
name|von_part
argument_list|,
name|a
operator|.
name|von_part
argument_list|)
operator|&&
name|Util
operator|.
name|equals
argument_list|(
name|last_part
argument_list|,
name|a
operator|.
name|last_part
argument_list|)
operator|&&
name|Util
operator|.
name|equals
argument_list|(
name|jr_part
argument_list|,
name|a
operator|.
name|jr_part
argument_list|)
return|;
block|}
comment|/**          * Creates the Author object. If any part of the name is absent,<CODE>null</CODE>          * must be passed; otherwise other methods may return erroneous results.          *           * @param first          *            the first name of the author (may consist of several          *            tokens, like "Charles Louis Xavier Joseph" in "Charles          *            Louis Xavier Joseph de la Vall{\'e}e Poussin")          * @param firstabbr          *            the abbreviated first name of the author (may consist of          *            several tokens, like "C. L. X. J." in "Charles Louis          *            Xavier Joseph de la Vall{\'e}e Poussin"). It is a          *            responsibility of the caller to create a reasonable          *            abbreviation of the first name.          * @param von          *            the von part of the author's name (may consist of several          *            tokens, like "de la" in "Charles Louis Xavier Joseph de la          *            Vall{\'e}e Poussin")          * @param last          *            the lats name of the author (may consist of several          *            tokens, like "Vall{\'e}e Poussin" in "Charles Louis Xavier          *            Joseph de la Vall{\'e}e Poussin")          * @param jr          *            the junior part of the author's name (may consist of          *            several tokens, like "Jr. III" in "Smith, Jr. III, John")          */
DECL|method|Author (String first, String firstabbr, String von, String last, String jr)
specifier|public
name|Author
parameter_list|(
name|String
name|first
parameter_list|,
name|String
name|firstabbr
parameter_list|,
name|String
name|von
parameter_list|,
name|String
name|last
parameter_list|,
name|String
name|jr
parameter_list|)
block|{
name|first_part
operator|=
name|removeStartAndEndBraces
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|first_abbr
operator|=
name|removeStartAndEndBraces
argument_list|(
name|firstabbr
argument_list|)
expr_stmt|;
name|von_part
operator|=
name|removeStartAndEndBraces
argument_list|(
name|von
argument_list|)
expr_stmt|;
name|last_part
operator|=
name|removeStartAndEndBraces
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|jr_part
operator|=
name|removeStartAndEndBraces
argument_list|(
name|jr
argument_list|)
expr_stmt|;
block|}
comment|/**          *           * @return true if the brackets in s are properly paired          */
DECL|method|properBrackets (String s)
specifier|private
name|boolean
name|properBrackets
parameter_list|(
name|String
name|s
parameter_list|)
block|{
comment|// nested construct is there, check for "proper" nesting
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|level
init|=
literal|0
decl_stmt|;
name|loop
label|:
while|while
condition|(
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'{'
case|:
name|level
operator|++
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|level
operator|--
expr_stmt|;
if|if
condition|(
name|level
operator|==
operator|-
literal|1
condition|)
block|{
comment|// the improper nesting
break|break
name|loop
break|;
block|}
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|level
operator|==
literal|0
operator|)
return|;
block|}
comment|/**          * Removes start and end brace at a string          *           * E.g.,           *   * {Vall{\'e}e Poussin} -> Vall{\'e}e Poussin          *   * {Vall{\'e}e} {Poussin} -> Vall{\'e}e Poussin          *   * Vall{\'e}e Poussin -> Vall{\'e}e Poussin          */
DECL|method|removeStartAndEndBraces (String name)
specifier|private
name|String
name|removeStartAndEndBraces
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
operator|!
name|name
operator|.
name|contains
argument_list|(
literal|"{"
argument_list|)
condition|)
return|return
name|name
return|;
name|String
index|[]
name|split
init|=
name|name
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|split
control|)
block|{
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
literal|"{"
argument_list|)
operator|&&
name|s
operator|.
name|endsWith
argument_list|(
literal|"}"
argument_list|)
condition|)
block|{
comment|// quick solution (which we don't do: just remove first "{" and last "}"
comment|// however, it might be that s is like {A}bbb{c}, where braces may not be removed
comment|// inner
name|String
name|inner
init|=
name|s
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|inner
operator|.
name|contains
argument_list|(
literal|"}"
argument_list|)
condition|)
block|{
if|if
condition|(
name|properBrackets
argument_list|(
name|inner
argument_list|)
condition|)
block|{
name|s
operator|=
name|inner
expr_stmt|;
block|}
else|else
block|{
comment|// no proper brackets if inner string: s is left untouched
block|}
block|}
else|else
block|{
comment|//  no inner curly brackets found, no check needed, inner can just be used as s
name|s
operator|=
name|inner
expr_stmt|;
block|}
block|}
block|}
name|b
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
comment|// delete last
name|b
operator|.
name|deleteCharAt
argument_list|(
name|b
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// now, all inner words are cleared
comment|// case {word word word} remains
comment|// as above, we have to be aware of {w}ord word wor{d} and {{w}ord word word}
name|name
operator|=
name|b
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"{"
argument_list|)
operator|&&
name|name
operator|.
name|endsWith
argument_list|(
literal|"}"
argument_list|)
condition|)
block|{
name|String
name|inner
init|=
name|name
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|name
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|properBrackets
argument_list|(
name|inner
argument_list|)
condition|)
block|{
return|return
name|inner
return|;
block|}
else|else
block|{
return|return
name|name
return|;
block|}
block|}
else|else
block|{
return|return
name|name
return|;
block|}
block|}
comment|/**          * Returns the first name of the author stored in this object ("First").          *           * @return first name of the author (may consist of several tokens)          */
DECL|method|getFirst ()
specifier|public
name|String
name|getFirst
parameter_list|()
block|{
return|return
name|first_part
return|;
block|}
comment|/**          * Returns the abbreviated first name of the author stored in this          * object ("F.").          *           * @return abbreviated first name of the author (may consist of several          *         tokens)          */
DECL|method|getFirstAbbr ()
specifier|public
name|String
name|getFirstAbbr
parameter_list|()
block|{
return|return
name|first_abbr
return|;
block|}
comment|/**          * Returns the von part of the author's name stored in this object          * ("von").          *           * @return von part of the author's name (may consist of several tokens)          */
DECL|method|getVon ()
specifier|public
name|String
name|getVon
parameter_list|()
block|{
return|return
name|von_part
return|;
block|}
comment|/**          * Returns the last name of the author stored in this object ("Last").          *           * @return last name of the author (may consist of several tokens)          */
DECL|method|getLast ()
specifier|public
name|String
name|getLast
parameter_list|()
block|{
return|return
name|last_part
return|;
block|}
comment|/**          * Returns the junior part of the author's name stored in this object          * ("Jr").          *           * @return junior part of the author's name (may consist of several          *         tokens) or null if the author does not have a Jr. Part          */
DECL|method|getJr ()
specifier|public
name|String
name|getJr
parameter_list|()
block|{
return|return
name|jr_part
return|;
block|}
comment|/**          * Returns von-part followed by last name ("von Last"). If both fields          * were specified as<CODE>null</CODE>, the empty string<CODE>""</CODE>          * is returned.          *           * @return 'von Last'          */
DECL|method|getLastOnly ()
specifier|public
name|String
name|getLastOnly
parameter_list|()
block|{
if|if
condition|(
name|von_part
operator|==
literal|null
condition|)
block|{
return|return
operator|(
name|last_part
operator|==
literal|null
condition|?
literal|""
else|:
name|last_part
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|last_part
operator|==
literal|null
condition|?
name|von_part
else|:
name|von_part
operator|+
literal|" "
operator|+
name|last_part
operator|)
return|;
block|}
block|}
comment|/**          * Returns the author's name in form 'von Last, Jr., First' with the          * first name full or abbreviated depending on parameter.          *           * @param abbr          *<CODE>true</CODE> - abbreviate first name,<CODE>false</CODE> -          *            do not abbreviate          * @return 'von Last, Jr., First' (if<CODE>abbr==false</CODE>) or          *         'von Last, Jr., F.' (if<CODE>abbr==true</CODE>)          */
DECL|method|getLastFirst (boolean abbr)
specifier|public
name|String
name|getLastFirst
parameter_list|(
name|boolean
name|abbr
parameter_list|)
block|{
name|String
name|res
init|=
name|getLastOnly
argument_list|()
decl_stmt|;
if|if
condition|(
name|jr_part
operator|!=
literal|null
condition|)
name|res
operator|+=
literal|", "
operator|+
name|jr_part
expr_stmt|;
if|if
condition|(
name|abbr
condition|)
block|{
if|if
condition|(
name|first_abbr
operator|!=
literal|null
condition|)
name|res
operator|+=
literal|", "
operator|+
name|first_abbr
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|first_part
operator|!=
literal|null
condition|)
name|res
operator|+=
literal|", "
operator|+
name|first_part
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
comment|/**          * Returns the author's name in form 'First von Last, Jr.' with the          * first name full or abbreviated depending on parameter.          *           * @param abbr          *<CODE>true</CODE> - abbreviate first name,<CODE>false</CODE> -          *            do not abbreviate          * @return 'First von Last, Jr.' (if<CODE>abbr==false</CODE>) or 'F.          *         von Last, Jr.' (if<CODE>abbr==true</CODE>)          */
DECL|method|getFirstLast (boolean abbr)
specifier|public
name|String
name|getFirstLast
parameter_list|(
name|boolean
name|abbr
parameter_list|)
block|{
name|String
name|res
init|=
name|getLastOnly
argument_list|()
decl_stmt|;
if|if
condition|(
name|abbr
condition|)
block|{
name|res
operator|=
operator|(
name|first_abbr
operator|==
literal|null
condition|?
literal|""
else|:
name|first_abbr
operator|+
literal|" "
operator|)
operator|+
name|res
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
operator|(
name|first_part
operator|==
literal|null
condition|?
literal|""
else|:
name|first_part
operator|+
literal|" "
operator|)
operator|+
name|res
expr_stmt|;
block|}
if|if
condition|(
name|jr_part
operator|!=
literal|null
condition|)
name|res
operator|+=
literal|", "
operator|+
name|jr_part
expr_stmt|;
return|return
name|res
return|;
block|}
comment|/**          * Returns the name as "Last, Jr, F." omitting the von-part and removing          * starting braces.          *           * @return "Last, Jr, F." as described above or "" if all these parts          *         are empty.          */
DECL|method|getNameForAlphabetization ()
specifier|public
name|String
name|getNameForAlphabetization
parameter_list|()
block|{
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|last_part
operator|!=
literal|null
condition|)
name|res
operator|.
name|append
argument_list|(
name|last_part
argument_list|)
expr_stmt|;
if|if
condition|(
name|jr_part
operator|!=
literal|null
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|jr_part
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|first_abbr
operator|!=
literal|null
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|first_abbr
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|res
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|res
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'{'
operator|)
condition|)
name|res
operator|.
name|deleteCharAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|res
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|// end Author
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
comment|//String s = "Ford, Jr., Henry and Guy L. {Steele Jr.} and Olaf Nilsen, Jr.";
name|String
name|s
init|=
literal|"Olaf von Nilsen, Jr."
decl_stmt|;
name|AuthorList
name|al
init|=
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|s
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|al
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Author
name|a
init|=
name|al
operator|.
name|getAuthor
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|": first = '"
operator|+
name|a
operator|.
name|getFirst
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|": last = '"
operator|+
name|a
operator|.
name|getLast
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|": jr = '"
operator|+
name|a
operator|.
name|getJr
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|": von = '"
operator|+
name|a
operator|.
name|getVon
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
operator|(
operator|new
name|CreateDocBookAuthors
argument_list|()
operator|)
operator|.
name|format
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|// end AuthorList
end_comment

end_unit

