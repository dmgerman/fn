begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003-2011 JabRef contributors.  This program is free software; you can redistribute it and/or modify  it under the terms of the GNU General Public License as published by  the Free Software Foundation; either version 2 of the License, or  (at your option) any later version.   This program is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License for more details.   You should have received a copy of the GNU General Public License along  with this program; if not, write to the Free Software Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.  */
end_comment

begin_package
DECL|package|net.sf.jabref.export
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|GUIGlobals
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|config
operator|.
name|SaveOrderConfig
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|l10n
operator|.
name|Localization
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|*
import|;
end_import

begin_class
DECL|class|FileActions
specifier|public
class|class
name|FileActions
block|{
DECL|enum|DatabaseSaveType
specifier|public
enum|enum
name|DatabaseSaveType
block|{
DECL|enumConstant|DEFAULT
DECL|enumConstant|PLAIN_BIBTEX
name|DEFAULT
block|,
name|PLAIN_BIBTEX
block|}
DECL|field|refPat
specifier|private
specifier|static
specifier|final
name|Pattern
name|refPat
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"(#[A-Za-z]+#)"
argument_list|)
decl_stmt|;
comment|// Used to detect string references in strings
DECL|field|previousStringType
specifier|private
specifier|static
name|BibtexString
operator|.
name|Type
name|previousStringType
decl_stmt|;
DECL|method|writePreamble (Writer fw, String preamble)
specifier|private
specifier|static
name|void
name|writePreamble
parameter_list|(
name|Writer
name|fw
parameter_list|,
name|String
name|preamble
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|preamble
operator|!=
literal|null
condition|)
block|{
name|fw
operator|.
name|write
argument_list|(
literal|"@PREAMBLE{"
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|preamble
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|'}'
operator|+
name|Globals
operator|.
name|NEWLINE
operator|+
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Write all strings in alphabetical order, modified to produce a safe (for      * BibTeX) order of the strings if they reference each other.      *      * @param fw The Writer to send the output to.      * @param database The database whose strings we should write.      * @throws IOException If anthing goes wrong in writing.      */
DECL|method|writeStrings (Writer fw, BibtexDatabase database)
specifier|private
specifier|static
name|void
name|writeStrings
parameter_list|(
name|Writer
name|fw
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
throws|throws
name|IOException
block|{
name|FileActions
operator|.
name|previousStringType
operator|=
name|BibtexString
operator|.
name|Type
operator|.
name|AUTHOR
expr_stmt|;
name|List
argument_list|<
name|BibtexString
argument_list|>
name|strings
init|=
operator|new
name|ArrayList
argument_list|<
name|BibtexString
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|database
operator|.
name|getStringKeySet
argument_list|()
control|)
block|{
name|strings
operator|.
name|add
argument_list|(
name|database
operator|.
name|getString
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|strings
argument_list|,
operator|new
name|BibtexStringComparator
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// First, make a Map of all entries:
name|HashMap
argument_list|<
name|String
argument_list|,
name|BibtexString
argument_list|>
name|remaining
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BibtexString
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|maxKeyLength
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BibtexString
name|string
range|:
name|strings
control|)
block|{
name|remaining
operator|.
name|put
argument_list|(
name|string
operator|.
name|getName
argument_list|()
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|maxKeyLength
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxKeyLength
argument_list|,
name|string
operator|.
name|getName
argument_list|()
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BibtexString
operator|.
name|Type
name|t
range|:
name|BibtexString
operator|.
name|Type
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|BibtexString
name|bs
range|:
name|strings
control|)
block|{
if|if
condition|(
name|remaining
operator|.
name|containsKey
argument_list|(
name|bs
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|bs
operator|.
name|getType
argument_list|()
operator|==
name|t
condition|)
block|{
name|FileActions
operator|.
name|writeString
argument_list|(
name|fw
argument_list|,
name|bs
argument_list|,
name|remaining
argument_list|,
name|maxKeyLength
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fw
operator|.
name|write
argument_list|(
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
DECL|method|writeString (Writer fw, BibtexString bs, HashMap<String, BibtexString> remaining, int maxKeyLength)
specifier|private
specifier|static
name|void
name|writeString
parameter_list|(
name|Writer
name|fw
parameter_list|,
name|BibtexString
name|bs
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|BibtexString
argument_list|>
name|remaining
parameter_list|,
name|int
name|maxKeyLength
parameter_list|)
throws|throws
name|IOException
block|{
comment|// First remove this from the "remaining" list so it can't cause problem with circular refs:
name|remaining
operator|.
name|remove
argument_list|(
name|bs
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Then we go through the string looking for references to other strings. If we find references
comment|// to strings that we will write, but still haven't, we write those before proceeding. This ensures
comment|// that the string order will be acceptable for BibTeX.
name|String
name|content
init|=
name|bs
operator|.
name|getContent
argument_list|()
decl_stmt|;
name|Matcher
name|m
decl_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|FileActions
operator|.
name|refPat
operator|.
name|matcher
argument_list|(
name|content
argument_list|)
operator|)
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|foundLabel
init|=
name|m
operator|.
name|group
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
name|restIndex
init|=
name|content
operator|.
name|indexOf
argument_list|(
name|foundLabel
argument_list|)
operator|+
name|foundLabel
operator|.
name|length
argument_list|()
decl_stmt|;
name|content
operator|=
name|content
operator|.
name|substring
argument_list|(
name|restIndex
argument_list|)
expr_stmt|;
name|Object
name|referred
init|=
name|remaining
operator|.
name|get
argument_list|(
name|foundLabel
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|foundLabel
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|// If the label we found exists as a key in the "remaining" Map, we go on and write it now:
if|if
condition|(
name|referred
operator|!=
literal|null
condition|)
block|{
name|FileActions
operator|.
name|writeString
argument_list|(
name|fw
argument_list|,
operator|(
name|BibtexString
operator|)
name|referred
argument_list|,
name|remaining
argument_list|,
name|maxKeyLength
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|FileActions
operator|.
name|previousStringType
operator|!=
name|bs
operator|.
name|getType
argument_list|()
condition|)
block|{
name|fw
operator|.
name|write
argument_list|(
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
name|FileActions
operator|.
name|previousStringType
operator|=
name|bs
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
name|String
name|suffix
init|=
literal|""
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|maxKeyLength
operator|-
name|bs
operator|.
name|getName
argument_list|()
operator|.
name|length
argument_list|()
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|suffix
operator|+=
literal|" "
expr_stmt|;
block|}
name|fw
operator|.
name|write
argument_list|(
literal|"@String { "
operator|+
name|bs
operator|.
name|getName
argument_list|()
operator|+
name|suffix
operator|+
literal|" = "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bs
operator|.
name|getContent
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|String
name|formatted
init|=
operator|new
name|LatexFieldFormatter
argument_list|()
operator|.
name|format
argument_list|(
name|bs
operator|.
name|getContent
argument_list|()
argument_list|,
name|Globals
operator|.
name|BIBTEX_STRING
argument_list|)
decl_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|formatted
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"The # character is not allowed in BibTeX strings unless escaped as in '\\#'."
argument_list|)
operator|+
literal|'\n'
operator|+
name|Localization
operator|.
name|lang
argument_list|(
literal|"Before saving, please edit any strings containing the # character."
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|fw
operator|.
name|write
argument_list|(
literal|"{}"
argument_list|)
expr_stmt|;
block|}
name|fw
operator|.
name|write
argument_list|(
literal|" }"
operator|+
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
comment|// + Globals.NEWLINE);
block|}
comment|/**      * Writes the JabRef signature and the encoding.      *      * @param encoding String the name of the encoding, which is part of the      * header.      */
DECL|method|writeBibFileHeader (Writer out, String encoding)
specifier|private
specifier|static
name|void
name|writeBibFileHeader
parameter_list|(
name|Writer
name|out
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|write
argument_list|(
literal|"% "
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|GUIGlobals
operator|.
name|SIGNATURE
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
literal|' '
operator|+
name|Globals
operator|.
name|BUILD_INFO
operator|.
name|getVersion
argument_list|()
operator|+
literal|'.'
operator|+
name|Globals
operator|.
name|NEWLINE
operator|+
literal|"% "
operator|+
name|GUIGlobals
operator|.
name|encPrefix
operator|+
name|encoding
operator|+
name|Globals
operator|.
name|NEWLINE
operator|+
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Saves the database to file. Two boolean values indicate whether only      * entries with a nonzero Globals.SEARCH value and only entries with a      * nonzero Globals.GROUPSEARCH value should be saved. This can be used to      * let the user save only the results of a search. False and false means all      * entries are saved.      */
DECL|method|saveDatabase (BibtexDatabase database, MetaData metaData, File file, JabRefPreferences prefs, boolean checkSearch, boolean checkGroup, String encoding, boolean suppressBackup)
specifier|public
specifier|static
name|SaveSession
name|saveDatabase
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|MetaData
name|metaData
parameter_list|,
name|File
name|file
parameter_list|,
name|JabRefPreferences
name|prefs
parameter_list|,
name|boolean
name|checkSearch
parameter_list|,
name|boolean
name|checkGroup
parameter_list|,
name|String
name|encoding
parameter_list|,
name|boolean
name|suppressBackup
parameter_list|)
throws|throws
name|SaveException
block|{
name|TreeMap
argument_list|<
name|String
argument_list|,
name|BibtexEntryType
argument_list|>
name|types
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|BibtexEntryType
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|backup
init|=
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|BACKUP
argument_list|)
decl_stmt|;
if|if
condition|(
name|suppressBackup
condition|)
block|{
name|backup
operator|=
literal|false
expr_stmt|;
block|}
name|SaveSession
name|session
decl_stmt|;
name|BibtexEntry
name|exceptionCause
init|=
literal|null
decl_stmt|;
try|try
block|{
name|session
operator|=
operator|new
name|SaveSession
argument_list|(
name|file
argument_list|,
name|encoding
argument_list|,
name|backup
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
name|encoding
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error from encoding: '"
operator|+
name|encoding
operator|+
literal|"' Len: "
operator|+
name|encoding
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// we must catch all exceptions to be able notify users that
comment|// saving failed, no matter what the reason was
comment|// (and they won't just quit JabRef thinking
comment|// everything worked and loosing data)
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|SaveException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
try|try
block|{
comment|// Get our data stream. This stream writes only to a temporary file,
comment|// until committed.
name|VerifyingWriter
name|fw
init|=
name|session
operator|.
name|getWriter
argument_list|()
decl_stmt|;
comment|// Write signature.
name|FileActions
operator|.
name|writeBibFileHeader
argument_list|(
name|fw
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
comment|// Write preamble if there is one.
name|FileActions
operator|.
name|writePreamble
argument_list|(
name|fw
argument_list|,
name|database
operator|.
name|getPreamble
argument_list|()
argument_list|)
expr_stmt|;
comment|// Write strings if there are any.
name|FileActions
operator|.
name|writeStrings
argument_list|(
name|fw
argument_list|,
name|database
argument_list|)
expr_stmt|;
comment|// Write database entries. Take care, using CrossRefEntry-
comment|// Comparator, that referred entries occur after referring
comment|// ones. Apart from crossref requirements, entries will be
comment|// sorted as they appear on the screen.
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|sorter
init|=
name|FileActions
operator|.
name|getSortedEntries
argument_list|(
name|database
argument_list|,
name|metaData
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|BibtexEntryWriter
name|bibtexEntryWriter
init|=
operator|new
name|BibtexEntryWriter
argument_list|(
operator|new
name|LatexFieldFormatter
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|be
range|:
name|sorter
control|)
block|{
name|exceptionCause
operator|=
name|be
expr_stmt|;
comment|// Check if we must write the type definition for this
comment|// entry, as well. Our criterion is that all non-standard
comment|// types (*not* customized standard types) must be written.
name|BibtexEntryType
name|tp
init|=
name|be
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|BibtexEntryType
operator|.
name|getStandardType
argument_list|(
name|tp
operator|.
name|getName
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
name|types
operator|.
name|put
argument_list|(
name|tp
operator|.
name|getName
argument_list|()
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
comment|// Check if the entry should be written.
name|boolean
name|write
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|checkSearch
operator|&&
operator|!
name|FileActions
operator|.
name|nonZeroField
argument_list|(
name|be
argument_list|,
name|BibtexFields
operator|.
name|SEARCH
argument_list|)
condition|)
block|{
name|write
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|checkGroup
operator|&&
operator|!
name|FileActions
operator|.
name|nonZeroField
argument_list|(
name|be
argument_list|,
name|BibtexFields
operator|.
name|GROUPSEARCH
argument_list|)
condition|)
block|{
name|write
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|write
condition|)
block|{
name|bibtexEntryWriter
operator|.
name|write
argument_list|(
name|be
argument_list|,
name|fw
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Write meta data.
if|if
condition|(
name|metaData
operator|!=
literal|null
condition|)
block|{
name|metaData
operator|.
name|writeMetaData
argument_list|(
name|fw
argument_list|)
expr_stmt|;
block|}
comment|// Write type definitions, if any:
if|if
condition|(
operator|!
name|types
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|BibtexEntryType
argument_list|>
name|stringBibtexEntryTypeEntry
range|:
name|types
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|BibtexEntryType
name|type
init|=
name|stringBibtexEntryTypeEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|instanceof
name|CustomEntryType
condition|)
block|{
name|CustomEntryType
name|tp
init|=
operator|(
name|CustomEntryType
operator|)
name|type
decl_stmt|;
name|tp
operator|.
name|save
argument_list|(
name|fw
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fw
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|session
operator|.
name|cancel
argument_list|()
expr_stmt|;
comment|// repairAfterError(file, backup, INIT_OK);
throw|throw
operator|new
name|SaveException
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|exceptionCause
argument_list|)
throw|;
block|}
return|return
name|session
return|;
block|}
DECL|class|SaveSettings
specifier|private
specifier|static
class|class
name|SaveSettings
block|{
DECL|field|pri
specifier|public
specifier|final
name|String
name|pri
decl_stmt|;
DECL|field|sec
specifier|public
specifier|final
name|String
name|sec
decl_stmt|;
DECL|field|ter
specifier|public
specifier|final
name|String
name|ter
decl_stmt|;
DECL|field|priD
specifier|public
specifier|final
name|boolean
name|priD
decl_stmt|;
DECL|field|secD
specifier|public
specifier|final
name|boolean
name|secD
decl_stmt|;
DECL|field|terD
specifier|public
specifier|final
name|boolean
name|terD
decl_stmt|;
DECL|method|SaveSettings (boolean isSaveOperation, MetaData metaData)
specifier|public
name|SaveSettings
parameter_list|(
name|boolean
name|isSaveOperation
parameter_list|,
name|MetaData
name|metaData
parameter_list|)
block|{
comment|/* three options:              * 1. original order (saveInOriginalOrder) -- not hit here as SaveSettings is not called in that case              * 2. current table sort order              * 3. ordered by specified order              */
name|Vector
argument_list|<
name|String
argument_list|>
name|storedSaveOrderConfig
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isSaveOperation
condition|)
block|{
name|storedSaveOrderConfig
operator|=
name|metaData
operator|.
name|getData
argument_list|(
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|DatabasePropertiesDialog
operator|.
name|SAVE_ORDER_CONFIG
argument_list|)
expr_stmt|;
block|}
comment|// This case should never be hit as SaveSettings() is never called if InOriginalOrder is true
assert|assert
name|storedSaveOrderConfig
operator|==
literal|null
operator|&&
name|isSaveOperation
operator|&&
operator|!
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|SAVE_IN_ORIGINAL_ORDER
argument_list|)
assert|;
assert|assert
name|storedSaveOrderConfig
operator|==
literal|null
operator|&&
operator|!
name|isSaveOperation
operator|&&
operator|!
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|EXPORT_IN_ORIGINAL_ORDER
argument_list|)
assert|;
if|if
condition|(
name|storedSaveOrderConfig
operator|!=
literal|null
condition|)
block|{
comment|// follow the metaData
name|SaveOrderConfig
name|saveOrderConfig
init|=
operator|new
name|SaveOrderConfig
argument_list|(
name|storedSaveOrderConfig
argument_list|)
decl_stmt|;
assert|assert
operator|!
name|saveOrderConfig
operator|.
name|saveInOriginalOrder
assert|;
assert|assert
name|saveOrderConfig
operator|.
name|saveInSpecifiedOrder
assert|;
name|pri
operator|=
name|saveOrderConfig
operator|.
name|sortCriteria
index|[
literal|0
index|]
operator|.
name|field
expr_stmt|;
name|sec
operator|=
name|saveOrderConfig
operator|.
name|sortCriteria
index|[
literal|1
index|]
operator|.
name|field
expr_stmt|;
name|ter
operator|=
name|saveOrderConfig
operator|.
name|sortCriteria
index|[
literal|2
index|]
operator|.
name|field
expr_stmt|;
name|priD
operator|=
name|saveOrderConfig
operator|.
name|sortCriteria
index|[
literal|0
index|]
operator|.
name|descending
expr_stmt|;
name|secD
operator|=
name|saveOrderConfig
operator|.
name|sortCriteria
index|[
literal|1
index|]
operator|.
name|descending
expr_stmt|;
name|terD
operator|=
name|saveOrderConfig
operator|.
name|sortCriteria
index|[
literal|2
index|]
operator|.
name|descending
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isSaveOperation
operator|&&
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|SAVE_IN_SPECIFIED_ORDER
argument_list|)
condition|)
block|{
name|pri
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|SAVE_PRIMARY_SORT_FIELD
argument_list|)
expr_stmt|;
name|sec
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|SAVE_SECONDARY_SORT_FIELD
argument_list|)
expr_stmt|;
name|ter
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|SAVE_TERTIARY_SORT_FIELD
argument_list|)
expr_stmt|;
name|priD
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|SAVE_PRIMARY_SORT_DESCENDING
argument_list|)
expr_stmt|;
name|secD
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|SAVE_SECONDARY_SORT_DESCENDING
argument_list|)
expr_stmt|;
name|terD
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|SAVE_TERTIARY_SORT_DESCENDING
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isSaveOperation
operator|&&
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|EXPORT_IN_SPECIFIED_ORDER
argument_list|)
condition|)
block|{
name|pri
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|EXPORT_PRIMARY_SORT_FIELD
argument_list|)
expr_stmt|;
name|sec
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|EXPORT_SECONDARY_SORT_FIELD
argument_list|)
expr_stmt|;
name|ter
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|EXPORT_TERTIARY_SORT_FIELD
argument_list|)
expr_stmt|;
name|priD
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|EXPORT_PRIMARY_SORT_DESCENDING
argument_list|)
expr_stmt|;
name|secD
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|EXPORT_SECONDARY_SORT_DESCENDING
argument_list|)
expr_stmt|;
name|terD
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|EXPORT_TERTIARY_SORT_DESCENDING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The setting is to save according to the current table order.
name|pri
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|PRIMARY_SORT_FIELD
argument_list|)
expr_stmt|;
name|sec
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|SECONDARY_SORT_FIELD
argument_list|)
expr_stmt|;
name|ter
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|TERTIARY_SORT_FIELD
argument_list|)
expr_stmt|;
name|priD
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|PRIMARY_SORT_DESCENDING
argument_list|)
expr_stmt|;
name|secD
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|SECONDARY_SORT_DESCENDING
argument_list|)
expr_stmt|;
name|terD
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|TERTIARY_SORT_DESCENDING
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getSaveComparators (boolean isSaveOperation, MetaData metaData)
specifier|private
specifier|static
name|List
argument_list|<
name|Comparator
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|>
name|getSaveComparators
parameter_list|(
name|boolean
name|isSaveOperation
parameter_list|,
name|MetaData
name|metaData
parameter_list|)
block|{
name|SaveSettings
name|saveSettings
init|=
operator|new
name|SaveSettings
argument_list|(
name|isSaveOperation
argument_list|,
name|metaData
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Comparator
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|>
name|comparators
init|=
operator|new
name|ArrayList
argument_list|<
name|Comparator
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|isSaveOperation
condition|)
block|{
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|CrossRefEntryComparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|FieldComparator
argument_list|(
name|saveSettings
operator|.
name|pri
argument_list|,
name|saveSettings
operator|.
name|priD
argument_list|)
argument_list|)
expr_stmt|;
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|FieldComparator
argument_list|(
name|saveSettings
operator|.
name|sec
argument_list|,
name|saveSettings
operator|.
name|secD
argument_list|)
argument_list|)
expr_stmt|;
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|FieldComparator
argument_list|(
name|saveSettings
operator|.
name|ter
argument_list|,
name|saveSettings
operator|.
name|terD
argument_list|)
argument_list|)
expr_stmt|;
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|FieldComparator
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|comparators
return|;
block|}
comment|/**      * Saves the database to file, including only the entries included in the      * supplied input array bes.      *      * @return A List containing warnings, if any.      */
DECL|method|savePartOfDatabase (BibtexDatabase database, MetaData metaData, File file, JabRefPreferences prefs, BibtexEntry[] bes, String encoding, DatabaseSaveType saveType)
specifier|public
specifier|static
name|SaveSession
name|savePartOfDatabase
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|MetaData
name|metaData
parameter_list|,
name|File
name|file
parameter_list|,
name|JabRefPreferences
name|prefs
parameter_list|,
name|BibtexEntry
index|[]
name|bes
parameter_list|,
name|String
name|encoding
parameter_list|,
name|DatabaseSaveType
name|saveType
parameter_list|)
throws|throws
name|SaveException
block|{
name|TreeMap
argument_list|<
name|String
argument_list|,
name|BibtexEntryType
argument_list|>
name|types
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|BibtexEntryType
argument_list|>
argument_list|()
decl_stmt|;
comment|// Map
comment|// to
comment|// collect
comment|// entry
comment|// type
comment|// definitions
comment|// that we must save along with entries using them.
name|BibtexEntry
name|be
init|=
literal|null
decl_stmt|;
name|boolean
name|backup
init|=
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|BACKUP
argument_list|)
decl_stmt|;
name|SaveSession
name|session
decl_stmt|;
try|try
block|{
name|session
operator|=
operator|new
name|SaveSession
argument_list|(
name|file
argument_list|,
name|encoding
argument_list|,
name|backup
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SaveException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
try|try
block|{
comment|// Define our data stream.
name|VerifyingWriter
name|fw
init|=
name|session
operator|.
name|getWriter
argument_list|()
decl_stmt|;
if|if
condition|(
name|saveType
operator|!=
name|DatabaseSaveType
operator|.
name|PLAIN_BIBTEX
condition|)
block|{
comment|// Write signature.
name|FileActions
operator|.
name|writeBibFileHeader
argument_list|(
name|fw
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
comment|// Write preamble if there is one.
name|FileActions
operator|.
name|writePreamble
argument_list|(
name|fw
argument_list|,
name|database
operator|.
name|getPreamble
argument_list|()
argument_list|)
expr_stmt|;
comment|// Write strings if there are any.
name|FileActions
operator|.
name|writeStrings
argument_list|(
name|fw
argument_list|,
name|database
argument_list|)
expr_stmt|;
comment|// Write database entries. Take care, using CrossRefEntry-
comment|// Comparator, that referred entries occur after referring
comment|// ones. Apart from crossref requirements, entries will be
comment|// sorted as they appear on the screen.
name|List
argument_list|<
name|Comparator
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|>
name|comparators
init|=
name|FileActions
operator|.
name|getSaveComparators
argument_list|(
literal|true
argument_list|,
name|metaData
argument_list|)
decl_stmt|;
comment|// Use glazed lists to get a sorted view of the entries:
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|sorter
init|=
operator|new
name|ArrayList
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|(
name|bes
operator|.
name|length
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|sorter
argument_list|,
name|bes
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sorter
argument_list|,
operator|new
name|FieldComparatorStack
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|(
name|comparators
argument_list|)
argument_list|)
expr_stmt|;
name|BibtexEntryWriter
name|bibtexEntryWriter
init|=
operator|new
name|BibtexEntryWriter
argument_list|(
operator|new
name|LatexFieldFormatter
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|aSorter
range|:
name|sorter
control|)
block|{
name|be
operator|=
name|aSorter
expr_stmt|;
comment|// Check if we must write the type definition for this
comment|// entry, as well. Our criterion is that all non-standard
comment|// types (*not* customized standard types) must be written.
name|BibtexEntryType
name|tp
init|=
name|be
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|BibtexEntryType
operator|.
name|getStandardType
argument_list|(
name|tp
operator|.
name|getName
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
name|types
operator|.
name|put
argument_list|(
name|tp
operator|.
name|getName
argument_list|()
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
name|bibtexEntryWriter
operator|.
name|write
argument_list|(
name|be
argument_list|,
name|fw
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
comment|// Write meta data.
if|if
condition|(
name|saveType
operator|!=
name|DatabaseSaveType
operator|.
name|PLAIN_BIBTEX
operator|&&
name|metaData
operator|!=
literal|null
condition|)
block|{
name|metaData
operator|.
name|writeMetaData
argument_list|(
name|fw
argument_list|)
expr_stmt|;
block|}
comment|// Write type definitions, if any:
if|if
condition|(
operator|!
name|types
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|BibtexEntryType
argument_list|>
name|stringBibtexEntryTypeEntry
range|:
name|types
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|CustomEntryType
name|tp
init|=
operator|(
name|CustomEntryType
operator|)
name|stringBibtexEntryTypeEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|tp
operator|.
name|save
argument_list|(
name|fw
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|Globals
operator|.
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
block|}
name|fw
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|session
operator|.
name|cancel
argument_list|()
expr_stmt|;
comment|//repairAfterError(file, backup, status);
throw|throw
operator|new
name|SaveException
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|be
argument_list|)
throw|;
block|}
return|return
name|session
return|;
block|}
comment|/**      * This method attempts to get a Reader for the file path given, either by      * loading it as a resource (from within jar), or as a normal file. If      * unsuccessful (e.g. file not found), an IOException is thrown.      */
DECL|method|getReader (String name)
specifier|public
specifier|static
name|Reader
name|getReader
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|Reader
name|reader
decl_stmt|;
comment|// Try loading as a resource first. This works for files inside the jar:
name|URL
name|reso
init|=
name|Globals
operator|.
name|class
operator|.
name|getResource
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|// If that didn't work, try loading as a normal file URL:
if|if
condition|(
name|reso
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|reader
operator|=
operator|new
name|InputStreamReader
argument_list|(
name|reso
operator|.
name|openStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Could not find layout file"
argument_list|)
operator|+
literal|": '"
operator|+
name|name
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|name
argument_list|)
decl_stmt|;
try|try
block|{
name|reader
operator|=
operator|new
name|FileReader
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Could not find layout file"
argument_list|)
operator|+
literal|": '"
operator|+
name|name
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
return|return
name|reader
return|;
block|}
comment|/*      * We have begun to use getSortedEntries() for both database save operations      * and non-database save operations.  In a non-database save operation      * (such as the exportDatabase call), we do not wish to use the      * global preference of saving in standard order.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getSortedEntries (BibtexDatabase database, MetaData metaData, Set<String> keySet, boolean isSaveOperation)
specifier|public
specifier|static
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|getSortedEntries
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|MetaData
name|metaData
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|keySet
parameter_list|,
name|boolean
name|isSaveOperation
parameter_list|)
block|{
name|boolean
name|inOriginalOrder
decl_stmt|;
if|if
condition|(
name|isSaveOperation
condition|)
block|{
name|Vector
argument_list|<
name|String
argument_list|>
name|storedSaveOrderConfig
init|=
name|metaData
operator|.
name|getData
argument_list|(
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|DatabasePropertiesDialog
operator|.
name|SAVE_ORDER_CONFIG
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedSaveOrderConfig
operator|==
literal|null
condition|)
block|{
name|inOriginalOrder
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|SAVE_IN_ORIGINAL_ORDER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SaveOrderConfig
name|saveOrderConfig
init|=
operator|new
name|SaveOrderConfig
argument_list|(
name|storedSaveOrderConfig
argument_list|)
decl_stmt|;
name|inOriginalOrder
operator|=
name|saveOrderConfig
operator|.
name|saveInOriginalOrder
expr_stmt|;
block|}
block|}
else|else
block|{
name|inOriginalOrder
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|EXPORT_IN_ORIGINAL_ORDER
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Comparator
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|>
name|comparators
decl_stmt|;
if|if
condition|(
name|inOriginalOrder
condition|)
block|{
comment|// Sort entries based on their creation order, utilizing the fact
comment|// that IDs used for entries are increasing, sortable numbers.
name|comparators
operator|=
operator|new
name|ArrayList
argument_list|<
name|Comparator
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|CrossRefEntryComparator
argument_list|()
argument_list|)
expr_stmt|;
name|comparators
operator|.
name|add
argument_list|(
operator|new
name|IdComparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|comparators
operator|=
name|FileActions
operator|.
name|getSaveComparators
argument_list|(
name|isSaveOperation
argument_list|,
name|metaData
argument_list|)
expr_stmt|;
block|}
name|FieldComparatorStack
argument_list|<
name|BibtexEntry
argument_list|>
name|comparatorStack
init|=
operator|new
name|FieldComparatorStack
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|(
name|comparators
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|sorter
init|=
operator|new
name|ArrayList
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|keySet
operator|==
literal|null
condition|)
block|{
name|keySet
operator|=
name|database
operator|.
name|getKeySet
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|keySet
operator|!=
literal|null
condition|)
block|{
name|Iterator
argument_list|<
name|String
argument_list|>
name|i
init|=
name|keySet
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|sorter
operator|.
name|add
argument_list|(
name|database
operator|.
name|getEntryById
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|sorter
argument_list|,
name|comparatorStack
argument_list|)
expr_stmt|;
return|return
name|sorter
return|;
block|}
comment|/**      * @return true iff the entry has a nonzero value in its field.      */
DECL|method|nonZeroField (BibtexEntry be, String field)
specifier|private
specifier|static
name|boolean
name|nonZeroField
parameter_list|(
name|BibtexEntry
name|be
parameter_list|,
name|String
name|field
parameter_list|)
block|{
name|String
name|o
init|=
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
return|return
name|o
operator|!=
literal|null
operator|&&
operator|!
name|o
operator|.
name|equals
argument_list|(
literal|"0"
argument_list|)
return|;
block|}
block|}
end_class

end_unit

