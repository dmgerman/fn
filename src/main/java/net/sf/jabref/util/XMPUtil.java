begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003-2011 JabRef contributors.     This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License along     with this program; if not, write to the Free Software Foundation, Inc.,     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */
end_comment

begin_package
DECL|package|net.sf.jabref.util
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|TransformerException
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|LatexFieldFormatter
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|imports
operator|.
name|BibtexParser
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|imports
operator|.
name|ParserResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jempbox
operator|.
name|impl
operator|.
name|DateConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jempbox
operator|.
name|impl
operator|.
name|XMLUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jempbox
operator|.
name|xmp
operator|.
name|XMPMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jempbox
operator|.
name|xmp
operator|.
name|XMPSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jempbox
operator|.
name|xmp
operator|.
name|XMPSchemaDublinCore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|COSVisitorException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocumentCatalog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocumentInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDMetadata
import|;
end_import

begin_comment
comment|/**  * XMPUtils provide support for reading and writing BibTex data as XMP-Metadata  * in PDF-documents.  *   * @author Christopher Oezbek<oezi@oezi.de>  *   * TODO:  *   * Synchronization  *   * @version $Revision$ ($Date$)  */
end_comment

begin_class
DECL|class|XMPUtil
specifier|public
class|class
name|XMPUtil
block|{
comment|/**      * Convenience method for readXMP(File).      *       * @param filename      *            The filename from which to open the file.      * @return BibtexEntryies found in the PDF or an empty list      * @throws IOException      */
DECL|method|readXMP (String filename)
specifier|public
specifier|static
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|readXMP
parameter_list|(
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|XMPUtil
operator|.
name|readXMP
argument_list|(
operator|new
name|File
argument_list|(
name|filename
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Try to write the given BibTexEntry in the XMP-stream of the given      * PDF-file.      *       * Throws an IOException if the file cannot be read or written, so the user      * can remove a lock or cancel the operation.      *       * The method will overwrite existing BibTeX-XMP-data, but keep other      * existing metadata.      *       * This is a convenience method for writeXMP(File, BibtexEntry).      *       * @param filename      *            The filename from which to open the file.      * @param entry      *            The entry to write.      * @param database      *            maybenull An optional database which the given bibtex entries      *            belong to, which will be used to resolve strings. If the      *            database is null the strings will not be resolved.      * @throws TransformerException      *             If the entry was malformed or unsupported.      * @throws IOException      *             If the file could not be written to or could not be found.      */
DECL|method|writeXMP (String filename, BibtexEntry entry, BibtexDatabase database)
specifier|public
specifier|static
name|void
name|writeXMP
parameter_list|(
name|String
name|filename
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
name|XMPUtil
operator|.
name|writeXMP
argument_list|(
operator|new
name|File
argument_list|(
name|filename
argument_list|)
argument_list|,
name|entry
argument_list|,
name|database
argument_list|)
expr_stmt|;
block|}
comment|/**      * Try to read the BibTexEntries from the XMP-stream of the given PDF-file.      *       * @param file      *            The file to read from.      *       * @throws IOException      *             Throws an IOException if the file cannot be read, so the user      *             than remove a lock or cancel the operation.      */
DECL|method|readXMP (File file)
specifier|public
specifier|static
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|readXMP
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|FileInputStream
name|is
init|=
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|XMPUtil
operator|.
name|readXMP
argument_list|(
name|is
argument_list|)
return|;
block|}
finally|finally
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Try to read the given BibTexEntry from the XMP-stream of the given      * inputstream containing a PDF-file.      *       * @param inputStream      *            The inputstream to read from.      *       * @throws IOException      *             Throws an IOException if the file cannot be read, so the user      *             than remove a lock or cancel the operation.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|readXMP (InputStream inputStream)
specifier|public
specifier|static
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|readXMP
parameter_list|(
name|InputStream
name|inputStream
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|result
init|=
operator|new
name|LinkedList
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|()
decl_stmt|;
name|PDDocument
name|document
init|=
literal|null
decl_stmt|;
try|try
block|{
name|document
operator|=
name|PDDocument
operator|.
name|load
argument_list|(
name|inputStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|document
operator|.
name|isEncrypted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|EncryptionNotSupportedException
argument_list|(
literal|"Error: Cannot read metadata from encrypted document."
argument_list|)
throw|;
block|}
name|XMPMetadata
name|meta
init|=
name|XMPUtil
operator|.
name|getXMPMetadata
argument_list|(
name|document
argument_list|)
decl_stmt|;
comment|// If we did not find any XMP metadata, search for non XMP metadata
if|if
condition|(
name|meta
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|XMPSchema
argument_list|>
name|schemas
init|=
name|meta
operator|.
name|getSchemasByNamespaceURI
argument_list|(
name|XMPSchemaBibtex
operator|.
name|NAMESPACE
argument_list|)
decl_stmt|;
for|for
control|(
name|XMPSchema
name|schema
range|:
name|schemas
control|)
block|{
name|XMPSchemaBibtex
name|bib
init|=
operator|(
name|XMPSchemaBibtex
operator|)
name|schema
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|bib
operator|.
name|getBibtexEntry
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// If we did not find anything have a look if a Dublin Core exists
if|if
condition|(
name|result
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|schemas
operator|=
name|meta
operator|.
name|getSchemasByNamespaceURI
argument_list|(
name|XMPSchemaDublinCore
operator|.
name|NAMESPACE
argument_list|)
expr_stmt|;
for|for
control|(
name|XMPSchema
name|schema
range|:
name|schemas
control|)
block|{
name|XMPSchemaDublinCore
name|dc
init|=
operator|(
name|XMPSchemaDublinCore
operator|)
name|schema
decl_stmt|;
name|BibtexEntry
name|entry
init|=
name|XMPUtil
operator|.
name|getBibtexEntryFromDublinCore
argument_list|(
name|dc
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|result
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|BibtexEntry
name|entry
init|=
name|XMPUtil
operator|.
name|getBibtexEntryFromDocumentInformation
argument_list|(
name|document
operator|.
name|getDocumentInformation
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|document
operator|!=
literal|null
condition|)
block|{
name|document
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|// return null, if no metadata was found
if|if
condition|(
name|result
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Helper function for retrieving a BibtexEntry from the      * PDDocumentInformation in a PDF file.      *       * To understand how to get hold of a PDDocumentInformation have a look in      * the test cases for XMPUtil.      *       * The BibtexEntry is build by mapping individual fields in the document      * information (like author, title, keywords) to fields in a bibtex entry.      *       * @param di      *            The document information from which to build a BibtexEntry.      *       * @return The bibtex entry found in the document information.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getBibtexEntryFromDocumentInformation ( PDDocumentInformation di)
specifier|public
specifier|static
name|BibtexEntry
name|getBibtexEntryFromDocumentInformation
parameter_list|(
name|PDDocumentInformation
name|di
parameter_list|)
block|{
name|BibtexEntry
name|entry
init|=
operator|new
name|BibtexEntry
argument_list|()
decl_stmt|;
name|String
name|s
init|=
name|di
operator|.
name|getAuthor
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"author"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|di
operator|.
name|getTitle
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"title"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|di
operator|.
name|getKeywords
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"keywords"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|di
operator|.
name|getSubject
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"abstract"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|COSDictionary
name|dict
init|=
name|di
operator|.
name|getDictionary
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|COSName
argument_list|,
name|COSBase
argument_list|>
name|o
range|:
name|dict
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|o
operator|.
name|getKey
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|startsWith
argument_list|(
literal|"bibtex/"
argument_list|)
condition|)
block|{
name|String
name|value
init|=
name|dict
operator|.
name|getString
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|key
operator|=
name|key
operator|.
name|substring
argument_list|(
literal|"bibtex/"
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"entrytype"
argument_list|)
condition|)
block|{
name|BibtexEntryType
name|type
init|=
name|BibtexEntryType
operator|.
name|getStandardType
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|entry
operator|.
name|setField
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Return null if no values were found
return|return
operator|(
name|entry
operator|.
name|getAllFields
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|?
name|entry
else|:
literal|null
operator|)
return|;
block|}
comment|/**      * Helper function for retrieving a BibtexEntry from the DublinCore metadata      * in a PDF file.      *       * To understand how to get hold of a XMPSchemaDublinCore have a look in the      * test cases for XMPUtil.      *       * The BibtexEntry is build by mapping individual fields in the dublin core      * (like creator, title, subject) to fields in a bibtex entry.      *       * @param dcSchema      *            The document information from which to build a BibtexEntry.      *       * @return The bibtex entry found in the document information.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getBibtexEntryFromDublinCore ( XMPSchemaDublinCore dcSchema)
specifier|public
specifier|static
name|BibtexEntry
name|getBibtexEntryFromDublinCore
parameter_list|(
name|XMPSchemaDublinCore
name|dcSchema
parameter_list|)
block|{
name|BibtexEntry
name|entry
init|=
operator|new
name|BibtexEntry
argument_list|()
decl_stmt|;
comment|/**          * Contributor -> Editor          */
name|List
argument_list|<
name|String
argument_list|>
name|contributors
init|=
name|dcSchema
operator|.
name|getContributors
argument_list|()
decl_stmt|;
if|if
condition|(
name|contributors
operator|!=
literal|null
condition|)
block|{
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|contributors
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|StringBuffer
name|sb
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"editor"
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Author -> Creator          */
name|List
argument_list|<
name|String
argument_list|>
name|creators
init|=
name|dcSchema
operator|.
name|getCreators
argument_list|()
decl_stmt|;
if|if
condition|(
name|creators
operator|!=
literal|null
condition|)
block|{
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|creators
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|StringBuffer
name|sb
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"author"
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Year + Month -> Date          */
name|List
argument_list|<
name|String
argument_list|>
name|dates
init|=
name|dcSchema
operator|.
name|getSequenceList
argument_list|(
literal|"dc:date"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|dates
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|dates
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|String
name|date
init|=
name|dates
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|Calendar
name|c
init|=
literal|null
decl_stmt|;
try|try
block|{
name|c
operator|=
name|DateConverter
operator|.
name|toCalendar
argument_list|(
name|date
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{              }
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"year"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|c
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
operator|.
name|length
argument_list|()
operator|>
literal|4
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"month"
argument_list|,
name|MonthUtil
operator|.
name|getMonthByIndex
argument_list|(
name|c
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|)
argument_list|)
operator|.
name|bibtexFormat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Abstract -> Description          */
name|String
name|s
init|=
name|dcSchema
operator|.
name|getDescription
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"abstract"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/**          * Identifier -> DOI          */
name|s
operator|=
name|dcSchema
operator|.
name|getIdentifier
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"doi"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/**          * Publisher -> Publisher          */
name|List
argument_list|<
name|String
argument_list|>
name|publishers
init|=
name|dcSchema
operator|.
name|getPublishers
argument_list|()
decl_stmt|;
if|if
condition|(
name|publishers
operator|!=
literal|null
condition|)
block|{
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|dcSchema
operator|.
name|getPublishers
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|StringBuffer
name|sb
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"publishers"
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Relation -> bibtexkey          *           * We abuse the relationship attribute to store all other values in the          * bibtex document          */
name|List
argument_list|<
name|String
argument_list|>
name|relationships
init|=
name|dcSchema
operator|.
name|getRelationships
argument_list|()
decl_stmt|;
if|if
condition|(
name|relationships
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|r
range|:
name|relationships
control|)
block|{
if|if
condition|(
name|r
operator|.
name|startsWith
argument_list|(
literal|"bibtex/"
argument_list|)
condition|)
block|{
name|r
operator|=
name|r
operator|.
name|substring
argument_list|(
literal|"bibtex/"
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|i
init|=
name|r
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|r
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|r
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**          * Rights -> Rights          */
name|s
operator|=
name|dcSchema
operator|.
name|getRights
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"rights"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/**          * Source -> Source          */
name|s
operator|=
name|dcSchema
operator|.
name|getSource
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"source"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/**          * Subject -> Keywords          */
name|List
argument_list|<
name|String
argument_list|>
name|subjects
init|=
name|dcSchema
operator|.
name|getSubjects
argument_list|()
decl_stmt|;
if|if
condition|(
name|subjects
operator|!=
literal|null
condition|)
block|{
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|subjects
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|StringBuffer
name|sb
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"keywords"
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Title -> Title          */
name|s
operator|=
name|dcSchema
operator|.
name|getTitle
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"title"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/**          * Type -> Type          */
name|List
argument_list|<
name|String
argument_list|>
name|l
init|=
name|dcSchema
operator|.
name|getTypes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|l
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|l
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|s
operator|=
name|l
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|BibtexEntryType
name|type
init|=
name|BibtexEntryType
operator|.
name|getStandardType
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|entry
operator|.
name|getAllFields
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|?
name|entry
else|:
literal|null
operator|)
return|;
block|}
comment|/**      * Try to write the given BibTexEntry in the XMP-stream of the given      * PDF-file.      *       * Throws an IOException if the file cannot be read or written, so the user      * can remove a lock or cancel the operation.      *       * The method will overwrite existing BibTeX-XMP-data, but keep other      * existing metadata.      *       * This is a convenience method for writeXMP(File, Collection).      *       * @param file      *            The file to write to.      * @param entry      *            The entry to write.      * @param database      *            maybenull An optional database which the given bibtex entries      *            belong to, which will be used to resolve strings. If the      *            database is null the strings will not be resolved.      * @throws TransformerException      *             If the entry was malformed or unsupported.      * @throws IOException      *             If the file could not be written to or could not be found.      */
DECL|method|writeXMP (File file, BibtexEntry entry, BibtexDatabase database)
specifier|public
specifier|static
name|void
name|writeXMP
parameter_list|(
name|File
name|file
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|l
init|=
operator|new
name|LinkedList
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|()
decl_stmt|;
name|l
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|XMPUtil
operator|.
name|writeXMP
argument_list|(
name|file
argument_list|,
name|l
argument_list|,
name|database
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write the given BibtexEntries as XMP-metadata text to the given stream.      *       * The text that is written to the stream contains a complete XMP-document.      *       * @param bibtexEntries      *            The BibtexEntries to write XMP-metadata for.      * @param database      *            maybenull An optional database which the given bibtex entries      *            belong to, which will be used to resolve strings. If the      *            database is null the strings will not be resolved.      * @throws TransformerException      *             Thrown if the bibtexEntries could not transformed to XMP.      * @throws IOException      *             Thrown if an IOException occured while writing to the stream.      *       * @see #toXMP(java.util.Collection, net.sf.jabref.BibtexDatabase) if you don't need strings to be      *      resolved.      */
DECL|method|toXMP (Collection<BibtexEntry> bibtexEntries, BibtexDatabase database, OutputStream outputStream)
specifier|private
specifier|static
name|void
name|toXMP
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|bibtexEntries
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|,
name|OutputStream
name|outputStream
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
if|if
condition|(
name|database
operator|!=
literal|null
condition|)
block|{
name|bibtexEntries
operator|=
name|database
operator|.
name|resolveForStrings
argument_list|(
name|bibtexEntries
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|XMPMetadata
name|x
init|=
operator|new
name|XMPMetadata
argument_list|()
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|e
range|:
name|bibtexEntries
control|)
block|{
name|XMPSchemaBibtex
name|schema
init|=
operator|new
name|XMPSchemaBibtex
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|x
operator|.
name|addSchema
argument_list|(
name|schema
argument_list|)
expr_stmt|;
name|schema
operator|.
name|setBibtexEntry
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|x
operator|.
name|save
argument_list|(
name|outputStream
argument_list|)
expr_stmt|;
block|}
comment|/**      * Convenience method for toXMP(Collection<BibtexEntry>, BibtexDatabase,      * OutputStream) returning a String containing the XMP-metadata of the given      * collection of BibtexEntries.      *       * The resulting metadata string is wrapped as a complete XMP-document.      *       * @param bibtexEntries      *            The BibtexEntries to return XMP-metadata for.       * @param database      *            maybenull An optional database which the given bibtex entries      *            belong to, which will be used to resolve strings. If the      *            database is null the strings will not be resolved.      * @return The XMP representation of the given bibtexEntries.      * @throws TransformerException      *             Thrown if the bibtexEntries could not transformed to XMP.      */
DECL|method|toXMP (Collection<BibtexEntry> bibtexEntries, BibtexDatabase database)
specifier|public
specifier|static
name|String
name|toXMP
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|bibtexEntries
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
throws|throws
name|TransformerException
block|{
try|try
block|{
name|ByteArrayOutputStream
name|bs
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|XMPUtil
operator|.
name|toXMP
argument_list|(
name|bibtexEntries
argument_list|,
name|database
argument_list|,
name|bs
argument_list|)
expr_stmt|;
return|return
name|bs
operator|.
name|toString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|TransformerException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Will read the XMPMetadata from the given pdf file, closing the file      * afterwards.      *       * @param inputStream      *            The inputStream representing a PDF-file to read the      *            XMPMetadata from.      * @return The XMPMetadata object found in the file or null if none is      *         found.      * @throws IOException      */
DECL|method|readRawXMP (InputStream inputStream)
specifier|private
specifier|static
name|XMPMetadata
name|readRawXMP
parameter_list|(
name|InputStream
name|inputStream
parameter_list|)
throws|throws
name|IOException
block|{
name|PDDocument
name|document
init|=
literal|null
decl_stmt|;
try|try
block|{
name|document
operator|=
name|PDDocument
operator|.
name|load
argument_list|(
name|inputStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|document
operator|.
name|isEncrypted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|EncryptionNotSupportedException
argument_list|(
literal|"Error: Cannot read metadata from encrypted document."
argument_list|)
throw|;
block|}
return|return
name|XMPUtil
operator|.
name|getXMPMetadata
argument_list|(
name|document
argument_list|)
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|document
operator|!=
literal|null
condition|)
block|{
name|document
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|getXMPMetadata (PDDocument document)
specifier|private
specifier|static
name|XMPMetadata
name|getXMPMetadata
parameter_list|(
name|PDDocument
name|document
parameter_list|)
throws|throws
name|IOException
block|{
name|PDDocumentCatalog
name|catalog
init|=
name|document
operator|.
name|getDocumentCatalog
argument_list|()
decl_stmt|;
name|PDMetadata
name|metaRaw
init|=
name|catalog
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
if|if
condition|(
name|metaRaw
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|XMPMetadata
name|meta
init|=
operator|new
name|XMPMetadata
argument_list|(
name|XMLUtil
operator|.
name|parse
argument_list|(
name|metaRaw
operator|.
name|createInputStream
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|meta
operator|.
name|addXMLNSMapping
argument_list|(
name|XMPSchemaBibtex
operator|.
name|NAMESPACE
argument_list|,
name|XMPSchemaBibtex
operator|.
name|class
argument_list|)
expr_stmt|;
return|return
name|meta
return|;
block|}
comment|/**      * Will read the XMPMetadata from the given pdf file, closing the file      * afterwards.      *       * @param file      *            The file to read the XMPMetadata from.      * @return The XMPMetadata object found in the file or null if none is      *         found.      * @throws IOException      */
DECL|method|readRawXMP (File file)
specifier|public
specifier|static
name|XMPMetadata
name|readRawXMP
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|FileInputStream
name|is
init|=
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|XMPUtil
operator|.
name|readRawXMP
argument_list|(
name|is
argument_list|)
return|;
block|}
finally|finally
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|writeToDCSchema (XMPSchemaDublinCore dcSchema, BibtexEntry entry, BibtexDatabase database)
specifier|private
specifier|static
name|void
name|writeToDCSchema
parameter_list|(
name|XMPSchemaDublinCore
name|dcSchema
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
block|{
if|if
condition|(
name|database
operator|!=
literal|null
condition|)
block|{
name|entry
operator|=
name|database
operator|.
name|resolveForStrings
argument_list|(
name|entry
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Query privacy filter settings
name|JabRefPreferences
name|prefs
init|=
name|JabRefPreferences
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|boolean
name|useXmpPrivacyFilter
init|=
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"useXmpPrivacyFilter"
argument_list|)
decl_stmt|;
comment|// Fields for which not to write XMP data later on:
name|TreeSet
argument_list|<
name|String
argument_list|>
name|filters
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|prefs
operator|.
name|getStringArray
argument_list|(
name|JabRefPreferences
operator|.
name|XMP_PRIVACY_FILTERS
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// Set all the values including key and entryType
for|for
control|(
name|String
name|field
range|:
name|entry
operator|.
name|getAllFields
argument_list|()
control|)
block|{
if|if
condition|(
name|useXmpPrivacyFilter
operator|&&
name|filters
operator|.
name|contains
argument_list|(
name|field
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"editor"
argument_list|)
condition|)
block|{
name|String
name|authors
init|=
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|/**                  * Editor -> Contributor                  *                   * Field: dc:contributor                  *                   * Type: bag ProperName                  *                   * Category: External                  *                   * Description: Contributors to the resource (other than the                  * authors).                  *                   * Bibtex-Fields used: editor                  */
name|AuthorList
name|list
init|=
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|authors
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|dcSchema
operator|.
name|addContributor
argument_list|(
name|list
operator|.
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getFirstLast
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/**              * ? -> Coverage              *               * Unmapped              *               * dc:coverage Text External The extent or scope of the resource.              */
comment|/**              * Author -> Creator              *               * Field: dc:creator              *               * Type: seq ProperName              *               * Category: External              *               * Description: The authors of the resource (listed in order of              * precedence, if significant).              *               * Bibtex-Fields used: author              */
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"author"
argument_list|)
condition|)
block|{
name|String
name|authors
init|=
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|AuthorList
name|list
init|=
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|authors
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|dcSchema
operator|.
name|addCreator
argument_list|(
name|list
operator|.
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getFirstLast
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"month"
argument_list|)
condition|)
block|{
comment|// Dealt with in year
continue|continue;
block|}
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"year"
argument_list|)
condition|)
block|{
comment|/**                  * Year + Month -> Date                  *                   * Field: dc:date                  *                   * Type: seq Date                  *                   * Category: External                  *                   * Description: Date(s) that something interesting happened to                  * the resource.                  *                   * Bibtex-Fields used: year, month                  */
name|String
name|publicationDate
init|=
name|Util
operator|.
name|getPublicationDate
argument_list|(
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|publicationDate
operator|!=
literal|null
condition|)
block|{
name|dcSchema
operator|.
name|addSequenceValue
argument_list|(
literal|"dc:date"
argument_list|,
name|publicationDate
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/**              * Abstract -> Description              *               * Field: dc:description              *               * Type: Lang Alt              *               * Category: External              *               * Description: A textual description of the content of the              * resource. Multiple values may be present for different languages.              *               * Bibtex-Fields used: abstract              */
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"abstract"
argument_list|)
condition|)
block|{
name|String
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|dcSchema
operator|.
name|setDescription
argument_list|(
name|o
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/**              * DOI -> identifier              *               * Field: dc:identifier              *               * Type: Text              *               * Category: External              *               * Description: Unique identifier of the resource.              *               * Bibtex-Fields used: doi              */
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"doi"
argument_list|)
condition|)
block|{
name|String
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|dcSchema
operator|.
name|setIdentifier
argument_list|(
name|o
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/**              * ? -> Language              *               * Unmapped              *               * dc:language bag Locale Internal An unordered array specifying the              * languages used in the resource.              */
comment|/**              * Publisher -> Publisher              *               * Field: dc:publisher              *               * Type: bag ProperName              *               * Category: External              *               * Description: Publishers.              *               * Bibtex-Fields used: doi              */
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"publisher"
argument_list|)
condition|)
block|{
name|String
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|dcSchema
operator|.
name|addPublisher
argument_list|(
name|o
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/**              * ? -> Rights              *               * Unmapped              *               * dc:rights Lang Alt External Informal rights statement, selected              * by language.              */
comment|/**              * ? -> Source              *               * Unmapped              *               * dc:source Text External Unique identifier of the work from which              * this resource was derived.              */
comment|/**              * Keywords -> Subject              *               * Field: dc:subject              *               * Type: bag Text              *               * Category: External              *               * Description: An unordered array of descriptive phrases or              * keywords that specify the topic of the content of the resource.              *               * Bibtex-Fields used: doi              */
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"keywords"
argument_list|)
condition|)
block|{
name|String
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|String
index|[]
name|keywords
init|=
name|o
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|keyword
range|:
name|keywords
control|)
block|{
name|dcSchema
operator|.
name|addSubject
argument_list|(
name|keyword
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/**              * Title -> Title              *               * Field: dc:title              *               * Type: Lang Alt              *               * Category: External              *               * Description: The title of the document, or the name given to the              * resource. Typically, it will be a name by which the resource is              * formally known.              *               * Bibtex-Fields used: title              */
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"title"
argument_list|)
condition|)
block|{
name|String
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|dcSchema
operator|.
name|setTitle
argument_list|(
name|o
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/**              * bibtextype -> relation              *               * Field: dc:relation              *               * Type: bag Text              *               * Category: External              *               * Description: Relationships to other documents.              *               * Bibtex-Fields used: bibtextype              */
comment|/**              * All others (including the bibtex key) get packaged in the              * relation attribute              */
name|String
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|dcSchema
operator|.
name|addRelation
argument_list|(
literal|"bibtex/"
operator|+
name|field
operator|+
literal|"/"
operator|+
name|o
argument_list|)
expr_stmt|;
block|}
comment|/**          * ? -> Format          *           * Unmapped          *           * dc:format MIMEType Internal The file format used when saving the          * resource. Tools and applications should set this property to the save          * format of the data. It may include appropriate qualifiers.          */
name|dcSchema
operator|.
name|setFormat
argument_list|(
literal|"application/pdf"
argument_list|)
expr_stmt|;
comment|/**          * Type -> Type          *           * Field: dc:type          *           * Type: bag open Choice          *           * Category: External          *           * Description: A document type; for example, novel, poem, or working          * paper.          *           * Bibtex-Fields used: title          */
name|Object
name|o
init|=
name|entry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|dcSchema
operator|.
name|addType
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Try to write the given BibTexEntry as a DublinCore XMP Schema      *       * Existing DublinCore schemas in the document are not modified.      *       * @param document      *            The pdf document to write to.      * @param entry      *            The Bibtex entry that is written as a schema.      * @param database      *            maybenull An optional database which the given bibtex entries      *            belong to, which will be used to resolve strings. If the      *            database is null the strings will not be resolved.      * @throws IOException      * @throws TransformerException      */
DECL|method|writeDublinCore (PDDocument document, BibtexEntry entry, BibtexDatabase database)
specifier|public
specifier|static
name|void
name|writeDublinCore
parameter_list|(
name|PDDocument
name|document
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
init|=
operator|new
name|ArrayList
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|()
decl_stmt|;
name|entries
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|XMPUtil
operator|.
name|writeDublinCore
argument_list|(
name|document
argument_list|,
name|entries
argument_list|,
name|database
argument_list|)
expr_stmt|;
block|}
comment|/**      * Try to write the given BibTexEntries as DublinCore XMP Schemas      *       * Existing DublinCore schemas in the document are removed      *       * @param document      *            The pdf document to write to.      * @param entries      *            The Bibtex entries that are written as schemas      * @param database      *            maybenull An optional database which the given bibtex entries      *            belong to, which will be used to resolve strings. If the      *            database is null the strings will not be resolved.      * @throws IOException      * @throws TransformerException      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|writeDublinCore (PDDocument document, Collection<BibtexEntry> entries, BibtexDatabase database)
specifier|private
specifier|static
name|void
name|writeDublinCore
parameter_list|(
name|PDDocument
name|document
parameter_list|,
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
if|if
condition|(
name|database
operator|!=
literal|null
condition|)
block|{
name|entries
operator|=
name|database
operator|.
name|resolveForStrings
argument_list|(
name|entries
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|PDDocumentCatalog
name|catalog
init|=
name|document
operator|.
name|getDocumentCatalog
argument_list|()
decl_stmt|;
name|PDMetadata
name|metaRaw
init|=
name|catalog
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|XMPMetadata
name|meta
decl_stmt|;
if|if
condition|(
name|metaRaw
operator|!=
literal|null
condition|)
block|{
name|meta
operator|=
operator|new
name|XMPMetadata
argument_list|(
name|XMLUtil
operator|.
name|parse
argument_list|(
name|metaRaw
operator|.
name|createInputStream
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|meta
operator|=
operator|new
name|XMPMetadata
argument_list|()
expr_stmt|;
block|}
comment|// Remove all current Dublin-Core schemas
name|List
argument_list|<
name|XMPSchema
argument_list|>
name|schemas
init|=
name|meta
operator|.
name|getSchemasByNamespaceURI
argument_list|(
name|XMPSchemaDublinCore
operator|.
name|NAMESPACE
argument_list|)
decl_stmt|;
for|for
control|(
name|XMPSchema
name|schema
range|:
name|schemas
control|)
block|{
name|schema
operator|.
name|getElement
argument_list|()
operator|.
name|getParentNode
argument_list|()
operator|.
name|removeChild
argument_list|(
name|schema
operator|.
name|getElement
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|XMPSchemaDublinCore
name|dcSchema
init|=
operator|new
name|XMPSchemaDublinCore
argument_list|(
name|meta
argument_list|)
decl_stmt|;
name|XMPUtil
operator|.
name|writeToDCSchema
argument_list|(
name|dcSchema
argument_list|,
name|entry
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|meta
operator|.
name|addSchema
argument_list|(
name|dcSchema
argument_list|)
expr_stmt|;
block|}
comment|// Save to stream and then input that stream to the PDF
name|ByteArrayOutputStream
name|os
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|meta
operator|.
name|save
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|ByteArrayInputStream
name|is
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|os
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|PDMetadata
name|metadataStream
init|=
operator|new
name|PDMetadata
argument_list|(
name|document
argument_list|,
name|is
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|catalog
operator|.
name|setMetadata
argument_list|(
name|metadataStream
argument_list|)
expr_stmt|;
block|}
comment|/**      * Try to write the given BibTexEntry in the Document Information (the      * properties of the pdf).      *       * Existing fields values are overriden if the bibtex entry has the      * corresponding value set.      *       * @param document      *            The pdf document to write to.      * @param entry      *            The Bibtex entry that is written into the PDF properties. *      * @param database      *            maybenull An optional database which the given bibtex entries      *            belong to, which will be used to resolve strings. If the      *            database is null the strings will not be resolved.      */
DECL|method|writeDocumentInformation (PDDocument document, BibtexEntry entry, BibtexDatabase database)
specifier|private
specifier|static
name|void
name|writeDocumentInformation
parameter_list|(
name|PDDocument
name|document
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
block|{
name|PDDocumentInformation
name|di
init|=
name|document
operator|.
name|getDocumentInformation
argument_list|()
decl_stmt|;
if|if
condition|(
name|database
operator|!=
literal|null
condition|)
block|{
name|entry
operator|=
name|database
operator|.
name|resolveForStrings
argument_list|(
name|entry
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Query privacy filter settings
name|JabRefPreferences
name|prefs
init|=
name|JabRefPreferences
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|boolean
name|useXmpPrivacyFilter
init|=
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"useXmpPrivacyFilter"
argument_list|)
decl_stmt|;
comment|// Fields for which not to write XMP data later on:
name|TreeSet
argument_list|<
name|String
argument_list|>
name|filters
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|prefs
operator|.
name|getStringArray
argument_list|(
name|JabRefPreferences
operator|.
name|XMP_PRIVACY_FILTERS
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// Set all the values including key and entryType
name|Set
argument_list|<
name|String
argument_list|>
name|fields
init|=
name|entry
operator|.
name|getAllFields
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
if|if
condition|(
name|useXmpPrivacyFilter
operator|&&
name|filters
operator|.
name|contains
argument_list|(
name|field
argument_list|)
condition|)
block|{
comment|// erase field instead of adding it
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"author"
argument_list|)
condition|)
block|{
name|di
operator|.
name|setAuthor
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"title"
argument_list|)
condition|)
block|{
name|di
operator|.
name|setTitle
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"keywords"
argument_list|)
condition|)
block|{
name|di
operator|.
name|setKeywords
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"abstract"
argument_list|)
condition|)
block|{
name|di
operator|.
name|setSubject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|di
operator|.
name|setCustomMetadataValue
argument_list|(
literal|"bibtex/"
operator|+
name|field
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"author"
argument_list|)
condition|)
block|{
name|di
operator|.
name|setAuthor
argument_list|(
name|entry
operator|.
name|getField
argument_list|(
literal|"author"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"title"
argument_list|)
condition|)
block|{
name|di
operator|.
name|setTitle
argument_list|(
name|entry
operator|.
name|getField
argument_list|(
literal|"title"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"keywords"
argument_list|)
condition|)
block|{
name|di
operator|.
name|setKeywords
argument_list|(
name|entry
operator|.
name|getField
argument_list|(
literal|"keywords"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"abstract"
argument_list|)
condition|)
block|{
name|di
operator|.
name|setSubject
argument_list|(
name|entry
operator|.
name|getField
argument_list|(
literal|"abstract"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|di
operator|.
name|setCustomMetadataValue
argument_list|(
literal|"bibtex/"
operator|+
name|field
argument_list|,
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|di
operator|.
name|setCustomMetadataValue
argument_list|(
literal|"bibtex/entrytype"
argument_list|,
name|entry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Try to write the given BibTexEntry in the XMP-stream of the given      * PDF-file.      *       * Throws an IOException if the file cannot be read or written, so the user      * can remove a lock or cancel the operation.      *       * The method will overwrite existing BibTeX-XMP-data, but keep other      * existing metadata.      *       * @param file      *            The file to write the entries to.      * @param bibtexEntries      *            The entries to write to the file. *      * @param database      *            maybenull An optional database which the given bibtex entries      *            belong to, which will be used to resolve strings. If the      *            database is null the strings will not be resolved.      * @param writePDFInfo      *            Write information also in PDF document properties      * @throws TransformerException      *             If the entry was malformed or unsupported.      * @throws IOException      *             If the file could not be written to or could not be found.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|writeXMP (File file, Collection<BibtexEntry> bibtexEntries, BibtexDatabase database, boolean writePDFInfo)
specifier|public
specifier|static
name|void
name|writeXMP
parameter_list|(
name|File
name|file
parameter_list|,
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|bibtexEntries
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|,
name|boolean
name|writePDFInfo
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
if|if
condition|(
name|database
operator|!=
literal|null
condition|)
block|{
name|bibtexEntries
operator|=
name|database
operator|.
name|resolveForStrings
argument_list|(
name|bibtexEntries
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|PDDocument
name|document
init|=
literal|null
decl_stmt|;
try|try
block|{
name|document
operator|=
name|PDDocument
operator|.
name|load
argument_list|(
name|file
operator|.
name|getAbsoluteFile
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|document
operator|.
name|isEncrypted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|EncryptionNotSupportedException
argument_list|(
literal|"Error: Cannot add metadata to encrypted document."
argument_list|)
throw|;
block|}
if|if
condition|(
name|writePDFInfo
operator|&&
operator|(
name|bibtexEntries
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
condition|)
block|{
name|XMPUtil
operator|.
name|writeDocumentInformation
argument_list|(
name|document
argument_list|,
name|bibtexEntries
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|XMPUtil
operator|.
name|writeDublinCore
argument_list|(
name|document
argument_list|,
name|bibtexEntries
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|PDDocumentCatalog
name|catalog
init|=
name|document
operator|.
name|getDocumentCatalog
argument_list|()
decl_stmt|;
name|PDMetadata
name|metaRaw
init|=
name|catalog
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|XMPMetadata
name|meta
decl_stmt|;
if|if
condition|(
name|metaRaw
operator|!=
literal|null
condition|)
block|{
name|meta
operator|=
operator|new
name|XMPMetadata
argument_list|(
name|XMLUtil
operator|.
name|parse
argument_list|(
name|metaRaw
operator|.
name|createInputStream
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|meta
operator|=
operator|new
name|XMPMetadata
argument_list|()
expr_stmt|;
block|}
name|meta
operator|.
name|addXMLNSMapping
argument_list|(
name|XMPSchemaBibtex
operator|.
name|NAMESPACE
argument_list|,
name|XMPSchemaBibtex
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// Remove all current Bibtex-schemas
name|List
argument_list|<
name|XMPSchema
argument_list|>
name|schemas
init|=
name|meta
operator|.
name|getSchemasByNamespaceURI
argument_list|(
name|XMPSchemaBibtex
operator|.
name|NAMESPACE
argument_list|)
decl_stmt|;
for|for
control|(
name|XMPSchema
name|schema
range|:
name|schemas
control|)
block|{
name|XMPSchemaBibtex
name|bib
init|=
operator|(
name|XMPSchemaBibtex
operator|)
name|schema
decl_stmt|;
name|bib
operator|.
name|getElement
argument_list|()
operator|.
name|getParentNode
argument_list|()
operator|.
name|removeChild
argument_list|(
name|bib
operator|.
name|getElement
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BibtexEntry
name|e
range|:
name|bibtexEntries
control|)
block|{
name|XMPSchemaBibtex
name|bibtex
init|=
operator|new
name|XMPSchemaBibtex
argument_list|(
name|meta
argument_list|)
decl_stmt|;
name|meta
operator|.
name|addSchema
argument_list|(
name|bibtex
argument_list|)
expr_stmt|;
name|bibtex
operator|.
name|setBibtexEntry
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// Save to stream and then input that stream to the PDF
name|ByteArrayOutputStream
name|os
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|meta
operator|.
name|save
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|ByteArrayInputStream
name|is
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|os
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|PDMetadata
name|metadataStream
init|=
operator|new
name|PDMetadata
argument_list|(
name|document
argument_list|,
name|is
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|catalog
operator|.
name|setMetadata
argument_list|(
name|metadataStream
argument_list|)
expr_stmt|;
comment|// Save
try|try
block|{
name|document
operator|.
name|save
argument_list|(
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|COSVisitorException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|TransformerException
argument_list|(
literal|"Could not write XMP-metadata: "
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|document
operator|!=
literal|null
condition|)
block|{
name|document
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Print usage information for the command line tool xmpUtil.      *       * @see XMPUtil#main(String[])      */
DECL|method|usage ()
specifier|private
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Read or write XMP-metadata from or to pdf file."
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Usage:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Read from PDF and print as bibtex:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  xmpUtil<pdf>"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Read from PDF and print raw XMP:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  xmpUtil -x<pdf>"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Write the entry in<bib> given by<key> to the PDF:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  xmpUtil<key><bib><pdf>"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Write all entries in<bib> to the PDF:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  xmpUtil<bib><pdf>"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"To report bugs visit http://jabref.sourceforge.net"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Command-line tool for working with XMP-data.      *       * Read or write XMP-metadata from or to pdf file.      *       * Usage:      *<dl>      *<dd>Read from PDF and print as bibtex:</dd>      *<dt>xmpUtil PDF</dt>      *<dd>Read from PDF and print raw XMP:</dd>      *<dt>xmpUtil -x PDF</dt>      *<dd>Write the entry in BIB given by KEY to the PDF:</dd>      *<dt>xmpUtil KEY BIB PDF</dt>      *<dd>Write all entries in BIB to the PDF:</dd>      *<dt>xmpUtil BIB PDF</dt>      *</dl>      *       * @param args      *            Command line strings passed to utility.      * @throws IOException      *             If any of the given files could not be read or written.      * @throws TransformerException      *             If the given BibtexEntry is malformed.      */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransformerException
block|{
comment|// Don't forget to initialize the preferences
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|==
literal|null
condition|)
block|{
name|Globals
operator|.
name|prefs
operator|=
name|JabRefPreferences
operator|.
name|getInstance
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|args
operator|.
name|length
condition|)
block|{
case|case
literal|0
case|:
name|XMPUtil
operator|.
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
block|{
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|endsWith
argument_list|(
literal|".pdf"
argument_list|)
condition|)
block|{
comment|// Read from pdf and write as BibTex
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|l
init|=
name|XMPUtil
operator|.
name|readXMP
argument_list|(
operator|new
name|File
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|BibtexEntryWriter
name|bibtexEntryWriter
init|=
operator|new
name|BibtexEntryWriter
argument_list|(
operator|new
name|LatexFieldFormatter
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|l
control|)
block|{
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|bibtexEntryWriter
operator|.
name|write
argument_list|(
name|entry
argument_list|,
name|sw
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|sw
operator|.
name|getBuffer
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|endsWith
argument_list|(
literal|".bib"
argument_list|)
condition|)
block|{
comment|// Read from bib and write as XMP
name|ParserResult
name|result
init|=
name|BibtexParser
operator|.
name|parse
argument_list|(
operator|new
name|FileReader
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
init|=
name|result
operator|.
name|getDatabase
argument_list|()
operator|.
name|getEntries
argument_list|()
decl_stmt|;
if|if
condition|(
name|entries
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Could not find BibtexEntry in "
operator|+
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|XMPUtil
operator|.
name|toXMP
argument_list|(
name|entries
argument_list|,
name|result
operator|.
name|getDatabase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|XMPUtil
operator|.
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|2
case|:
block|{
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"-x"
argument_list|)
operator|&&
name|args
index|[
literal|1
index|]
operator|.
name|endsWith
argument_list|(
literal|".pdf"
argument_list|)
condition|)
block|{
comment|// Read from pdf and write as BibTex
name|XMPMetadata
name|meta
init|=
name|XMPUtil
operator|.
name|readRawXMP
argument_list|(
operator|new
name|File
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|meta
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"The given pdf does not contain any XMP-metadata."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XMLUtil
operator|.
name|save
argument_list|(
name|meta
operator|.
name|getXMPDocument
argument_list|()
argument_list|,
name|System
operator|.
name|out
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|endsWith
argument_list|(
literal|".bib"
argument_list|)
operator|&&
name|args
index|[
literal|1
index|]
operator|.
name|endsWith
argument_list|(
literal|".pdf"
argument_list|)
condition|)
block|{
name|ParserResult
name|result
init|=
name|BibtexParser
operator|.
name|parse
argument_list|(
operator|new
name|FileReader
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
init|=
name|result
operator|.
name|getDatabase
argument_list|()
operator|.
name|getEntries
argument_list|()
decl_stmt|;
if|if
condition|(
name|entries
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Could not find BibtexEntry in "
operator|+
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XMPUtil
operator|.
name|writeXMP
argument_list|(
operator|new
name|File
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|entries
argument_list|,
name|result
operator|.
name|getDatabase
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"XMP written."
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|XMPUtil
operator|.
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
literal|3
case|:
block|{
if|if
condition|(
operator|!
name|args
index|[
literal|1
index|]
operator|.
name|endsWith
argument_list|(
literal|".bib"
argument_list|)
operator|&&
operator|!
name|args
index|[
literal|2
index|]
operator|.
name|endsWith
argument_list|(
literal|".pdf"
argument_list|)
condition|)
block|{
name|XMPUtil
operator|.
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
name|ParserResult
name|result
init|=
name|BibtexParser
operator|.
name|parse
argument_list|(
operator|new
name|FileReader
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|BibtexEntry
name|e
init|=
name|result
operator|.
name|getDatabase
argument_list|()
operator|.
name|getEntryByKey
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Could not find BibtexEntry "
operator|+
name|args
index|[
literal|0
index|]
operator|+
literal|" in "
operator|+
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XMPUtil
operator|.
name|writeXMP
argument_list|(
operator|new
name|File
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|e
argument_list|,
name|result
operator|.
name|getDatabase
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"XMP written."
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|XMPUtil
operator|.
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Will try to read XMP metadata from the given file, returning whether      * metadata was found.      *       * Caution: This method is as expensive as it is reading the actual metadata      * itself from the PDF.      *       * @param is      *            The inputstream to read the PDF from.      * @return whether a BibtexEntry was found in the given PDF.      */
DECL|method|hasMetadata (InputStream is)
specifier|public
specifier|static
name|boolean
name|hasMetadata
parameter_list|(
name|InputStream
name|is
parameter_list|)
block|{
try|try
block|{
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|l
init|=
name|XMPUtil
operator|.
name|readXMP
argument_list|(
name|is
argument_list|)
decl_stmt|;
return|return
name|l
operator|.
name|size
argument_list|()
operator|>
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
end_class

end_unit

