begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003-2012 JabRef contributors.     Copyright (C) 2015 Oliver Kopp      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License along     with this program; if not, write to the Free Software Foundation, Inc.,     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */
end_comment

begin_comment
comment|// created by : Morten O. Alver 2003
end_comment

begin_package
DECL|package|net.sf.jabref.util
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|BorderLayout
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|CardLayout
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Dimension
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Font
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|ActionEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|ActionListener
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|Action
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|ActionMap
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|BorderFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|Box
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|InputMap
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JButton
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JComponent
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JDialog
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JFrame
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JLabel
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JOptionPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JPanel
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JProgressBar
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JRootPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JScrollPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JTextArea
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|SwingUtilities
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|undo
operator|.
name|AbstractUndoableEdit
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|undo
operator|.
name|UndoableEdit
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|l10n
operator|.
name|Localization
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|util
operator|.
name|date
operator|.
name|MonthUtil
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|util
operator|.
name|date
operator|.
name|YearUtil
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|util
operator|.
name|io
operator|.
name|FileFinder
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|util
operator|.
name|io
operator|.
name|FileNameCleaner
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|util
operator|.
name|io
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|util
operator|.
name|strings
operator|.
name|StringUtil
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|util
operator|.
name|strings
operator|.
name|UnicodeCharMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|worker
operator|.
name|AbstractWorker
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|AuthorList
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibtexDatabase
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|BibtexEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|BibtexFields
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|worker
operator|.
name|CallBack
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|util
operator|.
name|date
operator|.
name|EasyDateFormat
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|EntryMarker
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|GUIGlobals
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|Globals
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|preftabs
operator|.
name|ImportSettingsTab
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|JabRefPreferences
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|MetaData
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|OpenFileFilter
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|worker
operator|.
name|Worker
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|exporter
operator|.
name|layout
operator|.
name|Layout
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|exporter
operator|.
name|layout
operator|.
name|LayoutHelper
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|ExternalFileType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|RegExpFileSearch
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|UnknownExternalFileType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|structure
operator|.
name|AbstractGroup
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|structure
operator|.
name|KeywordGroup
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|FileListEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|FileListTableModel
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|labelPattern
operator|.
name|LabelPatternUtil
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|undo
operator|.
name|NamedCompound
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|undo
operator|.
name|UndoableFieldChange
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jgoodies
operator|.
name|forms
operator|.
name|builder
operator|.
name|DefaultFormBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jgoodies
operator|.
name|forms
operator|.
name|layout
operator|.
name|FormLayout
import|;
end_import

begin_comment
comment|/**  * utility functions  */
end_comment

begin_class
DECL|class|Util
specifier|public
class|class
name|Util
block|{
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Log
name|LOGGER
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|Util
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|REMOTE_LINK_PATTERN
specifier|public
specifier|static
specifier|final
name|Pattern
name|REMOTE_LINK_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[a-z]+://.*"
argument_list|)
decl_stmt|;
DECL|field|dateFormatter
specifier|private
specifier|static
specifier|final
name|EasyDateFormat
name|dateFormatter
init|=
operator|new
name|EasyDateFormat
argument_list|()
decl_stmt|;
DECL|field|ARXIV_LOOKUP_PREFIX
specifier|public
specifier|static
specifier|final
name|String
name|ARXIV_LOOKUP_PREFIX
init|=
literal|"http://arxiv.org/abs/"
decl_stmt|;
DECL|field|SEPARATING_CHARS_NOSPACE
specifier|private
specifier|static
specifier|final
name|String
name|SEPARATING_CHARS_NOSPACE
init|=
literal|";,\n"
decl_stmt|;
DECL|field|UNICODE_CHAR_MAP
specifier|private
specifier|static
specifier|final
name|UnicodeCharMap
name|UNICODE_CHAR_MAP
init|=
operator|new
name|UnicodeCharMap
argument_list|()
decl_stmt|;
comment|/**      * This method sets the location of a Dialog such that it is centered with      * regard to another window, but not outside the screen on the left and the      * top.      */
DECL|method|placeDialog (java.awt.Dialog diag, java.awt.Container win)
specifier|public
specifier|static
name|void
name|placeDialog
parameter_list|(
name|java
operator|.
name|awt
operator|.
name|Dialog
name|diag
parameter_list|,
name|java
operator|.
name|awt
operator|.
name|Container
name|win
parameter_list|)
block|{
name|diag
operator|.
name|setLocationRelativeTo
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method translates a field or string from Bibtex notation, with      * possibly text contained in " " or { }, and string references,      * concatenated by '#' characters, into Bibkeeper notation, where string      * references are enclosed in a pair of '#' characters.      */
DECL|method|parseField (String content)
specifier|public
specifier|static
name|String
name|parseField
parameter_list|(
name|String
name|content
parameter_list|)
block|{
if|if
condition|(
name|content
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|content
return|;
block|}
name|String
index|[]
name|strings
init|=
name|content
operator|.
name|split
argument_list|(
literal|"#"
argument_list|)
decl_stmt|;
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|string
range|:
name|strings
control|)
block|{
name|String
name|s
init|=
name|string
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// String reference or not?
if|if
condition|(
name|c
operator|==
literal|'{'
operator|||
name|c
operator|==
literal|'"'
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|StringUtil
operator|.
name|shaveString
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This part should normally be a string reference, but if it's
comment|// a pure number, it is not.
name|String
name|s2
init|=
name|StringUtil
operator|.
name|shaveString
argument_list|(
name|s
argument_list|)
decl_stmt|;
try|try
block|{
name|Integer
operator|.
name|parseInt
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|s2
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|'#'
argument_list|)
operator|.
name|append
argument_list|(
name|s2
argument_list|)
operator|.
name|append
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Will return the publication date of the given bibtex entry in conformance      * to ISO 8601, i.e. either YYYY or YYYY-MM.      *       * @param entry      * @return will return the publication date of the entry or null if no year      *         was found.      */
comment|// TODO: Should be instance method of BibTexEntry
DECL|method|getPublicationDate (BibtexEntry entry)
specifier|public
specifier|static
name|String
name|getPublicationDate
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|)
block|{
name|Object
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
literal|"year"
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|year
init|=
name|YearUtil
operator|.
name|toFourDigitYear
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|o
operator|=
name|entry
operator|.
name|getField
argument_list|(
literal|"month"
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|MonthUtil
operator|.
name|Month
name|month
init|=
name|MonthUtil
operator|.
name|getMonth
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|month
operator|.
name|isValid
argument_list|()
condition|)
block|{
return|return
name|year
operator|+
literal|"-"
operator|+
name|month
operator|.
name|twoDigitNumber
return|;
block|}
block|}
return|return
name|year
return|;
block|}
comment|/**      * This method returns a String similar to the one passed in, except that it      * is molded into a form that is acceptable for bibtex.      *       * Watch-out that the returned string might be of length 0 afterwards.      *       * @param key      *            mayBeNull      */
DECL|method|checkLegalKey (String key)
specifier|public
specifier|static
name|String
name|checkLegalKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|JabRefPreferences
operator|.
name|getInstance
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|ENFORCE_LEGAL_BIBTEX_KEY
argument_list|)
condition|)
block|{
comment|// User doesn't want us to enforce legal characters. We must still look
comment|// for whitespace and some characters such as commas, since these would
comment|// interfere with parsing:
name|StringBuilder
name|newKey
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|key
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|key
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'{'
operator|&&
name|c
operator|!=
literal|'\\'
operator|&&
name|c
operator|!=
literal|'"'
operator|&&
name|c
operator|!=
literal|'}'
operator|&&
name|c
operator|!=
literal|','
condition|)
block|{
name|newKey
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|newKey
operator|.
name|toString
argument_list|()
return|;
block|}
name|StringBuilder
name|newKey
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|key
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|key
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'#'
operator|&&
name|c
operator|!=
literal|'{'
operator|&&
name|c
operator|!=
literal|'\\'
operator|&&
name|c
operator|!=
literal|'"'
operator|&&
name|c
operator|!=
literal|'}'
operator|&&
name|c
operator|!=
literal|'~'
operator|&&
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|'^'
operator|&&
name|c
operator|!=
literal|'\''
condition|)
block|{
name|newKey
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Replace non-english characters like umlauts etc. with a sensible
comment|// letter or letter combination that bibtex can accept.
return|return
name|Util
operator|.
name|replaceSpecialCharacters
argument_list|(
name|newKey
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Replace non-english characters like umlauts etc. with a sensible letter      * or letter combination that bibtex can accept. The basis for replacement      * is the HashMap Globals.UNICODE_CHARS.      */
DECL|method|replaceSpecialCharacters (String s)
specifier|public
specifier|static
name|String
name|replaceSpecialCharacters
parameter_list|(
name|String
name|s
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|chrAndReplace
range|:
name|UNICODE_CHAR_MAP
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|s
operator|=
name|s
operator|.
name|replaceAll
argument_list|(
name|chrAndReplace
operator|.
name|getKey
argument_list|()
argument_list|,
name|chrAndReplace
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
DECL|method|findDeliminatedWordsInField (BibtexDatabase db, String field, String deliminator)
specifier|public
specifier|static
name|TreeSet
argument_list|<
name|String
argument_list|>
name|findDeliminatedWordsInField
parameter_list|(
name|BibtexDatabase
name|db
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|deliminator
parameter_list|)
block|{
name|TreeSet
argument_list|<
name|String
argument_list|>
name|res
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|db
operator|.
name|getKeySet
argument_list|()
control|)
block|{
name|BibtexEntry
name|be
init|=
name|db
operator|.
name|getEntryById
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|Object
name|o
init|=
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|String
name|fieldValue
init|=
name|o
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|StringTokenizer
name|tok
init|=
operator|new
name|StringTokenizer
argument_list|(
name|fieldValue
argument_list|,
name|deliminator
argument_list|)
decl_stmt|;
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|res
operator|.
name|add
argument_list|(
name|StringUtil
operator|.
name|capitalizeFirst
argument_list|(
name|tok
operator|.
name|nextToken
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|res
return|;
block|}
comment|/**      * Returns a HashMap containing all words used in the database in the given      * field type. Characters in<code>remove</code> are not included.      *       * @param db      *            a<code>BibtexDatabase</code> value      * @param field      *            a<code>String</code> value      * @param remove      *            a<code>String</code> value      * @return a<code>HashSet</code> value      */
DECL|method|findAllWordsInField (BibtexDatabase db, String field, String remove)
specifier|public
specifier|static
name|TreeSet
argument_list|<
name|String
argument_list|>
name|findAllWordsInField
parameter_list|(
name|BibtexDatabase
name|db
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|remove
parameter_list|)
block|{
name|TreeSet
argument_list|<
name|String
argument_list|>
name|res
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|StringTokenizer
name|tok
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|db
operator|.
name|getKeySet
argument_list|()
control|)
block|{
name|BibtexEntry
name|be
init|=
name|db
operator|.
name|getEntryById
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|Object
name|o
init|=
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|tok
operator|=
operator|new
name|StringTokenizer
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|,
name|remove
argument_list|,
literal|false
argument_list|)
expr_stmt|;
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|res
operator|.
name|add
argument_list|(
name|StringUtil
operator|.
name|capitalizeFirst
argument_list|(
name|tok
operator|.
name|nextToken
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|res
return|;
block|}
comment|/**      * Finds all authors' last names in all the given fields for the given database.      * @param db The database.      * @param fields The fields to look in.      * @return a set containing the names.      */
DECL|method|findAuthorLastNames (BibtexDatabase db, List<String> fields)
specifier|public
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|findAuthorLastNames
parameter_list|(
name|BibtexDatabase
name|db
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|res
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|db
operator|.
name|getKeySet
argument_list|()
control|)
block|{
name|BibtexEntry
name|be
init|=
name|db
operator|.
name|getEntryById
argument_list|(
name|s
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
name|String
name|val
init|=
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
operator|&&
operator|!
name|val
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|AuthorList
name|al
init|=
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|val
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|al
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|AuthorList
operator|.
name|Author
name|a
init|=
name|al
operator|.
name|getAuthor
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|lastName
init|=
name|a
operator|.
name|getLast
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastName
operator|!=
literal|null
operator|&&
operator|!
name|lastName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|res
operator|.
name|add
argument_list|(
name|lastName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|res
return|;
block|}
comment|/**      * Make sure an URL is "portable", in that it doesn't contain bad characters      * that break the open command in some OSes.      *       * A call to this method will also remove \\url{} enclosings and clean Doi links. 	 *  	 * @param link :the URL to sanitize. 	 * @return Sanitized URL 	 */
DECL|method|sanitizeUrl (String link)
specifier|public
specifier|static
name|String
name|sanitizeUrl
parameter_list|(
name|String
name|link
parameter_list|)
block|{
name|link
operator|=
name|link
operator|.
name|trim
argument_list|()
expr_stmt|;
comment|// First check if it is enclosed in \\url{}. If so, remove the wrapper.
if|if
condition|(
name|link
operator|.
name|startsWith
argument_list|(
literal|"\\url{"
argument_list|)
operator|&&
name|link
operator|.
name|endsWith
argument_list|(
literal|"}"
argument_list|)
condition|)
block|{
name|link
operator|=
name|link
operator|.
name|substring
argument_list|(
literal|5
argument_list|,
name|link
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// DOI cleanup
comment|// converts doi-only link to full http address
comment|// Morten Alver 6 Nov 2012: this extracts a nonfunctional Doi from some complete
comment|// http addresses (e.g. http://onlinelibrary.wiley.com/doi/10.1002/rra.999/abstract, where
comment|// the trailing "/abstract" is included but doesn't lead to a resolvable Doi).
comment|// To prevent mangling of working URLs I'm disabling this check if the link is already
comment|// a full http link:
comment|// TODO: not sure if this is allowed
if|if
condition|(
name|link
operator|.
name|matches
argument_list|(
literal|"^doi:/*.*"
argument_list|)
condition|)
block|{
comment|// Remove 'doi:'
name|link
operator|=
name|link
operator|.
name|replaceFirst
argument_list|(
literal|"^doi:/*"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|link
operator|=
operator|new
name|DOI
argument_list|(
name|link
argument_list|)
operator|.
name|getURLAsASCIIString
argument_list|()
expr_stmt|;
block|}
name|Optional
argument_list|<
name|DOI
argument_list|>
name|doi
init|=
name|DOI
operator|.
name|build
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|doi
operator|.
name|isPresent
argument_list|()
operator|&&
operator|!
name|link
operator|.
name|matches
argument_list|(
literal|"^https?://.*"
argument_list|)
condition|)
block|{
name|link
operator|=
name|doi
operator|.
name|get
argument_list|()
operator|.
name|getURLAsASCIIString
argument_list|()
expr_stmt|;
block|}
comment|// FIXME: everything below is really flawed atm
name|link
operator|=
name|link
operator|.
name|replaceAll
argument_list|(
literal|"\\+"
argument_list|,
literal|"%2B"
argument_list|)
expr_stmt|;
try|try
block|{
name|link
operator|=
name|URLDecoder
operator|.
name|decode
argument_list|(
name|link
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|ignored
parameter_list|)
block|{         }
comment|/**          * Fix for: [ 1574773 ] sanitizeUrl() breaks ftp:// and file:///          *           * http://sourceforge.net/tracker/index.php?func=detail&aid=1574773&group_id=92314&atid=600306          */
try|try
block|{
return|return
operator|new
name|URI
argument_list|(
literal|null
argument_list|,
name|link
argument_list|,
literal|null
argument_list|)
operator|.
name|toASCIIString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
return|return
name|link
return|;
block|}
block|}
DECL|method|parseMethodsCalls (String calls)
specifier|public
specifier|static
name|ArrayList
argument_list|<
name|String
index|[]
argument_list|>
name|parseMethodsCalls
parameter_list|(
name|String
name|calls
parameter_list|)
throws|throws
name|RuntimeException
block|{
name|ArrayList
argument_list|<
name|String
index|[]
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|String
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|char
index|[]
name|c
init|=
name|calls
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|c
operator|.
name|length
condition|)
block|{
name|int
name|start
init|=
name|i
decl_stmt|;
if|if
condition|(
name|Character
operator|.
name|isJavaIdentifierStart
argument_list|(
name|c
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|c
operator|.
name|length
operator|&&
operator|(
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|c
index|[
name|i
index|]
argument_list|)
operator|||
name|c
index|[
name|i
index|]
operator|==
literal|'.'
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|c
operator|.
name|length
operator|&&
name|c
index|[
name|i
index|]
operator|==
literal|'('
condition|)
block|{
name|String
name|method
init|=
name|calls
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|// Skip the brace
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|c
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|c
index|[
name|i
index|]
operator|==
literal|'"'
condition|)
block|{
comment|// Parameter is in format "xxx"
comment|// Skip "
name|i
operator|++
expr_stmt|;
name|int
name|startParam
init|=
name|i
decl_stmt|;
name|i
operator|++
expr_stmt|;
name|boolean
name|escaped
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|i
operator|+
literal|1
operator|<
name|c
operator|.
name|length
operator|&&
operator|!
operator|(
operator|!
name|escaped
operator|&&
name|c
index|[
name|i
index|]
operator|==
literal|'"'
operator|&&
name|c
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|')'
operator|)
condition|)
block|{
if|if
condition|(
name|c
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
name|escaped
operator|=
operator|!
name|escaped
expr_stmt|;
block|}
else|else
block|{
name|escaped
operator|=
literal|false
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|String
name|param
init|=
name|calls
operator|.
name|substring
argument_list|(
name|startParam
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
operator|new
name|String
index|[]
block|{
name|method
block|,
name|param
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Parameter is in format xxx
name|int
name|startParam
init|=
name|i
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|c
operator|.
name|length
operator|&&
name|c
index|[
name|i
index|]
operator|!=
literal|')'
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
name|String
name|param
init|=
name|calls
operator|.
name|substring
argument_list|(
name|startParam
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
operator|new
name|String
index|[]
block|{
name|method
block|,
name|param
block|}
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Incorrecly terminated open brace
name|result
operator|.
name|add
argument_list|(
operator|new
name|String
index|[]
block|{
name|method
block|}
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
name|method
init|=
name|calls
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
operator|new
name|String
index|[]
block|{
name|method
block|}
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Takes a string that contains bracketed expression and expands each of      * these using getFieldAndFormat.      *      * Unknown Bracket expressions are silently dropped.      *      * @param bracketString      * @param entry      * @param database      * @return      */
DECL|field|squareBracketsPattern
specifier|private
specifier|static
specifier|final
name|Pattern
name|squareBracketsPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\[.*?\\]"
argument_list|)
decl_stmt|;
DECL|method|expandBrackets (String bracketString, BibtexEntry entry, BibtexDatabase database)
specifier|public
specifier|static
name|String
name|expandBrackets
parameter_list|(
name|String
name|bracketString
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
block|{
name|Matcher
name|m
init|=
name|Util
operator|.
name|squareBracketsPattern
operator|.
name|matcher
argument_list|(
name|bracketString
argument_list|)
decl_stmt|;
name|StringBuffer
name|s
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|replacement
init|=
name|Util
operator|.
name|getFieldAndFormat
argument_list|(
name|m
operator|.
name|group
argument_list|()
argument_list|,
name|entry
argument_list|,
name|database
argument_list|)
decl_stmt|;
if|if
condition|(
name|replacement
operator|==
literal|null
condition|)
block|{
name|replacement
operator|=
literal|""
expr_stmt|;
block|}
name|m
operator|.
name|appendReplacement
argument_list|(
name|s
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
block|}
name|m
operator|.
name|appendTail
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Sets empty or non-existing owner fields of bibtex entries inside a List      * to a specified default value. Timestamp field is also set. Preferences      * are checked to see if these options are enabled.      *       * @param bibs      *            List of bibtex entries      */
DECL|method|setAutomaticFields (Collection<BibtexEntry> bibs, boolean overwriteOwner, boolean overwriteTimestamp, boolean markEntries)
specifier|public
specifier|static
name|void
name|setAutomaticFields
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|bibs
parameter_list|,
name|boolean
name|overwriteOwner
parameter_list|,
name|boolean
name|overwriteTimestamp
parameter_list|,
name|boolean
name|markEntries
parameter_list|)
block|{
name|String
name|timeStampField
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|TIME_STAMP_FIELD
argument_list|)
decl_stmt|;
name|String
name|defaultOwner
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|DEFAULT_OWNER
argument_list|)
decl_stmt|;
name|String
name|timestamp
init|=
name|dateFormatter
operator|.
name|getCurrentDate
argument_list|()
decl_stmt|;
name|boolean
name|globalSetOwner
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|USE_OWNER
argument_list|)
decl_stmt|;
name|boolean
name|globalSetTimeStamp
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|USE_TIME_STAMP
argument_list|)
decl_stmt|;
comment|// Do not need to do anything if all options are disabled
if|if
condition|(
operator|!
operator|(
name|globalSetOwner
operator|||
name|globalSetTimeStamp
operator|||
name|markEntries
operator|)
condition|)
block|{
return|return;
block|}
comment|// Iterate through all entries
for|for
control|(
name|BibtexEntry
name|curEntry
range|:
name|bibs
control|)
block|{
name|boolean
name|setOwner
init|=
name|globalSetOwner
operator|&&
operator|(
name|overwriteOwner
operator|||
name|curEntry
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|OWNER
argument_list|)
operator|==
literal|null
operator|)
decl_stmt|;
name|boolean
name|setTimeStamp
init|=
name|globalSetTimeStamp
operator|&&
operator|(
name|overwriteTimestamp
operator|||
name|curEntry
operator|.
name|getField
argument_list|(
name|timeStampField
argument_list|)
operator|==
literal|null
operator|)
decl_stmt|;
name|Util
operator|.
name|setAutomaticFields
argument_list|(
name|curEntry
argument_list|,
name|setOwner
argument_list|,
name|defaultOwner
argument_list|,
name|setTimeStamp
argument_list|,
name|timeStampField
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|markEntries
condition|)
block|{
name|EntryMarker
operator|.
name|markEntry
argument_list|(
name|curEntry
argument_list|,
name|EntryMarker
operator|.
name|IMPORT_MARK_LEVEL
argument_list|,
literal|false
argument_list|,
operator|new
name|NamedCompound
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Sets empty or non-existing owner fields of a bibtex entry to a specified      * default value. Timestamp field is also set. Preferences are checked to      * see if these options are enabled.      *       * @param entry      *            The entry to set fields for.      * @param overwriteOwner      *              Indicates whether owner should be set if it is already set.      * @param overwriteTimestamp      *              Indicates whether timestamp should be set if it is already set.      */
DECL|method|setAutomaticFields (BibtexEntry entry, boolean overwriteOwner, boolean overwriteTimestamp)
specifier|public
specifier|static
name|void
name|setAutomaticFields
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|boolean
name|overwriteOwner
parameter_list|,
name|boolean
name|overwriteTimestamp
parameter_list|)
block|{
name|String
name|defaultOwner
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|DEFAULT_OWNER
argument_list|)
decl_stmt|;
name|String
name|timestamp
init|=
name|dateFormatter
operator|.
name|getCurrentDate
argument_list|()
decl_stmt|;
name|String
name|timeStampField
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|TIME_STAMP_FIELD
argument_list|)
decl_stmt|;
name|boolean
name|setOwner
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|USE_OWNER
argument_list|)
operator|&&
operator|(
name|overwriteOwner
operator|||
name|entry
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|OWNER
argument_list|)
operator|==
literal|null
operator|)
decl_stmt|;
name|boolean
name|setTimeStamp
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|USE_TIME_STAMP
argument_list|)
operator|&&
operator|(
name|overwriteTimestamp
operator|||
name|entry
operator|.
name|getField
argument_list|(
name|timeStampField
argument_list|)
operator|==
literal|null
operator|)
decl_stmt|;
name|Util
operator|.
name|setAutomaticFields
argument_list|(
name|entry
argument_list|,
name|setOwner
argument_list|,
name|defaultOwner
argument_list|,
name|setTimeStamp
argument_list|,
name|timeStampField
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
block|}
DECL|method|setAutomaticFields (BibtexEntry entry, boolean setOwner, String owner, boolean setTimeStamp, String timeStampField, String timeStamp)
specifier|private
specifier|static
name|void
name|setAutomaticFields
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|boolean
name|setOwner
parameter_list|,
name|String
name|owner
parameter_list|,
name|boolean
name|setTimeStamp
parameter_list|,
name|String
name|timeStampField
parameter_list|,
name|String
name|timeStamp
parameter_list|)
block|{
comment|// Set owner field if this option is enabled:
if|if
condition|(
name|setOwner
condition|)
block|{
comment|// No or empty owner field?
comment|// if (entry.getField(Globals.OWNER) == null
comment|// || ((String) entry.getField(Globals.OWNER)).length() == 0) {
comment|// Set owner field to default value
name|entry
operator|.
name|setField
argument_list|(
name|BibtexFields
operator|.
name|OWNER
argument_list|,
name|owner
argument_list|)
expr_stmt|;
comment|// }
block|}
if|if
condition|(
name|setTimeStamp
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|timeStampField
argument_list|,
name|timeStamp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Collect file links from the given set of fields, and add them to the list contained      * in the field GUIGlobals.FILE_FIELD.      * @param database The database to modify.      * @param fields The fields to find links in.      * @return A CompoundEdit specifying the undo operation for the whole operation.      */
DECL|method|upgradePdfPsToFile (BibtexDatabase database, String[] fields)
specifier|public
specifier|static
name|NamedCompound
name|upgradePdfPsToFile
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|String
index|[]
name|fields
parameter_list|)
block|{
return|return
name|Util
operator|.
name|upgradePdfPsToFile
argument_list|(
name|database
operator|.
name|getEntryMap
argument_list|()
operator|.
name|values
argument_list|()
argument_list|,
name|fields
argument_list|)
return|;
block|}
comment|/**      * Collect file links from the given set of fields, and add them to the list contained      * in the field GUIGlobals.FILE_FIELD.      * @param entries The entries to modify.      * @param fields The fields to find links in.      * @return A CompoundEdit specifying the undo operation for the whole operation.      */
DECL|method|upgradePdfPsToFile (Collection<BibtexEntry> entries, String[] fields)
specifier|public
specifier|static
name|NamedCompound
name|upgradePdfPsToFile
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
name|String
index|[]
name|fields
parameter_list|)
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Move external links to 'file' field"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|FileListTableModel
name|tableModel
init|=
operator|new
name|FileListTableModel
argument_list|()
decl_stmt|;
comment|// If there are already links in the file field, keep those on top:
name|String
name|oldFileContent
init|=
name|entry
operator|.
name|getField
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldFileContent
operator|!=
literal|null
condition|)
block|{
name|tableModel
operator|.
name|setContent
argument_list|(
name|oldFileContent
argument_list|)
expr_stmt|;
block|}
name|int
name|oldRowCount
init|=
name|tableModel
operator|.
name|getRowCount
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
name|String
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|o
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|FileListEntry
name|flEntry
init|=
operator|new
name|FileListEntry
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|o
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeByExt
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
name|tableModel
operator|.
name|addEntry
argument_list|(
name|tableModel
operator|.
name|getRowCount
argument_list|()
argument_list|,
name|flEntry
argument_list|)
expr_stmt|;
name|entry
operator|.
name|clearField
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|field
argument_list|,
name|o
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tableModel
operator|.
name|getRowCount
argument_list|()
operator|!=
name|oldRowCount
condition|)
block|{
name|String
name|newValue
init|=
name|tableModel
operator|.
name|getStringRepresentation
argument_list|()
decl_stmt|;
name|entry
operator|.
name|setField
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|,
name|oldFileContent
argument_list|,
name|newValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
return|return
name|ce
return|;
block|}
comment|/**      * Warns the user of undesired side effects of an explicit      * assignment/removal of entries to/from this group. Currently there are      * four types of groups: AllEntriesGroup, SearchGroup - do not support      * explicit assignment. ExplicitGroup - never modifies entries. KeywordGroup -      * only this modifies entries upon assignment/removal. Modifications are      * acceptable unless they affect a standard field (such as "author") besides      * the "keywords" field.      *       * @param parent      *            The Component used as a parent when displaying a confirmation      *            dialog.      * @return true if the assignment has no undesired side effects, or the user      *         chose to perform it anyway. false otherwise (this indicates that      *         the user has aborted the assignment).      */
DECL|method|warnAssignmentSideEffects (AbstractGroup[] groups, BibtexEntry[] entries, BibtexDatabase db, Component parent)
specifier|public
specifier|static
name|boolean
name|warnAssignmentSideEffects
parameter_list|(
name|AbstractGroup
index|[]
name|groups
parameter_list|,
name|BibtexEntry
index|[]
name|entries
parameter_list|,
name|BibtexDatabase
name|db
parameter_list|,
name|Component
name|parent
parameter_list|)
block|{
name|Vector
argument_list|<
name|String
argument_list|>
name|affectedFields
init|=
operator|new
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|AbstractGroup
name|group
range|:
name|groups
control|)
block|{
if|if
condition|(
name|group
operator|instanceof
name|KeywordGroup
condition|)
block|{
name|KeywordGroup
name|kg
init|=
operator|(
name|KeywordGroup
operator|)
name|group
decl_stmt|;
name|String
name|field
init|=
name|kg
operator|.
name|getSearchField
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"keywords"
argument_list|)
condition|)
block|{
continue|continue;
comment|// this is not undesired
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|BibtexFields
operator|.
name|numberOfPublicFields
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
name|BibtexFields
operator|.
name|getFieldName
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|affectedFields
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|affectedFields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
comment|// no side effects
block|}
comment|// show a warning, then return
name|StringBuffer
name|message
init|=
comment|// JZTODO lyrics...
operator|new
name|StringBuffer
argument_list|(
literal|"This action will modify the following field(s)\n"
operator|+
literal|"in at least one entry each:\n"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|affectedFields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|message
operator|.
name|append
argument_list|(
name|affectedFields
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|message
operator|.
name|append
argument_list|(
literal|"This could cause undesired changes to "
operator|+
literal|"your entries, so it is\nrecommended that you change the grouping field "
operator|+
literal|"in your group\ndefinition to \"keywords\" or a non-standard name."
operator|+
literal|"\n\nDo you still want to continue?"
argument_list|)
expr_stmt|;
name|int
name|choice
init|=
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|parent
argument_list|,
name|message
argument_list|,
name|Localization
operator|.
name|lang
argument_list|(
literal|"Warning"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_OPTION
argument_list|,
name|JOptionPane
operator|.
name|WARNING_MESSAGE
argument_list|)
decl_stmt|;
return|return
name|choice
operator|!=
name|JOptionPane
operator|.
name|NO_OPTION
return|;
comment|// if (groups instanceof KeywordGroup) {
comment|// KeywordGroup kg = (KeywordGroup) groups;
comment|// String field = kg.getSearchField().toLowerCase();
comment|// if (field.equals("keywords"))
comment|// return true; // this is not undesired
comment|// for (int i = 0; i< GUIGlobals.ALL_FIELDS.length; ++i) {
comment|// if (field.equals(GUIGlobals.ALL_FIELDS[i])) {
comment|// // show a warning, then return
comment|// String message = Globals // JZTODO lyrics...
comment|// .lang(
comment|// "This action will modify the \"%0\" field "
comment|// + "of your entries.\nThis could cause undesired changes to "
comment|// + "your entries, so it is\nrecommended that you change the grouping
comment|// field "
comment|// + "in your group\ndefinition to \"keywords\" or a non-standard name."
comment|// + "\n\nDo you still want to continue?",
comment|// field);
comment|// int choice = JOptionPane.showConfirmDialog(parent, message,
comment|// Globals.lang("Warning"), JOptionPane.YES_NO_OPTION,
comment|// JOptionPane.WARNING_MESSAGE);
comment|// return choice != JOptionPane.NO_OPTION;
comment|// }
comment|// }
comment|// }
comment|// return true; // found no side effects
block|}
comment|/**      * This method looks up what kind of external binding is used for the given      * field, and constructs on OpenFileFilter suitable for browsing for an      * external file.      *       * @param fieldName      *            The BibTeX field in question.      * @return The file filter.      */
DECL|method|getFileFilterForField (String fieldName)
specifier|public
specifier|static
name|OpenFileFilter
name|getFileFilterForField
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|String
name|s
init|=
name|BibtexFields
operator|.
name|getFieldExtras
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
specifier|final
name|String
name|ext
init|=
literal|"."
operator|+
name|fieldName
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
specifier|final
name|OpenFileFilter
name|off
decl_stmt|;
if|if
condition|(
literal|"browseDocZip"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|off
operator|=
operator|new
name|OpenFileFilter
argument_list|(
operator|new
name|String
index|[]
block|{
name|ext
block|,
name|ext
operator|+
literal|".gz"
block|,
name|ext
operator|+
literal|".bz2"
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|off
operator|=
operator|new
name|OpenFileFilter
argument_list|(
operator|new
name|String
index|[]
block|{
name|ext
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|off
return|;
block|}
comment|/**      * Set a given field to a given value for all entries in a Collection. This      * method DOES NOT update any UndoManager, but returns a relevant      * CompoundEdit that should be registered by the caller.      *       * @param entries      *            The entries to set the field for.      * @param field      *            The name of the field to set.      * @param text      *            The value to set. This value can be null, indicating that the      *            field should be cleared.      * @param overwriteValues      *            Indicate whether the value should be set even if an entry      *            already has the field set.      * @return A CompoundEdit for the entire operation.      */
DECL|method|massSetField (Collection<BibtexEntry> entries, String field, String text, boolean overwriteValues)
specifier|public
specifier|static
name|UndoableEdit
name|massSetField
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|text
parameter_list|,
name|boolean
name|overwriteValues
parameter_list|)
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Set field"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|String
name|oldVal
init|=
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|// If we are not allowed to overwrite values, check if there is a
comment|// nonempty
comment|// value already for this entry:
if|if
condition|(
operator|!
name|overwriteValues
operator|&&
name|oldVal
operator|!=
literal|null
operator|&&
operator|!
name|oldVal
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|text
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|.
name|clearField
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|field
argument_list|,
name|oldVal
argument_list|,
name|text
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
return|return
name|ce
return|;
block|}
comment|/**      * Move contents from one field to another for a Collection of entries.      * @param entries The entries to do this operation for.      * @param field The field to move contents from.      * @param newField The field to move contents into.      * @param overwriteValues If true, overwrites any existing values in the new field.      *          If false, makes no change for entries with existing value in the new field.      * @return A CompoundEdit for the entire operation.      */
DECL|method|massRenameField (Collection<BibtexEntry> entries, String field, String newField, boolean overwriteValues)
specifier|public
specifier|static
name|UndoableEdit
name|massRenameField
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|newField
parameter_list|,
name|boolean
name|overwriteValues
parameter_list|)
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Rename field"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|String
name|valToMove
init|=
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|// If there is no value, do nothing:
if|if
condition|(
name|valToMove
operator|==
literal|null
operator|||
name|valToMove
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|// If we are not allowed to overwrite values, check if there is a
comment|// nonempy value already for this entry for the new field:
name|String
name|valInNewField
init|=
name|entry
operator|.
name|getField
argument_list|(
name|newField
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|overwriteValues
operator|&&
name|valInNewField
operator|!=
literal|null
operator|&&
operator|!
name|valInNewField
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|entry
operator|.
name|setField
argument_list|(
name|newField
argument_list|,
name|valToMove
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|newField
argument_list|,
name|valInNewField
argument_list|,
name|valToMove
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|clearField
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|field
argument_list|,
name|valToMove
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
return|return
name|ce
return|;
block|}
comment|/**      * Optimized method for converting a String into an Integer      *      * From http://stackoverflow.com/questions/1030479/most-efficient-way-of-converting-string-to-integer-in-java      *      * @param str the String holding an Integer value      * @throws NumberFormatException if str cannot be parsed to an int      * @return the int value of str      */
DECL|method|intValueOf (String str)
specifier|public
specifier|static
name|int
name|intValueOf
parameter_list|(
name|String
name|str
parameter_list|)
block|{
name|int
name|ival
init|=
literal|0
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|int
name|end
decl_stmt|;
name|boolean
name|sign
init|=
literal|false
decl_stmt|;
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|str
operator|==
literal|null
operator|||
operator|(
name|end
operator|=
name|str
operator|.
name|length
argument_list|()
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|ch
operator|=
name|str
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|)
operator|<
literal|'0'
operator|||
name|ch
operator|>
literal|'9'
operator|)
operator|&&
operator|(
operator|!
operator|(
name|sign
operator|=
name|ch
operator|==
literal|'-'
operator|)
operator|||
operator|++
name|idx
operator|==
name|end
operator|||
operator|(
name|ch
operator|=
name|str
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
operator|)
operator|<
literal|'0'
operator|||
name|ch
operator|>
literal|'9'
operator|)
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
name|str
argument_list|)
throw|;
block|}
for|for
control|(
init|;
condition|;
name|ival
operator|*=
literal|10
control|)
block|{
name|ival
operator|+=
literal|'0'
operator|-
name|ch
expr_stmt|;
if|if
condition|(
operator|++
name|idx
operator|==
name|end
condition|)
block|{
return|return
name|sign
condition|?
name|ival
else|:
operator|-
name|ival
return|;
block|}
if|if
condition|(
operator|(
name|ch
operator|=
name|str
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
operator|)
operator|<
literal|'0'
operator|||
name|ch
operator|>
literal|'9'
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
name|str
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Static equals that can also return the right result when one of the      * objects is null.      *       * @param one      *            The object whose equals method is called if the first is not      *            null.      * @param two      *            The object passed to the first one if the first is not null.      * @return<code>one == null ? two == null : one.equals(two);</code>      */
DECL|method|equals (Object one, Object two)
specifier|public
specifier|static
name|boolean
name|equals
parameter_list|(
name|Object
name|one
parameter_list|,
name|Object
name|two
parameter_list|)
block|{
return|return
name|one
operator|==
literal|null
condition|?
name|two
operator|==
literal|null
else|:
name|one
operator|.
name|equals
argument_list|(
name|two
argument_list|)
return|;
block|}
comment|/**      * Run an AbstractWorker's methods using Spin features to put each method      * on the correct thread.      * @param worker The worker to run.      * @throws Throwable       */
DECL|method|runAbstractWorker (AbstractWorker worker)
specifier|public
specifier|static
name|void
name|runAbstractWorker
parameter_list|(
name|AbstractWorker
name|worker
parameter_list|)
throws|throws
name|Throwable
block|{
comment|// This part uses Spin's features:
name|Worker
name|wrk
init|=
name|worker
operator|.
name|getWorker
argument_list|()
decl_stmt|;
comment|// The Worker returned by getWorker() has been wrapped
comment|// by Spin.off(), which makes its methods be run in
comment|// a different thread from the EDT.
name|CallBack
name|clb
init|=
name|worker
operator|.
name|getCallBack
argument_list|()
decl_stmt|;
name|worker
operator|.
name|init
argument_list|()
expr_stmt|;
comment|// This method runs in this same thread, the EDT.
comment|// Useful for initial GUI actions, like printing a message.
comment|// The CallBack returned by getCallBack() has been wrapped
comment|// by Spin.over(), which makes its methods be run on
comment|// the EDT.
name|wrk
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// Runs the potentially time-consuming action
comment|// without freezing the GUI. The magic is that THIS line
comment|// of execution will not continue until run() is finished.
name|clb
operator|.
name|update
argument_list|()
expr_stmt|;
comment|// Runs the update() method on the EDT.
block|}
comment|/**      * Determines filename provided by an entry in a database      *      * @param database the database, where the entry is located      * @param entry the entry to which the file should be linked to      * @return a suggested fileName      */
DECL|method|getLinkedFileName (BibtexDatabase database, BibtexEntry entry)
specifier|public
specifier|static
name|String
name|getLinkedFileName
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|)
block|{
name|String
name|targetName
init|=
name|entry
operator|.
name|getCiteKey
argument_list|()
operator|==
literal|null
condition|?
literal|"default"
else|:
name|entry
operator|.
name|getCiteKey
argument_list|()
decl_stmt|;
name|StringReader
name|sr
init|=
operator|new
name|StringReader
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|ImportSettingsTab
operator|.
name|PREF_IMPORT_FILENAMEPATTERN
argument_list|)
argument_list|)
decl_stmt|;
name|Layout
name|layout
init|=
literal|null
decl_stmt|;
try|try
block|{
name|layout
operator|=
operator|new
name|LayoutHelper
argument_list|(
name|sr
argument_list|)
operator|.
name|getLayoutFromText
argument_list|(
name|Globals
operator|.
name|FORMATTER_PACKAGE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOGGER
operator|.
name|info
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Wrong Format"
argument_list|)
operator|.
name|concat
argument_list|(
literal|" "
argument_list|)
operator|.
name|concat
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|layout
operator|!=
literal|null
condition|)
block|{
name|targetName
operator|=
name|layout
operator|.
name|doLayout
argument_list|(
name|entry
argument_list|,
name|database
argument_list|)
expr_stmt|;
block|}
comment|//Removes illegal characters from filename
name|targetName
operator|=
name|FileNameCleaner
operator|.
name|cleanFileName
argument_list|(
name|targetName
argument_list|)
expr_stmt|;
return|return
name|targetName
return|;
block|}
DECL|method|getSeparatedKeywords (String keywords)
specifier|public
specifier|static
name|ArrayList
argument_list|<
name|String
argument_list|>
name|getSeparatedKeywords
parameter_list|(
name|String
name|keywords
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|res
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|keywords
operator|==
literal|null
condition|)
block|{
return|return
name|res
return|;
block|}
comment|// _NOSPACE is a hack to support keywords such as "choreography transactions"
comment|// a more intelligent algorithm would check for the separator chosen (SEPARATING_CHARS_NOSPACE)
comment|// if nothing is found, " " is likely to be the separating char.
comment|// solution by RisKeywords.java: s.split(",[ ]*")
name|StringTokenizer
name|tok
init|=
operator|new
name|StringTokenizer
argument_list|(
name|keywords
argument_list|,
name|SEPARATING_CHARS_NOSPACE
argument_list|)
decl_stmt|;
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|word
init|=
name|tok
operator|.
name|nextToken
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|res
operator|.
name|add
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
DECL|method|getSeparatedKeywords (BibtexEntry be)
specifier|public
specifier|static
name|ArrayList
argument_list|<
name|String
argument_list|>
name|getSeparatedKeywords
parameter_list|(
name|BibtexEntry
name|be
parameter_list|)
block|{
return|return
name|Util
operator|.
name|getSeparatedKeywords
argument_list|(
name|be
operator|.
name|getField
argument_list|(
literal|"keywords"
argument_list|)
argument_list|)
return|;
block|}
DECL|method|putKeywords (BibtexEntry entry, ArrayList<String> keywords, NamedCompound ce)
specifier|public
specifier|static
name|void
name|putKeywords
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|keywords
parameter_list|,
name|NamedCompound
name|ce
parameter_list|)
block|{
comment|// Set Keyword Field
name|String
name|oldValue
init|=
name|entry
operator|.
name|getField
argument_list|(
literal|"keywords"
argument_list|)
decl_stmt|;
name|String
name|newValue
decl_stmt|;
if|if
condition|(
operator|!
name|keywords
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|keyword
range|:
name|keywords
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|keyword
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|newValue
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|newValue
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|oldValue
operator|==
literal|null
operator|&&
name|newValue
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|oldValue
operator|==
literal|null
operator|||
operator|!
name|oldValue
operator|.
name|equals
argument_list|(
name|newValue
argument_list|)
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"keywords"
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
operator|!=
literal|null
condition|)
block|{
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
literal|"keywords"
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * @param ce indicates the undo named compound. May be null      */
DECL|method|updateField (BibtexEntry be, String field, String newValue, NamedCompound ce)
specifier|public
specifier|static
name|void
name|updateField
parameter_list|(
name|BibtexEntry
name|be
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|newValue
parameter_list|,
name|NamedCompound
name|ce
parameter_list|)
block|{
name|Util
operator|.
name|updateField
argument_list|(
name|be
argument_list|,
name|field
argument_list|,
name|newValue
argument_list|,
name|ce
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param ce indicates the undo named compound. May be null      */
DECL|method|updateField (BibtexEntry be, String field, String newValue, NamedCompound ce, Boolean nullFieldIfValueIsTheSame)
specifier|public
specifier|static
name|void
name|updateField
parameter_list|(
name|BibtexEntry
name|be
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|newValue
parameter_list|,
name|NamedCompound
name|ce
parameter_list|,
name|Boolean
name|nullFieldIfValueIsTheSame
parameter_list|)
block|{
name|String
name|oldValue
init|=
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|nullFieldIfValueIsTheSame
operator|&&
name|oldValue
operator|!=
literal|null
operator|&&
name|oldValue
operator|.
name|equals
argument_list|(
name|newValue
argument_list|)
condition|)
block|{
comment|// if oldValue == newValue then reset field if required by parameter
name|newValue
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|oldValue
operator|==
literal|null
operator|&&
name|newValue
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|oldValue
operator|==
literal|null
operator|||
operator|!
name|oldValue
operator|.
name|equals
argument_list|(
name|newValue
argument_list|)
condition|)
block|{
name|be
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
operator|!=
literal|null
condition|)
block|{
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|be
argument_list|,
name|field
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Binds ESC-Key to cancel button      * @param rootPane the pane to bind the action to. Typically, this variable is retrieved by this.getRootPane();      * @param cancelAction the action to bind      */
comment|// TODO: move to GUI
DECL|method|bindCloseDialogKeyToCancelAction (JRootPane rootPane, Action cancelAction)
specifier|public
specifier|static
name|void
name|bindCloseDialogKeyToCancelAction
parameter_list|(
name|JRootPane
name|rootPane
parameter_list|,
name|Action
name|cancelAction
parameter_list|)
block|{
name|InputMap
name|im
init|=
name|rootPane
operator|.
name|getInputMap
argument_list|(
name|JComponent
operator|.
name|WHEN_IN_FOCUSED_WINDOW
argument_list|)
decl_stmt|;
name|ActionMap
name|am
init|=
name|rootPane
operator|.
name|getActionMap
argument_list|()
decl_stmt|;
name|im
operator|.
name|put
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|getKey
argument_list|(
literal|"Close dialog"
argument_list|)
argument_list|,
literal|"close"
argument_list|)
expr_stmt|;
name|am
operator|.
name|put
argument_list|(
literal|"close"
argument_list|,
name|cancelAction
argument_list|)
expr_stmt|;
block|}
comment|/**      * Download the URL and return contents as a String.      * @param source      * @return      * @throws IOException      */
DECL|method|getResults (URLConnection source)
specifier|public
specifier|static
name|String
name|getResults
parameter_list|(
name|URLConnection
name|source
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|Util
operator|.
name|getResultsWithEncoding
argument_list|(
name|source
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Download the URL using specified encoding and return contents as a String.      * @param source      * encoding      * @return      * @throws IOException      */
DECL|method|getResultsWithEncoding (URLConnection source, String encoding)
specifier|public
specifier|static
name|String
name|getResultsWithEncoding
parameter_list|(
name|URLConnection
name|source
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStreamReader
name|in
decl_stmt|;
if|if
condition|(
name|encoding
operator|!=
literal|null
condition|)
block|{
name|in
operator|=
operator|new
name|InputStreamReader
argument_list|(
name|source
operator|.
name|getInputStream
argument_list|()
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|=
operator|new
name|InputStreamReader
argument_list|(
name|source
operator|.
name|getInputStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|byteRead
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|byteRead
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|byteRead
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|updateTimeStampIsSet ()
specifier|public
specifier|static
name|boolean
name|updateTimeStampIsSet
parameter_list|()
block|{
return|return
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|USE_TIME_STAMP
argument_list|)
operator|&&
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|UPDATE_TIMESTAMP
argument_list|)
return|;
block|}
comment|/**      * Updates the timestamp of the given entry,      * nests the given undaoableEdit in a named compound,      * and returns that named compound      */
DECL|method|doUpdateTimeStamp (BibtexEntry entry, AbstractUndoableEdit undoableEdit)
specifier|public
specifier|static
name|NamedCompound
name|doUpdateTimeStamp
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|AbstractUndoableEdit
name|undoableEdit
parameter_list|)
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|undoableEdit
operator|.
name|getPresentationName
argument_list|()
argument_list|)
decl_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
name|undoableEdit
argument_list|)
expr_stmt|;
name|String
name|timeStampField
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|TIME_STAMP_FIELD
argument_list|)
decl_stmt|;
name|String
name|timestamp
init|=
name|dateFormatter
operator|.
name|getCurrentDate
argument_list|()
decl_stmt|;
name|Util
operator|.
name|updateField
argument_list|(
name|entry
argument_list|,
name|timeStampField
argument_list|,
name|timestamp
argument_list|,
name|ce
argument_list|)
expr_stmt|;
return|return
name|ce
return|;
block|}
comment|/**      * Automatically add links for this set of entries, based on the globally stored list of      * external file types. The entries are modified, and corresponding UndoEdit elements      * added to the NamedCompound given as argument. Furthermore, all entries which are modified      * are added to the Set of entries given as an argument.      *      * The entries' bibtex keys must have been set - entries lacking key are ignored.      * The operation is done in a new thread, which is returned for the caller to wait for      * if needed.      *      * @param entries A collection of BibtexEntry objects to find links for.      * @param ce A NamedCompound to add UndoEdit elements to.      * @param changedEntries MODIFIED, optional. A Set of BibtexEntry objects to which all modified entries is added. This is used for status output and debugging      * @param singleTableModel UGLY HACK. The table model to insert links into. Already existing links are not duplicated or removed. This parameter has to be null if entries.count() != 1.      *   The hack has been introduced as a bibtexentry does not (yet) support the function getListTableModel() and the FileListEntryEditor editor holds an instance of that table model and does not reconstruct it after the search has succeeded.      * @param metaData The MetaData providing the relevant file directory, if any.      * @param callback An ActionListener that is notified (on the event dispatch thread) when the search is      *  finished. The ActionEvent has id=0 if no new links were added, and id=1 if one or more links were added.      *  This parameter can be null, which means that no callback will be notified.      * @param diag An instantiated modal JDialog which will be used to display the progress of the autosetting.      *      This parameter can be null, which means that no progress update will be shown.      * @return the thread performing the autosetting      */
DECL|method|autoSetLinks (final Collection<BibtexEntry> entries, final NamedCompound ce, final Set<BibtexEntry> changedEntries, final FileListTableModel singleTableModel, final MetaData metaData, final ActionListener callback, final JDialog diag)
specifier|public
specifier|static
name|Runnable
name|autoSetLinks
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
specifier|final
name|NamedCompound
name|ce
parameter_list|,
specifier|final
name|Set
argument_list|<
name|BibtexEntry
argument_list|>
name|changedEntries
parameter_list|,
specifier|final
name|FileListTableModel
name|singleTableModel
parameter_list|,
specifier|final
name|MetaData
name|metaData
parameter_list|,
specifier|final
name|ActionListener
name|callback
parameter_list|,
specifier|final
name|JDialog
name|diag
parameter_list|)
block|{
specifier|final
name|ExternalFileType
index|[]
name|types
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeSelection
argument_list|()
decl_stmt|;
if|if
condition|(
name|diag
operator|!=
literal|null
condition|)
block|{
specifier|final
name|JProgressBar
name|prog
init|=
operator|new
name|JProgressBar
argument_list|(
name|JProgressBar
operator|.
name|HORIZONTAL
argument_list|,
literal|0
argument_list|,
name|types
operator|.
name|length
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|JLabel
name|label
init|=
operator|new
name|JLabel
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Searching for files"
argument_list|)
argument_list|)
decl_stmt|;
name|prog
operator|.
name|setIndeterminate
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|prog
operator|.
name|setBorder
argument_list|(
name|BorderFactory
operator|.
name|createEmptyBorder
argument_list|(
literal|5
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|diag
operator|.
name|setTitle
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Autosetting links"
argument_list|)
argument_list|)
expr_stmt|;
name|diag
operator|.
name|getContentPane
argument_list|()
operator|.
name|add
argument_list|(
name|prog
argument_list|,
name|BorderLayout
operator|.
name|CENTER
argument_list|)
expr_stmt|;
name|diag
operator|.
name|getContentPane
argument_list|()
operator|.
name|add
argument_list|(
name|label
argument_list|,
name|BorderLayout
operator|.
name|SOUTH
argument_list|)
expr_stmt|;
name|diag
operator|.
name|pack
argument_list|()
expr_stmt|;
name|diag
operator|.
name|setLocationRelativeTo
argument_list|(
name|diag
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Runnable
name|r
init|=
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// determine directories to search in
name|ArrayList
argument_list|<
name|File
argument_list|>
name|dirs
init|=
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|()
decl_stmt|;
name|String
index|[]
name|dirsS
init|=
name|metaData
operator|.
name|getFileDirectory
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|dirs1
range|:
name|dirsS
control|)
block|{
name|dirs
operator|.
name|add
argument_list|(
operator|new
name|File
argument_list|(
name|dirs1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// determine extensions
name|Collection
argument_list|<
name|String
argument_list|>
name|extensions
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|ExternalFileType
name|type
range|:
name|types
control|)
block|{
name|extensions
operator|.
name|add
argument_list|(
name|type
operator|.
name|getExtension
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Run the search operation:
name|Map
argument_list|<
name|BibtexEntry
argument_list|,
name|java
operator|.
name|util
operator|.
name|List
argument_list|<
name|File
argument_list|>
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|AUTOLINK_USE_REG_EXP_SEARCH_KEY
argument_list|)
condition|)
block|{
name|String
name|regExp
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|REG_EXP_SEARCH_EXPRESSION_KEY
argument_list|)
decl_stmt|;
name|result
operator|=
name|RegExpFileSearch
operator|.
name|findFilesForSet
argument_list|(
name|entries
argument_list|,
name|extensions
argument_list|,
name|dirs
argument_list|,
name|regExp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Util
operator|.
name|findAssociatedFiles
argument_list|(
name|entries
argument_list|,
name|extensions
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
block|}
name|boolean
name|foundAny
init|=
literal|false
decl_stmt|;
comment|// Iterate over the entries:
for|for
control|(
name|BibtexEntry
name|anEntry
range|:
name|result
operator|.
name|keySet
argument_list|()
control|)
block|{
name|FileListTableModel
name|tableModel
decl_stmt|;
name|String
name|oldVal
init|=
name|anEntry
operator|.
name|getField
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|)
decl_stmt|;
if|if
condition|(
name|singleTableModel
operator|==
literal|null
condition|)
block|{
name|tableModel
operator|=
operator|new
name|FileListTableModel
argument_list|()
expr_stmt|;
if|if
condition|(
name|oldVal
operator|!=
literal|null
condition|)
block|{
name|tableModel
operator|.
name|setContent
argument_list|(
name|oldVal
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|entries
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
name|tableModel
operator|=
name|singleTableModel
expr_stmt|;
block|}
name|List
argument_list|<
name|File
argument_list|>
name|files
init|=
name|result
operator|.
name|get
argument_list|(
name|anEntry
argument_list|)
decl_stmt|;
for|for
control|(
name|File
name|f
range|:
name|files
control|)
block|{
name|f
operator|=
name|FileUtil
operator|.
name|shortenFileName
argument_list|(
name|f
argument_list|,
name|dirsS
argument_list|)
expr_stmt|;
name|boolean
name|alreadyHas
init|=
literal|false
decl_stmt|;
comment|//System.out.println("File: "+f.getPath());
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|tableModel
operator|.
name|getRowCount
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|FileListEntry
name|existingEntry
init|=
name|tableModel
operator|.
name|getEntry
argument_list|(
name|j
argument_list|)
decl_stmt|;
comment|//System.out.println("Comp: "+existingEntry.getLink());
if|if
condition|(
operator|new
name|File
argument_list|(
name|existingEntry
operator|.
name|getLink
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|alreadyHas
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|alreadyHas
condition|)
block|{
name|foundAny
operator|=
literal|true
expr_stmt|;
name|ExternalFileType
name|type
decl_stmt|;
name|int
name|index
init|=
name|f
operator|.
name|getPath
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|f
operator|.
name|getPath
argument_list|()
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
name|type
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeByExt
argument_list|(
name|f
operator|.
name|getPath
argument_list|()
operator|.
name|substring
argument_list|(
name|index
operator|+
literal|1
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
operator|new
name|UnknownExternalFileType
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|FileListEntry
name|flEntry
init|=
operator|new
name|FileListEntry
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|f
operator|.
name|getPath
argument_list|()
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tableModel
operator|.
name|addEntry
argument_list|(
name|tableModel
operator|.
name|getRowCount
argument_list|()
argument_list|,
name|flEntry
argument_list|)
expr_stmt|;
name|String
name|newVal
init|=
name|tableModel
operator|.
name|getStringRepresentation
argument_list|()
decl_stmt|;
if|if
condition|(
name|newVal
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|newVal
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|ce
operator|!=
literal|null
condition|)
block|{
comment|// store undo information
name|UndoableFieldChange
name|change
init|=
operator|new
name|UndoableFieldChange
argument_list|(
name|anEntry
argument_list|,
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|,
name|oldVal
argument_list|,
name|newVal
argument_list|)
decl_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
name|change
argument_list|)
expr_stmt|;
block|}
comment|// hack: if table model is given, do NOT modify entry
if|if
condition|(
name|singleTableModel
operator|==
literal|null
condition|)
block|{
name|anEntry
operator|.
name|setField
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changedEntries
operator|!=
literal|null
condition|)
block|{
name|changedEntries
operator|.
name|add
argument_list|(
name|anEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// handle callbacks and dialog
comment|// FIXME: The ID signals if action was successful :/
specifier|final
name|int
name|id
init|=
name|foundAny
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|SwingUtilities
operator|.
name|invokeLater
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|diag
operator|!=
literal|null
condition|)
block|{
name|diag
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
block|{
name|callback
operator|.
name|actionPerformed
argument_list|(
operator|new
name|ActionEvent
argument_list|(
name|this
argument_list|,
name|id
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|SwingUtilities
operator|.
name|invokeLater
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// show dialog which will be hidden when the task is done
if|if
condition|(
name|diag
operator|!=
literal|null
condition|)
block|{
name|diag
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/**      * Automatically add links for this entry to the table model given as an argument, based on      * the globally stored list of external file types. The entry itself is not modified. The entry's      * bibtex key must have been set.      *      * @param entry The BibtexEntry to find links for.      * @param singleTableModel The table model to insert links into. Already existing links are not duplicated or removed.      * @param metaData The MetaData providing the relevant file directory, if any.      * @param callback An ActionListener that is notified (on the event dispatch thread) when the search is      *  finished. The ActionEvent has id=0 if no new links were added, and id=1 if one or more links were added.      *  This parameter can be null, which means that no callback will be notified. The passed ActionEvent is constructed with      *  (this, id, ""), where id is 1 if something has been done and 0 if nothing has been done.      * @param diag An instantiated modal JDialog which will be used to display the progress of the autosetting.      *      This parameter can be null, which means that no progress update will be shown.      * @return the runnable able to perform the autosetting      */
DECL|method|autoSetLinks ( final BibtexEntry entry, final FileListTableModel singleTableModel, final MetaData metaData, final ActionListener callback, final JDialog diag)
specifier|public
specifier|static
name|Runnable
name|autoSetLinks
parameter_list|(
specifier|final
name|BibtexEntry
name|entry
parameter_list|,
specifier|final
name|FileListTableModel
name|singleTableModel
parameter_list|,
specifier|final
name|MetaData
name|metaData
parameter_list|,
specifier|final
name|ActionListener
name|callback
parameter_list|,
specifier|final
name|JDialog
name|diag
parameter_list|)
block|{
specifier|final
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
init|=
operator|new
name|ArrayList
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|()
decl_stmt|;
name|entries
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
name|Util
operator|.
name|autoSetLinks
argument_list|(
name|entries
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|singleTableModel
argument_list|,
name|metaData
argument_list|,
name|callback
argument_list|,
name|diag
argument_list|)
return|;
block|}
comment|/**      * Returns the list of linked files. The files have the absolute filename      *       * @param bes list of BibTeX entries      * @param fileDirs list of directories to try for expansion      *       * @return list of files. May be empty      */
DECL|method|getListOfLinkedFiles (BibtexEntry[] bes, String[] fileDirs)
specifier|public
specifier|static
name|List
argument_list|<
name|File
argument_list|>
name|getListOfLinkedFiles
parameter_list|(
name|BibtexEntry
index|[]
name|bes
parameter_list|,
name|String
index|[]
name|fileDirs
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|File
argument_list|>
name|res
init|=
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|bes
control|)
block|{
name|FileListTableModel
name|tm
init|=
operator|new
name|FileListTableModel
argument_list|()
decl_stmt|;
name|tm
operator|.
name|setContent
argument_list|(
name|entry
operator|.
name|getField
argument_list|(
literal|"file"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tm
operator|.
name|getRowCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|FileListEntry
name|flEntry
init|=
name|tm
operator|.
name|getEntry
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|File
name|f
init|=
name|FileUtil
operator|.
name|expandFilename
argument_list|(
name|flEntry
operator|.
name|getLink
argument_list|()
argument_list|,
name|fileDirs
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
block|{
name|res
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|res
return|;
block|}
DECL|method|findAssociatedFiles (Collection<BibtexEntry> entries, Collection<String> extensions, Collection<File> directories)
specifier|public
specifier|static
name|Map
argument_list|<
name|BibtexEntry
argument_list|,
name|List
argument_list|<
name|File
argument_list|>
argument_list|>
name|findAssociatedFiles
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|extensions
parameter_list|,
name|Collection
argument_list|<
name|File
argument_list|>
name|directories
parameter_list|)
block|{
name|HashMap
argument_list|<
name|BibtexEntry
argument_list|,
name|List
argument_list|<
name|File
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|BibtexEntry
argument_list|,
name|List
argument_list|<
name|File
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// First scan directories
name|Set
argument_list|<
name|File
argument_list|>
name|filesWithExtension
init|=
name|FileFinder
operator|.
name|findFiles
argument_list|(
name|extensions
argument_list|,
name|directories
argument_list|)
decl_stmt|;
comment|// Initialize Result-Set
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|result
operator|.
name|put
argument_list|(
name|entry
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|boolean
name|exactOnly
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|AUTOLINK_EXACT_KEY_ONLY
argument_list|)
decl_stmt|;
comment|// Now look for keys
name|nextFile
label|:
for|for
control|(
name|File
name|file
range|:
name|filesWithExtension
control|)
block|{
name|String
name|name
init|=
name|file
operator|.
name|getName
argument_list|()
decl_stmt|;
name|int
name|dot
init|=
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
comment|// First, look for exact matches:
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|String
name|citeKey
init|=
name|entry
operator|.
name|getCiteKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|citeKey
operator|!=
literal|null
operator|&&
operator|!
name|citeKey
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|dot
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|dot
argument_list|)
operator|.
name|equals
argument_list|(
name|citeKey
argument_list|)
condition|)
block|{
name|result
operator|.
name|get
argument_list|(
name|entry
argument_list|)
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
continue|continue
name|nextFile
continue|;
block|}
block|}
block|}
block|}
comment|// If we get here, we didn't find any exact matches. If non-exact
comment|// matches are allowed, try to find one:
if|if
condition|(
operator|!
name|exactOnly
condition|)
block|{
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|String
name|citeKey
init|=
name|entry
operator|.
name|getCiteKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|citeKey
operator|!=
literal|null
operator|&&
operator|!
name|citeKey
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|citeKey
argument_list|)
condition|)
block|{
name|result
operator|.
name|get
argument_list|(
name|entry
argument_list|)
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
continue|continue
name|nextFile
continue|;
block|}
block|}
block|}
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**      * Accepts a string like [author:lower] or [title:abbr] or [auth],      * whereas the first part signifies the bibtex-field to get, or the key generator      * field marker to use, while the others are the modifiers that will be applied.      *      * @param fieldAndFormat      * @param entry      * @param database      * @return      */
DECL|method|getFieldAndFormat (String fieldAndFormat, BibtexEntry entry, BibtexDatabase database)
specifier|public
specifier|static
name|String
name|getFieldAndFormat
parameter_list|(
name|String
name|fieldAndFormat
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
block|{
name|fieldAndFormat
operator|=
name|StringUtil
operator|.
name|stripBrackets
argument_list|(
name|fieldAndFormat
argument_list|)
expr_stmt|;
name|int
name|colon
init|=
name|fieldAndFormat
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
name|String
name|beforeColon
decl_stmt|;
name|String
name|afterColon
decl_stmt|;
if|if
condition|(
name|colon
operator|==
operator|-
literal|1
condition|)
block|{
name|beforeColon
operator|=
name|fieldAndFormat
expr_stmt|;
name|afterColon
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|beforeColon
operator|=
name|fieldAndFormat
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|afterColon
operator|=
name|fieldAndFormat
operator|.
name|substring
argument_list|(
name|colon
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|beforeColon
operator|=
name|beforeColon
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|beforeColon
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|fieldValue
init|=
name|BibtexDatabase
operator|.
name|getResolvedField
argument_list|(
name|beforeColon
argument_list|,
name|entry
argument_list|,
name|database
argument_list|)
decl_stmt|;
comment|// If no field value was found, try to interpret it as a key generator field marker:
if|if
condition|(
name|fieldValue
operator|==
literal|null
condition|)
block|{
name|fieldValue
operator|=
name|LabelPatternUtil
operator|.
name|makeLabel
argument_list|(
name|entry
argument_list|,
name|beforeColon
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fieldValue
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|afterColon
operator|==
literal|null
operator|||
name|afterColon
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|fieldValue
return|;
block|}
name|String
index|[]
name|parts
init|=
name|afterColon
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|fieldValue
operator|=
name|LabelPatternUtil
operator|.
name|applyModifiers
argument_list|(
name|fieldValue
argument_list|,
name|parts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fieldValue
return|;
block|}
comment|// Returns a reg exp pattern in the form (w1)|(w2)| ... wi are escaped if no regex search is enabled
DECL|method|getPatternForWords (ArrayList<String> words)
specifier|public
specifier|static
name|Pattern
name|getPatternForWords
parameter_list|(
name|ArrayList
argument_list|<
name|String
argument_list|>
name|words
parameter_list|)
block|{
if|if
condition|(
name|words
operator|==
literal|null
operator|||
name|words
operator|.
name|isEmpty
argument_list|()
operator|||
name|words
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Pattern
operator|.
name|compile
argument_list|(
literal|""
argument_list|)
return|;
block|}
name|boolean
name|regExSearch
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|REG_EXP_SEARCH
argument_list|)
decl_stmt|;
comment|// compile the words to a regex in the form (w1) | (w2) | (w3)
name|String
name|searchPattern
init|=
literal|"("
operator|.
name|concat
argument_list|(
name|regExSearch
condition|?
name|words
operator|.
name|get
argument_list|(
literal|0
argument_list|)
else|:
name|Pattern
operator|.
name|quote
argument_list|(
name|words
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|concat
argument_list|(
literal|")"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|words
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|searchPattern
operator|=
name|searchPattern
operator|.
name|concat
argument_list|(
literal|"|("
argument_list|)
operator|.
name|concat
argument_list|(
name|regExSearch
condition|?
name|words
operator|.
name|get
argument_list|(
name|i
argument_list|)
else|:
name|Pattern
operator|.
name|quote
argument_list|(
name|words
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
operator|.
name|concat
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|Pattern
name|pattern
decl_stmt|;
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|CASE_SENSITIVE_SEARCH
argument_list|)
condition|)
block|{
name|pattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|searchPattern
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|searchPattern
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
argument_list|)
expr_stmt|;
block|}
return|return
name|pattern
return|;
block|}
block|}
end_class

end_unit

