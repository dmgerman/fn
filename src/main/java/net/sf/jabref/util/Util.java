begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003-2012 JabRef contributors.     Copyright (C) 2015 Oliver Kopp      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License along     with this program; if not, write to the Free Software Foundation, Inc.,     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */
end_comment

begin_comment
comment|// created by : Morten O. Alver 2003
end_comment

begin_package
DECL|package|net.sf.jabref.util
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|BorderLayout
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|CardLayout
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Desktop
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Dimension
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Font
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|ActionEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|ActionListener
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLDecoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharsetEncoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|Action
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|ActionMap
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|BorderFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|Box
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|InputMap
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JButton
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JComponent
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JDialog
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JFrame
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JLabel
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JOptionPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JPanel
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JProgressBar
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JRootPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JScrollPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JTextArea
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|SwingUtilities
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|undo
operator|.
name|AbstractUndoableEdit
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|undo
operator|.
name|UndoableEdit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|AbstractWorker
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|AuthorList
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexDatabase
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexFields
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|CallBack
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|EasyDateFormat
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|EntryMarker
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|GUIGlobals
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|Globals
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|ImportSettingsTab
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|JabRefFrame
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|JabRefPreferences
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|MetaData
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|OpenFileFilter
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|Worker
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|Layout
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|LayoutHelper
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|ExternalFileType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|ExternalFileTypeEntryEditor
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|RegExpFileSearch
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|UnknownExternalFileType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|structure
operator|.
name|AbstractGroup
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|structure
operator|.
name|KeywordGroup
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|FileListEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|FileListEntryEditor
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|FileListTableModel
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|labelPattern
operator|.
name|LabelPatternUtil
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|net
operator|.
name|URLDownload
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|NamedCompound
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|UndoableFieldChange
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jgoodies
operator|.
name|forms
operator|.
name|builder
operator|.
name|DefaultFormBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jgoodies
operator|.
name|forms
operator|.
name|layout
operator|.
name|FormLayout
import|;
end_import

begin_comment
comment|/**  * utility functions  */
end_comment

begin_class
DECL|class|Util
specifier|public
class|class
name|Util
block|{
DECL|field|REMOTE_LINK_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|REMOTE_LINK_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[a-z]+://.*"
argument_list|)
decl_stmt|;
DECL|field|dateFormatter
specifier|private
specifier|static
specifier|final
name|EasyDateFormat
name|dateFormatter
init|=
operator|new
name|EasyDateFormat
argument_list|()
decl_stmt|;
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Log
name|LOGGER
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|Util
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|ARXIV_LOOKUP_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|ARXIV_LOOKUP_PREFIX
init|=
literal|"http://arxiv.org/abs/"
decl_stmt|;
DECL|field|SEPARATING_CHARS_NOSPACE
specifier|private
specifier|static
specifier|final
name|String
name|SEPARATING_CHARS_NOSPACE
init|=
literal|";,\n"
decl_stmt|;
DECL|field|UNICODE_CHAR_MAP
specifier|private
specifier|static
specifier|final
name|UnicodeCharMap
name|UNICODE_CHAR_MAP
init|=
operator|new
name|UnicodeCharMap
argument_list|()
decl_stmt|;
comment|/**      * This method sets the location of a Dialog such that it is centered with      * regard to another window, but not outside the screen on the left and the      * top.      */
DECL|method|placeDialog (java.awt.Dialog diag, java.awt.Container win)
specifier|public
specifier|static
name|void
name|placeDialog
parameter_list|(
name|java
operator|.
name|awt
operator|.
name|Dialog
name|diag
parameter_list|,
name|java
operator|.
name|awt
operator|.
name|Container
name|win
parameter_list|)
block|{
name|diag
operator|.
name|setLocationRelativeTo
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method translates a field or string from Bibtex notation, with      * possibly text contained in " " or { }, and string references,      * concatenated by '#' characters, into Bibkeeper notation, where string      * references are enclosed in a pair of '#' characters.      */
DECL|method|parseField (String content)
specifier|public
specifier|static
name|String
name|parseField
parameter_list|(
name|String
name|content
parameter_list|)
block|{
if|if
condition|(
name|content
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|content
return|;
block|}
name|String
index|[]
name|strings
init|=
name|content
operator|.
name|split
argument_list|(
literal|"#"
argument_list|)
decl_stmt|;
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|string
range|:
name|strings
control|)
block|{
name|String
name|s
init|=
name|string
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// String reference or not?
if|if
condition|(
name|c
operator|==
literal|'{'
operator|||
name|c
operator|==
literal|'"'
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|StringUtil
operator|.
name|shaveString
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This part should normally be a string reference, but if it's
comment|// a pure number, it is not.
name|String
name|s2
init|=
name|StringUtil
operator|.
name|shaveString
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|isInteger
argument_list|(
name|s2
argument_list|)
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|s2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|append
argument_list|(
literal|'#'
argument_list|)
operator|.
name|append
argument_list|(
name|s2
argument_list|)
operator|.
name|append
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|isInteger (String s)
specifier|private
specifier|static
name|boolean
name|isInteger
parameter_list|(
name|String
name|s
parameter_list|)
block|{
try|try
block|{
name|Integer
operator|.
name|parseInt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Will return the publication date of the given bibtex entry in conformance      * to ISO 8601, i.e. either YYYY or YYYY-MM.      *       * @param entry      * @return will return the publication date of the entry or null if no year      *         was found.      */
DECL|method|getPublicationDate (BibtexEntry entry)
specifier|public
specifier|static
name|String
name|getPublicationDate
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|)
block|{
name|Object
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
literal|"year"
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|year
init|=
name|YearUtil
operator|.
name|toFourDigitYear
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|o
operator|=
name|entry
operator|.
name|getField
argument_list|(
literal|"month"
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|MonthUtil
operator|.
name|Month
name|month
init|=
name|MonthUtil
operator|.
name|getMonth
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|month
operator|.
name|isValid
argument_list|()
condition|)
block|{
return|return
name|year
operator|+
literal|"-"
operator|+
name|month
operator|.
name|twoDigitNumber
return|;
block|}
block|}
return|return
name|year
return|;
block|}
comment|/**      * This method returns a String similar to the one passed in, except that it      * is molded into a form that is acceptable for bibtex.      *       * Watch-out that the returned string might be of length 0 afterwards.      *       * @param key      *            mayBeNull      */
DECL|method|checkLegalKey (String key)
specifier|public
specifier|static
name|String
name|checkLegalKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|JabRefPreferences
operator|.
name|getInstance
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|ENFORCE_LEGAL_BIBTEX_KEY
argument_list|)
condition|)
block|{
comment|// User doesn't want us to enforce legal characters. We must still look
comment|// for whitespace and some characters such as commas, since these would
comment|// interfere with parsing:
name|StringBuilder
name|newKey
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|key
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|key
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'{'
operator|&&
name|c
operator|!=
literal|'\\'
operator|&&
name|c
operator|!=
literal|'"'
operator|&&
name|c
operator|!=
literal|'}'
operator|&&
name|c
operator|!=
literal|','
condition|)
block|{
name|newKey
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|newKey
operator|.
name|toString
argument_list|()
return|;
block|}
name|StringBuilder
name|newKey
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|key
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|key
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'#'
operator|&&
name|c
operator|!=
literal|'{'
operator|&&
name|c
operator|!=
literal|'\\'
operator|&&
name|c
operator|!=
literal|'"'
operator|&&
name|c
operator|!=
literal|'}'
operator|&&
name|c
operator|!=
literal|'~'
operator|&&
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|'^'
operator|&&
name|c
operator|!=
literal|'\''
condition|)
block|{
name|newKey
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Replace non-english characters like umlauts etc. with a sensible
comment|// letter or letter combination that bibtex can accept.
return|return
name|Util
operator|.
name|replaceSpecialCharacters
argument_list|(
name|newKey
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Replace non-english characters like umlauts etc. with a sensible letter      * or letter combination that bibtex can accept. The basis for replacement      * is the HashMap GLobals.UNICODE_CHARS.      */
DECL|method|replaceSpecialCharacters (String s)
specifier|public
specifier|static
name|String
name|replaceSpecialCharacters
parameter_list|(
name|String
name|s
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|chrAndReplace
range|:
name|UNICODE_CHAR_MAP
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|s
operator|=
name|s
operator|.
name|replaceAll
argument_list|(
name|chrAndReplace
operator|.
name|getKey
argument_list|()
argument_list|,
name|chrAndReplace
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
DECL|method|findDeliminatedWordsInField (BibtexDatabase db, String field, String deliminator)
specifier|public
specifier|static
name|TreeSet
argument_list|<
name|String
argument_list|>
name|findDeliminatedWordsInField
parameter_list|(
name|BibtexDatabase
name|db
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|deliminator
parameter_list|)
block|{
name|TreeSet
argument_list|<
name|String
argument_list|>
name|res
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|db
operator|.
name|getKeySet
argument_list|()
control|)
block|{
name|BibtexEntry
name|be
init|=
name|db
operator|.
name|getEntryById
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|Object
name|o
init|=
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|String
name|fieldValue
init|=
name|o
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|StringTokenizer
name|tok
init|=
operator|new
name|StringTokenizer
argument_list|(
name|fieldValue
argument_list|,
name|deliminator
argument_list|)
decl_stmt|;
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|res
operator|.
name|add
argument_list|(
name|StringUtil
operator|.
name|nCase
argument_list|(
name|tok
operator|.
name|nextToken
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|res
return|;
block|}
comment|/**      * Returns a HashMap containing all words used in the database in the given      * field type. Characters in<code>remove</code> are not included.      *       * @param db      *            a<code>BibtexDatabase</code> value      * @param field      *            a<code>String</code> value      * @param remove      *            a<code>String</code> value      * @return a<code>HashSet</code> value      */
DECL|method|findAllWordsInField (BibtexDatabase db, String field, String remove)
specifier|public
specifier|static
name|TreeSet
argument_list|<
name|String
argument_list|>
name|findAllWordsInField
parameter_list|(
name|BibtexDatabase
name|db
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|remove
parameter_list|)
block|{
name|TreeSet
argument_list|<
name|String
argument_list|>
name|res
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|StringTokenizer
name|tok
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|db
operator|.
name|getKeySet
argument_list|()
control|)
block|{
name|BibtexEntry
name|be
init|=
name|db
operator|.
name|getEntryById
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|Object
name|o
init|=
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|tok
operator|=
operator|new
name|StringTokenizer
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|,
name|remove
argument_list|,
literal|false
argument_list|)
expr_stmt|;
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|res
operator|.
name|add
argument_list|(
name|StringUtil
operator|.
name|nCase
argument_list|(
name|tok
operator|.
name|nextToken
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|res
return|;
block|}
comment|/**      * Finds all authors' last names in all the given fields for the given database.      * @param db The database.      * @param fields The fields to look in.      * @return a set containing the names.      */
DECL|method|findAuthorLastNames (BibtexDatabase db, List<String> fields)
specifier|public
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|findAuthorLastNames
parameter_list|(
name|BibtexDatabase
name|db
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|res
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|db
operator|.
name|getKeySet
argument_list|()
control|)
block|{
name|BibtexEntry
name|be
init|=
name|db
operator|.
name|getEntryById
argument_list|(
name|s
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
name|String
name|val
init|=
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
operator|&&
operator|!
name|val
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|AuthorList
name|al
init|=
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|val
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|al
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|AuthorList
operator|.
name|Author
name|a
init|=
name|al
operator|.
name|getAuthor
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|lastName
init|=
name|a
operator|.
name|getLast
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastName
operator|!=
literal|null
operator|&&
operator|!
name|lastName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|res
operator|.
name|add
argument_list|(
name|lastName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|res
return|;
block|}
comment|/**      * Open a http/pdf/ps viewer for the given link string.      */
DECL|method|openExternalViewer (MetaData metaData, String link, String fieldName)
specifier|public
specifier|static
name|void
name|openExternalViewer
parameter_list|(
name|MetaData
name|metaData
parameter_list|,
name|String
name|link
parameter_list|,
name|String
name|fieldName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"ps"
argument_list|)
operator|||
name|fieldName
operator|.
name|equals
argument_list|(
literal|"pdf"
argument_list|)
condition|)
block|{
comment|// Find the default directory for this field type:
name|String
index|[]
name|dir
init|=
name|metaData
operator|.
name|getFileDirectory
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|File
name|file
init|=
name|FileUtil
operator|.
name|expandFilename
argument_list|(
name|link
argument_list|,
name|dir
argument_list|)
decl_stmt|;
comment|// Check that the file exists:
if|if
condition|(
name|file
operator|==
literal|null
operator|||
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"File not found"
argument_list|)
operator|+
literal|" ("
operator|+
name|fieldName
operator|+
literal|"): '"
operator|+
name|link
operator|+
literal|"'."
argument_list|)
throw|;
block|}
name|link
operator|=
name|file
operator|.
name|getCanonicalPath
argument_list|()
expr_stmt|;
comment|// Use the correct viewer even if pdf and ps are mixed up:
name|String
index|[]
name|split
init|=
name|file
operator|.
name|getName
argument_list|()
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
decl_stmt|;
if|if
condition|(
name|split
operator|.
name|length
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|split
index|[
name|split
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"pdf"
argument_list|)
condition|)
block|{
name|fieldName
operator|=
literal|"pdf"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|split
index|[
name|split
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"ps"
argument_list|)
operator|||
name|split
operator|.
name|length
operator|>=
literal|3
operator|&&
name|split
index|[
name|split
operator|.
name|length
operator|-
literal|2
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"ps"
argument_list|)
condition|)
block|{
name|fieldName
operator|=
literal|"ps"
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"doi"
argument_list|)
condition|)
block|{
name|fieldName
operator|=
literal|"url"
expr_stmt|;
comment|// sanitizing is done below at the treatment of "URL"
comment|// in sanatizeUrl a doi-link is correctly treated
block|}
elseif|else
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"eprint"
argument_list|)
condition|)
block|{
name|fieldName
operator|=
literal|"url"
expr_stmt|;
name|link
operator|=
name|Util
operator|.
name|sanitizeUrl
argument_list|(
name|link
argument_list|)
expr_stmt|;
comment|// Check to see if link field already contains a well formated URL
if|if
condition|(
operator|!
name|link
operator|.
name|startsWith
argument_list|(
literal|"http://"
argument_list|)
condition|)
block|{
name|link
operator|=
name|ARXIV_LOOKUP_PREFIX
operator|+
name|link
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"url"
argument_list|)
condition|)
block|{
comment|// html
try|try
block|{
name|Util
operator|.
name|openBrowser
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Error_opening_file_'%0'."
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"ps"
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
name|Globals
operator|.
name|ON_MAC
condition|)
block|{
name|ExternalFileType
name|type
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeByExt
argument_list|(
literal|"ps"
argument_list|)
decl_stmt|;
name|String
name|viewer
init|=
name|type
operator|!=
literal|null
condition|?
name|type
operator|.
name|getOpenWith
argument_list|()
else|:
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"psviewer"
argument_list|)
decl_stmt|;
name|String
index|[]
name|cmd
init|=
block|{
literal|"/usr/bin/open"
block|,
literal|"-a"
block|,
name|viewer
block|,
name|link
block|}
decl_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Globals
operator|.
name|ON_WIN
condition|)
block|{
name|Util
operator|.
name|openFileOnWindows
argument_list|(
name|link
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|/*                      * cmdArray[0] = Globals.prefs.get("psviewer"); cmdArray[1] =                      * link; Process child = Runtime.getRuntime().exec(                      * cmdArray[0] + " " + cmdArray[1]);                      */
block|}
else|else
block|{
name|ExternalFileType
name|type
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeByExt
argument_list|(
literal|"ps"
argument_list|)
decl_stmt|;
name|String
name|viewer
init|=
name|type
operator|!=
literal|null
condition|?
name|type
operator|.
name|getOpenWith
argument_list|()
else|:
literal|"xdg-open"
decl_stmt|;
name|String
index|[]
name|cmdArray
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
name|cmdArray
index|[
literal|0
index|]
operator|=
name|viewer
expr_stmt|;
name|cmdArray
index|[
literal|1
index|]
operator|=
name|link
expr_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmdArray
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"An error occured on the command: "
operator|+
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"psviewer"
argument_list|)
operator|+
literal|" "
operator|+
name|link
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"pdf"
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
name|Globals
operator|.
name|ON_MAC
condition|)
block|{
name|ExternalFileType
name|type
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeByExt
argument_list|(
literal|"pdf"
argument_list|)
decl_stmt|;
name|String
name|viewer
init|=
name|type
operator|!=
literal|null
condition|?
name|type
operator|.
name|getOpenWith
argument_list|()
else|:
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"psviewer"
argument_list|)
decl_stmt|;
name|String
index|[]
name|cmd
init|=
block|{
literal|"/usr/bin/open"
block|,
literal|"-a"
block|,
name|viewer
block|,
name|link
block|}
decl_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Globals
operator|.
name|ON_WIN
condition|)
block|{
name|Util
operator|.
name|openFileOnWindows
argument_list|(
name|link
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|/*                      * String[] spl = link.split("\\\\"); StringBuffer sb = new                      * StringBuffer(); for (int i = 0; i< spl.length; i++) { if                      * (i> 0) sb.append("\\"); if (spl[i].indexOf(" ")>= 0)                      * spl[i] = "\"" + spl[i] + "\""; sb.append(spl[i]); }                      * //pr(sb.toString()); link = sb.toString();                      *                       * String cmd = "cmd.exe /c start " + link;                      *                       * Process child = Runtime.getRuntime().exec(cmd);                      */
block|}
else|else
block|{
name|ExternalFileType
name|type
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeByExt
argument_list|(
literal|"pdf"
argument_list|)
decl_stmt|;
name|String
name|viewer
init|=
name|type
operator|!=
literal|null
condition|?
name|type
operator|.
name|getOpenWith
argument_list|()
else|:
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"psviewer"
argument_list|)
decl_stmt|;
name|String
index|[]
name|cmdArray
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
name|cmdArray
index|[
literal|0
index|]
operator|=
name|viewer
expr_stmt|;
name|cmdArray
index|[
literal|1
index|]
operator|=
name|link
expr_stmt|;
comment|// Process child = Runtime.getRuntime().exec(cmdArray[0]+"
comment|// "+cmdArray[1]);
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmdArray
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"An error occured on the command: "
operator|+
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"pdfviewer"
argument_list|)
operator|+
literal|" #"
operator|+
name|link
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Message: currently only PDF, PS and HTML files can be opened by double clicking"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Opens a file on a Windows system, using its default viewer.      *       * @param link      *            The file name.      * @param localFile      *            true if it is a local file, not an URL.      * @throws IOException      */
DECL|method|openFileOnWindows (String link, boolean localFile)
specifier|private
specifier|static
name|void
name|openFileOnWindows
parameter_list|(
name|String
name|link
parameter_list|,
name|boolean
name|localFile
parameter_list|)
throws|throws
name|IOException
block|{
comment|/*          * if (localFile) { String[] spl = link.split("\\\\"); StringBuffer sb =          * new StringBuffer(); for (int i = 0; i< spl.length; i++) { if (i> 0)          * sb.append("\\"); if (spl[i].indexOf(" ")>= 0) spl[i] = "\"" + spl[i] +          * "\""; sb.append(spl[i]); } link = sb.toString(); }          */
name|link
operator|=
name|link
operator|.
name|replaceAll
argument_list|(
literal|"&"
argument_list|,
literal|"\"&\""
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|" "
argument_list|,
literal|"\" \""
argument_list|)
expr_stmt|;
comment|// Bug fix for:
comment|// http://sourceforge.net/tracker/index.php?func=detail&aid=1489454&group_id=92314&atid=600306
name|String
name|cmd
decl_stmt|;
if|if
condition|(
name|Globals
operator|.
name|osName
operator|.
name|startsWith
argument_list|(
literal|"Windows 9"
argument_list|)
condition|)
block|{
name|cmd
operator|=
literal|"command.com /c start "
operator|+
name|link
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
literal|"cmd.exe /c start "
operator|+
name|link
expr_stmt|;
block|}
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|/**      * Opens a file on a Windows system, using the given application.      *      * @param link The file name.      * @param application Link to the app that opens the file.      * @throws IOException      */
DECL|method|openFileWithApplicationOnWindows (String link, String application)
specifier|private
specifier|static
name|void
name|openFileWithApplicationOnWindows
parameter_list|(
name|String
name|link
parameter_list|,
name|String
name|application
parameter_list|)
throws|throws
name|IOException
block|{
name|link
operator|=
name|link
operator|.
name|replaceAll
argument_list|(
literal|"&"
argument_list|,
literal|"\"&\""
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|" "
argument_list|,
literal|"\" \""
argument_list|)
expr_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|application
operator|+
literal|" "
operator|+
name|link
argument_list|)
expr_stmt|;
block|}
comment|/**      * Open an external file, attempting to use the correct viewer for it.      *       * @param metaData      *            The MetaData for the database this file belongs to.      * @param link      *            The file name.      * @return false if the link couldn't be resolved, true otherwise.      */
DECL|method|openExternalFileAnyFormat (final MetaData metaData, String link, final ExternalFileType fileType)
specifier|public
specifier|static
name|boolean
name|openExternalFileAnyFormat
parameter_list|(
specifier|final
name|MetaData
name|metaData
parameter_list|,
name|String
name|link
parameter_list|,
specifier|final
name|ExternalFileType
name|fileType
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|httpLink
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|Util
operator|.
name|REMOTE_LINK_PATTERN
operator|.
name|matcher
argument_list|(
name|link
operator|.
name|toLowerCase
argument_list|()
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|httpLink
operator|=
literal|true
expr_stmt|;
block|}
comment|/*if (link.toLowerCase().startsWith("file://")) {             link = link.substring(7);         }         final String ln = link;         if (REMOTE_LINK_PATTERN.matcher(link.toLowerCase()).matches()) {             (new Thread(new Runnable() {                 public void run() {                     openRemoteExternalFile(metaData, ln, fileType);                 }             })).start();              return true;         }*/
comment|//boolean httpLink = link.toLowerCase().startsWith("http:")
comment|//        || link.toLowerCase().startsWith("ftp:");
comment|// For other platforms we'll try to find the file type:
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|httpLink
condition|)
block|{
name|File
name|tmp
init|=
name|FileUtil
operator|.
name|expandFilename
argument_list|(
name|metaData
argument_list|,
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|null
condition|)
block|{
name|file
operator|=
name|tmp
expr_stmt|;
block|}
block|}
comment|// Check if we have arrived at a file type, and either an http link or an existing file:
if|if
condition|(
operator|(
name|httpLink
operator|||
name|file
operator|.
name|exists
argument_list|()
operator|)
operator|&&
name|fileType
operator|!=
literal|null
condition|)
block|{
comment|// Open the file:
name|String
name|filePath
init|=
name|httpLink
condition|?
name|link
else|:
name|file
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|Util
operator|.
name|openExternalFilePlatformIndependent
argument_list|(
name|fileType
argument_list|,
name|filePath
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
comment|// No file matched the name, or we didn't know the file type.
block|}
block|}
DECL|method|openExternalFilePlatformIndependent (ExternalFileType fileType, String filePath)
specifier|private
specifier|static
name|void
name|openExternalFilePlatformIndependent
parameter_list|(
name|ExternalFileType
name|fileType
parameter_list|,
name|String
name|filePath
parameter_list|)
throws|throws
name|IOException
block|{
comment|// For URLs, other solutions are
comment|//  * https://github.com/rajing/browserlauncher2, but it is not available in maven
comment|//  * a the solution combining http://stackoverflow.com/a/5226244/873282 and http://stackoverflow.com/a/28807079/873282
if|if
condition|(
name|Globals
operator|.
name|ON_MAC
condition|)
block|{
comment|// Use "-a<application>" if the app is specified, and just "open<filename>" otherwise:
name|String
index|[]
name|cmd
init|=
name|fileType
operator|.
name|getOpenWith
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|fileType
operator|.
name|getOpenWith
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
operator|new
name|String
index|[]
block|{
literal|"/usr/bin/open"
block|,
literal|"-a"
block|,
name|fileType
operator|.
name|getOpenWith
argument_list|()
block|,
name|filePath
block|}
else|:
operator|new
name|String
index|[]
block|{
literal|"/usr/bin/open"
block|,
name|filePath
block|}
decl_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Globals
operator|.
name|ON_WIN
condition|)
block|{
if|if
condition|(
name|fileType
operator|.
name|getOpenWith
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|fileType
operator|.
name|getOpenWith
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Application is specified. Use it:
name|Util
operator|.
name|openFileWithApplicationOnWindows
argument_list|(
name|filePath
argument_list|,
name|fileType
operator|.
name|getOpenWith
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Util
operator|.
name|openFileOnWindows
argument_list|(
name|filePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Use the given app if specified, and the universal "xdg-open" otherwise:
name|String
index|[]
name|openWith
decl_stmt|;
if|if
condition|(
name|fileType
operator|.
name|getOpenWith
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|fileType
operator|.
name|getOpenWith
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|openWith
operator|=
name|fileType
operator|.
name|getOpenWith
argument_list|()
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|openWith
operator|=
operator|new
name|String
index|[]
block|{
literal|"xdg-open"
block|}
expr_stmt|;
block|}
name|String
index|[]
name|cmdArray
init|=
operator|new
name|String
index|[
name|openWith
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|openWith
argument_list|,
literal|0
argument_list|,
name|cmdArray
argument_list|,
literal|0
argument_list|,
name|openWith
operator|.
name|length
argument_list|)
expr_stmt|;
name|cmdArray
index|[
name|cmdArray
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|filePath
expr_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmdArray
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|openRemoteExternalFile (final MetaData metaData, final String link, final ExternalFileType fileType)
specifier|public
specifier|static
name|void
name|openRemoteExternalFile
parameter_list|(
specifier|final
name|MetaData
name|metaData
parameter_list|,
specifier|final
name|String
name|link
parameter_list|,
specifier|final
name|ExternalFileType
name|fileType
parameter_list|)
block|{
name|File
name|temp
init|=
literal|null
decl_stmt|;
try|try
block|{
name|temp
operator|=
name|File
operator|.
name|createTempFile
argument_list|(
literal|"jabref-link"
argument_list|,
literal|"."
operator|+
name|fileType
operator|.
name|getExtension
argument_list|()
argument_list|)
expr_stmt|;
name|temp
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Downloading to '"
operator|+
name|temp
operator|.
name|getPath
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
operator|new
name|URLDownload
argument_list|(
operator|new
name|URL
argument_list|(
name|link
argument_list|)
argument_list|)
operator|.
name|downloadToFile
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Done"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
specifier|final
name|String
name|ln
init|=
name|temp
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|SwingUtilities
operator|.
name|invokeLater
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|Util
operator|.
name|openExternalFileAnyFormat
argument_list|(
name|metaData
argument_list|,
name|ln
argument_list|,
name|fileType
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|openExternalFileUnknown (JabRefFrame frame, BibtexEntry entry, MetaData metaData, String link, UnknownExternalFileType fileType)
specifier|public
specifier|static
name|boolean
name|openExternalFileUnknown
parameter_list|(
name|JabRefFrame
name|frame
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|,
name|MetaData
name|metaData
parameter_list|,
name|String
name|link
parameter_list|,
name|UnknownExternalFileType
name|fileType
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|cancelMessage
init|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Unable to open file."
argument_list|)
decl_stmt|;
name|String
index|[]
name|options
init|=
operator|new
name|String
index|[]
block|{
name|Globals
operator|.
name|lang
argument_list|(
literal|"Define '%0'"
argument_list|,
name|fileType
operator|.
name|getName
argument_list|()
argument_list|)
block|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Change file type"
argument_list|)
block|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Cancel"
argument_list|)
block|}
decl_stmt|;
name|String
name|defOption
init|=
name|options
index|[
literal|0
index|]
decl_stmt|;
name|int
name|answer
init|=
name|JOptionPane
operator|.
name|showOptionDialog
argument_list|(
name|frame
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"This external link is of the type '%0', which is undefined. What do you want to do?"
argument_list|,
name|fileType
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Undefined file type"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_CANCEL_OPTION
argument_list|,
name|JOptionPane
operator|.
name|QUESTION_MESSAGE
argument_list|,
literal|null
argument_list|,
name|options
argument_list|,
name|defOption
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|==
name|JOptionPane
operator|.
name|CANCEL_OPTION
condition|)
block|{
name|frame
operator|.
name|output
argument_list|(
name|cancelMessage
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|answer
operator|==
name|JOptionPane
operator|.
name|YES_OPTION
condition|)
block|{
comment|// User wants to define the new file type. Show the dialog:
name|ExternalFileType
name|newType
init|=
operator|new
name|ExternalFileType
argument_list|(
name|fileType
operator|.
name|getName
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"new"
argument_list|)
decl_stmt|;
name|ExternalFileTypeEntryEditor
name|editor
init|=
operator|new
name|ExternalFileTypeEntryEditor
argument_list|(
name|frame
argument_list|,
name|newType
argument_list|)
decl_stmt|;
name|editor
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|editor
operator|.
name|okPressed
argument_list|()
condition|)
block|{
comment|// Get the old list of types, add this one, and update the list in prefs:
name|List
argument_list|<
name|ExternalFileType
argument_list|>
name|fileTypes
init|=
operator|new
name|ArrayList
argument_list|<
name|ExternalFileType
argument_list|>
argument_list|()
decl_stmt|;
name|ExternalFileType
index|[]
name|oldTypes
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeSelection
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|fileTypes
argument_list|,
name|oldTypes
argument_list|)
expr_stmt|;
name|fileTypes
operator|.
name|add
argument_list|(
name|newType
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|fileTypes
argument_list|)
expr_stmt|;
name|Globals
operator|.
name|prefs
operator|.
name|setExternalFileTypes
argument_list|(
name|fileTypes
argument_list|)
expr_stmt|;
comment|// Finally, open the file:
return|return
name|Util
operator|.
name|openExternalFileAnyFormat
argument_list|(
name|metaData
argument_list|,
name|link
argument_list|,
name|newType
argument_list|)
return|;
block|}
else|else
block|{
comment|// Cancelled:
name|frame
operator|.
name|output
argument_list|(
name|cancelMessage
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
comment|// User wants to change the type of this link.
comment|// First get a model of all file links for this entry:
name|FileListTableModel
name|tModel
init|=
operator|new
name|FileListTableModel
argument_list|()
decl_stmt|;
name|String
name|oldValue
init|=
name|entry
operator|.
name|getField
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|)
decl_stmt|;
name|tModel
operator|.
name|setContent
argument_list|(
name|oldValue
argument_list|)
expr_stmt|;
name|FileListEntry
name|flEntry
init|=
literal|null
decl_stmt|;
comment|// Then find which one we are looking at:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tModel
operator|.
name|getRowCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|FileListEntry
name|iEntry
init|=
name|tModel
operator|.
name|getEntry
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|iEntry
operator|.
name|getLink
argument_list|()
operator|.
name|equals
argument_list|(
name|link
argument_list|)
condition|)
block|{
name|flEntry
operator|=
name|iEntry
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|flEntry
operator|==
literal|null
condition|)
block|{
comment|// This shouldn't happen, so I'm not sure what to put in here:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not find the file list entry "
operator|+
name|link
operator|+
literal|" in "
operator|+
name|entry
argument_list|)
throw|;
block|}
name|FileListEntryEditor
name|editor
init|=
operator|new
name|FileListEntryEditor
argument_list|(
name|frame
argument_list|,
name|flEntry
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
name|metaData
argument_list|)
decl_stmt|;
name|editor
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|editor
operator|.
name|okPressed
argument_list|()
condition|)
block|{
comment|// Store the changes and add an undo edit:
name|String
name|newValue
init|=
name|tModel
operator|.
name|getStringRepresentation
argument_list|()
decl_stmt|;
name|UndoableFieldChange
name|ce
init|=
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
decl_stmt|;
name|entry
operator|.
name|setField
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
name|frame
operator|.
name|basePanel
argument_list|()
operator|.
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|frame
operator|.
name|basePanel
argument_list|()
operator|.
name|markBaseChanged
argument_list|()
expr_stmt|;
comment|// Finally, open the link:
return|return
name|Util
operator|.
name|openExternalFileAnyFormat
argument_list|(
name|metaData
argument_list|,
name|flEntry
operator|.
name|getLink
argument_list|()
argument_list|,
name|flEntry
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// Cancelled:
name|frame
operator|.
name|output
argument_list|(
name|cancelMessage
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
comment|/**      * Make sure an URL is "portable", in that it doesn't contain bad characters      * that break the open command in some OSes.      *       * A call to this method will also remove \\url{} enclosings and clean DOI links. 	 *  	 * @param link :the URL to sanitize. 	 * @return Sanitized URL 	 */
DECL|method|sanitizeUrl (String link)
specifier|public
specifier|static
name|String
name|sanitizeUrl
parameter_list|(
name|String
name|link
parameter_list|)
block|{
name|link
operator|=
name|link
operator|.
name|trim
argument_list|()
expr_stmt|;
comment|// First check if it is enclosed in \\url{}. If so, remove
comment|// the wrapper.
if|if
condition|(
name|link
operator|.
name|startsWith
argument_list|(
literal|"\\url{"
argument_list|)
operator|&&
name|link
operator|.
name|endsWith
argument_list|(
literal|"}"
argument_list|)
condition|)
block|{
name|link
operator|=
name|link
operator|.
name|substring
argument_list|(
literal|5
argument_list|,
name|link
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|link
operator|.
name|matches
argument_list|(
literal|"^doi:/*.*"
argument_list|)
condition|)
block|{
comment|// Remove 'doi:'
name|link
operator|=
name|link
operator|.
name|replaceFirst
argument_list|(
literal|"^doi:/*"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|link
operator|=
name|Globals
operator|.
name|DOI_LOOKUP_PREFIX
operator|+
name|link
expr_stmt|;
block|}
comment|// converts doi-only link to full http address
comment|// Morten Alver 6 Nov 2012: this extracts a nonfunctional DOI from some complete
comment|// http addresses (e.g. http://onlinelibrary.wiley.com/doi/10.1002/rra.999/abstract, where
comment|// the trailing "/abstract" is included but doesn't lead to a resolvable DOI).
comment|// To prevent mangling of working URLs I'm disabling this check if the link is already
comment|// a full http link:
if|if
condition|(
name|DOIUtil
operator|.
name|checkForPlainDOI
argument_list|(
name|link
argument_list|)
operator|&&
operator|!
name|link
operator|.
name|startsWith
argument_list|(
literal|"http://"
argument_list|)
condition|)
block|{
name|link
operator|=
name|Globals
operator|.
name|DOI_LOOKUP_PREFIX
operator|+
name|DOIUtil
operator|.
name|getDOI
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
name|link
operator|=
name|link
operator|.
name|replaceAll
argument_list|(
literal|"\\+"
argument_list|,
literal|"%2B"
argument_list|)
expr_stmt|;
try|try
block|{
name|link
operator|=
name|URLDecoder
operator|.
name|decode
argument_list|(
name|link
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|ignored
parameter_list|)
block|{         }
comment|/**          * Fix for: [ 1574773 ] sanitizeUrl() breaks ftp:// and file:///          *           * http://sourceforge.net/tracker/index.php?func=detail&aid=1574773&group_id=92314&atid=600306          */
try|try
block|{
return|return
operator|new
name|URI
argument_list|(
literal|null
argument_list|,
name|link
argument_list|,
literal|null
argument_list|)
operator|.
name|toASCIIString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
return|return
name|link
return|;
block|}
block|}
DECL|method|parseMethodsCalls (String calls)
specifier|public
specifier|static
name|ArrayList
argument_list|<
name|String
index|[]
argument_list|>
name|parseMethodsCalls
parameter_list|(
name|String
name|calls
parameter_list|)
throws|throws
name|RuntimeException
block|{
name|ArrayList
argument_list|<
name|String
index|[]
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|String
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|char
index|[]
name|c
init|=
name|calls
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|c
operator|.
name|length
condition|)
block|{
name|int
name|start
init|=
name|i
decl_stmt|;
if|if
condition|(
name|Character
operator|.
name|isJavaIdentifierStart
argument_list|(
name|c
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|c
operator|.
name|length
operator|&&
operator|(
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|c
index|[
name|i
index|]
argument_list|)
operator|||
name|c
index|[
name|i
index|]
operator|==
literal|'.'
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|c
operator|.
name|length
operator|&&
name|c
index|[
name|i
index|]
operator|==
literal|'('
condition|)
block|{
name|String
name|method
init|=
name|calls
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|// Skip the brace
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|c
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|c
index|[
name|i
index|]
operator|==
literal|'"'
condition|)
block|{
comment|// Parameter is in format "xxx"
comment|// Skip "
name|i
operator|++
expr_stmt|;
name|int
name|startParam
init|=
name|i
decl_stmt|;
name|i
operator|++
expr_stmt|;
name|boolean
name|escaped
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|i
operator|+
literal|1
operator|<
name|c
operator|.
name|length
operator|&&
operator|!
operator|(
operator|!
name|escaped
operator|&&
name|c
index|[
name|i
index|]
operator|==
literal|'"'
operator|&&
name|c
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|')'
operator|)
condition|)
block|{
if|if
condition|(
name|c
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
name|escaped
operator|=
operator|!
name|escaped
expr_stmt|;
block|}
else|else
block|{
name|escaped
operator|=
literal|false
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|String
name|param
init|=
name|calls
operator|.
name|substring
argument_list|(
name|startParam
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
operator|new
name|String
index|[]
block|{
name|method
block|,
name|param
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Parameter is in format xxx
name|int
name|startParam
init|=
name|i
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|c
operator|.
name|length
operator|&&
name|c
index|[
name|i
index|]
operator|!=
literal|')'
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
name|String
name|param
init|=
name|calls
operator|.
name|substring
argument_list|(
name|startParam
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
operator|new
name|String
index|[]
block|{
name|method
block|,
name|param
block|}
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Incorrecly terminated open brace
name|result
operator|.
name|add
argument_list|(
operator|new
name|String
index|[]
block|{
name|method
block|}
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
name|method
init|=
name|calls
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
operator|new
name|String
index|[]
block|{
name|method
block|}
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|field|squareBracketsPattern
specifier|private
specifier|static
specifier|final
name|Pattern
name|squareBracketsPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\[.*?\\]"
argument_list|)
decl_stmt|;
comment|/**      * Takes a string that contains bracketed expression and expands each of      * these using getFieldAndFormat.      *      * Unknown Bracket expressions are silently dropped.      *      * @param bracketString      * @param entry      * @param database      * @return      */
DECL|method|expandBrackets (String bracketString, BibtexEntry entry, BibtexDatabase database)
specifier|public
specifier|static
name|String
name|expandBrackets
parameter_list|(
name|String
name|bracketString
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
block|{
name|Matcher
name|m
init|=
name|Util
operator|.
name|squareBracketsPattern
operator|.
name|matcher
argument_list|(
name|bracketString
argument_list|)
decl_stmt|;
name|StringBuffer
name|s
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|replacement
init|=
name|Util
operator|.
name|getFieldAndFormat
argument_list|(
name|m
operator|.
name|group
argument_list|()
argument_list|,
name|entry
argument_list|,
name|database
argument_list|)
decl_stmt|;
if|if
condition|(
name|replacement
operator|==
literal|null
condition|)
block|{
name|replacement
operator|=
literal|""
expr_stmt|;
block|}
name|m
operator|.
name|appendReplacement
argument_list|(
name|s
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
block|}
name|m
operator|.
name|appendTail
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Sets empty or non-existing owner fields of bibtex entries inside a List      * to a specified default value. Timestamp field is also set. Preferences      * are checked to see if these options are enabled.      *       * @param bibs      *            List of bibtex entries      */
DECL|method|setAutomaticFields (Collection<BibtexEntry> bibs, boolean overwriteOwner, boolean overwriteTimestamp, boolean markEntries)
specifier|public
specifier|static
name|void
name|setAutomaticFields
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|bibs
parameter_list|,
name|boolean
name|overwriteOwner
parameter_list|,
name|boolean
name|overwriteTimestamp
parameter_list|,
name|boolean
name|markEntries
parameter_list|)
block|{
name|String
name|timeStampField
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|TIME_STAMP_FIELD
argument_list|)
decl_stmt|;
name|String
name|defaultOwner
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|DEFAULT_OWNER
argument_list|)
decl_stmt|;
name|String
name|timestamp
init|=
name|dateFormatter
operator|.
name|getCurrentDate
argument_list|()
decl_stmt|;
name|boolean
name|globalSetOwner
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|USE_OWNER
argument_list|)
decl_stmt|,
name|globalSetTimeStamp
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|USE_TIME_STAMP
argument_list|)
decl_stmt|;
comment|// Do not need to do anything if all options are disabled
if|if
condition|(
operator|!
operator|(
name|globalSetOwner
operator|||
name|globalSetTimeStamp
operator|||
name|markEntries
operator|)
condition|)
block|{
return|return;
block|}
comment|// Iterate through all entries
for|for
control|(
name|BibtexEntry
name|curEntry
range|:
name|bibs
control|)
block|{
name|boolean
name|setOwner
init|=
name|globalSetOwner
operator|&&
operator|(
name|overwriteOwner
operator|||
name|curEntry
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|OWNER
argument_list|)
operator|==
literal|null
operator|)
decl_stmt|;
name|boolean
name|setTimeStamp
init|=
name|globalSetTimeStamp
operator|&&
operator|(
name|overwriteTimestamp
operator|||
name|curEntry
operator|.
name|getField
argument_list|(
name|timeStampField
argument_list|)
operator|==
literal|null
operator|)
decl_stmt|;
name|Util
operator|.
name|setAutomaticFields
argument_list|(
name|curEntry
argument_list|,
name|setOwner
argument_list|,
name|defaultOwner
argument_list|,
name|setTimeStamp
argument_list|,
name|timeStampField
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|markEntries
condition|)
block|{
name|EntryMarker
operator|.
name|markEntry
argument_list|(
name|curEntry
argument_list|,
name|EntryMarker
operator|.
name|IMPORT_MARK_LEVEL
argument_list|,
literal|false
argument_list|,
operator|new
name|NamedCompound
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Sets empty or non-existing owner fields of a bibtex entry to a specified      * default value. Timestamp field is also set. Preferences are checked to      * see if these options are enabled.      *       * @param entry      *            The entry to set fields for.      * @param overwriteOwner      *              Indicates whether owner should be set if it is already set.      * @param overwriteTimestamp      *              Indicates whether timestamp should be set if it is already set.      */
DECL|method|setAutomaticFields (BibtexEntry entry, boolean overwriteOwner, boolean overwriteTimestamp)
specifier|public
specifier|static
name|void
name|setAutomaticFields
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|boolean
name|overwriteOwner
parameter_list|,
name|boolean
name|overwriteTimestamp
parameter_list|)
block|{
name|String
name|defaultOwner
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|DEFAULT_OWNER
argument_list|)
decl_stmt|;
name|String
name|timestamp
init|=
name|dateFormatter
operator|.
name|getCurrentDate
argument_list|()
decl_stmt|;
name|String
name|timeStampField
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|TIME_STAMP_FIELD
argument_list|)
decl_stmt|;
name|boolean
name|setOwner
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|USE_OWNER
argument_list|)
operator|&&
operator|(
name|overwriteOwner
operator|||
name|entry
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|OWNER
argument_list|)
operator|==
literal|null
operator|)
decl_stmt|;
name|boolean
name|setTimeStamp
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|USE_TIME_STAMP
argument_list|)
operator|&&
operator|(
name|overwriteTimestamp
operator|||
name|entry
operator|.
name|getField
argument_list|(
name|timeStampField
argument_list|)
operator|==
literal|null
operator|)
decl_stmt|;
name|Util
operator|.
name|setAutomaticFields
argument_list|(
name|entry
argument_list|,
name|setOwner
argument_list|,
name|defaultOwner
argument_list|,
name|setTimeStamp
argument_list|,
name|timeStampField
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
block|}
DECL|method|setAutomaticFields (BibtexEntry entry, boolean setOwner, String owner, boolean setTimeStamp, String timeStampField, String timeStamp)
specifier|private
specifier|static
name|void
name|setAutomaticFields
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|boolean
name|setOwner
parameter_list|,
name|String
name|owner
parameter_list|,
name|boolean
name|setTimeStamp
parameter_list|,
name|String
name|timeStampField
parameter_list|,
name|String
name|timeStamp
parameter_list|)
block|{
comment|// Set owner field if this option is enabled:
if|if
condition|(
name|setOwner
condition|)
block|{
comment|// No or empty owner field?
comment|// if (entry.getField(Globals.OWNER) == null
comment|// || ((String) entry.getField(Globals.OWNER)).length() == 0) {
comment|// Set owner field to default value
name|entry
operator|.
name|setField
argument_list|(
name|BibtexFields
operator|.
name|OWNER
argument_list|,
name|owner
argument_list|)
expr_stmt|;
comment|// }
block|}
if|if
condition|(
name|setTimeStamp
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|timeStampField
argument_list|,
name|timeStamp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This method is called at startup, and makes necessary adaptations to      * preferences for users from an earlier version of Jabref.      */
DECL|method|performCompatibilityUpdate ()
specifier|public
specifier|static
name|void
name|performCompatibilityUpdate
parameter_list|()
block|{
comment|// Make sure "abstract" is not in General fields, because
comment|// Jabref 1.55 moves the abstract to its own tab.
name|String
name|genFields
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|GENERAL_FIELDS
argument_list|)
decl_stmt|;
comment|// pr(genFields+"\t"+genFields.indexOf("abstract"));
if|if
condition|(
name|genFields
operator|.
name|contains
argument_list|(
literal|"abstract"
argument_list|)
condition|)
block|{
comment|// pr(genFields+"\t"+genFields.indexOf("abstract"));
name|String
name|newGen
decl_stmt|;
if|if
condition|(
name|genFields
operator|.
name|equals
argument_list|(
literal|"abstract"
argument_list|)
condition|)
block|{
name|newGen
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|genFields
operator|.
name|contains
argument_list|(
literal|";abstract;"
argument_list|)
condition|)
block|{
name|newGen
operator|=
name|genFields
operator|.
name|replaceAll
argument_list|(
literal|";abstract;"
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|genFields
operator|.
name|indexOf
argument_list|(
literal|"abstract;"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newGen
operator|=
name|genFields
operator|.
name|replaceAll
argument_list|(
literal|"abstract;"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|genFields
operator|.
name|indexOf
argument_list|(
literal|";abstract"
argument_list|)
operator|==
name|genFields
operator|.
name|length
argument_list|()
operator|-
literal|9
condition|)
block|{
name|newGen
operator|=
name|genFields
operator|.
name|replaceAll
argument_list|(
literal|";abstract"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newGen
operator|=
name|genFields
expr_stmt|;
block|}
comment|// pr(newGen);
name|Globals
operator|.
name|prefs
operator|.
name|put
argument_list|(
name|JabRefPreferences
operator|.
name|GENERAL_FIELDS
argument_list|,
name|newGen
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Collect file links from the given set of fields, and add them to the list contained      * in the field GUIGlobals.FILE_FIELD.      * @param database The database to modify.      * @param fields The fields to find links in.      * @return A CompoundEdit specifying the undo operation for the whole operation.      */
DECL|method|upgradePdfPsToFile (BibtexDatabase database, String[] fields)
specifier|public
specifier|static
name|NamedCompound
name|upgradePdfPsToFile
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|String
index|[]
name|fields
parameter_list|)
block|{
return|return
name|Util
operator|.
name|upgradePdfPsToFile
argument_list|(
name|database
operator|.
name|getEntryMap
argument_list|()
operator|.
name|values
argument_list|()
argument_list|,
name|fields
argument_list|)
return|;
block|}
comment|/**      * Collect file links from the given set of fields, and add them to the list contained      * in the field GUIGlobals.FILE_FIELD.      * @param entries The entries to modify.      * @param fields The fields to find links in.      * @return A CompoundEdit specifying the undo operation for the whole operation.      */
DECL|method|upgradePdfPsToFile (Collection<BibtexEntry> entries, String[] fields)
specifier|public
specifier|static
name|NamedCompound
name|upgradePdfPsToFile
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
name|String
index|[]
name|fields
parameter_list|)
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Move external links to 'file' field"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|FileListTableModel
name|tableModel
init|=
operator|new
name|FileListTableModel
argument_list|()
decl_stmt|;
comment|// If there are already links in the file field, keep those on top:
name|String
name|oldFileContent
init|=
name|entry
operator|.
name|getField
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldFileContent
operator|!=
literal|null
condition|)
block|{
name|tableModel
operator|.
name|setContent
argument_list|(
name|oldFileContent
argument_list|)
expr_stmt|;
block|}
name|int
name|oldRowCount
init|=
name|tableModel
operator|.
name|getRowCount
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
name|String
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|o
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|FileListEntry
name|flEntry
init|=
operator|new
name|FileListEntry
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|o
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeByExt
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
name|tableModel
operator|.
name|addEntry
argument_list|(
name|tableModel
operator|.
name|getRowCount
argument_list|()
argument_list|,
name|flEntry
argument_list|)
expr_stmt|;
name|entry
operator|.
name|clearField
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|field
argument_list|,
name|o
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tableModel
operator|.
name|getRowCount
argument_list|()
operator|!=
name|oldRowCount
condition|)
block|{
name|String
name|newValue
init|=
name|tableModel
operator|.
name|getStringRepresentation
argument_list|()
decl_stmt|;
name|entry
operator|.
name|setField
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|,
name|oldFileContent
argument_list|,
name|newValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
return|return
name|ce
return|;
block|}
comment|/**      * Warns the user of undesired side effects of an explicit      * assignment/removal of entries to/from this group. Currently there are      * four types of groups: AllEntriesGroup, SearchGroup - do not support      * explicit assignment. ExplicitGroup - never modifies entries. KeywordGroup -      * only this modifies entries upon assignment/removal. Modifications are      * acceptable unless they affect a standard field (such as "author") besides      * the "keywords" field.      *       * @param parent      *            The Component used as a parent when displaying a confirmation      *            dialog.      * @return true if the assignment has no undesired side effects, or the user      *         chose to perform it anyway. false otherwise (this indicates that      *         the user has aborted the assignment).      */
DECL|method|warnAssignmentSideEffects (AbstractGroup[] groups, BibtexEntry[] entries, BibtexDatabase db, Component parent)
specifier|public
specifier|static
name|boolean
name|warnAssignmentSideEffects
parameter_list|(
name|AbstractGroup
index|[]
name|groups
parameter_list|,
name|BibtexEntry
index|[]
name|entries
parameter_list|,
name|BibtexDatabase
name|db
parameter_list|,
name|Component
name|parent
parameter_list|)
block|{
name|Vector
argument_list|<
name|String
argument_list|>
name|affectedFields
init|=
operator|new
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|AbstractGroup
name|group
range|:
name|groups
control|)
block|{
if|if
condition|(
name|group
operator|instanceof
name|KeywordGroup
condition|)
block|{
name|KeywordGroup
name|kg
init|=
operator|(
name|KeywordGroup
operator|)
name|group
decl_stmt|;
name|String
name|field
init|=
name|kg
operator|.
name|getSearchField
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"keywords"
argument_list|)
condition|)
block|{
continue|continue;
comment|// this is not undesired
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|BibtexFields
operator|.
name|numberOfPublicFields
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
name|BibtexFields
operator|.
name|getFieldName
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|affectedFields
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|affectedFields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
comment|// no side effects
block|}
comment|// show a warning, then return
name|StringBuffer
name|message
init|=
comment|// JZTODO lyrics...
operator|new
name|StringBuffer
argument_list|(
literal|"This action will modify the following field(s)\n"
operator|+
literal|"in at least one entry each:\n"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|affectedFields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|message
operator|.
name|append
argument_list|(
name|affectedFields
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|message
operator|.
name|append
argument_list|(
literal|"This could cause undesired changes to "
operator|+
literal|"your entries, so it is\nrecommended that you change the grouping field "
operator|+
literal|"in your group\ndefinition to \"keywords\" or a non-standard name."
operator|+
literal|"\n\nDo you still want to continue?"
argument_list|)
expr_stmt|;
name|int
name|choice
init|=
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|parent
argument_list|,
name|message
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Warning"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_OPTION
argument_list|,
name|JOptionPane
operator|.
name|WARNING_MESSAGE
argument_list|)
decl_stmt|;
return|return
name|choice
operator|!=
name|JOptionPane
operator|.
name|NO_OPTION
return|;
comment|// if (groups instanceof KeywordGroup) {
comment|// KeywordGroup kg = (KeywordGroup) groups;
comment|// String field = kg.getSearchField().toLowerCase();
comment|// if (field.equals("keywords"))
comment|// return true; // this is not undesired
comment|// for (int i = 0; i< GUIGlobals.ALL_FIELDS.length; ++i) {
comment|// if (field.equals(GUIGlobals.ALL_FIELDS[i])) {
comment|// // show a warning, then return
comment|// String message = Globals // JZTODO lyrics...
comment|// .lang(
comment|// "This action will modify the \"%0\" field "
comment|// + "of your entries.\nThis could cause undesired changes to "
comment|// + "your entries, so it is\nrecommended that you change the grouping
comment|// field "
comment|// + "in your group\ndefinition to \"keywords\" or a non-standard name."
comment|// + "\n\nDo you still want to continue?",
comment|// field);
comment|// int choice = JOptionPane.showConfirmDialog(parent, message,
comment|// Globals.lang("Warning"), JOptionPane.YES_NO_OPTION,
comment|// JOptionPane.WARNING_MESSAGE);
comment|// return choice != JOptionPane.NO_OPTION;
comment|// }
comment|// }
comment|// }
comment|// return true; // found no side effects
block|}
comment|/**      * Wrap all uppercase letters, or sequences of uppercase letters, in curly      * braces. Ignore letters within a pair of # character, as these are part of      * a string label that should not be modified.      *       * @param s      *            The string to modify.      * @return The resulting string after wrapping capitals.      */
DECL|method|putBracesAroundCapitals (String s)
specifier|public
specifier|static
name|String
name|putBracesAroundCapitals
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|boolean
name|inString
init|=
literal|false
decl_stmt|,
name|isBracing
init|=
literal|false
decl_stmt|,
name|escaped
init|=
literal|false
decl_stmt|;
name|int
name|inBrace
init|=
literal|0
decl_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// Update variables based on special characters:
name|int
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
name|inBrace
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
block|{
name|inBrace
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|escaped
operator|&&
name|c
operator|==
literal|'#'
condition|)
block|{
name|inString
operator|=
operator|!
name|inString
expr_stmt|;
block|}
comment|// See if we should start bracing:
if|if
condition|(
name|inBrace
operator|==
literal|0
operator|&&
operator|!
name|isBracing
operator|&&
operator|!
name|inString
operator|&&
name|Character
operator|.
name|isLetter
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|&&
name|Character
operator|.
name|isUpperCase
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|isBracing
operator|=
literal|true
expr_stmt|;
block|}
comment|// See if we should close a brace set:
if|if
condition|(
name|isBracing
operator|&&
operator|!
operator|(
name|Character
operator|.
name|isLetter
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|&&
name|Character
operator|.
name|isUpperCase
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|isBracing
operator|=
literal|false
expr_stmt|;
block|}
comment|// Add the current character:
name|buf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
comment|// Check if we are entering an escape sequence:
name|escaped
operator|=
name|c
operator|==
literal|'\\'
operator|&&
operator|!
name|escaped
expr_stmt|;
block|}
comment|// Check if we have an unclosed brace:
if|if
condition|(
name|isBracing
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
comment|/*          * if (s.length() == 0) return s; // Protect against ArrayIndexOutOf....          * StringBuffer buf = new StringBuffer();          *           * Matcher mcr = titleCapitalPattern.matcher(s.substring(1)); while          * (mcr.find()) { String replaceStr = mcr.group();          * mcr.appendReplacement(buf, "{" + replaceStr + "}"); }          * mcr.appendTail(buf); return s.substring(0, 1) + buf.toString();          */
block|}
DECL|field|BRACED_TITLE_CAPITAL_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|BRACED_TITLE_CAPITAL_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\{[A-Z]+\\}"
argument_list|)
decl_stmt|;
comment|/**      * This method looks for occurences of capital letters enclosed in an      * arbitrary number of pairs of braces, e.g. "{AB}" or "{{T}}". All of these      * pairs of braces are removed.      *       * @param s      *            The String to analyze.      * @return A new String with braces removed.      */
DECL|method|removeBracesAroundCapitals (String s)
specifier|public
specifier|static
name|String
name|removeBracesAroundCapitals
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|String
name|previous
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|Util
operator|.
name|removeSingleBracesAroundCapitals
argument_list|(
name|s
argument_list|)
operator|)
operator|.
name|length
argument_list|()
operator|<
name|previous
operator|.
name|length
argument_list|()
condition|)
block|{
name|previous
operator|=
name|s
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/**      * This method looks for occurences of capital letters enclosed in one pair      * of braces, e.g. "{AB}". All these are replaced by only the capitals in      * between the braces.      *       * @param s      *            The String to analyze.      * @return A new String with braces removed.      */
DECL|method|removeSingleBracesAroundCapitals (String s)
specifier|private
specifier|static
name|String
name|removeSingleBracesAroundCapitals
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|Matcher
name|mcr
init|=
name|Util
operator|.
name|BRACED_TITLE_CAPITAL_PATTERN
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
name|mcr
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|replaceStr
init|=
name|mcr
operator|.
name|group
argument_list|()
decl_stmt|;
name|mcr
operator|.
name|appendReplacement
argument_list|(
name|buf
argument_list|,
name|replaceStr
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|replaceStr
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mcr
operator|.
name|appendTail
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This method looks up what kind of external binding is used for the given      * field, and constructs on OpenFileFilter suitable for browsing for an      * external file.      *       * @param fieldName      *            The BibTeX field in question.      * @return The file filter.      */
DECL|method|getFileFilterForField (String fieldName)
specifier|public
specifier|static
name|OpenFileFilter
name|getFileFilterForField
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|String
name|s
init|=
name|BibtexFields
operator|.
name|getFieldExtras
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
specifier|final
name|String
name|ext
init|=
literal|"."
operator|+
name|fieldName
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
specifier|final
name|OpenFileFilter
name|off
decl_stmt|;
if|if
condition|(
literal|"browseDocZip"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|off
operator|=
operator|new
name|OpenFileFilter
argument_list|(
operator|new
name|String
index|[]
block|{
name|ext
block|,
name|ext
operator|+
literal|".gz"
block|,
name|ext
operator|+
literal|".bz2"
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|off
operator|=
operator|new
name|OpenFileFilter
argument_list|(
operator|new
name|String
index|[]
block|{
name|ext
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|off
return|;
block|}
comment|/**      * This method can be used to display a "rich" error dialog which offers the      * entire stack trace for an exception.      *       * @param parent      * @param e      */
DECL|method|showQuickErrorDialog (JFrame parent, String title, Exception e)
specifier|public
specifier|static
name|void
name|showQuickErrorDialog
parameter_list|(
name|JFrame
name|parent
parameter_list|,
name|String
name|title
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
comment|// create and configure a text area - fill it with exception text.
specifier|final
name|JPanel
name|pan
init|=
operator|new
name|JPanel
argument_list|()
decl_stmt|,
name|details
init|=
operator|new
name|JPanel
argument_list|()
decl_stmt|;
specifier|final
name|CardLayout
name|crd
init|=
operator|new
name|CardLayout
argument_list|()
decl_stmt|;
name|pan
operator|.
name|setLayout
argument_list|(
name|crd
argument_list|)
expr_stmt|;
specifier|final
name|JTextArea
name|textArea
init|=
operator|new
name|JTextArea
argument_list|()
decl_stmt|;
name|textArea
operator|.
name|setFont
argument_list|(
operator|new
name|Font
argument_list|(
literal|"Sans-Serif"
argument_list|,
name|Font
operator|.
name|PLAIN
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|textArea
operator|.
name|setEditable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|StringWriter
name|writer
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|(
operator|new
name|PrintWriter
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
name|textArea
operator|.
name|setText
argument_list|(
name|writer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|JLabel
name|lab
init|=
operator|new
name|JLabel
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
name|JButton
name|flip
init|=
operator|new
name|JButton
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Details"
argument_list|)
argument_list|)
decl_stmt|;
name|FormLayout
name|layout
init|=
operator|new
name|FormLayout
argument_list|(
literal|"left:pref"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|DefaultFormBuilder
name|builder
init|=
operator|new
name|DefaultFormBuilder
argument_list|(
name|layout
argument_list|)
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|builder
operator|.
name|nextLine
argument_list|()
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|Box
operator|.
name|createVerticalGlue
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|nextLine
argument_list|()
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|flip
argument_list|)
expr_stmt|;
specifier|final
name|JPanel
name|simple
init|=
name|builder
operator|.
name|getPanel
argument_list|()
decl_stmt|;
comment|// stuff it in a scrollpane with a controlled size.
name|JScrollPane
name|scrollPane
init|=
operator|new
name|JScrollPane
argument_list|(
name|textArea
argument_list|)
decl_stmt|;
name|scrollPane
operator|.
name|setPreferredSize
argument_list|(
operator|new
name|Dimension
argument_list|(
literal|350
argument_list|,
literal|150
argument_list|)
argument_list|)
expr_stmt|;
name|details
operator|.
name|setLayout
argument_list|(
operator|new
name|BorderLayout
argument_list|()
argument_list|)
expr_stmt|;
name|details
operator|.
name|add
argument_list|(
name|scrollPane
argument_list|,
name|BorderLayout
operator|.
name|CENTER
argument_list|)
expr_stmt|;
name|flip
operator|.
name|addActionListener
argument_list|(
operator|new
name|ActionListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|actionPerformed
parameter_list|(
name|ActionEvent
name|event
parameter_list|)
block|{
name|crd
operator|.
name|show
argument_list|(
name|pan
argument_list|,
literal|"details"
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|pan
operator|.
name|add
argument_list|(
name|simple
argument_list|,
literal|"simple"
argument_list|)
expr_stmt|;
name|pan
operator|.
name|add
argument_list|(
name|details
argument_list|,
literal|"details"
argument_list|)
expr_stmt|;
comment|// pass the scrollpane to the joptionpane.
name|JOptionPane
operator|.
name|showMessageDialog
argument_list|(
name|parent
argument_list|,
name|pan
argument_list|,
name|title
argument_list|,
name|JOptionPane
operator|.
name|ERROR_MESSAGE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set a given field to a given value for all entries in a Collection. This      * method DOES NOT update any UndoManager, but returns a relevant      * CompoundEdit that should be registered by the caller.      *       * @param entries      *            The entries to set the field for.      * @param field      *            The name of the field to set.      * @param text      *            The value to set. This value can be null, indicating that the      *            field should be cleared.      * @param overwriteValues      *            Indicate whether the value should be set even if an entry      *            already has the field set.      * @return A CompoundEdit for the entire operation.      */
DECL|method|massSetField (Collection<BibtexEntry> entries, String field, String text, boolean overwriteValues)
specifier|public
specifier|static
name|UndoableEdit
name|massSetField
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|text
parameter_list|,
name|boolean
name|overwriteValues
parameter_list|)
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Set field"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|String
name|oldVal
init|=
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|// If we are not allowed to overwrite values, check if there is a
comment|// nonempty
comment|// value already for this entry:
if|if
condition|(
operator|!
name|overwriteValues
operator|&&
name|oldVal
operator|!=
literal|null
operator|&&
operator|!
name|oldVal
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|text
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|.
name|clearField
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|field
argument_list|,
name|oldVal
argument_list|,
name|text
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
return|return
name|ce
return|;
block|}
comment|/**      * Move contents from one field to another for a Collection of entries.      * @param entries The entries to do this operation for.      * @param field The field to move contents from.      * @param newField The field to move contents into.      * @param overwriteValues If true, overwrites any existing values in the new field.      *          If false, makes no change for entries with existing value in the new field.      * @return A CompoundEdit for the entire operation.      */
DECL|method|massRenameField (Collection<BibtexEntry> entries, String field, String newField, boolean overwriteValues)
specifier|public
specifier|static
name|UndoableEdit
name|massRenameField
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|newField
parameter_list|,
name|boolean
name|overwriteValues
parameter_list|)
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Rename field"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|String
name|valToMove
init|=
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|// If there is no value, do nothing:
if|if
condition|(
name|valToMove
operator|==
literal|null
operator|||
name|valToMove
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|// If we are not allowed to overwrite values, check if there is a
comment|// nonempy value already for this entry for the new field:
name|String
name|valInNewField
init|=
name|entry
operator|.
name|getField
argument_list|(
name|newField
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|overwriteValues
operator|&&
name|valInNewField
operator|!=
literal|null
operator|&&
operator|!
name|valInNewField
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|entry
operator|.
name|setField
argument_list|(
name|newField
argument_list|,
name|valToMove
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|newField
argument_list|,
name|valInNewField
argument_list|,
name|valToMove
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|clearField
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|field
argument_list|,
name|valToMove
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
return|return
name|ce
return|;
block|}
comment|/**      * Make a list of supported character encodings that can encode all      * characters in the given String.      *       * @param characters      *            A String of characters that should be supported by the      *            encodings.      * @return A List of character encodings      */
DECL|method|findEncodingsForString (String characters)
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|findEncodingsForString
parameter_list|(
name|String
name|characters
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|encodings
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Globals
operator|.
name|ENCODINGS
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|CharsetEncoder
name|encoder
init|=
name|Charset
operator|.
name|forName
argument_list|(
name|Globals
operator|.
name|ENCODINGS
index|[
name|i
index|]
argument_list|)
operator|.
name|newEncoder
argument_list|()
decl_stmt|;
if|if
condition|(
name|encoder
operator|.
name|canEncode
argument_list|(
name|characters
argument_list|)
condition|)
block|{
name|encodings
operator|.
name|add
argument_list|(
name|Globals
operator|.
name|ENCODINGS
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|encodings
return|;
block|}
comment|/**      * From http://stackoverflow.com/questions/1030479/most-efficient-way-of-converting-string-to-integer-in-java      *      * @param str      * @return      */
DECL|method|intValueOf (String str)
specifier|public
specifier|static
name|int
name|intValueOf
parameter_list|(
name|String
name|str
parameter_list|)
block|{
name|int
name|ival
init|=
literal|0
decl_stmt|,
name|idx
init|=
literal|0
decl_stmt|,
name|end
decl_stmt|;
name|boolean
name|sign
init|=
literal|false
decl_stmt|;
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|str
operator|==
literal|null
operator|||
operator|(
name|end
operator|=
name|str
operator|.
name|length
argument_list|()
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|ch
operator|=
name|str
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|)
operator|<
literal|'0'
operator|||
name|ch
operator|>
literal|'9'
operator|)
operator|&&
operator|(
operator|!
operator|(
name|sign
operator|=
name|ch
operator|==
literal|'-'
operator|)
operator|||
operator|++
name|idx
operator|==
name|end
operator|||
operator|(
name|ch
operator|=
name|str
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
operator|)
operator|<
literal|'0'
operator|||
name|ch
operator|>
literal|'9'
operator|)
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
name|str
argument_list|)
throw|;
block|}
for|for
control|(
init|;
condition|;
name|ival
operator|*=
literal|10
control|)
block|{
name|ival
operator|+=
literal|'0'
operator|-
name|ch
expr_stmt|;
if|if
condition|(
operator|++
name|idx
operator|==
name|end
condition|)
block|{
return|return
name|sign
condition|?
name|ival
else|:
operator|-
name|ival
return|;
block|}
if|if
condition|(
operator|(
name|ch
operator|=
name|str
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
operator|)
operator|<
literal|'0'
operator|||
name|ch
operator|>
literal|'9'
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
name|str
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Encodes a two-dimensional String array into a single string, using ':' and      * ';' as separators. The characters ':' and ';' are escaped with '\'.      * @param values The String array.      * @return The encoded String.      */
DECL|method|encodeStringArray (String[][] values)
specifier|public
specifier|static
name|String
name|encodeStringArray
parameter_list|(
name|String
index|[]
index|[]
name|values
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|Util
operator|.
name|encodeStringArray
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|values
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Encodes a String array into a single string, using ':' as separator.      * The characters ':' and ';' are escaped with '\'.      * @param entry The String array.      * @return The encoded String.      */
DECL|method|encodeStringArray (String[] entry)
specifier|private
specifier|static
name|String
name|encodeStringArray
parameter_list|(
name|String
index|[]
name|entry
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|entry
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|Util
operator|.
name|encodeString
argument_list|(
name|entry
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|entry
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Decodes an encoded double String array back into array form. The array      * is assumed to be square, and delimited by the characters ';' (first dim) and      * ':' (second dim).      * @param value The encoded String to be decoded.      * @return The decoded String array.      */
DECL|method|decodeStringDoubleArray (String value)
specifier|public
specifier|static
name|String
index|[]
index|[]
name|decodeStringDoubleArray
parameter_list|(
name|String
name|value
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|newList
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|thisEntry
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|escaped
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|value
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|value
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|escaped
operator|&&
name|c
operator|==
literal|'\\'
condition|)
block|{
name|escaped
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|escaped
operator|&&
name|c
operator|==
literal|':'
condition|)
block|{
name|thisEntry
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|escaped
operator|&&
name|c
operator|==
literal|';'
condition|)
block|{
name|thisEntry
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
name|newList
operator|.
name|add
argument_list|(
name|thisEntry
argument_list|)
expr_stmt|;
name|thisEntry
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|escaped
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|thisEntry
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|thisEntry
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|newList
operator|.
name|add
argument_list|(
name|thisEntry
argument_list|)
expr_stmt|;
block|}
comment|// Convert to String[][]:
name|String
index|[]
index|[]
name|res
init|=
operator|new
name|String
index|[
name|newList
operator|.
name|size
argument_list|()
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|res
index|[
name|i
index|]
operator|=
operator|new
name|String
index|[
name|newList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|res
index|[
name|i
index|]
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|res
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|newList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
DECL|method|encodeString (String s)
specifier|public
specifier|static
name|String
name|encodeString
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|';'
operator|||
name|c
operator|==
literal|':'
operator|||
name|c
operator|==
literal|'\\'
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Static equals that can also return the right result when one of the      * objects is null.      *       * @param one      *            The object whose equals method is called if the first is not      *            null.      * @param two      *            The object passed to the first one if the first is not null.      * @return<code>one == null ? two == null : one.equals(two);</code>      */
DECL|method|equals (Object one, Object two)
specifier|public
specifier|static
name|boolean
name|equals
parameter_list|(
name|Object
name|one
parameter_list|,
name|Object
name|two
parameter_list|)
block|{
return|return
name|one
operator|==
literal|null
condition|?
name|two
operator|==
literal|null
else|:
name|one
operator|.
name|equals
argument_list|(
name|two
argument_list|)
return|;
block|}
comment|/**      * Run an AbstractWorker's methods using Spin features to put each method      * on the correct thread.      * @param worker The worker to run.      * @throws Throwable       */
DECL|method|runAbstractWorker (AbstractWorker worker)
specifier|public
specifier|static
name|void
name|runAbstractWorker
parameter_list|(
name|AbstractWorker
name|worker
parameter_list|)
throws|throws
name|Throwable
block|{
comment|// This part uses Spin's features:
name|Worker
name|wrk
init|=
name|worker
operator|.
name|getWorker
argument_list|()
decl_stmt|;
comment|// The Worker returned by getWorker() has been wrapped
comment|// by Spin.off(), which makes its methods be run in
comment|// a different thread from the EDT.
name|CallBack
name|clb
init|=
name|worker
operator|.
name|getCallBack
argument_list|()
decl_stmt|;
name|worker
operator|.
name|init
argument_list|()
expr_stmt|;
comment|// This method runs in this same thread, the EDT.
comment|// Useful for initial GUI actions, like printing a message.
comment|// The CallBack returned by getCallBack() has been wrapped
comment|// by Spin.over(), which makes its methods be run on
comment|// the EDT.
name|wrk
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// Runs the potentially time-consuming action
comment|// without freezing the GUI. The magic is that THIS line
comment|// of execution will not continue until run() is finished.
name|clb
operator|.
name|update
argument_list|()
expr_stmt|;
comment|// Runs the update() method on the EDT.
block|}
comment|/**      * Build a String array containing all those elements of all that are not      * in subset.      * @param all The array of all values.      * @param subset The subset of values.      * @return The remainder that is not part of the subset.      */
DECL|method|getRemainder (String[] all, String[] subset)
specifier|public
specifier|static
name|String
index|[]
name|getRemainder
parameter_list|(
name|String
index|[]
name|all
parameter_list|,
name|String
index|[]
name|subset
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|al
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|anAll
range|:
name|all
control|)
block|{
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|aSubset
range|:
name|subset
control|)
block|{
if|if
condition|(
name|aSubset
operator|.
name|equals
argument_list|(
name|anAll
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|al
operator|.
name|add
argument_list|(
name|anAll
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|al
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|al
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Determines filename provided by an entry in a database      *      * @param database the database, where the entry is located      * @param entry the entry to which the file should be linked to      * @return a suggested fileName      */
DECL|method|getLinkedFileName (BibtexDatabase database, BibtexEntry entry)
specifier|public
specifier|static
name|String
name|getLinkedFileName
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|)
block|{
name|String
name|targetName
init|=
name|entry
operator|.
name|getCiteKey
argument_list|()
operator|==
literal|null
condition|?
literal|"default"
else|:
name|entry
operator|.
name|getCiteKey
argument_list|()
decl_stmt|;
name|StringReader
name|sr
init|=
operator|new
name|StringReader
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|ImportSettingsTab
operator|.
name|PREF_IMPORT_FILENAMEPATTERN
argument_list|)
argument_list|)
decl_stmt|;
name|Layout
name|layout
init|=
literal|null
decl_stmt|;
try|try
block|{
name|layout
operator|=
operator|new
name|LayoutHelper
argument_list|(
name|sr
argument_list|)
operator|.
name|getLayoutFromText
argument_list|(
name|Globals
operator|.
name|FORMATTER_PACKAGE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOGGER
operator|.
name|info
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Wrong Format"
argument_list|)
operator|.
name|concat
argument_list|(
literal|" "
argument_list|)
operator|.
name|concat
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|layout
operator|!=
literal|null
condition|)
block|{
name|targetName
operator|=
name|layout
operator|.
name|doLayout
argument_list|(
name|entry
argument_list|,
name|database
argument_list|)
expr_stmt|;
block|}
comment|//Removes illegal characters from filename
name|targetName
operator|=
name|FileNameCleaner
operator|.
name|cleanFileName
argument_list|(
name|targetName
argument_list|)
expr_stmt|;
return|return
name|targetName
return|;
block|}
DECL|method|getSeparatedKeywords (String keywords)
specifier|public
specifier|static
name|ArrayList
argument_list|<
name|String
argument_list|>
name|getSeparatedKeywords
parameter_list|(
name|String
name|keywords
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|res
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|keywords
operator|==
literal|null
condition|)
block|{
return|return
name|res
return|;
block|}
comment|// _NOSPACE is a hack to support keywords such as "choreography transactions"
comment|// a more intelligent algorithm would check for the separator chosen (SEPARATING_CHARS_NOSPACE)
comment|// if nothing is found, " " is likely to be the separating char.
comment|// solution by RisKeywords.java: s.split(",[ ]*")
name|StringTokenizer
name|tok
init|=
operator|new
name|StringTokenizer
argument_list|(
name|keywords
argument_list|,
name|SEPARATING_CHARS_NOSPACE
argument_list|)
decl_stmt|;
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|word
init|=
name|tok
operator|.
name|nextToken
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|res
operator|.
name|add
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
DECL|method|getSeparatedKeywords (BibtexEntry be)
specifier|public
specifier|static
name|ArrayList
argument_list|<
name|String
argument_list|>
name|getSeparatedKeywords
parameter_list|(
name|BibtexEntry
name|be
parameter_list|)
block|{
return|return
name|Util
operator|.
name|getSeparatedKeywords
argument_list|(
name|be
operator|.
name|getField
argument_list|(
literal|"keywords"
argument_list|)
argument_list|)
return|;
block|}
DECL|method|putKeywords (BibtexEntry entry, ArrayList<String> keywords, NamedCompound ce)
specifier|public
specifier|static
name|void
name|putKeywords
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|keywords
parameter_list|,
name|NamedCompound
name|ce
parameter_list|)
block|{
comment|// Set Keyword Field
name|String
name|oldValue
init|=
name|entry
operator|.
name|getField
argument_list|(
literal|"keywords"
argument_list|)
decl_stmt|;
name|String
name|newValue
decl_stmt|;
if|if
condition|(
operator|!
name|keywords
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|keyword
range|:
name|keywords
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|keyword
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|newValue
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|newValue
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|oldValue
operator|==
literal|null
operator|&&
name|newValue
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|oldValue
operator|==
literal|null
operator|||
operator|!
name|oldValue
operator|.
name|equals
argument_list|(
name|newValue
argument_list|)
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"keywords"
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
operator|!=
literal|null
condition|)
block|{
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
literal|"keywords"
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * @param ce indicates the undo named compound. May be null      */
DECL|method|updateField (BibtexEntry be, String field, String newValue, NamedCompound ce)
specifier|public
specifier|static
name|void
name|updateField
parameter_list|(
name|BibtexEntry
name|be
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|newValue
parameter_list|,
name|NamedCompound
name|ce
parameter_list|)
block|{
name|Util
operator|.
name|updateField
argument_list|(
name|be
argument_list|,
name|field
argument_list|,
name|newValue
argument_list|,
name|ce
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param ce indicates the undo named compound. May be null      */
DECL|method|updateField (BibtexEntry be, String field, String newValue, NamedCompound ce, Boolean nullFieldIfValueIsTheSame)
specifier|public
specifier|static
name|void
name|updateField
parameter_list|(
name|BibtexEntry
name|be
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|newValue
parameter_list|,
name|NamedCompound
name|ce
parameter_list|,
name|Boolean
name|nullFieldIfValueIsTheSame
parameter_list|)
block|{
name|String
name|oldValue
init|=
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|nullFieldIfValueIsTheSame
operator|&&
name|oldValue
operator|!=
literal|null
operator|&&
name|oldValue
operator|.
name|equals
argument_list|(
name|newValue
argument_list|)
condition|)
block|{
comment|// if oldValue == newValue then reset field if required by parameter
name|newValue
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|oldValue
operator|==
literal|null
operator|&&
name|newValue
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|oldValue
operator|==
literal|null
operator|||
operator|!
name|oldValue
operator|.
name|equals
argument_list|(
name|newValue
argument_list|)
condition|)
block|{
name|be
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
operator|!=
literal|null
condition|)
block|{
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|be
argument_list|,
name|field
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Binds ESC-Key to cancel button      * @param rootPane the pane to bind the action to. Typically, this variable is retrieved by this.getRootPane();      * @param cancelAction the action to bind      */
DECL|method|bindCloseDialogKeyToCancelAction (JRootPane rootPane, Action cancelAction)
specifier|public
specifier|static
name|void
name|bindCloseDialogKeyToCancelAction
parameter_list|(
name|JRootPane
name|rootPane
parameter_list|,
name|Action
name|cancelAction
parameter_list|)
block|{
name|InputMap
name|im
init|=
name|rootPane
operator|.
name|getInputMap
argument_list|(
name|JComponent
operator|.
name|WHEN_IN_FOCUSED_WINDOW
argument_list|)
decl_stmt|;
name|ActionMap
name|am
init|=
name|rootPane
operator|.
name|getActionMap
argument_list|()
decl_stmt|;
name|im
operator|.
name|put
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|getKey
argument_list|(
literal|"Close dialog"
argument_list|)
argument_list|,
literal|"close"
argument_list|)
expr_stmt|;
name|am
operator|.
name|put
argument_list|(
literal|"close"
argument_list|,
name|cancelAction
argument_list|)
expr_stmt|;
block|}
comment|/**      * Download the URL and return contents as a String.      * @param source      * @return      * @throws IOException      */
DECL|method|getResults (URLConnection source)
specifier|public
specifier|static
name|String
name|getResults
parameter_list|(
name|URLConnection
name|source
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|Util
operator|.
name|getResultsWithEncoding
argument_list|(
name|source
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Download the URL using specified encoding and return contents as a String.      * @param source      * encoding      * @return      * @throws IOException      */
DECL|method|getResultsWithEncoding (URLConnection source, String encoding)
specifier|public
specifier|static
name|String
name|getResultsWithEncoding
parameter_list|(
name|URLConnection
name|source
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStreamReader
name|in
decl_stmt|;
if|if
condition|(
name|encoding
operator|!=
literal|null
condition|)
block|{
name|in
operator|=
operator|new
name|InputStreamReader
argument_list|(
name|source
operator|.
name|getInputStream
argument_list|()
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|=
operator|new
name|InputStreamReader
argument_list|(
name|source
operator|.
name|getInputStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|byteRead
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|byteRead
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|byteRead
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|updateTimeStampIsSet ()
specifier|public
specifier|static
name|boolean
name|updateTimeStampIsSet
parameter_list|()
block|{
return|return
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|USE_TIME_STAMP
argument_list|)
operator|&&
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|UPDATE_TIMESTAMP
argument_list|)
return|;
block|}
comment|/**      * Updates the timestamp of the given entry,      * nests the given undaoableEdit in a named compound,      * and returns that named compound      */
DECL|method|doUpdateTimeStamp (BibtexEntry entry, AbstractUndoableEdit undoableEdit)
specifier|public
specifier|static
name|NamedCompound
name|doUpdateTimeStamp
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|AbstractUndoableEdit
name|undoableEdit
parameter_list|)
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|undoableEdit
operator|.
name|getPresentationName
argument_list|()
argument_list|)
decl_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
name|undoableEdit
argument_list|)
expr_stmt|;
name|String
name|timeStampField
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|TIME_STAMP_FIELD
argument_list|)
decl_stmt|;
name|String
name|timestamp
init|=
name|dateFormatter
operator|.
name|getCurrentDate
argument_list|()
decl_stmt|;
name|Util
operator|.
name|updateField
argument_list|(
name|entry
argument_list|,
name|timeStampField
argument_list|,
name|timestamp
argument_list|,
name|ce
argument_list|)
expr_stmt|;
return|return
name|ce
return|;
block|}
comment|/**      * Automatically add links for this set of entries, based on the globally stored list of      * external file types. The entries are modified, and corresponding UndoEdit elements      * added to the NamedCompound given as argument. Furthermore, all entries which are modified      * are added to the Set of entries given as an argument.      *      * The entries' bibtex keys must have been set - entries lacking key are ignored.      * The operation is done in a new thread, which is returned for the caller to wait for      * if needed.      *      * @param entries A collection of BibtexEntry objects to find links for.      * @param ce A NamedCompound to add UndoEdit elements to.      * @param changedEntries MODIFIED, optional. A Set of BibtexEntry objects to which all modified entries is added. This is used for status output and debugging      * @param singleTableModel UGLY HACK. The table model to insert links into. Already existing links are not duplicated or removed. This parameter has to be null if entries.count() != 1.      *   The hack has been introduced as a bibtexentry does not (yet) support the function getListTableModel() and the FileListEntryEditor editor holds an instance of that table model and does not reconstruct it after the search has succeeded.      * @param metaData The MetaData providing the relevant file directory, if any.      * @param callback An ActionListener that is notified (on the event dispatch thread) when the search is      *  finished. The ActionEvent has id=0 if no new links were added, and id=1 if one or more links were added.      *  This parameter can be null, which means that no callback will be notified.      * @param diag An instantiated modal JDialog which will be used to display the progress of the autosetting.      *      This parameter can be null, which means that no progress update will be shown.      * @return the thread performing the autosetting      */
DECL|method|autoSetLinks (final Collection<BibtexEntry> entries, final NamedCompound ce, final Set<BibtexEntry> changedEntries, final FileListTableModel singleTableModel, final MetaData metaData, final ActionListener callback, final JDialog diag)
specifier|public
specifier|static
name|Runnable
name|autoSetLinks
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
specifier|final
name|NamedCompound
name|ce
parameter_list|,
specifier|final
name|Set
argument_list|<
name|BibtexEntry
argument_list|>
name|changedEntries
parameter_list|,
specifier|final
name|FileListTableModel
name|singleTableModel
parameter_list|,
specifier|final
name|MetaData
name|metaData
parameter_list|,
specifier|final
name|ActionListener
name|callback
parameter_list|,
specifier|final
name|JDialog
name|diag
parameter_list|)
block|{
specifier|final
name|ExternalFileType
index|[]
name|types
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeSelection
argument_list|()
decl_stmt|;
if|if
condition|(
name|diag
operator|!=
literal|null
condition|)
block|{
specifier|final
name|JProgressBar
name|prog
init|=
operator|new
name|JProgressBar
argument_list|(
name|JProgressBar
operator|.
name|HORIZONTAL
argument_list|,
literal|0
argument_list|,
name|types
operator|.
name|length
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|JLabel
name|label
init|=
operator|new
name|JLabel
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Searching for files"
argument_list|)
argument_list|)
decl_stmt|;
name|prog
operator|.
name|setIndeterminate
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|prog
operator|.
name|setBorder
argument_list|(
name|BorderFactory
operator|.
name|createEmptyBorder
argument_list|(
literal|5
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|diag
operator|.
name|setTitle
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Autosetting links"
argument_list|)
argument_list|)
expr_stmt|;
name|diag
operator|.
name|getContentPane
argument_list|()
operator|.
name|add
argument_list|(
name|prog
argument_list|,
name|BorderLayout
operator|.
name|CENTER
argument_list|)
expr_stmt|;
name|diag
operator|.
name|getContentPane
argument_list|()
operator|.
name|add
argument_list|(
name|label
argument_list|,
name|BorderLayout
operator|.
name|SOUTH
argument_list|)
expr_stmt|;
name|diag
operator|.
name|pack
argument_list|()
expr_stmt|;
name|diag
operator|.
name|setLocationRelativeTo
argument_list|(
name|diag
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Runnable
name|r
init|=
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// determine directories to search in
name|ArrayList
argument_list|<
name|File
argument_list|>
name|dirs
init|=
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|()
decl_stmt|;
name|String
index|[]
name|dirsS
init|=
name|metaData
operator|.
name|getFileDirectory
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|dirs1
range|:
name|dirsS
control|)
block|{
name|dirs
operator|.
name|add
argument_list|(
operator|new
name|File
argument_list|(
name|dirs1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// determine extensions
name|Collection
argument_list|<
name|String
argument_list|>
name|extensions
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|ExternalFileType
name|type
range|:
name|types
control|)
block|{
name|extensions
operator|.
name|add
argument_list|(
name|type
operator|.
name|getExtension
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Run the search operation:
name|Map
argument_list|<
name|BibtexEntry
argument_list|,
name|java
operator|.
name|util
operator|.
name|List
argument_list|<
name|File
argument_list|>
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|USE_REG_EXP_SEARCH_KEY
argument_list|)
condition|)
block|{
name|String
name|regExp
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|REG_EXP_SEARCH_EXPRESSION_KEY
argument_list|)
decl_stmt|;
name|result
operator|=
name|RegExpFileSearch
operator|.
name|findFilesForSet
argument_list|(
name|entries
argument_list|,
name|extensions
argument_list|,
name|dirs
argument_list|,
name|regExp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Util
operator|.
name|findAssociatedFiles
argument_list|(
name|entries
argument_list|,
name|extensions
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
block|}
name|boolean
name|foundAny
init|=
literal|false
decl_stmt|;
comment|// Iterate over the entries:
for|for
control|(
name|BibtexEntry
name|anEntry
range|:
name|result
operator|.
name|keySet
argument_list|()
control|)
block|{
name|FileListTableModel
name|tableModel
decl_stmt|;
name|String
name|oldVal
init|=
name|anEntry
operator|.
name|getField
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|)
decl_stmt|;
if|if
condition|(
name|singleTableModel
operator|==
literal|null
condition|)
block|{
name|tableModel
operator|=
operator|new
name|FileListTableModel
argument_list|()
expr_stmt|;
if|if
condition|(
name|oldVal
operator|!=
literal|null
condition|)
block|{
name|tableModel
operator|.
name|setContent
argument_list|(
name|oldVal
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|entries
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
name|tableModel
operator|=
name|singleTableModel
expr_stmt|;
block|}
name|List
argument_list|<
name|File
argument_list|>
name|files
init|=
name|result
operator|.
name|get
argument_list|(
name|anEntry
argument_list|)
decl_stmt|;
for|for
control|(
name|File
name|f
range|:
name|files
control|)
block|{
name|f
operator|=
name|FileUtil
operator|.
name|shortenFileName
argument_list|(
name|f
argument_list|,
name|dirsS
argument_list|)
expr_stmt|;
name|boolean
name|alreadyHas
init|=
literal|false
decl_stmt|;
comment|//System.out.println("File: "+f.getPath());
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|tableModel
operator|.
name|getRowCount
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|FileListEntry
name|existingEntry
init|=
name|tableModel
operator|.
name|getEntry
argument_list|(
name|j
argument_list|)
decl_stmt|;
comment|//System.out.println("Comp: "+existingEntry.getLink());
if|if
condition|(
operator|new
name|File
argument_list|(
name|existingEntry
operator|.
name|getLink
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|alreadyHas
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|alreadyHas
condition|)
block|{
name|foundAny
operator|=
literal|true
expr_stmt|;
name|ExternalFileType
name|type
decl_stmt|;
name|int
name|index
init|=
name|f
operator|.
name|getPath
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|f
operator|.
name|getPath
argument_list|()
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
name|type
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeByExt
argument_list|(
name|f
operator|.
name|getPath
argument_list|()
operator|.
name|substring
argument_list|(
name|index
operator|+
literal|1
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
operator|new
name|UnknownExternalFileType
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|FileListEntry
name|flEntry
init|=
operator|new
name|FileListEntry
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|f
operator|.
name|getPath
argument_list|()
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tableModel
operator|.
name|addEntry
argument_list|(
name|tableModel
operator|.
name|getRowCount
argument_list|()
argument_list|,
name|flEntry
argument_list|)
expr_stmt|;
name|String
name|newVal
init|=
name|tableModel
operator|.
name|getStringRepresentation
argument_list|()
decl_stmt|;
if|if
condition|(
name|newVal
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|newVal
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|ce
operator|!=
literal|null
condition|)
block|{
comment|// store undo information
name|UndoableFieldChange
name|change
init|=
operator|new
name|UndoableFieldChange
argument_list|(
name|anEntry
argument_list|,
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|,
name|oldVal
argument_list|,
name|newVal
argument_list|)
decl_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
name|change
argument_list|)
expr_stmt|;
block|}
comment|// hack: if table model is given, do NOT modify entry
if|if
condition|(
name|singleTableModel
operator|==
literal|null
condition|)
block|{
name|anEntry
operator|.
name|setField
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changedEntries
operator|!=
literal|null
condition|)
block|{
name|changedEntries
operator|.
name|add
argument_list|(
name|anEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// handle callbacks and dialog
specifier|final
name|int
name|id
init|=
name|foundAny
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|SwingUtilities
operator|.
name|invokeLater
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|diag
operator|!=
literal|null
condition|)
block|{
name|diag
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
block|{
name|callback
operator|.
name|actionPerformed
argument_list|(
operator|new
name|ActionEvent
argument_list|(
name|this
argument_list|,
name|id
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
if|if
condition|(
name|diag
operator|!=
literal|null
condition|)
block|{
name|diag
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
comment|/**      * Automatically add links for this entry to the table model given as an argument, based on      * the globally stored list of external file types. The entry itself is not modified. The entry's      * bibtex key must have been set.      *      * @param entry The BibtexEntry to find links for.      * @param singleTableModel The table model to insert links into. Already existing links are not duplicated or removed.      * @param metaData The MetaData providing the relevant file directory, if any.      * @param callback An ActionListener that is notified (on the event dispatch thread) when the search is      *  finished. The ActionEvent has id=0 if no new links were added, and id=1 if one or more links were added.      *  This parameter can be null, which means that no callback will be notified. The passed ActionEvent is constructed with      *  (this, id, ""), where id is 1 if something has been done and 0 if nothing has been done.      * @param diag An instantiated modal JDialog which will be used to display the progress of the autosetting.      *      This parameter can be null, which means that no progress update will be shown.      * @return the runnable able to perform the autosetting      */
DECL|method|autoSetLinks ( final BibtexEntry entry, final FileListTableModel singleTableModel, final MetaData metaData, final ActionListener callback, final JDialog diag)
specifier|public
specifier|static
name|Runnable
name|autoSetLinks
parameter_list|(
specifier|final
name|BibtexEntry
name|entry
parameter_list|,
specifier|final
name|FileListTableModel
name|singleTableModel
parameter_list|,
specifier|final
name|MetaData
name|metaData
parameter_list|,
specifier|final
name|ActionListener
name|callback
parameter_list|,
specifier|final
name|JDialog
name|diag
parameter_list|)
block|{
specifier|final
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
init|=
operator|new
name|ArrayList
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|()
decl_stmt|;
name|entries
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
name|Util
operator|.
name|autoSetLinks
argument_list|(
name|entries
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|singleTableModel
argument_list|,
name|metaData
argument_list|,
name|callback
argument_list|,
name|diag
argument_list|)
return|;
block|}
comment|/**      * Opens a file browser of the folder of the given file. If possible, the file is selected      * @param fileLink the location of the file      * @throws IOException      */
DECL|method|openFolderAndSelectFile (String fileLink)
specifier|public
specifier|static
name|void
name|openFolderAndSelectFile
parameter_list|(
name|String
name|fileLink
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|Globals
operator|.
name|ON_WIN
condition|)
block|{
name|Util
operator|.
name|openFolderAndSelectFileOnWindows
argument_list|(
name|fileLink
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Globals
operator|.
name|ON_LINUX
condition|)
block|{
name|Util
operator|.
name|openFolderAndSelectFileOnLinux
argument_list|(
name|fileLink
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Util
operator|.
name|openFolderAndSelectFileGeneric
argument_list|(
name|fileLink
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|openFolderAndSelectFileOnLinux (String fileLink)
specifier|private
specifier|static
name|void
name|openFolderAndSelectFileOnLinux
parameter_list|(
name|String
name|fileLink
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|desktopSession
init|=
name|System
operator|.
name|getenv
argument_list|(
literal|"DESKTOP_SESSION"
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|cmd
decl_stmt|;
if|if
condition|(
name|desktopSession
operator|.
name|contains
argument_list|(
literal|"gnome"
argument_list|)
condition|)
block|{
name|cmd
operator|=
literal|"nautilus "
operator|+
name|fileLink
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|desktopSession
operator|.
name|contains
argument_list|(
literal|"kde"
argument_list|)
condition|)
block|{
name|cmd
operator|=
literal|"dolphin --select "
operator|+
name|fileLink
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
literal|"xdg-open "
operator|+
name|fileLink
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|fileLink
operator|.
name|lastIndexOf
argument_list|(
name|File
operator|.
name|separator
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
DECL|method|openFolderAndSelectFileGeneric (String fileLink)
specifier|private
specifier|static
name|void
name|openFolderAndSelectFileGeneric
parameter_list|(
name|String
name|fileLink
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|fileLink
argument_list|)
decl_stmt|;
name|Desktop
operator|.
name|getDesktop
argument_list|()
operator|.
name|open
argument_list|(
name|f
operator|.
name|getParentFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|openFolderAndSelectFileOnWindows (String link)
specifier|private
specifier|static
name|void
name|openFolderAndSelectFileOnWindows
parameter_list|(
name|String
name|link
parameter_list|)
throws|throws
name|IOException
block|{
name|link
operator|=
name|link
operator|.
name|replace
argument_list|(
literal|"&"
argument_list|,
literal|"\"&\""
argument_list|)
expr_stmt|;
name|String
name|cmd
init|=
literal|"explorer.exe /select,\""
operator|+
name|link
operator|+
literal|"\""
decl_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the list of linked files. The files have the absolute filename      *       * @param bes list of BibTeX entries      * @param fileDirs list of directories to try for expansion      *       * @return list of files. May be empty      */
DECL|method|getListOfLinkedFiles (BibtexEntry[] bes, String[] fileDirs)
specifier|public
specifier|static
name|List
argument_list|<
name|File
argument_list|>
name|getListOfLinkedFiles
parameter_list|(
name|BibtexEntry
index|[]
name|bes
parameter_list|,
name|String
index|[]
name|fileDirs
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|File
argument_list|>
name|res
init|=
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|bes
control|)
block|{
name|FileListTableModel
name|tm
init|=
operator|new
name|FileListTableModel
argument_list|()
decl_stmt|;
name|tm
operator|.
name|setContent
argument_list|(
name|entry
operator|.
name|getField
argument_list|(
literal|"file"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tm
operator|.
name|getRowCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|FileListEntry
name|flEntry
init|=
name|tm
operator|.
name|getEntry
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|File
name|f
init|=
name|FileUtil
operator|.
name|expandFilename
argument_list|(
name|flEntry
operator|.
name|getLink
argument_list|()
argument_list|,
name|fileDirs
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
block|{
name|res
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|res
return|;
block|}
DECL|method|findAssociatedFiles (Collection<BibtexEntry> entries, Collection<String> extensions, Collection<File> directories)
specifier|public
specifier|static
name|Map
argument_list|<
name|BibtexEntry
argument_list|,
name|List
argument_list|<
name|File
argument_list|>
argument_list|>
name|findAssociatedFiles
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|extensions
parameter_list|,
name|Collection
argument_list|<
name|File
argument_list|>
name|directories
parameter_list|)
block|{
name|HashMap
argument_list|<
name|BibtexEntry
argument_list|,
name|List
argument_list|<
name|File
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|BibtexEntry
argument_list|,
name|List
argument_list|<
name|File
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// First scan directories
name|Set
argument_list|<
name|File
argument_list|>
name|filesWithExtension
init|=
name|UtilFindFiles
operator|.
name|findFiles
argument_list|(
name|extensions
argument_list|,
name|directories
argument_list|)
decl_stmt|;
comment|// Initialize Result-Set
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|result
operator|.
name|put
argument_list|(
name|entry
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|boolean
name|exactOnly
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|AUTOLINK_EXACT_KEY_ONLY
argument_list|)
decl_stmt|;
comment|// Now look for keys
name|nextFile
label|:
for|for
control|(
name|File
name|file
range|:
name|filesWithExtension
control|)
block|{
name|String
name|name
init|=
name|file
operator|.
name|getName
argument_list|()
decl_stmt|;
name|int
name|dot
init|=
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
comment|// First, look for exact matches:
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|String
name|citeKey
init|=
name|entry
operator|.
name|getCiteKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|citeKey
operator|!=
literal|null
operator|&&
operator|!
name|citeKey
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|dot
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|dot
argument_list|)
operator|.
name|equals
argument_list|(
name|citeKey
argument_list|)
condition|)
block|{
name|result
operator|.
name|get
argument_list|(
name|entry
argument_list|)
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
continue|continue
name|nextFile
continue|;
block|}
block|}
block|}
block|}
comment|// If we get here, we didn't find any exact matches. If non-exact
comment|// matches are allowed, try to find one:
if|if
condition|(
operator|!
name|exactOnly
condition|)
block|{
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|String
name|citeKey
init|=
name|entry
operator|.
name|getCiteKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|citeKey
operator|!=
literal|null
operator|&&
operator|!
name|citeKey
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|citeKey
argument_list|)
condition|)
block|{
name|result
operator|.
name|get
argument_list|(
name|entry
argument_list|)
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
continue|continue
name|nextFile
continue|;
block|}
block|}
block|}
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**      * Accepts a string like [author:lower] or [title:abbr] or [auth],      * whereas the first part signifies the bibtex-field to get, or the key generator      * field marker to use, while the others are the modifiers that will be applied.      *      * @param fieldAndFormat      * @param entry      * @param database      * @return      */
DECL|method|getFieldAndFormat (String fieldAndFormat, BibtexEntry entry, BibtexDatabase database)
specifier|public
specifier|static
name|String
name|getFieldAndFormat
parameter_list|(
name|String
name|fieldAndFormat
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
block|{
name|fieldAndFormat
operator|=
name|StringUtil
operator|.
name|stripBrackets
argument_list|(
name|fieldAndFormat
argument_list|)
expr_stmt|;
name|int
name|colon
init|=
name|fieldAndFormat
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
name|String
name|beforeColon
decl_stmt|,
name|afterColon
decl_stmt|;
if|if
condition|(
name|colon
operator|==
operator|-
literal|1
condition|)
block|{
name|beforeColon
operator|=
name|fieldAndFormat
expr_stmt|;
name|afterColon
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|beforeColon
operator|=
name|fieldAndFormat
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|afterColon
operator|=
name|fieldAndFormat
operator|.
name|substring
argument_list|(
name|colon
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|beforeColon
operator|=
name|beforeColon
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|beforeColon
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|fieldValue
init|=
name|BibtexDatabase
operator|.
name|getResolvedField
argument_list|(
name|beforeColon
argument_list|,
name|entry
argument_list|,
name|database
argument_list|)
decl_stmt|;
comment|// If no field value was found, try to interpret it as a key generator field marker:
if|if
condition|(
name|fieldValue
operator|==
literal|null
condition|)
block|{
name|fieldValue
operator|=
name|LabelPatternUtil
operator|.
name|makeLabel
argument_list|(
name|entry
argument_list|,
name|beforeColon
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fieldValue
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|afterColon
operator|==
literal|null
operator|||
name|afterColon
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|fieldValue
return|;
block|}
name|String
index|[]
name|parts
init|=
name|afterColon
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|fieldValue
operator|=
name|LabelPatternUtil
operator|.
name|applyModifiers
argument_list|(
name|fieldValue
argument_list|,
name|parts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fieldValue
return|;
block|}
comment|/**      * Opens the given URL using the system browser      *       * @param url the URL to open      * @throws IOException      */
DECL|method|openBrowser (String url)
specifier|public
specifier|static
name|void
name|openBrowser
parameter_list|(
name|String
name|url
parameter_list|)
throws|throws
name|IOException
block|{
name|url
operator|=
name|Util
operator|.
name|sanitizeUrl
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|ExternalFileType
name|fileType
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeByExt
argument_list|(
literal|"html"
argument_list|)
decl_stmt|;
name|Util
operator|.
name|openExternalFilePlatformIndependent
argument_list|(
name|fileType
argument_list|,
name|url
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

