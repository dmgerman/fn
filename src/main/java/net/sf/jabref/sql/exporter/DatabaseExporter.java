begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003-2016 JabRef contributors.     This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General public static License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General public static License for more details.      You should have received a copy of the GNU General public static License along     with this program; if not, write to the Free Software Foundation, Inc.,     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.  */
end_comment

begin_package
DECL|package|net.sf.jabref.sql.exporter
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|sql
operator|.
name|exporter
package|;
end_package

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|PreparedStatement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JOptionPane
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibDatabaseContext
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|Globals
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|JabRefFrame
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|exporter
operator|.
name|BibDatabaseWriter
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|exporter
operator|.
name|SavePreferences
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|groups
operator|.
name|AbstractGroup
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|groups
operator|.
name|AllEntriesGroup
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|groups
operator|.
name|ExplicitGroup
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|groups
operator|.
name|GroupHierarchyType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|groups
operator|.
name|GroupTreeNode
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|groups
operator|.
name|KeywordGroup
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|groups
operator|.
name|SearchGroup
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|l10n
operator|.
name|Localization
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|util
operator|.
name|strings
operator|.
name|StringUtil
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|EntryTypes
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabase
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabaseMode
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|BibEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|BibtexString
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|EntryType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|sql
operator|.
name|DBImportExportDialog
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|sql
operator|.
name|DBStrings
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|sql
operator|.
name|Database
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|sql
operator|.
name|DatabaseUtil
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|sql
operator|.
name|SQLUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_comment
comment|/**  * @author igorsteinmacher.  *<p>  *         Jan 20th Abstract Class to provide main features to export entries to a DB. To insert a new DB it is  *         necessary to extend this class and add the DB name the enum available at  *         net.sf.jabref.sql.DBImporterAndExporterFactory (and to the GUI). This class and its subclasses create  *         database, entries and related stuff within a DB.  */
end_comment

begin_class
DECL|class|DatabaseExporter
specifier|public
class|class
name|DatabaseExporter
block|{
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Log
name|LOGGER
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DatabaseExporter
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|dbNames
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|dbNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|database
specifier|private
specifier|final
name|Database
name|database
decl_stmt|;
DECL|field|dbStrings
specifier|private
name|DBStrings
name|dbStrings
decl_stmt|;
DECL|method|DatabaseExporter (Database database)
specifier|public
name|DatabaseExporter
parameter_list|(
name|Database
name|database
parameter_list|)
block|{
name|this
operator|.
name|database
operator|=
name|database
expr_stmt|;
block|}
comment|/**      * Method for the exportDatabase methods.      *      * @param databaseContext the database to export      * @param entriesToExport The list of the entries to export.      * @param out             The output (PrintStream or Connection) object to which the DML should be written.      * @throws SQLException      */
DECL|method|performExport (BibDatabaseContext databaseContext, List<BibEntry> entriesToExport, Connection out, String dbName)
specifier|public
name|void
name|performExport
parameter_list|(
name|BibDatabaseContext
name|databaseContext
parameter_list|,
name|List
argument_list|<
name|BibEntry
argument_list|>
name|entriesToExport
parameter_list|,
name|Connection
name|out
parameter_list|,
name|String
name|dbName
parameter_list|)
throws|throws
name|SQLException
block|{
name|SavePreferences
name|savePrefs
init|=
name|SavePreferences
operator|.
name|loadForExportFromPreferences
argument_list|(
name|Globals
operator|.
name|prefs
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|entries
init|=
name|BibDatabaseWriter
operator|.
name|getSortedEntries
argument_list|(
name|databaseContext
argument_list|,
name|entriesToExport
argument_list|,
name|savePrefs
argument_list|)
decl_stmt|;
name|GroupTreeNode
name|gtn
init|=
name|databaseContext
operator|.
name|getMetaData
argument_list|()
operator|.
name|getGroups
argument_list|()
decl_stmt|;
specifier|final
name|int
name|databaseID
init|=
name|DatabaseUtil
operator|.
name|getDatabaseIDByName
argument_list|(
name|databaseContext
argument_list|,
name|out
argument_list|,
name|dbName
argument_list|)
decl_stmt|;
name|DatabaseUtil
operator|.
name|removeAllRecordsForAGivenDB
argument_list|(
name|out
argument_list|,
name|databaseID
argument_list|)
expr_stmt|;
name|populateEntryTypesTable
argument_list|(
name|out
argument_list|,
name|databaseContext
operator|.
name|getMode
argument_list|()
argument_list|)
expr_stmt|;
name|populateEntriesTable
argument_list|(
name|databaseID
argument_list|,
name|entries
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|populateStringTable
argument_list|(
name|databaseContext
operator|.
name|getDatabase
argument_list|()
argument_list|,
name|out
argument_list|,
name|databaseID
argument_list|)
expr_stmt|;
name|populateGroupTypesTable
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|populateGroupsTable
argument_list|(
name|gtn
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|out
argument_list|,
name|databaseID
argument_list|)
expr_stmt|;
name|populateEntryGroupsTable
argument_list|(
name|gtn
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|out
argument_list|,
name|databaseID
argument_list|)
expr_stmt|;
block|}
comment|/**      * Generates the DML required to populate the entries table with jabref data and writes it to the output      * PrintStream.      *      * @param database_id ID of Jabref database related to the entries to be exported This information can be gathered      *                    using getDatabaseIDByPath(metaData, connection)      * @param entries     The BibtexEntries to export      * @param connection  The output (PrintStream or Connection) object to which the DML should be written.      */
DECL|method|populateEntriesTable (final int database_id, List<BibEntry> entries, Connection connection)
specifier|private
name|void
name|populateEntriesTable
parameter_list|(
specifier|final
name|int
name|database_id
parameter_list|,
name|List
argument_list|<
name|BibEntry
argument_list|>
name|entries
parameter_list|,
name|Connection
name|connection
parameter_list|)
throws|throws
name|SQLException
block|{
for|for
control|(
name|BibEntry
name|entry
range|:
name|entries
control|)
block|{
try|try
init|(
name|PreparedStatement
name|statement
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
literal|"INSERT INTO entries (jabref_eid, entry_types_id, cite_key, "
operator|+
name|SQLUtil
operator|.
name|getFieldStr
argument_list|()
operator|+
literal|", database_id) "
operator|+
literal|"VALUES (?, (SELECT entry_types_id FROM entry_types WHERE label= ? ), ?, "
operator|+
name|SQLUtil
operator|.
name|getAllFields
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|s
lambda|->
literal|"?"
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|joining
argument_list|(
literal|", "
argument_list|)
argument_list|)
operator|+
literal|", ?);"
argument_list|)
init|)
block|{
name|statement
operator|.
name|setString
argument_list|(
literal|1
argument_list|,
name|entry
operator|.
name|getId
argument_list|()
argument_list|)
block|;
name|statement
operator|.
name|setString
argument_list|(
literal|2
argument_list|,
name|entry
operator|.
name|getType
argument_list|()
argument_list|)
block|;
name|statement
operator|.
name|setString
argument_list|(
literal|3
argument_list|,
name|entry
operator|.
name|getCiteKey
argument_list|()
argument_list|)
block|;
name|int
name|value
operator|=
literal|4
block|;
for|for
control|(
name|String
name|field
range|:
name|SQLUtil
operator|.
name|getAllFields
argument_list|()
control|)
block|{
name|statement
operator|.
name|setString
argument_list|(
name|value
argument_list|,
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|++
expr_stmt|;
block|}
name|statement
operator|.
name|setInt
argument_list|(
name|value
argument_list|,
name|database_id
argument_list|)
expr_stmt|;
name|statement
operator|.
name|execute
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|/**      * Recursive method to include a tree of groups.      *      * @param cursor      The current GroupTreeNode in the GroupsTree      * @param parentID    The integer ID associated with the cursors's parent node      * @param currentID   The integer value to associate with the cursor      * @param connection  The Connection      * @param database_id Id of jabref database to which the group is part of      */
end_comment

begin_function
DECL|method|populateEntryGroupsTable (GroupTreeNode cursor, int parentID, int currentID, Connection connection, final int database_id)
specifier|private
name|int
name|populateEntryGroupsTable
parameter_list|(
name|GroupTreeNode
name|cursor
parameter_list|,
name|int
name|parentID
parameter_list|,
name|int
name|currentID
parameter_list|,
name|Connection
name|connection
parameter_list|,
specifier|final
name|int
name|database_id
parameter_list|)
block|{
if|if
condition|(
name|cursor
operator|==
literal|null
condition|)
block|{
comment|// no groups passed
return|return
operator|-
literal|1
return|;
block|}
comment|// recurse on child nodes (depth-first traversal)
name|String
name|sql
init|=
literal|"SELECT groups_id FROM groups WHERE label = ? AND database_id= ? AND parent_id = ? ;"
decl_stmt|;
try|try
init|(
name|PreparedStatement
name|statement
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
name|sql
argument_list|)
init|)
block|{
name|statement
operator|.
name|setString
argument_list|(
literal|1
argument_list|,
name|cursor
operator|.
name|getGroup
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|statement
operator|.
name|setInt
argument_list|(
literal|2
argument_list|,
name|database_id
argument_list|)
expr_stmt|;
name|statement
operator|.
name|setInt
argument_list|(
literal|3
argument_list|,
name|parentID
argument_list|)
expr_stmt|;
try|try
init|(
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|()
init|)
block|{
comment|// setting values to ID and myID to be used in case of textual SQL
comment|// export
name|currentID
operator|++
expr_stmt|;
name|int
name|myID
init|=
name|currentID
decl_stmt|;
name|resultSet
operator|.
name|next
argument_list|()
expr_stmt|;
name|myID
operator|=
name|resultSet
operator|.
name|getInt
argument_list|(
literal|"groups_id"
argument_list|)
expr_stmt|;
for|for
control|(
name|GroupTreeNode
name|child
range|:
name|cursor
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|currentID
operator|=
name|populateEntryGroupsTable
argument_list|(
name|child
argument_list|,
name|myID
argument_list|,
name|currentID
argument_list|,
name|connection
argument_list|,
name|database_id
argument_list|)
expr_stmt|;
block|}
block|}
comment|//Unfortunatley, AutoCloseable throws only Exception
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Cannot close resource"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|currentID
return|;
block|}
end_function

begin_comment
comment|/**      * Generates the SQL required to populate the entry_types table with jabref data.      *      * @param out  The output (PrintSream or Connection) object to which the DML should be written.      * @param type      */
end_comment

begin_function
DECL|method|populateEntryTypesTable (Connection out, BibDatabaseMode type)
specifier|private
name|void
name|populateEntryTypesTable
parameter_list|(
name|Connection
name|out
parameter_list|,
name|BibDatabaseMode
name|type
parameter_list|)
throws|throws
name|SQLException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|fieldRequirement
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|existentTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
init|(
name|Statement
name|sm
init|=
name|out
operator|.
name|createStatement
argument_list|()
init|;
name|ResultSet
name|rs
operator|=
name|sm
operator|.
name|executeQuery
argument_list|(
literal|"SELECT label FROM entry_types"
argument_list|)
init|)
block|{
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|existentTypes
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|EntryType
name|val
range|:
name|EntryTypes
operator|.
name|getAllValues
argument_list|(
name|type
argument_list|)
control|)
block|{
name|StringBuilder
name|querySB
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|fieldRequirement
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SQLUtil
operator|.
name|getAllFields
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|fieldRequirement
operator|.
name|add
argument_list|(
name|i
argument_list|,
literal|"gen"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|reqFields
init|=
name|val
operator|.
name|getRequiredFieldsFlat
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|optFields
init|=
name|val
operator|.
name|getOptionalFields
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|utiFields
init|=
name|Collections
operator|.
name|singletonList
argument_list|(
literal|"search"
argument_list|)
decl_stmt|;
name|fieldRequirement
operator|=
name|SQLUtil
operator|.
name|setFieldRequirement
argument_list|(
name|SQLUtil
operator|.
name|getAllFields
argument_list|()
argument_list|,
name|reqFields
argument_list|,
name|optFields
argument_list|,
name|utiFields
argument_list|,
name|fieldRequirement
argument_list|)
expr_stmt|;
if|if
condition|(
name|existentTypes
operator|.
name|contains
argument_list|(
name|val
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
condition|)
block|{
name|String
index|[]
name|update
init|=
name|SQLUtil
operator|.
name|getFieldStr
argument_list|()
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|querySB
operator|.
name|append
argument_list|(
literal|"UPDATE entry_types SET \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldRequirement
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|querySB
operator|.
name|append
argument_list|(
name|update
index|[
name|i
index|]
argument_list|)
operator|.
name|append
argument_list|(
literal|"='"
argument_list|)
operator|.
name|append
argument_list|(
name|fieldRequirement
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"',"
argument_list|)
expr_stmt|;
block|}
name|querySB
operator|.
name|delete
argument_list|(
name|querySB
operator|.
name|lastIndexOf
argument_list|(
literal|","
argument_list|)
argument_list|,
name|querySB
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|querySB
operator|.
name|append
argument_list|(
literal|" WHERE label='"
argument_list|)
operator|.
name|append
argument_list|(
name|val
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"';"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|querySB
operator|.
name|append
argument_list|(
literal|"INSERT INTO entry_types (label, "
argument_list|)
operator|.
name|append
argument_list|(
name|SQLUtil
operator|.
name|getFieldStr
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|") VALUES ('"
argument_list|)
operator|.
name|append
argument_list|(
name|val
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|aFieldRequirement
range|:
name|fieldRequirement
control|)
block|{
name|querySB
operator|.
name|append
argument_list|(
literal|", '"
argument_list|)
operator|.
name|append
argument_list|(
name|aFieldRequirement
argument_list|)
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|querySB
operator|.
name|append
argument_list|(
literal|");"
argument_list|)
expr_stmt|;
block|}
name|SQLUtil
operator|.
name|processQuery
argument_list|(
name|out
argument_list|,
name|querySB
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Recursive worker method for the populateGroupsTable methods.      *      * @param cursor      The current GroupTreeNode in the GroupsTree      * @param parentID    The integer ID associated with the cursors's parent node      * @param currentID   The integer value to associate with the cursor      * @param out         The output (PrintStream or Connection) object to which the DML should be written.      * @param database_id Id of jabref database to which the groups/entries are part of      */
end_comment

begin_function
DECL|method|populateGroupsTable (GroupTreeNode cursor, int parentID, int currentID, Connection out, final int database_id)
specifier|private
name|int
name|populateGroupsTable
parameter_list|(
name|GroupTreeNode
name|cursor
parameter_list|,
name|int
name|parentID
parameter_list|,
name|int
name|currentID
parameter_list|,
name|Connection
name|out
parameter_list|,
specifier|final
name|int
name|database_id
parameter_list|)
throws|throws
name|SQLException
block|{
if|if
condition|(
name|cursor
operator|==
literal|null
condition|)
block|{
comment|// no groups passed
return|return
operator|-
literal|1
return|;
block|}
name|AbstractGroup
name|group
init|=
name|cursor
operator|.
name|getGroup
argument_list|()
decl_stmt|;
name|String
name|searchField
init|=
literal|null
decl_stmt|;
name|String
name|searchExpr
init|=
literal|null
decl_stmt|;
name|String
name|caseSens
init|=
literal|null
decl_stmt|;
name|String
name|regExp
init|=
literal|null
decl_stmt|;
name|GroupHierarchyType
name|hierContext
init|=
name|group
operator|.
name|getHierarchicalContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|group
operator|instanceof
name|KeywordGroup
condition|)
block|{
name|searchField
operator|=
operator|(
operator|(
name|KeywordGroup
operator|)
name|group
operator|)
operator|.
name|getSearchField
argument_list|()
expr_stmt|;
name|searchExpr
operator|=
operator|(
operator|(
name|KeywordGroup
operator|)
name|group
operator|)
operator|.
name|getSearchExpression
argument_list|()
expr_stmt|;
name|caseSens
operator|=
operator|(
operator|(
name|KeywordGroup
operator|)
name|group
operator|)
operator|.
name|isCaseSensitive
argument_list|()
condition|?
literal|"1"
else|:
literal|"0"
expr_stmt|;
name|regExp
operator|=
operator|(
operator|(
name|KeywordGroup
operator|)
name|group
operator|)
operator|.
name|isRegExp
argument_list|()
condition|?
literal|"1"
else|:
literal|"0"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|group
operator|instanceof
name|SearchGroup
condition|)
block|{
name|searchExpr
operator|=
operator|(
operator|(
name|SearchGroup
operator|)
name|group
operator|)
operator|.
name|getSearchExpression
argument_list|()
expr_stmt|;
name|caseSens
operator|=
operator|(
operator|(
name|SearchGroup
operator|)
name|group
operator|)
operator|.
name|isCaseSensitive
argument_list|()
condition|?
literal|"1"
else|:
literal|"0"
expr_stmt|;
name|regExp
operator|=
operator|(
operator|(
name|SearchGroup
operator|)
name|group
operator|)
operator|.
name|isRegExp
argument_list|()
condition|?
literal|"1"
else|:
literal|"0"
expr_stmt|;
block|}
comment|// Protect all quotes in the group descriptions:
if|if
condition|(
name|searchField
operator|!=
literal|null
condition|)
block|{
name|searchField
operator|=
name|StringUtil
operator|.
name|quote
argument_list|(
name|searchField
argument_list|,
literal|"'"
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|searchExpr
operator|!=
literal|null
condition|)
block|{
name|searchExpr
operator|=
name|StringUtil
operator|.
name|quote
argument_list|(
name|searchExpr
argument_list|,
literal|"'"
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
block|}
name|SQLUtil
operator|.
name|processQuery
argument_list|(
name|out
argument_list|,
literal|"INSERT INTO groups (label, parent_id, group_types_id, search_field, "
operator|+
literal|"search_expression, case_sensitive, reg_exp, hierarchical_context, database_id) "
operator|+
literal|"VALUES ('"
operator|+
name|group
operator|.
name|getName
argument_list|()
operator|+
literal|"', "
operator|+
name|parentID
operator|+
literal|", (SELECT group_types_id FROM group_types where label='"
operator|+
name|group
operator|.
name|getTypeId
argument_list|()
operator|+
literal|"')"
operator|+
literal|", "
operator|+
operator|(
name|searchField
operator|!=
literal|null
condition|?
literal|'\''
operator|+
name|searchField
operator|+
literal|'\''
else|:
literal|"NULL"
operator|)
operator|+
literal|", "
operator|+
operator|(
name|searchExpr
operator|!=
literal|null
condition|?
literal|'\''
operator|+
name|searchExpr
operator|+
literal|'\''
else|:
literal|"NULL"
operator|)
operator|+
literal|", "
operator|+
operator|(
name|caseSens
operator|!=
literal|null
condition|?
literal|'\''
operator|+
name|caseSens
operator|+
literal|'\''
else|:
literal|"NULL"
operator|)
operator|+
literal|", "
operator|+
operator|(
name|regExp
operator|!=
literal|null
condition|?
literal|'\''
operator|+
name|regExp
operator|+
literal|'\''
else|:
literal|"NULL"
operator|)
operator|+
literal|", "
operator|+
name|hierContext
operator|.
name|ordinal
argument_list|()
operator|+
literal|", '"
operator|+
name|database_id
operator|+
literal|"');"
argument_list|)
expr_stmt|;
comment|// recurse on child nodes (depth-first traversal)
try|try
init|(
name|Statement
name|statement
init|=
name|out
operator|.
name|createStatement
argument_list|()
init|;
name|ResultSet
name|rs
operator|=
name|statement
operator|.
name|executeQuery
argument_list|(
literal|"SELECT groups_id FROM groups WHERE label='"
operator|+
name|cursor
operator|.
name|getGroup
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' AND database_id='"
operator|+
name|database_id
operator|+
literal|"' AND parent_id='"
operator|+
name|parentID
operator|+
literal|"';"
argument_list|)
init|)
block|{
comment|// setting values to ID and myID to be used in case of textual SQL
comment|// export
name|int
name|myID
init|=
name|currentID
decl_stmt|;
name|rs
operator|.
name|next
argument_list|()
expr_stmt|;
name|myID
operator|=
name|rs
operator|.
name|getInt
argument_list|(
literal|"groups_id"
argument_list|)
expr_stmt|;
for|for
control|(
name|GroupTreeNode
name|child
range|:
name|cursor
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|currentID
operator|++
expr_stmt|;
name|currentID
operator|=
name|populateGroupsTable
argument_list|(
name|child
argument_list|,
name|myID
argument_list|,
name|currentID
argument_list|,
name|out
argument_list|,
name|database_id
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Cannot close resource"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|currentID
return|;
block|}
end_function

begin_comment
comment|/**      * Generates the DML required to populate the group_types table with JabRef data.      *      * @param out The output (PrintSream or Connection) object to which the DML should be written.      * @throws SQLException      */
end_comment

begin_function
DECL|method|populateGroupTypesTable (Connection out)
specifier|private
specifier|static
name|void
name|populateGroupTypesTable
parameter_list|(
name|Connection
name|out
parameter_list|)
throws|throws
name|SQLException
block|{
name|int
name|quantity
init|=
literal|0
decl_stmt|;
try|try
init|(
name|Statement
name|sm
init|=
name|out
operator|.
name|createStatement
argument_list|()
init|;
name|ResultSet
name|res
operator|=
name|sm
operator|.
name|executeQuery
argument_list|(
literal|"SELECT COUNT(*) AS amount FROM group_types"
argument_list|)
init|)
block|{
name|res
operator|.
name|next
argument_list|()
expr_stmt|;
name|quantity
operator|=
name|res
operator|.
name|getInt
argument_list|(
literal|"amount"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|quantity
operator|==
literal|0
condition|)
block|{
name|String
index|[]
name|typeNames
init|=
operator|new
name|String
index|[]
block|{
name|AllEntriesGroup
operator|.
name|ID
block|,
name|ExplicitGroup
operator|.
name|ID
block|,
name|KeywordGroup
operator|.
name|ID
block|,
name|SearchGroup
operator|.
name|ID
block|}
decl_stmt|;
for|for
control|(
name|String
name|typeName
range|:
name|typeNames
control|)
block|{
name|String
name|insert
init|=
literal|"INSERT INTO group_types (label) VALUES ('"
operator|+
name|typeName
operator|+
literal|"');"
decl_stmt|;
name|SQLUtil
operator|.
name|processQuery
argument_list|(
name|out
argument_list|,
name|insert
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**      * Generates the SQL required to populate the strings table with jabref data.      *      * @param database    BibDatabase object used from where the strings will be exported      * @param out         The output (PrintStream or Connection) object to which the DML should be written.      * @param database_id ID of Jabref database related to the entries to be exported This information can be gathered      *                    using getDatabaseIDByPath(metaData, out)      * @throws SQLException      */
end_comment

begin_function
DECL|method|populateStringTable (BibDatabase database, Connection out, final int database_id)
specifier|private
specifier|static
name|void
name|populateStringTable
parameter_list|(
name|BibDatabase
name|database
parameter_list|,
name|Connection
name|out
parameter_list|,
specifier|final
name|int
name|database_id
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|insert
init|=
literal|"INSERT INTO strings (label, content, database_id) VALUES ("
decl_stmt|;
if|if
condition|(
name|database
operator|.
name|getPreamble
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|String
name|dml
init|=
name|insert
operator|+
literal|"'@PREAMBLE', "
operator|+
literal|'\''
operator|+
name|StringUtil
operator|.
name|quote
argument_list|(
name|database
operator|.
name|getPreamble
argument_list|()
argument_list|,
literal|"'"
argument_list|,
literal|'\\'
argument_list|)
operator|+
literal|"', "
operator|+
literal|'\''
operator|+
name|database_id
operator|+
literal|"');"
decl_stmt|;
name|SQLUtil
operator|.
name|processQuery
argument_list|(
name|out
argument_list|,
name|dml
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|key
range|:
name|database
operator|.
name|getStringKeySet
argument_list|()
control|)
block|{
name|BibtexString
name|string
init|=
name|database
operator|.
name|getString
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|String
name|dml
init|=
name|insert
operator|+
literal|'\''
operator|+
name|StringUtil
operator|.
name|quote
argument_list|(
name|string
operator|.
name|getName
argument_list|()
argument_list|,
literal|"'"
argument_list|,
literal|'\\'
argument_list|)
operator|+
literal|"', "
operator|+
literal|'\''
operator|+
name|StringUtil
operator|.
name|quote
argument_list|(
name|string
operator|.
name|getContent
argument_list|()
argument_list|,
literal|"'"
argument_list|,
literal|'\\'
argument_list|)
operator|+
literal|"', "
operator|+
literal|'\''
operator|+
name|database_id
operator|+
literal|'\''
operator|+
literal|");"
decl_stmt|;
name|SQLUtil
operator|.
name|processQuery
argument_list|(
name|out
argument_list|,
name|dml
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Given a DBStrings it connects to the DB and returns the java.sql.Connection object      *      * @param dbstrings The DBStrings to use to make the connection      * @return java.sql.Connection to the DB chosen      * @throws Exception      */
end_comment

begin_function
DECL|method|connectToDB (DBStrings dbstrings)
specifier|public
name|Connection
name|connectToDB
parameter_list|(
name|DBStrings
name|dbstrings
parameter_list|)
throws|throws
name|Exception
block|{
name|this
operator|.
name|dbStrings
operator|=
name|dbstrings
expr_stmt|;
return|return
name|database
operator|.
name|connectAndEnsureDatabaseExists
argument_list|(
name|dbStrings
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**      * Generates DML code necessary to create all tables in a database, and writes it to appropriate output.      *      * @param out The output (PrintStream or Connection) object to which the DML should be written.      */
end_comment

begin_function
DECL|method|createTables (Connection out)
specifier|public
name|void
name|createTables
parameter_list|(
name|Connection
name|out
parameter_list|)
throws|throws
name|SQLException
block|{
for|for
control|(
name|Database
operator|.
name|Table
name|table
range|:
name|Database
operator|.
name|Table
operator|.
name|values
argument_list|()
control|)
block|{
name|SQLUtil
operator|.
name|processQuery
argument_list|(
name|out
argument_list|,
name|database
operator|.
name|getCreateTableSQL
argument_list|(
name|table
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Accepts the BibDatabase and MetaData, generates the DML required to create and populate SQL database tables,      * and writes this DML to the specified SQL database.      *      * @param databaseContext the database to export      * @param entriesToExport The list of the entries to export.      * @param databaseStrings The necessary database connection information      */
end_comment

begin_function
DECL|method|exportDatabaseToDBMS (final BibDatabaseContext databaseContext, List<BibEntry> entriesToExport, DBStrings databaseStrings, JabRefFrame frame)
specifier|public
name|void
name|exportDatabaseToDBMS
parameter_list|(
specifier|final
name|BibDatabaseContext
name|databaseContext
parameter_list|,
name|List
argument_list|<
name|BibEntry
argument_list|>
name|entriesToExport
parameter_list|,
name|DBStrings
name|databaseStrings
parameter_list|,
name|JabRefFrame
name|frame
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|dbName
decl_stmt|;
name|boolean
name|redisplay
init|=
literal|false
decl_stmt|;
try|try
init|(
name|Connection
name|conn
init|=
name|this
operator|.
name|connectToDB
argument_list|(
name|databaseStrings
argument_list|)
init|)
block|{
try|try
block|{
name|createTables
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|Vector
argument_list|<
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|>
name|matrix
init|=
name|createExistentDBNamesMatrix
argument_list|(
name|databaseStrings
argument_list|)
decl_stmt|;
name|DBImportExportDialog
name|dialogo
init|=
operator|new
name|DBImportExportDialog
argument_list|(
name|frame
argument_list|,
name|matrix
argument_list|,
name|DBImportExportDialog
operator|.
name|DialogType
operator|.
name|EXPORTER
argument_list|)
decl_stmt|;
if|if
condition|(
name|dialogo
operator|.
name|removeAction
condition|)
block|{
name|dbName
operator|=
name|getDBName
argument_list|(
name|matrix
argument_list|,
name|databaseStrings
argument_list|,
name|frame
argument_list|,
name|dialogo
argument_list|)
expr_stmt|;
name|DatabaseUtil
operator|.
name|removeDB
argument_list|(
name|dialogo
argument_list|,
name|dbName
argument_list|,
name|conn
argument_list|,
name|databaseContext
argument_list|)
expr_stmt|;
name|redisplay
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dialogo
operator|.
name|hasDBSelected
condition|)
block|{
name|dbName
operator|=
name|getDBName
argument_list|(
name|matrix
argument_list|,
name|databaseStrings
argument_list|,
name|frame
argument_list|,
name|dialogo
argument_list|)
expr_stmt|;
name|performExport
argument_list|(
name|databaseContext
argument_list|,
name|entriesToExport
argument_list|,
name|conn
argument_list|,
name|dbName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|conn
operator|.
name|getAutoCommit
argument_list|()
condition|)
block|{
name|conn
operator|.
name|commit
argument_list|()
expr_stmt|;
name|conn
operator|.
name|setAutoCommit
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|redisplay
condition|)
block|{
name|exportDatabaseToDBMS
argument_list|(
name|databaseContext
argument_list|,
name|entriesToExport
argument_list|,
name|databaseStrings
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
if|if
condition|(
operator|(
name|conn
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|conn
operator|.
name|getAutoCommit
argument_list|()
condition|)
block|{
name|conn
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
throw|throw
name|ex
throw|;
block|}
block|}
block|}
end_function

begin_function
DECL|method|getDBName (Vector<Vector<String>> matrix, DBStrings databaseStrings, JabRefFrame frame, DBImportExportDialog dialogo)
specifier|private
name|String
name|getDBName
parameter_list|(
name|Vector
argument_list|<
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|>
name|matrix
parameter_list|,
name|DBStrings
name|databaseStrings
parameter_list|,
name|JabRefFrame
name|frame
parameter_list|,
name|DBImportExportDialog
name|dialogo
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|dbName
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|matrix
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|dialogo
operator|.
name|hasDBSelected
condition|)
block|{
name|dbName
operator|=
name|dialogo
operator|.
name|selectedDB
expr_stmt|;
if|if
condition|(
operator|(
name|dialogo
operator|.
name|selectedInt
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|dialogo
operator|.
name|removeAction
operator|)
condition|)
block|{
name|dbName
operator|=
name|JOptionPane
operator|.
name|showInputDialog
argument_list|(
name|dialogo
operator|.
name|getDiag
argument_list|()
argument_list|,
name|Localization
operator|.
name|lang
argument_list|(
literal|"Please enter the desired name:"
argument_list|)
argument_list|,
name|Localization
operator|.
name|lang
argument_list|(
literal|"SQL Export"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|INFORMATION_MESSAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbName
operator|==
literal|null
condition|)
block|{
name|getDBName
argument_list|(
name|matrix
argument_list|,
name|databaseStrings
argument_list|,
name|frame
argument_list|,
operator|new
name|DBImportExportDialog
argument_list|(
name|frame
argument_list|,
name|matrix
argument_list|,
name|DBImportExportDialog
operator|.
name|DialogType
operator|.
name|EXPORTER
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|!
name|isValidDBName
argument_list|(
name|dbNames
argument_list|,
name|dbName
argument_list|)
condition|)
block|{
name|dbName
operator|=
name|JOptionPane
operator|.
name|showInputDialog
argument_list|(
name|dialogo
operator|.
name|getDiag
argument_list|()
argument_list|,
name|Localization
operator|.
name|lang
argument_list|(
literal|"You have entered an invalid or already existent DB name."
argument_list|)
operator|+
literal|'\n'
operator|+
name|Localization
operator|.
name|lang
argument_list|(
literal|"Please enter the desired name:"
argument_list|)
argument_list|,
name|Localization
operator|.
name|lang
argument_list|(
literal|"SQL Export"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|ERROR_MESSAGE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|dbName
operator|=
name|JOptionPane
operator|.
name|showInputDialog
argument_list|(
name|frame
argument_list|,
name|Localization
operator|.
name|lang
argument_list|(
literal|"Please enter the desired name:"
argument_list|)
argument_list|,
name|Localization
operator|.
name|lang
argument_list|(
literal|"SQL Export"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|INFORMATION_MESSAGE
argument_list|)
expr_stmt|;
block|}
return|return
name|dbName
return|;
block|}
end_function

begin_function
DECL|method|createExistentDBNamesMatrix (DBStrings databaseStrings)
specifier|private
name|Vector
argument_list|<
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|>
name|createExistentDBNamesMatrix
parameter_list|(
name|DBStrings
name|databaseStrings
parameter_list|)
throws|throws
name|Exception
block|{
try|try
init|(
name|Connection
name|conn
init|=
name|this
operator|.
name|connectToDB
argument_list|(
name|databaseStrings
argument_list|)
init|;
name|Statement
name|statement
operator|=
name|conn
operator|.
name|createStatement
argument_list|()
init|;
name|ResultSet
name|rs
operator|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|SQLUtil
operator|.
name|queryAllFromTable
argument_list|(
literal|"jabref_database"
argument_list|)
argument_list|)
init|)
block|{
name|Vector
argument_list|<
name|String
argument_list|>
name|v
decl_stmt|;
name|Vector
argument_list|<
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|>
name|matrix
init|=
operator|new
name|Vector
argument_list|<>
argument_list|()
decl_stmt|;
name|dbNames
operator|.
name|clear
argument_list|()
expr_stmt|;
name|v
operator|=
operator|new
name|Vector
argument_list|<>
argument_list|()
expr_stmt|;
name|v
operator|.
name|add
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"< CREATE NEW DATABASE>"
argument_list|)
argument_list|)
expr_stmt|;
name|matrix
operator|.
name|add
argument_list|(
name|v
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|v
operator|=
operator|new
name|Vector
argument_list|<>
argument_list|()
expr_stmt|;
name|v
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|"database_name"
argument_list|)
argument_list|)
expr_stmt|;
name|matrix
operator|.
name|add
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|dbNames
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|"database_name"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|matrix
return|;
block|}
block|}
end_function

begin_function
DECL|method|isValidDBName (List<String> databaseNames, String desiredName)
specifier|private
name|boolean
name|isValidDBName
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|databaseNames
parameter_list|,
name|String
name|desiredName
parameter_list|)
block|{
return|return
operator|(
name|desiredName
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|desiredName
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|)
operator|&&
operator|!
name|databaseNames
operator|.
name|contains
argument_list|(
name|desiredName
argument_list|)
return|;
block|}
end_function

unit|}
end_unit

