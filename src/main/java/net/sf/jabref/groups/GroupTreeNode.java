begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003-2015 JabRef contributors.     This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License along     with this program; if not, write to the Free Software Foundation, Inc.,     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */
end_comment

begin_package
DECL|package|net.sf.jabref.groups
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|search
operator|.
name|SearchMatcher
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|search
operator|.
name|matchers
operator|.
name|MatcherSet
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|structure
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabase
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|BibEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|search
operator|.
name|matchers
operator|.
name|MatcherSets
import|;
end_import

begin_comment
comment|/**  * A node in the groups tree that holds exactly one AbstractGroup.  *  * @author jzieren  */
end_comment

begin_class
DECL|class|GroupTreeNode
specifier|public
class|class
name|GroupTreeNode
extends|extends
name|TreeNode
block|{
DECL|field|group
specifier|private
name|AbstractGroup
name|group
decl_stmt|;
comment|/**      * Creates this node and associates the specified group with it.      */
DECL|method|GroupTreeNode (AbstractGroup group)
specifier|public
name|GroupTreeNode
parameter_list|(
name|AbstractGroup
name|group
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|setGroup
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
comment|/**      * @return The group associated with this node.      */
DECL|method|getGroup ()
specifier|public
name|AbstractGroup
name|getGroup
parameter_list|()
block|{
return|return
name|group
return|;
block|}
comment|/**      * Associates the specified group with this node.      */
DECL|method|setGroup (AbstractGroup group)
specifier|public
name|void
name|setGroup
parameter_list|(
name|AbstractGroup
name|group
parameter_list|)
block|{
name|this
operator|.
name|group
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns a textual representation of this node and its children. This      * representation contains both the tree structure and the textual      * representations of the group associated with each node. It thus allows a      * complete reconstruction of this object and its children.      */
DECL|method|getTreeAsString ()
specifier|public
name|String
name|getTreeAsString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// Append myself
name|sb
operator|.
name|append
argument_list|(
name|this
operator|.
name|getLevel
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
operator|.
name|append
argument_list|(
name|this
operator|.
name|getGroup
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|// Append children
for|for
control|(
name|GroupTreeNode
name|child
range|:
name|children
argument_list|()
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|child
operator|.
name|getTreeAsString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Creates a deep copy of this node and all of its children, including all      * groups.      *      * @return This object's deep copy.      */
DECL|method|deepCopy ()
specifier|public
name|GroupTreeNode
name|deepCopy
parameter_list|()
block|{
name|GroupTreeNode
name|copy
init|=
operator|new
name|GroupTreeNode
argument_list|(
name|group
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|copy
operator|.
name|add
argument_list|(
name|getChildAt
argument_list|(
name|i
argument_list|)
operator|.
name|deepCopy
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|copy
return|;
block|}
comment|/**      * Update all groups, if necessary, to handle the situation where the group      * tree is applied to a different BibDatabase than it was created for. This      * is for instance used when updating the group tree due to an external change.      *      * @param db The database to refresh for.      */
DECL|method|refreshGroupsForNewDatabase (BibDatabase db)
specifier|public
name|void
name|refreshGroupsForNewDatabase
parameter_list|(
name|BibDatabase
name|db
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|GroupTreeNode
name|node
init|=
name|getChildAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|node
operator|.
name|getGroup
argument_list|()
operator|.
name|refreshForNewDatabase
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|node
operator|.
name|refreshGroupsForNewDatabase
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * A GroupTreeNode can create a SearchRule that finds elements contained in      * its own group, or the union of those elements in its own group and its      * children's groups (recursively), or the intersection of the elements in      * its own group and its parent's group. This setting is configured in the      * group contained in this node.      *      * @return A SearchRule that finds the desired elements.      */
DECL|method|getSearchRule ()
specifier|public
name|SearchMatcher
name|getSearchRule
parameter_list|()
block|{
return|return
name|getSearchRule
argument_list|(
name|group
operator|.
name|getHierarchicalContext
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getSearchRule (GroupHierarchyType originalContext)
specifier|private
name|SearchMatcher
name|getSearchRule
parameter_list|(
name|GroupHierarchyType
name|originalContext
parameter_list|)
block|{
specifier|final
name|GroupHierarchyType
name|context
init|=
name|group
operator|.
name|getHierarchicalContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
operator|==
name|GroupHierarchyType
operator|.
name|INDEPENDENT
condition|)
block|{
return|return
name|group
return|;
block|}
name|MatcherSet
name|searchRule
init|=
name|MatcherSets
operator|.
name|build
argument_list|(
name|context
operator|==
name|GroupHierarchyType
operator|.
name|REFINING
condition|?
name|MatcherSets
operator|.
name|MatcherType
operator|.
name|AND
else|:
name|MatcherSets
operator|.
name|MatcherType
operator|.
name|OR
argument_list|)
decl_stmt|;
name|searchRule
operator|.
name|addRule
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|context
operator|==
name|GroupHierarchyType
operator|.
name|INCLUDING
operator|)
operator|&&
operator|(
name|originalContext
operator|!=
name|GroupHierarchyType
operator|.
name|REFINING
operator|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|searchRule
operator|.
name|addRule
argument_list|(
name|getChildAt
argument_list|(
name|i
argument_list|)
operator|.
name|getSearchRule
argument_list|(
name|originalContext
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|context
operator|==
name|GroupHierarchyType
operator|.
name|REFINING
operator|)
operator|&&
operator|!
name|isRoot
argument_list|()
operator|&&
operator|(
name|originalContext
operator|!=
name|GroupHierarchyType
operator|.
name|INCLUDING
operator|)
condition|)
block|{
name|searchRule
operator|.
name|addRule
argument_list|(
name|getParent
argument_list|()
operator|.
name|getSearchRule
argument_list|(
name|originalContext
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|searchRule
return|;
block|}
DECL|method|canMoveUp ()
specifier|public
name|boolean
name|canMoveUp
parameter_list|()
block|{
return|return
operator|(
name|getPreviousSibling
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|!
operator|(
name|group
operator|instanceof
name|AllEntriesGroup
operator|)
return|;
block|}
DECL|method|canMoveDown ()
specifier|public
name|boolean
name|canMoveDown
parameter_list|()
block|{
return|return
operator|(
name|getNextSibling
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|!
operator|(
name|group
operator|instanceof
name|AllEntriesGroup
operator|)
return|;
block|}
DECL|method|canMoveLeft ()
specifier|public
name|boolean
name|canMoveLeft
parameter_list|()
block|{
return|return
operator|!
operator|(
name|getGroup
argument_list|()
operator|instanceof
name|AllEntriesGroup
operator|)
operator|&&
operator|!
operator|(
name|getParent
argument_list|()
operator|.
name|getGroup
argument_list|()
operator|instanceof
name|AllEntriesGroup
operator|)
return|;
block|}
DECL|method|canMoveRight ()
specifier|public
name|boolean
name|canMoveRight
parameter_list|()
block|{
return|return
operator|(
name|getPreviousSibling
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|!
operator|(
name|group
operator|instanceof
name|AllEntriesGroup
operator|)
return|;
block|}
DECL|method|moveUp ()
specifier|public
name|Optional
argument_list|<
name|MoveGroupChange
argument_list|>
name|moveUp
parameter_list|()
block|{
specifier|final
name|GroupTreeNode
name|parent
init|=
name|getParent
argument_list|()
decl_stmt|;
specifier|final
name|int
name|index
init|=
name|parent
operator|.
name|getIndex
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>
literal|0
condition|)
block|{
name|parent
operator|.
name|insert
argument_list|(
name|this
argument_list|,
name|index
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|Optional
operator|.
name|of
argument_list|(
operator|new
name|MoveGroupChange
argument_list|(
name|parent
argument_list|,
name|index
argument_list|,
name|parent
argument_list|,
name|index
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
DECL|method|moveDown ()
specifier|public
name|Optional
argument_list|<
name|MoveGroupChange
argument_list|>
name|moveDown
parameter_list|()
block|{
specifier|final
name|GroupTreeNode
name|parent
init|=
name|getParent
argument_list|()
decl_stmt|;
specifier|final
name|int
name|index
init|=
name|parent
operator|.
name|getIndex
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|<
operator|(
name|parent
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
name|parent
operator|.
name|insert
argument_list|(
name|this
argument_list|,
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|Optional
operator|.
name|of
argument_list|(
operator|new
name|MoveGroupChange
argument_list|(
name|parent
argument_list|,
name|index
argument_list|,
name|parent
argument_list|,
name|index
operator|+
literal|1
argument_list|)
argument_list|)
return|;
block|}
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
DECL|method|moveLeft ()
specifier|public
name|Optional
argument_list|<
name|MoveGroupChange
argument_list|>
name|moveLeft
parameter_list|()
block|{
specifier|final
name|GroupTreeNode
name|parent
init|=
name|getParent
argument_list|()
decl_stmt|;
specifier|final
name|GroupTreeNode
name|grandParent
init|=
name|parent
operator|.
name|getParent
argument_list|()
decl_stmt|;
specifier|final
name|int
name|index
init|=
name|this
operator|.
name|getPositionInParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|grandParent
operator|==
literal|null
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
specifier|final
name|int
name|indexOfParent
init|=
name|grandParent
operator|.
name|getIndex
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|grandParent
operator|.
name|insert
argument_list|(
name|this
argument_list|,
name|indexOfParent
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|Optional
operator|.
name|of
argument_list|(
operator|new
name|MoveGroupChange
argument_list|(
name|parent
argument_list|,
name|index
argument_list|,
name|grandParent
argument_list|,
name|indexOfParent
operator|+
literal|1
argument_list|)
argument_list|)
return|;
block|}
DECL|method|moveRight ()
specifier|public
name|Optional
argument_list|<
name|MoveGroupChange
argument_list|>
name|moveRight
parameter_list|()
block|{
specifier|final
name|GroupTreeNode
name|previousSibling
init|=
name|getPreviousSibling
argument_list|()
decl_stmt|;
specifier|final
name|GroupTreeNode
name|parent
init|=
name|getParent
argument_list|()
decl_stmt|;
specifier|final
name|int
name|index
init|=
name|this
operator|.
name|getPositionInParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|previousSibling
operator|==
literal|null
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
name|previousSibling
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|Optional
operator|.
name|of
argument_list|(
operator|new
name|MoveGroupChange
argument_list|(
name|parent
argument_list|,
name|index
argument_list|,
name|previousSibling
argument_list|,
name|previousSibling
operator|.
name|getChildCount
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Adds the selected entries to this node's group.      */
DECL|method|addToGroup (List<BibEntry> entries)
specifier|public
name|Optional
argument_list|<
name|EntriesGroupChange
argument_list|>
name|addToGroup
parameter_list|(
name|List
argument_list|<
name|BibEntry
argument_list|>
name|entries
parameter_list|)
block|{
if|if
condition|(
name|group
operator|.
name|supportsAdd
argument_list|()
condition|)
block|{
return|return
name|group
operator|.
name|add
argument_list|(
name|entries
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
block|}
comment|/**      * Removes the selected entries from this node's group.      */
DECL|method|removeFromGroup (List<BibEntry> entries)
specifier|public
name|Optional
argument_list|<
name|EntriesGroupChange
argument_list|>
name|removeFromGroup
parameter_list|(
name|List
argument_list|<
name|BibEntry
argument_list|>
name|entries
parameter_list|)
block|{
if|if
condition|(
name|group
operator|.
name|supportsRemove
argument_list|()
condition|)
block|{
return|return
name|group
operator|.
name|remove
argument_list|(
name|entries
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
block|}
comment|/**      * Recursively compares this node's group and all subgroups.      */
annotation|@
name|Override
DECL|method|equals (Object other)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|GroupTreeNode
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|GroupTreeNode
name|otherNode
init|=
operator|(
name|GroupTreeNode
operator|)
name|other
decl_stmt|;
if|if
condition|(
name|getChildCount
argument_list|()
operator|!=
name|otherNode
operator|.
name|getChildCount
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|AbstractGroup
name|g1
init|=
name|group
decl_stmt|;
name|AbstractGroup
name|g2
init|=
name|otherNode
operator|.
name|getGroup
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|g1
operator|==
literal|null
operator|)
operator|&&
operator|(
name|g2
operator|!=
literal|null
operator|)
operator|)
operator|||
operator|(
operator|(
name|g1
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|g2
operator|==
literal|null
operator|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|(
name|g1
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|g2
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|g1
operator|.
name|equals
argument_list|(
name|g2
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|getChildAt
argument_list|(
name|i
argument_list|)
operator|.
name|equals
argument_list|(
name|otherNode
operator|.
name|getChildAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|group
operator|.
name|getName
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/**      * Get all groups which contain any of the entries and which support removal of entries.      */
DECL|method|getContainingGroupsSupportingRemoval (List<BibEntry> entries)
specifier|public
name|List
argument_list|<
name|GroupTreeNode
argument_list|>
name|getContainingGroupsSupportingRemoval
parameter_list|(
name|List
argument_list|<
name|BibEntry
argument_list|>
name|entries
parameter_list|)
block|{
name|List
argument_list|<
name|GroupTreeNode
argument_list|>
name|groups
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Add myself if I contain the entries
if|if
condition|(
name|this
operator|.
name|group
operator|.
name|supportsRemove
argument_list|()
operator|&&
name|this
operator|.
name|group
operator|.
name|containsAny
argument_list|(
name|entries
argument_list|)
condition|)
block|{
name|groups
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|// Traverse children
for|for
control|(
name|GroupTreeNode
name|child
range|:
name|children
argument_list|()
control|)
block|{
name|groups
operator|.
name|addAll
argument_list|(
name|child
operator|.
name|getContainingGroupsSupportingRemoval
argument_list|(
name|entries
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|groups
return|;
block|}
DECL|method|getContainingGroups (List<BibEntry> entries, boolean requireAll)
specifier|public
name|List
argument_list|<
name|GroupTreeNode
argument_list|>
name|getContainingGroups
parameter_list|(
name|List
argument_list|<
name|BibEntry
argument_list|>
name|entries
parameter_list|,
name|boolean
name|requireAll
parameter_list|)
block|{
name|List
argument_list|<
name|GroupTreeNode
argument_list|>
name|groups
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Add myself if I contain the entries
if|if
condition|(
name|requireAll
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|group
operator|.
name|containsAll
argument_list|(
name|entries
argument_list|)
condition|)
block|{
name|groups
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|this
operator|.
name|group
operator|.
name|containsAny
argument_list|(
name|entries
argument_list|)
condition|)
block|{
name|groups
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Traverse children
for|for
control|(
name|GroupTreeNode
name|child
range|:
name|children
argument_list|()
control|)
block|{
name|groups
operator|.
name|addAll
argument_list|(
name|child
operator|.
name|getContainingGroups
argument_list|(
name|entries
argument_list|,
name|requireAll
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|groups
return|;
block|}
DECL|method|getMatchingGroups (List<BibEntry> entries)
specifier|public
name|List
argument_list|<
name|GroupTreeNode
argument_list|>
name|getMatchingGroups
parameter_list|(
name|List
argument_list|<
name|BibEntry
argument_list|>
name|entries
parameter_list|)
block|{
name|List
argument_list|<
name|GroupTreeNode
argument_list|>
name|groups
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Add myself if I contain the entries
name|SearchMatcher
name|matcher
init|=
name|getSearchRule
argument_list|()
decl_stmt|;
for|for
control|(
name|BibEntry
name|entry
range|:
name|entries
control|)
block|{
if|if
condition|(
name|matcher
operator|.
name|isMatch
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|groups
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|// Traverse children
for|for
control|(
name|GroupTreeNode
name|child
range|:
name|children
argument_list|()
control|)
block|{
name|groups
operator|.
name|addAll
argument_list|(
name|child
operator|.
name|getMatchingGroups
argument_list|(
name|entries
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|groups
return|;
block|}
comment|/**      * For all explicit subgroups, replace the i'th entry of originalEntries with the i'th entry of newEntries.      */
DECL|method|replaceEntriesInExplicitGroup (List<BibEntry> originalEntries, List<BibEntry> newEntries)
specifier|public
name|void
name|replaceEntriesInExplicitGroup
parameter_list|(
name|List
argument_list|<
name|BibEntry
argument_list|>
name|originalEntries
parameter_list|,
name|List
argument_list|<
name|BibEntry
argument_list|>
name|newEntries
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|group
operator|instanceof
name|ExplicitGroup
condition|)
block|{
name|ExplicitGroup
name|group
init|=
operator|(
name|ExplicitGroup
operator|)
name|this
operator|.
name|group
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|originalEntries
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|BibEntry
name|entry
init|=
name|originalEntries
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|group
operator|.
name|contains
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|group
operator|.
name|removeEntry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|group
operator|.
name|addEntry
argument_list|(
name|newEntries
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Traverse children
for|for
control|(
name|GroupTreeNode
name|child
range|:
name|children
argument_list|()
control|)
block|{
name|child
operator|.
name|replaceEntriesInExplicitGroup
argument_list|(
name|originalEntries
argument_list|,
name|newEntries
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

