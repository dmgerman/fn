begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2003 David Weitzman, Morten O. Alver  All programs in this directory and subdirectories are published under the GNU General Public License as described below.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA  Further information about the GNU GPL is available at: http://www.gnu.org/copyleft/gpl.ja.html  Note: Modified for use in JabRef  */
end_comment

begin_comment
comment|// created by : ?
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// modified : r.nagel 23.08.2004
end_comment

begin_comment
comment|//                - insert getEntryByKey() methode needed by AuxSubGenerator
end_comment

begin_package
DECL|package|net.sf.jabref
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
package|;
end_package

begin_import
import|import
name|java
operator|.
name|beans
operator|.
name|PropertyChangeEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|beans
operator|.
name|PropertyVetoException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|beans
operator|.
name|VetoableChangeListener
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JOptionPane
import|;
end_import

begin_class
DECL|class|BibtexDatabase
specifier|public
class|class
name|BibtexDatabase
block|{
DECL|field|_entries
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|BibtexEntry
argument_list|>
name|_entries
init|=
operator|new
name|Hashtable
argument_list|<
name|String
argument_list|,
name|BibtexEntry
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|_preamble
name|String
name|_preamble
init|=
literal|null
decl_stmt|;
DECL|field|_strings
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|BibtexString
argument_list|>
name|_strings
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BibtexString
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|_strings_
name|Vector
argument_list|<
name|String
argument_list|>
name|_strings_
init|=
operator|new
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|changeListeners
specifier|final
name|Set
argument_list|<
name|DatabaseChangeListener
argument_list|>
name|changeListeners
init|=
operator|new
name|HashSet
argument_list|<
name|DatabaseChangeListener
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|followCrossrefs
specifier|private
name|boolean
name|followCrossrefs
init|=
literal|true
decl_stmt|;
comment|/**      * use a map instead of a set since i need to know how many of each key is      * inthere      */
DECL|field|allKeys
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|allKeys
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|/*      * Entries are stored in a HashMap with the ID as key. What happens if      * someone changes a BibtexEntry's ID after it has been added to this      * BibtexDatabase? The key of that entry would be the old ID, not the new      * one. Use a PropertyChangeListener to identify an ID change and update the      * Map.      */
DECL|field|listener
specifier|private
specifier|final
name|VetoableChangeListener
name|listener
init|=
operator|new
name|VetoableChangeListener
argument_list|()
block|{
specifier|public
name|void
name|vetoableChange
parameter_list|(
name|PropertyChangeEvent
name|pce
parameter_list|)
throws|throws
name|PropertyVetoException
block|{
if|if
condition|(
name|pce
operator|.
name|getPropertyName
argument_list|()
operator|==
literal|null
condition|)
name|fireDatabaseChanged
argument_list|(
operator|new
name|DatabaseChangeEvent
argument_list|(
name|BibtexDatabase
operator|.
name|this
argument_list|,
name|DatabaseChangeEvent
operator|.
name|ChangeType
operator|.
name|CHANGING_ENTRY
argument_list|,
operator|(
name|BibtexEntry
operator|)
name|pce
operator|.
name|getSource
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|"id"
operator|.
name|equals
argument_list|(
name|pce
operator|.
name|getPropertyName
argument_list|()
argument_list|)
condition|)
block|{
comment|// locate the entry under its old key
name|BibtexEntry
name|oldEntry
init|=
name|_entries
operator|.
name|remove
argument_list|(
name|pce
operator|.
name|getOldValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldEntry
operator|!=
name|pce
operator|.
name|getSource
argument_list|()
condition|)
block|{
comment|// Something is very wrong!
comment|// The entry under the old key isn't
comment|// the one that sent this event.
comment|// Restore the old state.
name|_entries
operator|.
name|put
argument_list|(
operator|(
name|String
operator|)
name|pce
operator|.
name|getOldValue
argument_list|()
argument_list|,
name|oldEntry
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|PropertyVetoException
argument_list|(
literal|"Wrong old ID"
argument_list|,
name|pce
argument_list|)
throw|;
block|}
if|if
condition|(
name|_entries
operator|.
name|get
argument_list|(
name|pce
operator|.
name|getNewValue
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|_entries
operator|.
name|put
argument_list|(
operator|(
name|String
operator|)
name|pce
operator|.
name|getOldValue
argument_list|()
argument_list|,
name|oldEntry
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|PropertyVetoException
argument_list|(
literal|"New ID already in use, please choose another"
argument_list|,
name|pce
argument_list|)
throw|;
block|}
comment|// and re-file this entry
name|_entries
operator|.
name|put
argument_list|(
operator|(
name|String
operator|)
name|pce
operator|.
name|getNewValue
argument_list|()
argument_list|,
operator|(
name|BibtexEntry
operator|)
name|pce
operator|.
name|getSource
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fireDatabaseChanged
argument_list|(
operator|new
name|DatabaseChangeEvent
argument_list|(
name|BibtexDatabase
operator|.
name|this
argument_list|,
name|DatabaseChangeEvent
operator|.
name|ChangeType
operator|.
name|CHANGED_ENTRY
argument_list|,
operator|(
name|BibtexEntry
operator|)
name|pce
operator|.
name|getSource
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//Util.pr(pce.getSource().toString()+"\n"+pce.getPropertyName()
comment|//    +"\n"+pce.getNewValue());
block|}
block|}
block|}
decl_stmt|;
comment|/**      * Returns the number of entries.      */
DECL|method|getEntryCount ()
specifier|public
specifier|synchronized
name|int
name|getEntryCount
parameter_list|()
block|{
return|return
name|_entries
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Returns a Set containing the keys to all entries.      * Use getKeySet().iterator() to iterate over all entries.      */
DECL|method|getKeySet ()
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|String
argument_list|>
name|getKeySet
parameter_list|()
block|{
return|return
name|_entries
operator|.
name|keySet
argument_list|()
return|;
block|}
comment|/**      * Returns an EntrySorter with the sorted entries from this base,      * sorted by the given Comparator.      */
DECL|method|getSorter (Comparator<BibtexEntry> comp)
specifier|public
specifier|synchronized
name|EntrySorter
name|getSorter
parameter_list|(
name|Comparator
argument_list|<
name|BibtexEntry
argument_list|>
name|comp
parameter_list|)
block|{
name|EntrySorter
name|sorter
init|=
operator|new
name|EntrySorter
argument_list|(
name|_entries
argument_list|,
name|comp
argument_list|)
decl_stmt|;
name|addDatabaseChangeListener
argument_list|(
name|sorter
argument_list|)
expr_stmt|;
return|return
name|sorter
return|;
block|}
comment|/**      * Just temporary, for testing purposes....      * @return      */
DECL|method|getEntryMap ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|BibtexEntry
argument_list|>
name|getEntryMap
parameter_list|()
block|{
return|return
name|_entries
return|;
block|}
comment|/**      * Returns the entry with the given ID (-> entry_type + hashcode).      */
DECL|method|getEntryById (String id)
specifier|public
specifier|synchronized
name|BibtexEntry
name|getEntryById
parameter_list|(
name|String
name|id
parameter_list|)
block|{
return|return
name|_entries
operator|.
name|get
argument_list|(
name|id
argument_list|)
return|;
block|}
DECL|method|getEntries ()
specifier|public
specifier|synchronized
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|getEntries
parameter_list|()
block|{
return|return
name|_entries
operator|.
name|values
argument_list|()
return|;
block|}
comment|/**      * Returns the entry with the given bibtex key.      */
DECL|method|getEntryByKey (String key)
specifier|public
specifier|synchronized
name|BibtexEntry
name|getEntryByKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|BibtexEntry
name|back
init|=
literal|null
decl_stmt|;
name|int
name|keyHash
init|=
name|key
operator|.
name|hashCode
argument_list|()
decl_stmt|;
comment|// key hash for better performance
name|Set
argument_list|<
name|String
argument_list|>
name|keySet
init|=
name|_entries
operator|.
name|keySet
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|entrieID
range|:
name|keySet
control|)
block|{
name|BibtexEntry
name|entry
init|=
name|getEntryById
argument_list|(
name|entrieID
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|entry
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|entry
operator|.
name|getCiteKey
argument_list|()
operator|!=
literal|null
operator|)
condition|)
block|{
name|String
name|citeKey
init|=
name|entry
operator|.
name|getCiteKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|citeKey
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|keyHash
operator|==
name|citeKey
operator|.
name|hashCode
argument_list|()
condition|)
block|{
name|back
operator|=
name|entry
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|back
return|;
block|}
DECL|method|getEntriesByKey (String key)
specifier|public
specifier|synchronized
name|BibtexEntry
index|[]
name|getEntriesByKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
init|=
operator|new
name|ArrayList
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|_entries
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
name|entry
operator|.
name|getCiteKey
argument_list|()
argument_list|)
condition|)
name|entries
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
return|return
name|entries
operator|.
name|toArray
argument_list|(
operator|new
name|BibtexEntry
index|[
name|entries
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Inserts the entry, given that its ID is not already in use.      * use Util.createId(...) to make up a unique ID for an entry.      */
DECL|method|insertEntry (BibtexEntry entry)
specifier|public
specifier|synchronized
name|boolean
name|insertEntry
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|)
throws|throws
name|KeyCollisionException
block|{
name|String
name|id
init|=
name|entry
operator|.
name|getId
argument_list|()
decl_stmt|;
if|if
condition|(
name|getEntryById
argument_list|(
name|id
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|KeyCollisionException
argument_list|(
literal|"ID is already in use, please choose another"
argument_list|)
throw|;
block|}
name|entry
operator|.
name|addPropertyChangeListener
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|_entries
operator|.
name|put
argument_list|(
name|id
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|fireDatabaseChanged
argument_list|(
operator|new
name|DatabaseChangeEvent
argument_list|(
name|this
argument_list|,
name|DatabaseChangeEvent
operator|.
name|ChangeType
operator|.
name|ADDED_ENTRY
argument_list|,
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|checkForDuplicateKeyAndAdd
argument_list|(
literal|null
argument_list|,
name|entry
operator|.
name|getCiteKey
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Removes the entry with the given string.      *       * Returns null if not found.      */
DECL|method|removeEntry (String id)
specifier|public
specifier|synchronized
name|BibtexEntry
name|removeEntry
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|BibtexEntry
name|oldValue
init|=
name|_entries
operator|.
name|remove
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldValue
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|removeKeyFromSet
argument_list|(
name|oldValue
operator|.
name|getCiteKey
argument_list|()
argument_list|)
expr_stmt|;
name|oldValue
operator|.
name|removePropertyChangeListener
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|fireDatabaseChanged
argument_list|(
operator|new
name|DatabaseChangeEvent
argument_list|(
name|this
argument_list|,
name|DatabaseChangeEvent
operator|.
name|ChangeType
operator|.
name|REMOVED_ENTRY
argument_list|,
name|oldValue
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|oldValue
return|;
block|}
DECL|method|setCiteKeyForEntry (String id, String key)
specifier|public
specifier|synchronized
name|boolean
name|setCiteKeyForEntry
parameter_list|(
name|String
name|id
parameter_list|,
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
operator|!
name|_entries
operator|.
name|containsKey
argument_list|(
name|id
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// Entry doesn't exist!
name|BibtexEntry
name|entry
init|=
name|getEntryById
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|String
name|oldKey
init|=
name|entry
operator|.
name|getCiteKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
name|entry
operator|.
name|setField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|entry
operator|.
name|clearField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
expr_stmt|;
return|return
name|checkForDuplicateKeyAndAdd
argument_list|(
name|oldKey
argument_list|,
name|entry
operator|.
name|getCiteKey
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Sets the database's preamble.      */
DECL|method|setPreamble (String preamble)
specifier|public
specifier|synchronized
name|void
name|setPreamble
parameter_list|(
name|String
name|preamble
parameter_list|)
block|{
name|_preamble
operator|=
name|preamble
expr_stmt|;
block|}
comment|/**      * Returns the database's preamble.      */
DECL|method|getPreamble ()
specifier|public
specifier|synchronized
name|String
name|getPreamble
parameter_list|()
block|{
return|return
name|_preamble
return|;
block|}
comment|/**      * Inserts a Bibtex String at the given index.      */
DECL|method|addString (BibtexString string)
specifier|public
specifier|synchronized
name|void
name|addString
parameter_list|(
name|BibtexString
name|string
parameter_list|)
throws|throws
name|KeyCollisionException
block|{
if|if
condition|(
name|hasStringLabel
argument_list|(
name|string
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|KeyCollisionException
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"A string with this label already exists"
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|_strings
operator|.
name|containsKey
argument_list|(
name|string
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
throw|throw
operator|new
name|KeyCollisionException
argument_list|(
literal|"Duplicate BibtexString id."
argument_list|)
throw|;
name|_strings
operator|.
name|put
argument_list|(
name|string
operator|.
name|getId
argument_list|()
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes the string at the given index.      */
DECL|method|removeString (String id)
specifier|public
specifier|synchronized
name|void
name|removeString
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|_strings
operator|.
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns a Set of keys to all BibtexString objects in the database.      * These are in no sorted order.      */
DECL|method|getStringKeySet ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getStringKeySet
parameter_list|()
block|{
return|return
name|_strings
operator|.
name|keySet
argument_list|()
return|;
block|}
comment|/**      * Returns a Collection of all BibtexString objects in the database.      * These are in no particular order.      */
DECL|method|getStringValues ()
specifier|public
name|Collection
argument_list|<
name|BibtexString
argument_list|>
name|getStringValues
parameter_list|()
block|{
return|return
name|_strings
operator|.
name|values
argument_list|()
return|;
block|}
comment|/**      * Returns the string at the given index.      */
DECL|method|getString (String o)
specifier|public
specifier|synchronized
name|BibtexString
name|getString
parameter_list|(
name|String
name|o
parameter_list|)
block|{
return|return
name|_strings
operator|.
name|get
argument_list|(
name|o
argument_list|)
return|;
block|}
comment|/**      * Returns the number of strings.      */
DECL|method|getStringCount ()
specifier|public
specifier|synchronized
name|int
name|getStringCount
parameter_list|()
block|{
return|return
name|_strings
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Returns true if a string with the given label already exists.      */
DECL|method|hasStringLabel (String label)
specifier|public
specifier|synchronized
name|boolean
name|hasStringLabel
parameter_list|(
name|String
name|label
parameter_list|)
block|{
for|for
control|(
name|BibtexString
name|value
range|:
name|_strings
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|value
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|label
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Resolves any references to strings contained in this field content,      * if possible.      */
DECL|method|resolveForStrings (String content)
specifier|public
name|String
name|resolveForStrings
parameter_list|(
name|String
name|content
parameter_list|)
block|{
if|if
condition|(
name|content
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Content for resolveForStrings must not be null."
argument_list|)
throw|;
block|}
return|return
name|resolveContent
argument_list|(
name|content
argument_list|,
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Take the given collection of BibtexEntry and resolve any string      * references.      *       * @param entries      *            A collection of BibtexEntries in which all strings of the form      *            #xxx# will be resolved against the hash map of string      *            references stored in the databasee.      *                  * @param inPlace If inPlace is true then the given BibtexEntries will be modified, if false then copies of the BibtexEntries are made before resolving the strings.      *       * @return a list of bibtexentries, with all strings resolved. It is dependent on the value of inPlace whether copies are made or the given BibtexEntries are modified.       */
DECL|method|resolveForStrings (Collection<BibtexEntry> entries, boolean inPlace)
specifier|public
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|resolveForStrings
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
name|boolean
name|inPlace
parameter_list|)
block|{
if|if
condition|(
name|entries
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|(
name|entries
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|results
operator|.
name|add
argument_list|(
name|this
operator|.
name|resolveForStrings
argument_list|(
name|entry
argument_list|,
name|inPlace
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
comment|/**      * Take the given BibtexEntry and resolve any string references.      *       * @param entry      *            A BibtexEntry in which all strings of the form #xxx# will be      *            resolved against the hash map of string references stored in      *            the databasee.      *       * @param inPlace      *            If inPlace is true then the given BibtexEntry will be      *            modified, if false then a copy is made using close made before      *            resolving the strings.      *       * @return a BibtexEntry with all string references resolved. It is      *         dependent on the value of inPlace whether a copy is made or the      *         given BibtexEntries is modified.      */
DECL|method|resolveForStrings (BibtexEntry entry, boolean inPlace)
specifier|public
name|BibtexEntry
name|resolveForStrings
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|boolean
name|inPlace
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inPlace
condition|)
block|{
name|entry
operator|=
operator|(
name|BibtexEntry
operator|)
name|entry
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Object
name|field
range|:
name|entry
operator|.
name|getAllFields
argument_list|()
control|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|field
operator|.
name|toString
argument_list|()
argument_list|,
name|this
operator|.
name|resolveForStrings
argument_list|(
name|entry
operator|.
name|getField
argument_list|(
name|field
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
comment|/**      * If the label represents a string contained in this database, returns      * that string's content. Resolves references to other strings, taking      * care not to follow a circular reference pattern.      * If the string is undefined, returns null.      */
DECL|method|resolveString (String label, HashSet<String> usedIds)
specifier|private
name|String
name|resolveString
parameter_list|(
name|String
name|label
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|usedIds
parameter_list|)
block|{
for|for
control|(
name|BibtexString
name|string
range|:
name|_strings
operator|.
name|values
argument_list|()
control|)
block|{
comment|//Util.pr(label+" : "+string.getName());
if|if
condition|(
name|string
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
name|label
operator|.
name|toLowerCase
argument_list|()
argument_list|)
condition|)
block|{
comment|// First check if this string label has been resolved
comment|// earlier in this recursion. If so, we have a
comment|// circular reference, and have to stop to avoid
comment|// infinite recursion.
if|if
condition|(
name|usedIds
operator|.
name|contains
argument_list|(
name|string
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
name|Util
operator|.
name|pr
argument_list|(
literal|"Stopped due to circular reference in strings: "
operator|+
name|label
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
comment|// If not, log this string's ID now.
name|usedIds
operator|.
name|add
argument_list|(
name|string
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Ok, we found the string. Now we must make sure we
comment|// resolve any references to other strings in this one.
name|String
name|res
init|=
name|string
operator|.
name|getContent
argument_list|()
decl_stmt|;
name|res
operator|=
name|resolveContent
argument_list|(
name|res
argument_list|,
name|usedIds
argument_list|)
expr_stmt|;
comment|// Finished with recursing this branch, so we remove our
comment|// ID again:
name|usedIds
operator|.
name|remove
argument_list|(
name|string
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
block|}
comment|// If we get to this point, the string has obviously not been defined locally.
comment|// Check if one of the standard BibTeX month strings has been used:
name|MonthUtil
operator|.
name|Month
name|month
init|=
name|MonthUtil
operator|.
name|getMonthByShortName
argument_list|(
name|label
argument_list|)
decl_stmt|;
if|if
condition|(
name|month
operator|.
name|isValid
argument_list|()
condition|)
block|{
return|return
name|month
operator|.
name|fullName
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
DECL|method|resolveContent (String res, HashSet<String> usedIds)
specifier|private
name|String
name|resolveContent
parameter_list|(
name|String
name|res
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|usedIds
parameter_list|)
block|{
comment|//if (res.matches(".*#[-\\^\\:\\w]+#.*")) {
if|if
condition|(
name|res
operator|.
name|matches
argument_list|(
literal|".*#[^#]+#.*"
argument_list|)
condition|)
block|{
name|StringBuilder
name|newRes
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|piv
init|=
literal|0
decl_stmt|,
name|next
decl_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|res
operator|.
name|indexOf
argument_list|(
literal|"#"
argument_list|,
name|piv
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|// We found the next string ref. Append the text
comment|// up to it.
if|if
condition|(
name|next
operator|>
literal|0
condition|)
name|newRes
operator|.
name|append
argument_list|(
name|res
operator|.
name|substring
argument_list|(
name|piv
argument_list|,
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|stringEnd
init|=
name|res
operator|.
name|indexOf
argument_list|(
literal|"#"
argument_list|,
name|next
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|stringEnd
operator|>=
literal|0
condition|)
block|{
comment|// We found the boundaries of the string ref,
comment|// now resolve that one.
name|String
name|refLabel
init|=
name|res
operator|.
name|substring
argument_list|(
name|next
operator|+
literal|1
argument_list|,
name|stringEnd
argument_list|)
decl_stmt|;
name|String
name|resolved
init|=
name|resolveString
argument_list|(
name|refLabel
argument_list|,
name|usedIds
argument_list|)
decl_stmt|;
if|if
condition|(
name|resolved
operator|==
literal|null
condition|)
block|{
comment|// Could not resolve string. Display the #
comment|// characters rather than removing them:
name|newRes
operator|.
name|append
argument_list|(
name|res
operator|.
name|substring
argument_list|(
name|next
argument_list|,
name|stringEnd
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|// The string was resolved, so we display its meaning only,
comment|// stripping the # characters signifying the string label:
name|newRes
operator|.
name|append
argument_list|(
name|resolved
argument_list|)
expr_stmt|;
name|piv
operator|=
name|stringEnd
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// We didn't find the boundaries of the string ref. This
comment|// makes it impossible to interpret it as a string label.
comment|// So we should just append the rest of the text and finish.
name|newRes
operator|.
name|append
argument_list|(
name|res
operator|.
name|substring
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|piv
operator|=
name|res
operator|.
name|length
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|piv
operator|<
name|res
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
name|newRes
operator|.
name|append
argument_list|(
name|res
operator|.
name|substring
argument_list|(
name|piv
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|newRes
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
comment|//##########################################
comment|//  usage:
comment|//  isDuplicate=checkForDuplicateKeyAndAdd( null, b.getKey() , issueDuplicateWarning);
comment|//############################################
comment|// if the newkey already exists and is not the same as oldkey it will give a warning
comment|// else it will add the newkey to the to set and remove the oldkey
DECL|method|checkForDuplicateKeyAndAdd (String oldKey, String newKey, boolean issueWarning)
specifier|public
name|boolean
name|checkForDuplicateKeyAndAdd
parameter_list|(
name|String
name|oldKey
parameter_list|,
name|String
name|newKey
parameter_list|,
name|boolean
name|issueWarning
parameter_list|)
block|{
comment|// Globals.logger(" checkForDuplicateKeyAndAdd [oldKey = " + oldKey + "] [newKey = " + newKey + "]");
name|boolean
name|duplicate
decl_stmt|;
if|if
condition|(
name|oldKey
operator|==
literal|null
condition|)
block|{
comment|// this is a new entry so don't bother removing oldKey
name|duplicate
operator|=
name|addKeyToSet
argument_list|(
name|newKey
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|oldKey
operator|.
name|equals
argument_list|(
name|newKey
argument_list|)
condition|)
block|{
comment|// were OK because the user did not change keys
name|duplicate
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// user changed the key
comment|// removed the oldkey
comment|// But what if more than two have the same key?
comment|// this means that user can add another key and would not get a warning!
comment|// consider this: i add a key xxx, then i add another key xxx . I get a warning. I delete the key xxx. JBM
comment|// removes this key from the allKey. then I add another key xxx. I don't get a warning!
comment|// i need a way to count the number of keys of each type
comment|// hashmap=>int (increment each time)
name|removeKeyFromSet
argument_list|(
name|oldKey
argument_list|)
expr_stmt|;
name|duplicate
operator|=
name|addKeyToSet
argument_list|(
name|newKey
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|duplicate
operator|&&
name|issueWarning
condition|)
block|{
name|JOptionPane
operator|.
name|showMessageDialog
argument_list|(
literal|null
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Warning there is a duplicate key"
argument_list|)
operator|+
literal|":"
operator|+
name|newKey
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Duplicate Key Warning"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|WARNING_MESSAGE
argument_list|)
expr_stmt|;
comment|//, options);
block|}
return|return
name|duplicate
return|;
block|}
comment|/**      * Returns the number of occurences of the given key in this database.      */
DECL|method|getNumberOfKeyOccurences (String key)
specifier|public
name|int
name|getNumberOfKeyOccurences
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|Object
name|o
init|=
name|allKeys
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|(
name|Integer
operator|)
name|o
return|;
block|}
comment|//========================================================
comment|// keep track of all the keys to warn if there are duplicates
comment|//========================================================
DECL|method|addKeyToSet (String key)
specifier|private
name|boolean
name|addKeyToSet
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|boolean
name|exists
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|key
operator|==
literal|null
operator|)
operator|||
name|key
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
return|return
literal|false
return|;
comment|//don't put empty key
if|if
condition|(
name|allKeys
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
comment|// warning
name|exists
operator|=
literal|true
expr_stmt|;
name|allKeys
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|allKeys
operator|.
name|get
argument_list|(
name|key
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// incrementInteger( allKeys.get(key)));
block|}
else|else
name|allKeys
operator|.
name|put
argument_list|(
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|exists
return|;
block|}
comment|//========================================================
comment|// reduce the number of keys by 1. if this number goes to zero then remove from the set
comment|// note: there is a good reason why we should not use a hashset but use hashmap instead
comment|//========================================================
DECL|method|removeKeyFromSet (String key)
specifier|private
name|void
name|removeKeyFromSet
parameter_list|(
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
operator|(
name|key
operator|==
literal|null
operator|)
operator|||
name|key
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
return|return;
if|if
condition|(
name|allKeys
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|Integer
name|tI
init|=
name|allKeys
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
comment|// if(allKeys.get(key) instanceof Integer)
if|if
condition|(
name|tI
operator|==
literal|1
condition|)
name|allKeys
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
else|else
name|allKeys
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|tI
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|//decrementInteger( tI ));
block|}
block|}
DECL|method|fireDatabaseChanged (DatabaseChangeEvent e)
specifier|public
name|void
name|fireDatabaseChanged
parameter_list|(
name|DatabaseChangeEvent
name|e
parameter_list|)
block|{
for|for
control|(
name|DatabaseChangeListener
name|listener
range|:
name|changeListeners
control|)
block|{
name|listener
operator|.
name|databaseChanged
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addDatabaseChangeListener (DatabaseChangeListener l)
specifier|public
name|void
name|addDatabaseChangeListener
parameter_list|(
name|DatabaseChangeListener
name|l
parameter_list|)
block|{
name|changeListeners
operator|.
name|add
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
DECL|method|removeDatabaseChangeListener (DatabaseChangeListener l)
specifier|public
name|void
name|removeDatabaseChangeListener
parameter_list|(
name|DatabaseChangeListener
name|l
parameter_list|)
block|{
name|changeListeners
operator|.
name|remove
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the text stored in the given field of the given bibtex entry      * which belongs to the given database.      *       * If a database is given, this function will try to resolve any string      * references in the field-value.      * Also, if a database is given, this function will try to find values for      * unset fields in the entry linked by the "crossref" field, if any.      *       * @param field      *            The field to return the value of.      * @param bibtex maybenull      *            The bibtex entry which contains the field.      * @param database maybenull      *            The database of the bibtex entry.      * @return The resolved field value or null if not found.      */
DECL|method|getResolvedField (String field, BibtexEntry bibtex, BibtexDatabase database)
specifier|public
specifier|static
name|String
name|getResolvedField
parameter_list|(
name|String
name|field
parameter_list|,
name|BibtexEntry
name|bibtex
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"bibtextype"
argument_list|)
condition|)
return|return
name|bibtex
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
return|;
comment|// TODO: Changed this to also consider alias fields, which is the expected
comment|// behavior for the preview layout and for the check whatever all fields are present.
comment|// But there might be unwanted side-effects?!
name|Object
name|o
init|=
name|bibtex
operator|.
name|getFieldOrAlias
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|// If this field is not set, and the entry has a crossref, try to look up the
comment|// field in the referred entry: Do not do this for the bibtex key.
if|if
condition|(
operator|(
name|o
operator|==
literal|null
operator|)
operator|&&
operator|(
name|database
operator|!=
literal|null
operator|)
operator|&&
name|database
operator|.
name|followCrossrefs
operator|&&
operator|!
name|field
operator|.
name|equals
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
condition|)
block|{
name|Object
name|crossRef
init|=
name|bibtex
operator|.
name|getField
argument_list|(
literal|"crossref"
argument_list|)
decl_stmt|;
if|if
condition|(
name|crossRef
operator|!=
literal|null
condition|)
block|{
name|BibtexEntry
name|referred
init|=
name|database
operator|.
name|getEntryByKey
argument_list|(
operator|(
name|String
operator|)
name|crossRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|referred
operator|!=
literal|null
condition|)
block|{
comment|// Ok, we found the referred entry. Get the field value from that
comment|// entry. If it is unset there, too, stop looking:
name|o
operator|=
name|referred
operator|.
name|getField
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|getText
argument_list|(
operator|(
name|String
operator|)
name|o
argument_list|,
name|database
argument_list|)
return|;
block|}
comment|/**      * Returns a text with references resolved according to an optionally given      * database.           * @param toResolve maybenull The text to resolve.      * @param database maybenull The database to use for resolving the text.      * @return The resolved text or the original text if either the text or the database are null      */
DECL|method|getText (String toResolve, BibtexDatabase database)
specifier|public
specifier|static
name|String
name|getText
parameter_list|(
name|String
name|toResolve
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
block|{
if|if
condition|(
name|toResolve
operator|!=
literal|null
operator|&&
name|database
operator|!=
literal|null
condition|)
return|return
name|database
operator|.
name|resolveForStrings
argument_list|(
name|toResolve
argument_list|)
return|;
return|return
name|toResolve
return|;
block|}
DECL|method|setFollowCrossrefs (boolean followCrossrefs)
specifier|public
name|void
name|setFollowCrossrefs
parameter_list|(
name|boolean
name|followCrossrefs
parameter_list|)
block|{
name|this
operator|.
name|followCrossrefs
operator|=
name|followCrossrefs
expr_stmt|;
block|}
block|}
end_class

end_unit

