begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003-2015 JabRef contributors.     This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License along     with this program; if not, write to the Free Software Foundation, Inc.,     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */
end_comment

begin_package
DECL|package|net.sf.jabref.openoffice
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|openoffice
package|;
end_package

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|awt
operator|.
name|Point
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|beans
operator|.
name|IllegalTypeException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|beans
operator|.
name|NotRemoveableException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|beans
operator|.
name|PropertyExistException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|beans
operator|.
name|PropertyVetoException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|beans
operator|.
name|UnknownPropertyException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|beans
operator|.
name|XPropertyContainer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|beans
operator|.
name|XPropertySet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|comp
operator|.
name|helper
operator|.
name|Bootstrap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|container
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|container
operator|.
name|*
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|document
operator|.
name|XDocumentPropertiesSupplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|frame
operator|.
name|XComponentLoader
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|frame
operator|.
name|XController
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|frame
operator|.
name|XDesktop
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|frame
operator|.
name|XModel
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|lang
operator|.
name|DisposedException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|lang
operator|.
name|IllegalArgumentException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|lang
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|lang
operator|.
name|WrappedTargetException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|lang
operator|.
name|XComponent
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|lang
operator|.
name|XMultiComponentFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|lang
operator|.
name|XMultiServiceFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|text
operator|.
name|*
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|uno
operator|.
name|Any
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|uno
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|uno
operator|.
name|UnoRuntime
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|uno
operator|.
name|XComponentContext
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|bibtex
operator|.
name|comparator
operator|.
name|FieldComparator
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|exporter
operator|.
name|layout
operator|.
name|Layout
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|l10n
operator|.
name|Localization
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabase
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|BibEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|openoffice
operator|.
name|sorting
operator|.
name|AuthorYearTitleComparator
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|openoffice
operator|.
name|sorting
operator|.
name|YearAuthorTitleComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLClassLoader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_comment
comment|/**  * Class for manipulating the Bibliography of the currently start document in OpenOffice.  */
end_comment

begin_class
DECL|class|OOBibBase
class|class
name|OOBibBase
block|{
DECL|field|POSTFORMATTER
specifier|private
specifier|static
specifier|final
name|OOPreFormatter
name|POSTFORMATTER
init|=
operator|new
name|OOPreFormatter
argument_list|()
decl_stmt|;
DECL|field|BIB_SECTION_NAME
specifier|private
specifier|static
specifier|final
name|String
name|BIB_SECTION_NAME
init|=
literal|"JR_bib"
decl_stmt|;
DECL|field|BIB_SECTION_END_NAME
specifier|private
specifier|static
specifier|final
name|String
name|BIB_SECTION_END_NAME
init|=
literal|"JR_bib_end"
decl_stmt|;
DECL|field|BIB_CITATION
specifier|private
specifier|static
specifier|final
name|String
name|BIB_CITATION
init|=
literal|"JR_cite"
decl_stmt|;
DECL|field|CITE_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|CITE_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|OOBibBase
operator|.
name|BIB_CITATION
operator|+
literal|"\\d*_(\\d*)_(.*)"
argument_list|)
decl_stmt|;
DECL|field|AUTHORYEAR_PAR
specifier|private
specifier|static
specifier|final
name|int
name|AUTHORYEAR_PAR
init|=
literal|1
decl_stmt|;
DECL|field|AUTHORYEAR_INTEXT
specifier|private
specifier|static
specifier|final
name|int
name|AUTHORYEAR_INTEXT
init|=
literal|2
decl_stmt|;
DECL|field|INVISIBLE_CIT
specifier|private
specifier|static
specifier|final
name|int
name|INVISIBLE_CIT
init|=
literal|3
decl_stmt|;
DECL|field|mxDocFactory
specifier|private
name|XMultiServiceFactory
name|mxDocFactory
decl_stmt|;
DECL|field|mxDoc
specifier|private
name|XTextDocument
name|mxDoc
decl_stmt|;
DECL|field|text
specifier|private
name|XText
name|text
decl_stmt|;
DECL|field|xDesktop
specifier|private
specifier|final
name|XDesktop
name|xDesktop
decl_stmt|;
DECL|field|xViewCursorSupplier
specifier|private
name|XTextViewCursorSupplier
name|xViewCursorSupplier
decl_stmt|;
DECL|field|xCurrentComponent
specifier|private
name|XComponent
name|xCurrentComponent
decl_stmt|;
DECL|field|propertySet
specifier|private
name|XPropertySet
name|propertySet
decl_stmt|;
DECL|field|userProperties
specifier|private
name|XPropertyContainer
name|userProperties
decl_stmt|;
DECL|field|atEnd
specifier|private
specifier|final
name|boolean
name|atEnd
decl_stmt|;
DECL|field|entryComparator
specifier|private
specifier|final
name|AuthorYearTitleComparator
name|entryComparator
init|=
operator|new
name|AuthorYearTitleComparator
argument_list|()
decl_stmt|;
DECL|field|yearAuthorTitleComparator
specifier|private
specifier|final
name|YearAuthorTitleComparator
name|yearAuthorTitleComparator
init|=
operator|new
name|YearAuthorTitleComparator
argument_list|()
decl_stmt|;
DECL|field|uniquefiers
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|uniquefiers
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|sortedReferenceMarks
specifier|private
name|String
index|[]
name|sortedReferenceMarks
decl_stmt|;
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Log
name|LOGGER
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|OOBibBase
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|OOBibBase (String pathToOO, boolean atEnd)
specifier|public
name|OOBibBase
parameter_list|(
name|String
name|pathToOO
parameter_list|,
name|boolean
name|atEnd
parameter_list|)
throws|throws
name|Exception
block|{
name|this
operator|.
name|atEnd
operator|=
name|atEnd
expr_stmt|;
name|xDesktop
operator|=
name|simpleBootstrap
argument_list|(
name|pathToOO
argument_list|)
expr_stmt|;
comment|//getDesktop();
name|selectDocument
argument_list|()
expr_stmt|;
block|}
DECL|method|isConnectedToDocument ()
specifier|public
name|boolean
name|isConnectedToDocument
parameter_list|()
block|{
return|return
name|xCurrentComponent
operator|!=
literal|null
return|;
block|}
DECL|method|getCurrentDocumentTitle ()
specifier|public
name|String
name|getCurrentDocumentTitle
parameter_list|()
block|{
if|if
condition|(
name|mxDoc
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
try|try
block|{
return|return
name|String
operator|.
name|valueOf
argument_list|(
name|OOUtil
operator|.
name|getProperty
argument_list|(
name|mxDoc
operator|.
name|getCurrentController
argument_list|()
operator|.
name|getFrame
argument_list|()
argument_list|,
literal|"Title"
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnknownPropertyException
decl||
name|WrappedTargetException
name|e
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Could not get document title"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
block|}
DECL|method|selectDocument ()
specifier|public
name|void
name|selectDocument
parameter_list|()
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|XTextDocument
argument_list|>
name|ls
init|=
name|getTextDocuments
argument_list|()
decl_stmt|;
name|XTextDocument
name|selected
decl_stmt|;
if|if
condition|(
name|ls
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// No text documents found.
throw|throw
operator|new
name|Exception
argument_list|(
literal|"No Writer documents found"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|ls
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|selected
operator|=
name|OOUtil
operator|.
name|selectComponent
argument_list|(
name|ls
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|selected
operator|=
name|ls
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|selected
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|xCurrentComponent
operator|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XComponent
operator|.
name|class
argument_list|,
name|selected
argument_list|)
expr_stmt|;
name|mxDoc
operator|=
name|selected
expr_stmt|;
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XDocumentIndexesSupplier
operator|.
name|class
argument_list|,
name|xCurrentComponent
argument_list|)
expr_stmt|;
name|XModel
name|xModel
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XModel
operator|.
name|class
argument_list|,
name|xCurrentComponent
argument_list|)
decl_stmt|;
name|XController
name|xController
init|=
name|xModel
operator|.
name|getCurrentController
argument_list|()
decl_stmt|;
name|xViewCursorSupplier
operator|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XTextViewCursorSupplier
operator|.
name|class
argument_list|,
name|xController
argument_list|)
expr_stmt|;
comment|// get a reference to the body text of the document
name|text
operator|=
name|mxDoc
operator|.
name|getText
argument_list|()
expr_stmt|;
comment|// Access the text document's multi service factory:
name|mxDocFactory
operator|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XMultiServiceFactory
operator|.
name|class
argument_list|,
name|mxDoc
argument_list|)
expr_stmt|;
name|XDocumentPropertiesSupplier
name|supp
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XDocumentPropertiesSupplier
operator|.
name|class
argument_list|,
name|mxDoc
argument_list|)
decl_stmt|;
name|userProperties
operator|=
name|supp
operator|.
name|getDocumentProperties
argument_list|()
operator|.
name|getUserDefinedProperties
argument_list|()
expr_stmt|;
name|propertySet
operator|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XPropertySet
operator|.
name|class
argument_list|,
name|userProperties
argument_list|)
expr_stmt|;
block|}
DECL|method|simpleBootstrap (String pathToExecutable)
specifier|private
name|XDesktop
name|simpleBootstrap
parameter_list|(
name|String
name|pathToExecutable
parameter_list|)
throws|throws
name|Exception
block|{
name|ClassLoader
name|loader
init|=
name|ClassLoader
operator|.
name|getSystemClassLoader
argument_list|()
decl_stmt|;
if|if
condition|(
name|loader
operator|instanceof
name|URLClassLoader
condition|)
block|{
name|URLClassLoader
name|cl
init|=
operator|(
name|URLClassLoader
operator|)
name|loader
decl_stmt|;
name|Class
argument_list|<
name|URLClassLoader
argument_list|>
name|sysclass
init|=
name|URLClassLoader
operator|.
name|class
decl_stmt|;
try|try
block|{
name|Method
name|method
init|=
name|sysclass
operator|.
name|getDeclaredMethod
argument_list|(
literal|"addURL"
argument_list|,
name|URL
operator|.
name|class
argument_list|)
decl_stmt|;
name|method
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|method
operator|.
name|invoke
argument_list|(
name|cl
argument_list|,
operator|new
name|File
argument_list|(
name|pathToExecutable
argument_list|)
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
decl||
name|NoSuchMethodException
decl||
name|MalformedURLException
name|t
parameter_list|)
block|{
name|LOGGER
operator|.
name|error
argument_list|(
literal|"Error, could not add URL to system classloader"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cl
operator|.
name|close
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error, could not add URL to system classloader"
argument_list|,
name|t
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|LOGGER
operator|.
name|error
argument_list|(
literal|"Error occured, URLClassLoader expected but "
operator|+
name|loader
operator|.
name|getClass
argument_list|()
operator|+
literal|" received. Could not continue."
argument_list|)
expr_stmt|;
block|}
comment|//Get the office component context:
name|XComponentContext
name|xContext
init|=
name|Bootstrap
operator|.
name|bootstrap
argument_list|()
decl_stmt|;
comment|//Get the office service manager:
name|XMultiComponentFactory
name|xServiceManager
init|=
name|xContext
operator|.
name|getServiceManager
argument_list|()
decl_stmt|;
comment|//Create the desktop, which is the root frame of the
comment|//hierarchy of frames that contain viewable components:
name|Object
name|desktop
init|=
name|xServiceManager
operator|.
name|createInstanceWithContext
argument_list|(
literal|"com.sun.star.frame.Desktop"
argument_list|,
name|xContext
argument_list|)
decl_stmt|;
name|XDesktop
name|xD
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XDesktop
operator|.
name|class
argument_list|,
name|desktop
argument_list|)
decl_stmt|;
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XComponentLoader
operator|.
name|class
argument_list|,
name|desktop
argument_list|)
expr_stmt|;
return|return
name|xD
return|;
block|}
DECL|method|getTextDocuments ()
specifier|private
name|List
argument_list|<
name|XTextDocument
argument_list|>
name|getTextDocuments
parameter_list|()
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|XTextDocument
argument_list|>
name|res
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|XEnumerationAccess
name|enumA
init|=
name|xDesktop
operator|.
name|getComponents
argument_list|()
decl_stmt|;
name|XEnumeration
name|e
init|=
name|enumA
operator|.
name|createEnumeration
argument_list|()
decl_stmt|;
comment|// TODO: http://api.openoffice.org/docs/DevelopersGuide/OfficeDev/OfficeDev.xhtml#1_1_3_2_1_2_Frame_Hierarchies
while|while
condition|(
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|Object
name|o
init|=
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|XComponent
name|comp
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XComponent
operator|.
name|class
argument_list|,
name|o
argument_list|)
decl_stmt|;
name|XTextDocument
name|doc
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XTextDocument
operator|.
name|class
argument_list|,
name|comp
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
name|res
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
DECL|method|setCustomProperty (String property, String value)
specifier|public
name|void
name|setCustomProperty
parameter_list|(
name|String
name|property
parameter_list|,
name|String
name|value
parameter_list|)
throws|throws
name|UnknownPropertyException
throws|,
name|NotRemoveableException
throws|,
name|PropertyExistException
throws|,
name|IllegalTypeException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|propertySet
operator|.
name|getPropertySetInfo
argument_list|()
operator|.
name|hasPropertyByName
argument_list|(
name|property
argument_list|)
condition|)
block|{
name|userProperties
operator|.
name|removeProperty
argument_list|(
name|property
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|userProperties
operator|.
name|addProperty
argument_list|(
name|property
argument_list|,
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|beans
operator|.
name|PropertyAttribute
operator|.
name|REMOVEABLE
argument_list|,
operator|new
name|Any
argument_list|(
name|Type
operator|.
name|STRING
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getCustomProperty (String property)
specifier|public
name|String
name|getCustomProperty
parameter_list|(
name|String
name|property
parameter_list|)
throws|throws
name|UnknownPropertyException
throws|,
name|WrappedTargetException
block|{
if|if
condition|(
name|propertySet
operator|.
name|getPropertySetInfo
argument_list|()
operator|.
name|hasPropertyByName
argument_list|(
name|property
argument_list|)
condition|)
block|{
return|return
name|propertySet
operator|.
name|getPropertyValue
argument_list|(
name|property
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
DECL|method|updateSortedReferenceMarks ()
specifier|public
name|void
name|updateSortedReferenceMarks
parameter_list|()
throws|throws
name|WrappedTargetException
throws|,
name|NoSuchElementException
block|{
name|XReferenceMarksSupplier
name|supplier
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XReferenceMarksSupplier
operator|.
name|class
argument_list|,
name|xCurrentComponent
argument_list|)
decl_stmt|;
name|XNameAccess
name|nameAccess
init|=
name|supplier
operator|.
name|getReferenceMarks
argument_list|()
decl_stmt|;
name|sortedReferenceMarks
operator|=
name|getSortedReferenceMarks
argument_list|(
name|nameAccess
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method inserts a cite marker in the text for the given BibEntry,      * and may refresh the bibliography.      * @param entries The entries to cite.      * @param database The database the entry belongs to.      * @param style The bibliography style we are using.      * @param inParenthesis Indicates whether it is an in-text citation or a citation in parenthesis.      *   This is not relevant if numbered citations are used.      * @param withText Indicates whether this should be a normal citation (true) or an empty      *   (invisible) citation (false).      * @param sync Indicates whether the reference list should be refreshed.      * @throws Exception      */
DECL|method|insertEntry (BibEntry[] entries, BibDatabase database, List<BibDatabase> allBases, OOBibStyle style, boolean inParenthesis, boolean withText, String pageInfo, boolean sync)
specifier|public
name|void
name|insertEntry
parameter_list|(
name|BibEntry
index|[]
name|entries
parameter_list|,
name|BibDatabase
name|database
parameter_list|,
name|List
argument_list|<
name|BibDatabase
argument_list|>
name|allBases
parameter_list|,
name|OOBibStyle
name|style
parameter_list|,
name|boolean
name|inParenthesis
parameter_list|,
name|boolean
name|withText
parameter_list|,
name|String
name|pageInfo
parameter_list|,
name|boolean
name|sync
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
name|XTextViewCursor
name|xViewCursor
init|=
name|xViewCursorSupplier
operator|.
name|getViewCursor
argument_list|()
decl_stmt|;
if|if
condition|(
name|entries
operator|.
name|length
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|style
operator|.
name|getBooleanCitProperty
argument_list|(
literal|"MultiCiteChronological"
argument_list|)
condition|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|entries
argument_list|,
name|yearAuthorTitleComparator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|entries
argument_list|,
name|entryComparator
argument_list|)
expr_stmt|;
block|}
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|entries
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|BibEntry
name|entry
init|=
name|entries
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getCiteKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|keyString
init|=
name|sb
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|// Insert bookmark:
name|String
name|bName
init|=
name|getUniqueReferenceMarkName
argument_list|(
name|keyString
argument_list|,
name|withText
condition|?
name|inParenthesis
condition|?
name|OOBibBase
operator|.
name|AUTHORYEAR_PAR
else|:
name|OOBibBase
operator|.
name|AUTHORYEAR_INTEXT
else|:
name|OOBibBase
operator|.
name|INVISIBLE_CIT
argument_list|)
decl_stmt|;
comment|//XTextContent content = insertBookMark(bName, xViewCursor);
comment|// If we should store metadata for page info, do that now:
if|if
condition|(
name|pageInfo
operator|!=
literal|null
condition|)
block|{
name|LOGGER
operator|.
name|info
argument_list|(
literal|"Storing page info: "
operator|+
name|pageInfo
argument_list|)
expr_stmt|;
name|setCustomProperty
argument_list|(
name|bName
argument_list|,
name|pageInfo
argument_list|)
expr_stmt|;
block|}
name|xViewCursor
operator|.
name|getText
argument_list|()
operator|.
name|insertString
argument_list|(
name|xViewCursor
argument_list|,
literal|" "
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|.
name|isFormatCitations
argument_list|()
condition|)
block|{
name|XPropertySet
name|xCursorProps
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XPropertySet
operator|.
name|class
argument_list|,
name|xViewCursor
argument_list|)
decl_stmt|;
name|String
name|charStyle
init|=
name|style
operator|.
name|getCitationCharacterFormat
argument_list|()
decl_stmt|;
try|try
block|{
name|xCursorProps
operator|.
name|setPropertyValue
argument_list|(
literal|"CharStyleName"
argument_list|,
name|charStyle
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownPropertyException
decl||
name|PropertyVetoException
decl||
name|IllegalArgumentException
decl||
name|WrappedTargetException
name|ex
parameter_list|)
block|{
comment|// Setting the character format failed, so we throw an exception that
comment|// will result in an error message for the user. Before that,
comment|// delete the space we inserted:
name|xViewCursor
operator|.
name|goLeft
argument_list|(
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|xViewCursor
operator|.
name|setString
argument_list|(
literal|""
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|UndefinedCharacterFormatException
argument_list|(
name|charStyle
argument_list|)
throw|;
block|}
block|}
name|xViewCursor
operator|.
name|goLeft
argument_list|(
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|String
name|citeText
init|=
name|style
operator|.
name|isNumberEntries
argument_list|()
condition|?
literal|"-"
else|:
name|style
operator|.
name|getCitationMarker
argument_list|(
name|entries
argument_list|,
name|database
argument_list|,
name|inParenthesis
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|insertReferenceMark
argument_list|(
name|bName
argument_list|,
name|citeText
argument_list|,
name|xViewCursor
argument_list|,
name|withText
argument_list|,
name|style
argument_list|)
expr_stmt|;
comment|//xViewCursor.collapseToEnd();
name|xViewCursor
operator|.
name|collapseToEnd
argument_list|()
expr_stmt|;
name|xViewCursor
operator|.
name|goRight
argument_list|(
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|XTextRange
name|position
init|=
name|xViewCursor
operator|.
name|getEnd
argument_list|()
decl_stmt|;
if|if
condition|(
name|sync
condition|)
block|{
comment|// To account for numbering and for uniqiefiers, we must refresh the cite markers:
name|updateSortedReferenceMarks
argument_list|()
expr_stmt|;
name|refreshCiteMarkers
argument_list|(
name|allBases
argument_list|,
name|style
argument_list|)
expr_stmt|;
comment|// Insert it at the current position:
name|rebuildBibTextSection
argument_list|(
name|allBases
argument_list|,
name|style
argument_list|)
expr_stmt|;
block|}
comment|// Go back to the relevant position:
name|xViewCursor
operator|.
name|gotoRange
argument_list|(
name|position
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DisposedException
name|ex
parameter_list|)
block|{
comment|// We need to catch this one here because the OpenOfficePanel class is
comment|// loaded before connection, and therefore cannot directly reference
comment|// or catch a DisposedException (which is in a OO jar file).
throw|throw
operator|new
name|ConnectionLostException
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * Refresh all cite markers in the document.      * @param databases The databases to get entries from.      * @param style The bibliography style to use.      * @return A list of those referenced BibTeX keys that could not be resolved.      * @throws Exception      */
DECL|method|refreshCiteMarkers (List<BibDatabase> databases, OOBibStyle style)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|refreshCiteMarkers
parameter_list|(
name|List
argument_list|<
name|BibDatabase
argument_list|>
name|databases
parameter_list|,
name|OOBibStyle
name|style
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
return|return
name|refreshCiteMarkersInternal
argument_list|(
name|databases
argument_list|,
name|style
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|DisposedException
name|ex
parameter_list|)
block|{
comment|// We need to catch this one here because the OpenOfficePanel class is
comment|// loaded before connection, and therefore cannot directly reference
comment|// or catch a DisposedException (which is in a OO jar file).
throw|throw
operator|new
name|ConnectionLostException
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
DECL|method|getReferenceMarks ()
specifier|public
name|XNameAccess
name|getReferenceMarks
parameter_list|()
block|{
name|XReferenceMarksSupplier
name|supplier
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XReferenceMarksSupplier
operator|.
name|class
argument_list|,
name|xCurrentComponent
argument_list|)
decl_stmt|;
return|return
name|supplier
operator|.
name|getReferenceMarks
argument_list|()
return|;
block|}
DECL|method|getJabRefReferenceMarks (XNameAccess nameAccess)
specifier|public
name|String
index|[]
name|getJabRefReferenceMarks
parameter_list|(
name|XNameAccess
name|nameAccess
parameter_list|)
block|{
name|String
index|[]
name|names
init|=
name|nameAccess
operator|.
name|getElementNames
argument_list|()
decl_stmt|;
comment|// Remove all reference marks that don't look like JabRef citations:
name|ArrayList
argument_list|<
name|String
argument_list|>
name|tmp
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
if|if
condition|(
name|CITE_PATTERN
operator|.
name|matcher
argument_list|(
name|name
argument_list|)
operator|.
name|find
argument_list|()
condition|)
block|{
name|tmp
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|names
operator|=
name|tmp
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|tmp
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
return|return
name|names
return|;
block|}
DECL|method|refreshCiteMarkersInternal (List<BibDatabase> databases, OOBibStyle style)
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|refreshCiteMarkersInternal
parameter_list|(
name|List
argument_list|<
name|BibDatabase
argument_list|>
name|databases
parameter_list|,
name|OOBibStyle
name|style
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|String
argument_list|>
name|cited
init|=
name|findCitedKeys
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|BibDatabase
argument_list|>
name|linkSourceBase
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|BibEntry
argument_list|,
name|BibDatabase
argument_list|>
name|entries
init|=
name|findCitedEntries
argument_list|(
name|databases
argument_list|,
name|cited
argument_list|,
name|linkSourceBase
argument_list|)
decl_stmt|;
name|XNameAccess
name|nameAccess
init|=
name|getReferenceMarks
argument_list|()
decl_stmt|;
name|String
index|[]
name|names
decl_stmt|;
if|if
condition|(
name|style
operator|.
name|isSortByPosition
argument_list|()
condition|)
block|{
comment|// We need to sort the reference marks according to their order of appearance:
comment|/*if (sortedReferenceMarks == null)                 updateSortedReferenceMarks();*/
name|names
operator|=
name|sortedReferenceMarks
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|style
operator|.
name|isNumberEntries
argument_list|()
condition|)
block|{
comment|// We need to sort the reference marks according to the sorting of the bibliographic
comment|// entries:
name|SortedMap
argument_list|<
name|BibEntry
argument_list|,
name|BibDatabase
argument_list|>
name|newMap
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|entryComparator
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|BibEntry
argument_list|,
name|BibDatabase
argument_list|>
name|bibtexEntryBibtexDatabaseEntry
range|:
name|entries
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|newMap
operator|.
name|put
argument_list|(
name|bibtexEntryBibtexDatabaseEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|bibtexEntryBibtexDatabaseEntry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|entries
operator|=
name|newMap
expr_stmt|;
comment|// Rebuild the list of cited keys according to the sort order:
name|cited
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|BibEntry
name|entry
range|:
name|entries
operator|.
name|keySet
argument_list|()
control|)
block|{
name|cited
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getCiteKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|names
operator|=
name|nameAccess
operator|.
name|getElementNames
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/*if (sortedReferenceMarks == null)                 updateSortedReferenceMarks();*/
name|names
operator|=
name|sortedReferenceMarks
expr_stmt|;
block|}
comment|// Remove all reference marks that don't look like JabRef citations:
name|List
argument_list|<
name|String
argument_list|>
name|tmp
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
if|if
condition|(
name|CITE_PATTERN
operator|.
name|matcher
argument_list|(
name|name
argument_list|)
operator|.
name|find
argument_list|()
condition|)
block|{
name|tmp
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|names
operator|=
name|tmp
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|tmp
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|numbers
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|lastNum
init|=
literal|0
decl_stmt|;
comment|// First compute citation markers for all citations:
name|String
index|[]
name|citMarkers
init|=
operator|new
name|String
index|[
name|names
operator|.
name|length
index|]
decl_stmt|;
name|String
index|[]
index|[]
name|normCitMarkers
init|=
operator|new
name|String
index|[
name|names
operator|.
name|length
index|]
index|[]
decl_stmt|;
name|String
index|[]
index|[]
name|bibtexKeys
init|=
operator|new
name|String
index|[
name|names
operator|.
name|length
index|]
index|[]
decl_stmt|;
name|int
name|minGroupingCount
init|=
name|style
operator|.
name|getIntCitProperty
argument_list|(
literal|"MinimumGroupingCount"
argument_list|)
decl_stmt|;
name|int
index|[]
name|types
init|=
operator|new
name|int
index|[
name|names
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|names
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Matcher
name|m
init|=
name|CITE_PATTERN
operator|.
name|matcher
argument_list|(
name|names
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|typeStr
init|=
name|m
operator|.
name|group
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
name|type
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|typeStr
argument_list|)
decl_stmt|;
name|types
index|[
name|i
index|]
operator|=
name|type
expr_stmt|;
comment|// Remember the type in case we need to uniquefy.
name|String
index|[]
name|keys
init|=
name|m
operator|.
name|group
argument_list|(
literal|2
argument_list|)
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|bibtexKeys
index|[
name|i
index|]
operator|=
name|keys
expr_stmt|;
name|BibEntry
index|[]
name|cEntries
init|=
operator|new
name|BibEntry
index|[
name|keys
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|cEntries
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|BibDatabase
name|database
init|=
name|linkSourceBase
operator|.
name|get
argument_list|(
name|keys
index|[
name|j
index|]
argument_list|)
decl_stmt|;
name|cEntries
index|[
name|j
index|]
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|database
operator|!=
literal|null
condition|)
block|{
name|cEntries
index|[
name|j
index|]
operator|=
name|database
operator|.
name|getEntryByKey
argument_list|(
name|keys
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cEntries
index|[
name|j
index|]
operator|==
literal|null
condition|)
block|{
name|LOGGER
operator|.
name|info
argument_list|(
literal|"BibTeX key not found : '"
operator|+
name|keys
index|[
name|j
index|]
operator|+
literal|'\''
argument_list|)
expr_stmt|;
name|LOGGER
operator|.
name|info
argument_list|(
literal|"Problem with reference mark: '"
operator|+
name|names
index|[
name|i
index|]
operator|+
literal|'\''
argument_list|)
expr_stmt|;
name|cEntries
index|[
name|j
index|]
operator|=
operator|new
name|UndefinedBibtexEntry
argument_list|(
name|keys
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|String
index|[]
name|normCitMarker
init|=
operator|new
name|String
index|[
name|keys
operator|.
name|length
index|]
decl_stmt|;
name|String
name|citationMarker
decl_stmt|;
if|if
condition|(
name|style
operator|.
name|isBibtexKeyCiteMarkers
argument_list|()
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|normCitMarkers
index|[
name|i
index|]
operator|=
operator|new
name|String
index|[
name|keys
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|keys
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|normCitMarkers
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|cEntries
index|[
name|j
index|]
operator|.
name|getCiteKey
argument_list|()
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|cEntries
index|[
name|j
index|]
operator|.
name|getCiteKey
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
operator|(
name|keys
operator|.
name|length
operator|-
literal|1
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
name|citationMarker
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|style
operator|.
name|isNumberEntries
argument_list|()
condition|)
block|{
if|if
condition|(
name|style
operator|.
name|isSortByPosition
argument_list|()
condition|)
block|{
comment|// We have sorted the citation markers according to their order of appearance,
comment|// so we simply count up for each marker referring to a new entry:
name|List
argument_list|<
name|Integer
argument_list|>
name|num
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|keys
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|keys
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|cEntries
index|[
name|j
index|]
operator|instanceof
name|UndefinedBibtexEntry
condition|)
block|{
name|num
operator|.
name|add
argument_list|(
name|j
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num
operator|.
name|add
argument_list|(
name|j
argument_list|,
name|lastNum
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|numbers
operator|.
name|containsKey
argument_list|(
name|keys
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|num
operator|.
name|add
argument_list|(
name|j
argument_list|,
name|numbers
operator|.
name|get
argument_list|(
name|keys
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|numbers
operator|.
name|put
argument_list|(
name|keys
index|[
name|j
index|]
argument_list|,
name|num
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|lastNum
operator|=
name|num
operator|.
name|get
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|citationMarker
operator|=
name|style
operator|.
name|getNumCitationMarker
argument_list|(
name|num
argument_list|,
name|minGroupingCount
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|keys
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|num
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|normCitMarker
index|[
name|j
index|]
operator|=
name|style
operator|.
name|getNumCitationMarker
argument_list|(
name|list
argument_list|,
name|minGroupingCount
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// We need to find the number of the cited entry in the bibliography,
comment|// and use that number for the cite marker:
name|List
argument_list|<
name|Integer
argument_list|>
name|num
init|=
name|findCitedEntryIndex
argument_list|(
name|names
index|[
name|i
index|]
argument_list|,
name|cited
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|BibEntryNotFoundException
argument_list|(
name|names
index|[
name|i
index|]
argument_list|,
name|Localization
operator|.
name|lang
argument_list|(
literal|"Could not resolve BibTeX entry for citation marker '%0'."
argument_list|,
name|names
index|[
name|i
index|]
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
name|citationMarker
operator|=
name|style
operator|.
name|getNumCitationMarker
argument_list|(
name|num
argument_list|,
name|minGroupingCount
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|keys
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|num
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|normCitMarker
index|[
name|j
index|]
operator|=
name|style
operator|.
name|getNumCitationMarker
argument_list|(
name|list
argument_list|,
name|minGroupingCount
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|cEntries
operator|.
name|length
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|style
operator|.
name|getBooleanCitProperty
argument_list|(
literal|"MultiCiteChronological"
argument_list|)
condition|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|cEntries
argument_list|,
name|yearAuthorTitleComparator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|cEntries
argument_list|,
name|entryComparator
argument_list|)
expr_stmt|;
block|}
comment|// Update key list to match the new sorting:
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|cEntries
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|bibtexKeys
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|cEntries
index|[
name|j
index|]
operator|.
name|getCiteKey
argument_list|()
expr_stmt|;
block|}
block|}
name|citationMarker
operator|=
name|style
operator|.
name|getCitationMarker
argument_list|(
name|cEntries
argument_list|,
name|entries
operator|.
name|get
argument_list|(
name|cEntries
argument_list|)
argument_list|,
name|type
operator|==
name|OOBibBase
operator|.
name|AUTHORYEAR_PAR
argument_list|,
operator|(
name|String
index|[]
operator|)
literal|null
argument_list|,
operator|(
name|int
index|[]
operator|)
literal|null
argument_list|)
expr_stmt|;
comment|// We need "normalized" (in parenthesis) markers for uniqueness checking purposes:
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|cEntries
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|normCitMarker
index|[
name|j
index|]
operator|=
name|style
operator|.
name|getCitationMarker
argument_list|(
name|cEntries
index|[
name|j
index|]
argument_list|,
name|entries
operator|.
name|get
argument_list|(
name|cEntries
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|citMarkers
index|[
name|i
index|]
operator|=
name|citationMarker
expr_stmt|;
name|normCitMarkers
index|[
name|i
index|]
operator|=
name|normCitMarker
expr_stmt|;
block|}
block|}
name|uniquefiers
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|style
operator|.
name|isBibtexKeyCiteMarkers
argument_list|()
operator|&&
operator|!
name|style
operator|.
name|isNumberEntries
argument_list|()
condition|)
block|{
comment|// See if there are duplicate citations marks referring to different entries. If so, we need to
comment|// use uniquefiers:
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|refKeys
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|refNums
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|citMarkers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
index|[]
name|markers
init|=
name|normCitMarkers
index|[
name|i
index|]
decl_stmt|;
comment|// compare normalized markers, since the actual markers can be different
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|markers
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|String
name|marker
init|=
name|markers
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|refKeys
operator|.
name|containsKey
argument_list|(
name|marker
argument_list|)
condition|)
block|{
comment|// Ok, we have seen this exact marker before.
if|if
condition|(
operator|!
name|refKeys
operator|.
name|get
argument_list|(
name|marker
argument_list|)
operator|.
name|contains
argument_list|(
name|bibtexKeys
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
condition|)
block|{
comment|// ... but not for this entry.
name|refKeys
operator|.
name|get
argument_list|(
name|marker
argument_list|)
operator|.
name|add
argument_list|(
name|bibtexKeys
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|refNums
operator|.
name|get
argument_list|(
name|marker
argument_list|)
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|List
argument_list|<
name|String
argument_list|>
name|l
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|l
operator|.
name|add
argument_list|(
name|bibtexKeys
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|refKeys
operator|.
name|put
argument_list|(
name|marker
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|l2
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|l2
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|refNums
operator|.
name|put
argument_list|(
name|marker
argument_list|,
name|l2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Go through the collected lists and see where we need to uniquefy:
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|stringListEntry
range|:
name|refKeys
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|keys
init|=
name|stringListEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|keys
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// This marker appears for more than one unique entry:
name|int
name|uniq
init|=
literal|'a'
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|keys
control|)
block|{
comment|// Update the map of uniquefiers for the benefit of both the following generation of new
comment|// citation markers, and for the method that builds the bibliography:
name|uniquefiers
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
operator|(
name|char
operator|)
name|uniq
argument_list|)
argument_list|)
expr_stmt|;
name|uniq
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|// Finally, go through all citation markers, and update those referring to entries in our current list:
name|int
name|maxAuthorsFirst
init|=
name|style
operator|.
name|getIntCitProperty
argument_list|(
literal|"MaxAuthorsFirst"
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|seenBefore
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|bibtexKeys
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|boolean
name|needsChange
init|=
literal|false
decl_stmt|;
name|int
index|[]
name|firstLimAuthors
init|=
operator|new
name|int
index|[
name|bibtexKeys
index|[
name|j
index|]
operator|.
name|length
index|]
decl_stmt|;
name|String
index|[]
name|uniquif
init|=
operator|new
name|String
index|[
name|bibtexKeys
index|[
name|j
index|]
operator|.
name|length
index|]
decl_stmt|;
name|BibEntry
index|[]
name|cEntries
init|=
operator|new
name|BibEntry
index|[
name|bibtexKeys
index|[
name|j
index|]
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|bibtexKeys
index|[
name|j
index|]
operator|.
name|length
condition|;
name|k
operator|++
control|)
block|{
name|firstLimAuthors
index|[
name|k
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|maxAuthorsFirst
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|seenBefore
operator|.
name|contains
argument_list|(
name|bibtexKeys
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
condition|)
block|{
name|firstLimAuthors
index|[
name|k
index|]
operator|=
name|maxAuthorsFirst
expr_stmt|;
block|}
name|seenBefore
operator|.
name|add
argument_list|(
name|bibtexKeys
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
name|String
name|uniq
init|=
name|uniquefiers
operator|.
name|get
argument_list|(
name|bibtexKeys
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|uniq
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|uniq
operator|.
name|length
argument_list|()
operator|>=
literal|0
operator|)
condition|)
block|{
name|needsChange
operator|=
literal|true
expr_stmt|;
name|BibDatabase
name|database
init|=
name|linkSourceBase
operator|.
name|get
argument_list|(
name|bibtexKeys
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|database
operator|!=
literal|null
condition|)
block|{
name|cEntries
index|[
name|k
index|]
operator|=
name|database
operator|.
name|getEntryByKey
argument_list|(
name|bibtexKeys
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
name|uniquif
index|[
name|k
index|]
operator|=
name|uniq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|firstLimAuthors
index|[
name|k
index|]
operator|>
literal|0
condition|)
block|{
name|needsChange
operator|=
literal|true
expr_stmt|;
name|BibDatabase
name|database
init|=
name|linkSourceBase
operator|.
name|get
argument_list|(
name|bibtexKeys
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|database
operator|!=
literal|null
condition|)
block|{
name|cEntries
index|[
name|k
index|]
operator|=
name|database
operator|.
name|getEntryByKey
argument_list|(
name|bibtexKeys
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
name|uniquif
index|[
name|k
index|]
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|BibDatabase
name|database
init|=
name|linkSourceBase
operator|.
name|get
argument_list|(
name|bibtexKeys
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|database
operator|!=
literal|null
condition|)
block|{
name|cEntries
index|[
name|k
index|]
operator|=
name|database
operator|.
name|getEntryByKey
argument_list|(
name|bibtexKeys
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
name|uniquif
index|[
name|k
index|]
operator|=
literal|""
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needsChange
condition|)
block|{
name|citMarkers
index|[
name|j
index|]
operator|=
name|style
operator|.
name|getCitationMarker
argument_list|(
name|cEntries
argument_list|,
name|entries
operator|.
name|get
argument_list|(
name|cEntries
argument_list|)
argument_list|,
name|types
index|[
name|j
index|]
operator|==
name|OOBibBase
operator|.
name|AUTHORYEAR_PAR
argument_list|,
name|uniquif
argument_list|,
name|firstLimAuthors
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Refresh all reference marks with the citation markers we computed:
name|boolean
name|hadBibSection
init|=
name|getBookmarkRange
argument_list|(
name|OOBibBase
operator|.
name|BIB_SECTION_NAME
argument_list|)
operator|!=
literal|null
decl_stmt|;
comment|// Check if we are supposed to set a character format for citations:
name|boolean
name|mustTestCharFormat
init|=
name|style
operator|.
name|isFormatCitations
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|names
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|o
init|=
name|nameAccess
operator|.
name|getByName
argument_list|(
name|names
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|XTextContent
name|bm
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XTextContent
operator|.
name|class
argument_list|,
name|o
argument_list|)
decl_stmt|;
name|XTextCursor
name|cursor
init|=
name|bm
operator|.
name|getAnchor
argument_list|()
operator|.
name|getText
argument_list|()
operator|.
name|createTextCursorByRange
argument_list|(
name|bm
operator|.
name|getAnchor
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|mustTestCharFormat
condition|)
block|{
comment|// If we are supposed to set character format for citations, must run a test before we
comment|// delete old citation markers. Otherwise, if the specified character format doesn't
comment|// exist, we end up deleting the markers before the process crashes due to a the missing
comment|// format, with catastrophic consequences for the user.
name|mustTestCharFormat
operator|=
literal|false
expr_stmt|;
comment|// need to do this only once
name|XPropertySet
name|xCursorProps
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XPropertySet
operator|.
name|class
argument_list|,
name|cursor
argument_list|)
decl_stmt|;
name|String
name|charStyle
init|=
name|style
operator|.
name|getCitationCharacterFormat
argument_list|()
decl_stmt|;
try|try
block|{
name|xCursorProps
operator|.
name|setPropertyValue
argument_list|(
literal|"CharStyleName"
argument_list|,
name|charStyle
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownPropertyException
decl||
name|PropertyVetoException
decl||
name|IllegalArgumentException
decl||
name|WrappedTargetException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|UndefinedCharacterFormatException
argument_list|(
name|charStyle
argument_list|)
throw|;
block|}
block|}
name|text
operator|.
name|removeTextContent
argument_list|(
name|bm
argument_list|)
expr_stmt|;
name|insertReferenceMark
argument_list|(
name|names
index|[
name|i
index|]
argument_list|,
name|citMarkers
index|[
name|i
index|]
argument_list|,
name|cursor
argument_list|,
name|types
index|[
name|i
index|]
operator|!=
name|OOBibBase
operator|.
name|INVISIBLE_CIT
argument_list|,
name|style
argument_list|)
expr_stmt|;
if|if
condition|(
name|hadBibSection
operator|&&
operator|(
name|getBookmarkRange
argument_list|(
name|OOBibBase
operator|.
name|BIB_SECTION_NAME
argument_list|)
operator|==
literal|null
operator|)
condition|)
block|{
comment|// We have overwritten the marker for the start of the reference list.
comment|// We need to add it again.
name|cursor
operator|.
name|collapseToEnd
argument_list|()
expr_stmt|;
name|OOUtil
operator|.
name|insertParagraphBreak
argument_list|(
name|text
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
name|insertBookMark
argument_list|(
name|OOBibBase
operator|.
name|BIB_SECTION_NAME
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
block|}
block|}
name|ArrayList
argument_list|<
name|String
argument_list|>
name|unresolvedKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|BibEntry
name|entry
range|:
name|entries
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|instanceof
name|UndefinedBibtexEntry
condition|)
block|{
name|String
name|key
init|=
operator|(
operator|(
name|UndefinedBibtexEntry
operator|)
name|entry
operator|)
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|unresolvedKeys
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|unresolvedKeys
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|unresolvedKeys
return|;
block|}
DECL|method|getSortedReferenceMarks (final XNameAccess nameAccess)
specifier|private
name|String
index|[]
name|getSortedReferenceMarks
parameter_list|(
specifier|final
name|XNameAccess
name|nameAccess
parameter_list|)
throws|throws
name|WrappedTargetException
throws|,
name|NoSuchElementException
block|{
name|XTextViewCursorSupplier
name|css
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XTextViewCursorSupplier
operator|.
name|class
argument_list|,
name|mxDoc
operator|.
name|getCurrentController
argument_list|()
argument_list|)
decl_stmt|;
name|XTextViewCursor
name|tvc
init|=
name|css
operator|.
name|getViewCursor
argument_list|()
decl_stmt|;
name|XTextRange
name|initialPos
init|=
name|tvc
operator|.
name|getStart
argument_list|()
decl_stmt|;
name|String
index|[]
name|names
init|=
name|nameAccess
operator|.
name|getElementNames
argument_list|()
decl_stmt|;
name|Point
index|[]
name|positions
init|=
operator|new
name|Point
index|[
name|names
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|names
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|names
index|[
name|i
index|]
decl_stmt|;
name|XTextContent
name|tc
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XTextContent
operator|.
name|class
argument_list|,
name|nameAccess
operator|.
name|getByName
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
name|XTextRange
name|r
init|=
name|tc
operator|.
name|getAnchor
argument_list|()
decl_stmt|;
comment|// Check if we are inside a footnote:
if|if
condition|(
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XFootnote
operator|.
name|class
argument_list|,
name|r
operator|.
name|getText
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// Find the linking footnote marker:
name|XFootnote
name|footer
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XFootnote
operator|.
name|class
argument_list|,
name|r
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
comment|// The footnote's anchor gives the correct position in the text:
name|r
operator|=
name|footer
operator|.
name|getAnchor
argument_list|()
expr_stmt|;
block|}
name|positions
index|[
name|i
index|]
operator|=
name|findPosition
argument_list|(
name|tvc
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
name|TreeSet
argument_list|<
name|ComparableMark
argument_list|>
name|set
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|positions
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|set
operator|.
name|add
argument_list|(
operator|new
name|ComparableMark
argument_list|(
name|names
index|[
name|i
index|]
argument_list|,
name|positions
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ComparableMark
name|mark
range|:
name|set
control|)
block|{
comment|//System.out.println(mark.getPosition().X+" -- "+mark.getPosition().Y+" : "+mark.getName());
name|names
index|[
name|i
index|]
operator|=
name|mark
operator|.
name|getName
argument_list|()
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|tvc
operator|.
name|gotoRange
argument_list|(
name|initialPos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|//xFrame.dispose();
return|return
name|names
return|;
block|}
DECL|method|rebuildBibTextSection (List<BibDatabase> databases, OOBibStyle style)
specifier|public
name|void
name|rebuildBibTextSection
parameter_list|(
name|List
argument_list|<
name|BibDatabase
argument_list|>
name|databases
parameter_list|,
name|OOBibStyle
name|style
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|String
argument_list|>
name|cited
init|=
name|findCitedKeys
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|BibDatabase
argument_list|>
name|linkSourceBase
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|BibEntry
argument_list|,
name|BibDatabase
argument_list|>
name|entries
init|=
name|findCitedEntries
argument_list|(
name|databases
argument_list|,
name|cited
argument_list|,
name|linkSourceBase
argument_list|)
decl_stmt|;
name|String
index|[]
name|names
init|=
name|sortedReferenceMarks
decl_stmt|;
if|if
condition|(
name|style
operator|.
name|isSortByPosition
argument_list|()
condition|)
block|{
comment|// We need to sort the entries according to their order of appearance:
name|entries
operator|=
name|getSortedEntriesFromSortedRefMarks
argument_list|(
name|names
argument_list|,
name|entries
argument_list|,
name|linkSourceBase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SortedMap
argument_list|<
name|BibEntry
argument_list|,
name|BibDatabase
argument_list|>
name|newMap
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|entryComparator
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|BibEntry
argument_list|,
name|BibDatabase
argument_list|>
name|bibtexEntryBibtexDatabaseEntry
range|:
name|entries
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|newMap
operator|.
name|put
argument_list|(
name|bibtexEntryBibtexDatabaseEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|bibtexEntryBibtexDatabaseEntry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|entries
operator|=
name|newMap
expr_stmt|;
block|}
name|clearBibTextSectionContent2
argument_list|()
expr_stmt|;
name|populateBibTextSection
argument_list|(
name|entries
argument_list|,
name|style
argument_list|)
expr_stmt|;
block|}
DECL|method|getUniqueReferenceMarkName (String bibtexKey, int type)
specifier|private
name|String
name|getUniqueReferenceMarkName
parameter_list|(
name|String
name|bibtexKey
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|XReferenceMarksSupplier
name|supplier
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XReferenceMarksSupplier
operator|.
name|class
argument_list|,
name|xCurrentComponent
argument_list|)
decl_stmt|;
name|XNameAccess
name|xNamedRefMarks
init|=
name|supplier
operator|.
name|getReferenceMarks
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|String
name|name
init|=
name|OOBibBase
operator|.
name|BIB_CITATION
operator|+
literal|'_'
operator|+
name|type
operator|+
literal|'_'
operator|+
name|bibtexKey
decl_stmt|;
while|while
condition|(
name|xNamedRefMarks
operator|.
name|hasByName
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|name
operator|=
name|OOBibBase
operator|.
name|BIB_CITATION
operator|+
name|i
operator|+
literal|'_'
operator|+
name|type
operator|+
literal|'_'
operator|+
name|bibtexKey
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
DECL|method|findCitedEntries (List<BibDatabase> databases, List<String> keys, Map<String, BibDatabase> linkSourceBase)
specifier|private
name|Map
argument_list|<
name|BibEntry
argument_list|,
name|BibDatabase
argument_list|>
name|findCitedEntries
parameter_list|(
name|List
argument_list|<
name|BibDatabase
argument_list|>
name|databases
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|keys
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|BibDatabase
argument_list|>
name|linkSourceBase
parameter_list|)
block|{
name|Map
argument_list|<
name|BibEntry
argument_list|,
name|BibDatabase
argument_list|>
name|entries
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|keys
control|)
block|{
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|BibDatabase
name|database
range|:
name|databases
control|)
block|{
name|BibEntry
name|entry
init|=
name|database
operator|.
name|getEntryByKey
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|entries
operator|.
name|put
argument_list|(
name|entry
argument_list|,
name|database
argument_list|)
expr_stmt|;
name|linkSourceBase
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|database
argument_list|)
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|entries
operator|.
name|put
argument_list|(
operator|new
name|UndefinedBibtexEntry
argument_list|(
name|key
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|entries
return|;
block|}
DECL|method|findCitedKeys ()
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|findCitedKeys
parameter_list|()
throws|throws
name|NoSuchElementException
throws|,
name|WrappedTargetException
block|{
name|XReferenceMarksSupplier
name|supplier
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XReferenceMarksSupplier
operator|.
name|class
argument_list|,
name|xCurrentComponent
argument_list|)
decl_stmt|;
name|XNameAccess
name|xNamedMarks
init|=
name|supplier
operator|.
name|getReferenceMarks
argument_list|()
decl_stmt|;
name|String
index|[]
name|names
init|=
name|xNamedMarks
operator|.
name|getElementNames
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name1
range|:
name|names
control|)
block|{
name|Object
name|bookmark
init|=
name|xNamedMarks
operator|.
name|getByName
argument_list|(
name|name1
argument_list|)
decl_stmt|;
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XTextContent
operator|.
name|class
argument_list|,
name|bookmark
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|newKeys
init|=
name|parseRefMarkName
argument_list|(
name|name1
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|newKeys
control|)
block|{
if|if
condition|(
operator|!
name|keys
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|keys
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|keys
return|;
block|}
DECL|method|getSortedEntriesFromSortedRefMarks (String[] names, Map<BibEntry, BibDatabase> entries, Map<String, BibDatabase> linkSourceBase)
specifier|private
name|Map
argument_list|<
name|BibEntry
argument_list|,
name|BibDatabase
argument_list|>
name|getSortedEntriesFromSortedRefMarks
parameter_list|(
name|String
index|[]
name|names
parameter_list|,
name|Map
argument_list|<
name|BibEntry
argument_list|,
name|BibDatabase
argument_list|>
name|entries
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|BibDatabase
argument_list|>
name|linkSourceBase
parameter_list|)
block|{
name|Map
argument_list|<
name|BibEntry
argument_list|,
name|BibDatabase
argument_list|>
name|newList
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|BibEntry
argument_list|,
name|BibEntry
argument_list|>
name|adaptedEntries
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
name|Matcher
name|m
init|=
name|CITE_PATTERN
operator|.
name|matcher
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
index|[]
name|keys
init|=
name|m
operator|.
name|group
argument_list|(
literal|2
argument_list|)
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|keys
control|)
block|{
name|BibDatabase
name|database
init|=
name|linkSourceBase
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|BibEntry
name|origEntry
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|database
operator|!=
literal|null
condition|)
block|{
name|origEntry
operator|=
name|database
operator|.
name|getEntryByKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|origEntry
operator|==
literal|null
condition|)
block|{
name|LOGGER
operator|.
name|info
argument_list|(
literal|"BibTeX key not found : '"
operator|+
name|key
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|LOGGER
operator|.
name|info
argument_list|(
literal|"Problem with reference mark: '"
operator|+
name|name
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|newList
operator|.
name|put
argument_list|(
operator|new
name|UndefinedBibtexEntry
argument_list|(
name|key
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BibEntry
name|entry
init|=
name|adaptedEntries
operator|.
name|get
argument_list|(
name|origEntry
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
name|entry
operator|=
operator|(
name|BibEntry
operator|)
name|origEntry
operator|.
name|clone
argument_list|()
expr_stmt|;
name|adaptedEntries
operator|.
name|put
argument_list|(
name|origEntry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newList
operator|.
name|containsKey
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|newList
operator|.
name|put
argument_list|(
name|entry
argument_list|,
name|database
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|newList
return|;
block|}
DECL|method|findPosition (XTextViewCursor cursor, XTextRange range)
specifier|private
name|Point
name|findPosition
parameter_list|(
name|XTextViewCursor
name|cursor
parameter_list|,
name|XTextRange
name|range
parameter_list|)
block|{
name|cursor
operator|.
name|gotoRange
argument_list|(
name|range
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|cursor
operator|.
name|getPosition
argument_list|()
return|;
block|}
comment|/**      * Extract the list of bibtex keys from a reference mark name.      * @param name The reference mark name.      * @return The list of bibtex keys encoded in the name.      */
DECL|method|parseRefMarkName (String name)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|parseRefMarkName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Matcher
name|m
init|=
name|CITE_PATTERN
operator|.
name|matcher
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
index|[]
name|keystring
init|=
name|m
operator|.
name|group
argument_list|(
literal|2
argument_list|)
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|aKeystring
range|:
name|keystring
control|)
block|{
if|if
condition|(
operator|!
name|keys
operator|.
name|contains
argument_list|(
name|aKeystring
argument_list|)
condition|)
block|{
name|keys
operator|.
name|add
argument_list|(
name|aKeystring
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|keys
return|;
block|}
comment|/**      * Resolve the bibtex key from a citation reference marker name, and look up      * the index of the key in a list of keys.      * @param citRefName The name of the ReferenceMark representing the citation.      * @param keys A List of bibtex keys representing the entries in the bibliography.      * @return the indices of the cited keys, -1 if a key is not found. Returns null if the ref name      *   could not be resolved as a citation.      */
DECL|method|findCitedEntryIndex (String citRefName, List<String> keys)
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|findCitedEntryIndex
parameter_list|(
name|String
name|citRefName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|keys
parameter_list|)
block|{
name|Matcher
name|m
init|=
name|CITE_PATTERN
operator|.
name|matcher
argument_list|(
name|citRefName
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|keyStrings
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|m
operator|.
name|group
argument_list|(
literal|2
argument_list|)
operator|.
name|split
argument_list|(
literal|","
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|res
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|keyStrings
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|keyStrings
control|)
block|{
name|int
name|ind
init|=
name|keys
operator|.
name|indexOf
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|res
operator|.
name|add
argument_list|(
name|ind
operator|==
operator|-
literal|1
condition|?
operator|-
literal|1
else|:
literal|1
operator|+
name|ind
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
else|else
block|{
return|return
name|Collections
operator|.
name|EMPTY_LIST
return|;
block|}
block|}
DECL|method|getCitationContext (XNameAccess nameAccess, String refMarkName, int charBefore, int charAfter, boolean htmlMarkup)
specifier|public
name|String
name|getCitationContext
parameter_list|(
name|XNameAccess
name|nameAccess
parameter_list|,
name|String
name|refMarkName
parameter_list|,
name|int
name|charBefore
parameter_list|,
name|int
name|charAfter
parameter_list|,
name|boolean
name|htmlMarkup
parameter_list|)
throws|throws
name|NoSuchElementException
throws|,
name|WrappedTargetException
block|{
name|Object
name|o
init|=
name|nameAccess
operator|.
name|getByName
argument_list|(
name|refMarkName
argument_list|)
decl_stmt|;
name|XTextContent
name|bm
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XTextContent
operator|.
name|class
argument_list|,
name|o
argument_list|)
decl_stmt|;
name|XTextCursor
name|cursor
init|=
name|bm
operator|.
name|getAnchor
argument_list|()
operator|.
name|getText
argument_list|()
operator|.
name|createTextCursorByRange
argument_list|(
name|bm
operator|.
name|getAnchor
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|citPart
init|=
name|cursor
operator|.
name|getString
argument_list|()
decl_stmt|;
name|int
name|flex
init|=
literal|8
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|charBefore
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|cursor
operator|.
name|goLeft
argument_list|(
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|>=
operator|(
name|charBefore
operator|-
name|flex
operator|)
operator|)
operator|&&
name|Character
operator|.
name|isWhitespace
argument_list|(
name|cursor
operator|.
name|getString
argument_list|()
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|ex
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Problem going left"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|length
init|=
name|cursor
operator|.
name|getString
argument_list|()
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|added
init|=
name|length
operator|-
name|citPart
operator|.
name|length
argument_list|()
decl_stmt|;
name|cursor
operator|.
name|collapseToStart
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|charAfter
operator|+
name|length
operator|)
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|cursor
operator|.
name|goRight
argument_list|(
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
operator|(
operator|(
name|charAfter
operator|+
name|length
operator|)
operator|-
name|flex
operator|)
condition|)
block|{
name|String
name|strNow
init|=
name|cursor
operator|.
name|getString
argument_list|()
decl_stmt|;
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|strNow
operator|.
name|charAt
argument_list|(
name|strNow
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|ex
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Problem going right"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|result
init|=
name|cursor
operator|.
name|getString
argument_list|()
decl_stmt|;
if|if
condition|(
name|htmlMarkup
condition|)
block|{
name|result
operator|=
name|result
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|added
argument_list|)
operator|+
literal|"<b>"
operator|+
name|citPart
operator|+
literal|"</b>"
operator|+
name|result
operator|.
name|substring
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|.
name|trim
argument_list|()
return|;
block|}
DECL|method|insertFullReferenceAtCursor (XTextCursor cursor, Map<BibEntry, BibDatabase> entries, OOBibStyle style, String parFormat)
specifier|private
name|void
name|insertFullReferenceAtCursor
parameter_list|(
name|XTextCursor
name|cursor
parameter_list|,
name|Map
argument_list|<
name|BibEntry
argument_list|,
name|BibDatabase
argument_list|>
name|entries
parameter_list|,
name|OOBibStyle
name|style
parameter_list|,
name|String
name|parFormat
parameter_list|)
throws|throws
name|UndefinedParagraphFormatException
throws|,
name|IllegalArgumentException
throws|,
name|UnknownPropertyException
throws|,
name|PropertyVetoException
throws|,
name|WrappedTargetException
block|{
comment|// If we don't have numbered entries, we need to sort the entries before adding them:
if|if
condition|(
operator|!
name|style
operator|.
name|isSortByPosition
argument_list|()
condition|)
block|{
name|Map
argument_list|<
name|BibEntry
argument_list|,
name|BibDatabase
argument_list|>
name|newMap
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|entryComparator
argument_list|)
decl_stmt|;
name|newMap
operator|.
name|putAll
argument_list|(
name|entries
argument_list|)
expr_stmt|;
name|entries
operator|=
name|newMap
expr_stmt|;
block|}
name|int
name|number
init|=
literal|1
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|BibEntry
argument_list|,
name|BibDatabase
argument_list|>
name|entry
range|:
name|entries
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|instanceof
name|UndefinedBibtexEntry
condition|)
block|{
continue|continue;
block|}
name|OOUtil
operator|.
name|insertParagraphBreak
argument_list|(
name|text
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|.
name|isNumberEntries
argument_list|()
condition|)
block|{
name|int
name|minGroupingCount
init|=
name|style
operator|.
name|getIntCitProperty
argument_list|(
literal|"MinimumGroupingCount"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|number
operator|++
argument_list|)
expr_stmt|;
name|OOUtil
operator|.
name|insertTextAtCurrentLocation
argument_list|(
name|text
argument_list|,
name|cursor
argument_list|,
name|style
operator|.
name|getNumCitationMarker
argument_list|(
name|list
argument_list|,
name|minGroupingCount
argument_list|,
literal|true
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|Layout
name|layout
init|=
name|style
operator|.
name|getReferenceFormat
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|layout
operator|.
name|setPostFormatter
argument_list|(
name|POSTFORMATTER
argument_list|)
expr_stmt|;
name|OOUtil
operator|.
name|insertFullReferenceAtCurrentLocation
argument_list|(
name|text
argument_list|,
name|cursor
argument_list|,
name|layout
argument_list|,
name|parFormat
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|uniquefiers
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getCiteKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|createBibTextSection2 (boolean end)
specifier|private
name|void
name|createBibTextSection2
parameter_list|(
name|boolean
name|end
parameter_list|)
throws|throws
name|Exception
block|{
name|XTextCursor
name|mxDocCursor
init|=
name|text
operator|.
name|createTextCursor
argument_list|()
decl_stmt|;
if|if
condition|(
name|end
condition|)
block|{
name|mxDocCursor
operator|.
name|gotoEnd
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|OOUtil
operator|.
name|insertParagraphBreak
argument_list|(
name|text
argument_list|,
name|mxDocCursor
argument_list|)
expr_stmt|;
comment|// Create a new TextSection from the document factory and access it's XNamed interface
name|XNamed
name|xChildNamed
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XNamed
operator|.
name|class
argument_list|,
name|mxDocFactory
operator|.
name|createInstance
argument_list|(
literal|"com.sun.star.text.TextSection"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Set the new sections name to 'Child_Section'
name|xChildNamed
operator|.
name|setName
argument_list|(
name|OOBibBase
operator|.
name|BIB_SECTION_NAME
argument_list|)
expr_stmt|;
comment|// Access the Child_Section's XTextContent interface and insert it into the document
name|XTextContent
name|xChildSection
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XTextContent
operator|.
name|class
argument_list|,
name|xChildNamed
argument_list|)
decl_stmt|;
name|text
operator|.
name|insertTextContent
argument_list|(
name|mxDocCursor
argument_list|,
name|xChildSection
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|clearBibTextSectionContent2 ()
specifier|private
name|void
name|clearBibTextSectionContent2
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Check if the section exists:
name|XTextSectionsSupplier
name|supp
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XTextSectionsSupplier
operator|.
name|class
argument_list|,
name|mxDoc
argument_list|)
decl_stmt|;
try|try
block|{
name|XTextSection
name|section
init|=
call|(
name|XTextSection
call|)
argument_list|(
operator|(
name|Any
operator|)
name|supp
operator|.
name|getTextSections
argument_list|()
operator|.
name|getByName
argument_list|(
name|OOBibBase
operator|.
name|BIB_SECTION_NAME
argument_list|)
argument_list|)
operator|.
name|getObject
argument_list|()
decl_stmt|;
comment|// Clear it:
name|XTextCursor
name|cursor
init|=
name|text
operator|.
name|createTextCursorByRange
argument_list|(
name|section
operator|.
name|getAnchor
argument_list|()
argument_list|)
decl_stmt|;
name|cursor
operator|.
name|gotoRange
argument_list|(
name|section
operator|.
name|getAnchor
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|setString
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|ex
parameter_list|)
block|{
name|createBibTextSection2
argument_list|(
name|atEnd
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|populateBibTextSection (Map<BibEntry, BibDatabase> entries, OOBibStyle style)
specifier|private
name|void
name|populateBibTextSection
parameter_list|(
name|Map
argument_list|<
name|BibEntry
argument_list|,
name|BibDatabase
argument_list|>
name|entries
parameter_list|,
name|OOBibStyle
name|style
parameter_list|)
throws|throws
name|Exception
block|{
name|XTextSectionsSupplier
name|supp
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XTextSectionsSupplier
operator|.
name|class
argument_list|,
name|mxDoc
argument_list|)
decl_stmt|;
name|XTextSection
name|section
init|=
call|(
name|XTextSection
call|)
argument_list|(
operator|(
name|Any
operator|)
name|supp
operator|.
name|getTextSections
argument_list|()
operator|.
name|getByName
argument_list|(
name|OOBibBase
operator|.
name|BIB_SECTION_NAME
argument_list|)
argument_list|)
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|XTextCursor
name|cursor
init|=
name|text
operator|.
name|createTextCursorByRange
argument_list|(
name|section
operator|.
name|getAnchor
argument_list|()
argument_list|)
decl_stmt|;
name|OOUtil
operator|.
name|insertTextAtCurrentLocation
argument_list|(
name|text
argument_list|,
name|cursor
argument_list|,
operator|(
name|String
operator|)
name|style
operator|.
name|getProperty
argument_list|(
literal|"Title"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|style
operator|.
name|getProperty
argument_list|(
literal|"ReferenceHeaderParagraphFormat"
argument_list|)
argument_list|)
expr_stmt|;
name|insertFullReferenceAtCursor
argument_list|(
name|cursor
argument_list|,
name|entries
argument_list|,
name|style
argument_list|,
operator|(
name|String
operator|)
name|style
operator|.
name|getProperty
argument_list|(
literal|"ReferenceParagraphFormat"
argument_list|)
argument_list|)
expr_stmt|;
name|insertBookMark
argument_list|(
name|OOBibBase
operator|.
name|BIB_SECTION_END_NAME
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
block|}
DECL|method|insertBookMark (String name, XTextCursor position)
specifier|private
name|XTextContent
name|insertBookMark
parameter_list|(
name|String
name|name
parameter_list|,
name|XTextCursor
name|position
parameter_list|)
throws|throws
name|Exception
block|{
name|Object
name|bookmark
init|=
name|mxDocFactory
operator|.
name|createInstance
argument_list|(
literal|"com.sun.star.text.Bookmark"
argument_list|)
decl_stmt|;
comment|// name the bookmark
name|XNamed
name|xNamed
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XNamed
operator|.
name|class
argument_list|,
name|bookmark
argument_list|)
decl_stmt|;
name|xNamed
operator|.
name|setName
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|// get XTextContent interface
name|XTextContent
name|xTextContent
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XTextContent
operator|.
name|class
argument_list|,
name|bookmark
argument_list|)
decl_stmt|;
comment|// insert bookmark at the end of the document
comment|// instead of mxDocText.getEnd you could use a text cursor's XTextRange interface or any XTextRange
name|text
operator|.
name|insertTextContent
argument_list|(
name|position
argument_list|,
name|xTextContent
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|position
operator|.
name|collapseToEnd
argument_list|()
expr_stmt|;
return|return
name|xTextContent
return|;
block|}
DECL|method|insertReferenceMark (String name, String citText, XTextCursor position, boolean withText, OOBibStyle style)
specifier|private
name|void
name|insertReferenceMark
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|citText
parameter_list|,
name|XTextCursor
name|position
parameter_list|,
name|boolean
name|withText
parameter_list|,
name|OOBibStyle
name|style
parameter_list|)
throws|throws
name|Exception
block|{
comment|// Check if there is "page info" stored for this citation. If so, insert it into
comment|// the citation text before inserting the citation:
name|String
name|pageInfo
init|=
name|getCustomProperty
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|pageInfo
operator|!=
literal|null
condition|)
block|{
name|citText
operator|=
name|style
operator|.
name|insertPageInfo
argument_list|(
name|citText
argument_list|,
name|pageInfo
argument_list|)
expr_stmt|;
block|}
name|Object
name|bookmark
init|=
name|mxDocFactory
operator|.
name|createInstance
argument_list|(
literal|"com.sun.star.text.ReferenceMark"
argument_list|)
decl_stmt|;
comment|// Name the reference
name|XNamed
name|xNamed
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XNamed
operator|.
name|class
argument_list|,
name|bookmark
argument_list|)
decl_stmt|;
name|xNamed
operator|.
name|setName
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|withText
condition|)
block|{
name|position
operator|.
name|setString
argument_list|(
name|citText
argument_list|)
expr_stmt|;
name|XPropertySet
name|xCursorProps
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XPropertySet
operator|.
name|class
argument_list|,
name|position
argument_list|)
decl_stmt|;
comment|// Set language to [None]:
name|xCursorProps
operator|.
name|setPropertyValue
argument_list|(
literal|"CharLocale"
argument_list|,
operator|new
name|Locale
argument_list|(
literal|"zxx"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|.
name|isFormatCitations
argument_list|()
condition|)
block|{
name|String
name|charStyle
init|=
name|style
operator|.
name|getCitationCharacterFormat
argument_list|()
decl_stmt|;
try|try
block|{
name|xCursorProps
operator|.
name|setPropertyValue
argument_list|(
literal|"CharStyleName"
argument_list|,
name|charStyle
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownPropertyException
decl||
name|PropertyVetoException
decl||
name|IllegalArgumentException
decl||
name|WrappedTargetException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|UndefinedCharacterFormatException
argument_list|(
name|charStyle
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
name|position
operator|.
name|setString
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|// get XTextContent interface
name|XTextContent
name|xTextContent
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XTextContent
operator|.
name|class
argument_list|,
name|bookmark
argument_list|)
decl_stmt|;
name|position
operator|.
name|getText
argument_list|()
operator|.
name|insertTextContent
argument_list|(
name|position
argument_list|,
name|xTextContent
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Check if we should italicize the "et al." string in citations:
name|boolean
name|italicize
init|=
name|style
operator|.
name|getBooleanCitProperty
argument_list|(
literal|"ItalicEtAl"
argument_list|)
decl_stmt|;
if|if
condition|(
name|italicize
condition|)
block|{
name|String
name|etAlString
init|=
name|style
operator|.
name|getStringCitProperty
argument_list|(
literal|"EtAlString"
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|citText
operator|.
name|indexOf
argument_list|(
name|etAlString
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|italicizeOrBold
argument_list|(
name|position
argument_list|,
literal|true
argument_list|,
name|index
argument_list|,
name|index
operator|+
name|etAlString
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|position
operator|.
name|collapseToEnd
argument_list|()
expr_stmt|;
block|}
DECL|method|italicizeOrBold (XTextCursor position, boolean italicize, int start, int end)
specifier|private
name|void
name|italicizeOrBold
parameter_list|(
name|XTextCursor
name|position
parameter_list|,
name|boolean
name|italicize
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
throws|throws
name|Exception
block|{
name|XTextRange
name|rng
init|=
name|position
operator|.
name|getStart
argument_list|()
decl_stmt|;
name|XTextCursor
name|cursor
init|=
name|position
operator|.
name|getText
argument_list|()
operator|.
name|createTextCursorByRange
argument_list|(
name|rng
argument_list|)
decl_stmt|;
name|cursor
operator|.
name|goRight
argument_list|(
operator|(
name|short
operator|)
name|start
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|goRight
argument_list|(
call|(
name|short
call|)
argument_list|(
name|end
operator|-
name|start
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|XPropertySet
name|xcp
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XPropertySet
operator|.
name|class
argument_list|,
name|cursor
argument_list|)
decl_stmt|;
if|if
condition|(
name|italicize
condition|)
block|{
name|xcp
operator|.
name|setPropertyValue
argument_list|(
literal|"CharPosture"
argument_list|,
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|awt
operator|.
name|FontSlant
operator|.
name|ITALIC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xcp
operator|.
name|setPropertyValue
argument_list|(
literal|"CharWeight"
argument_list|,
name|com
operator|.
name|sun
operator|.
name|star
operator|.
name|awt
operator|.
name|FontWeight
operator|.
name|BOLD
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeReferenceMark (String name)
specifier|private
name|void
name|removeReferenceMark
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|NoSuchElementException
throws|,
name|WrappedTargetException
block|{
name|XReferenceMarksSupplier
name|xSupplier
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XReferenceMarksSupplier
operator|.
name|class
argument_list|,
name|xCurrentComponent
argument_list|)
decl_stmt|;
if|if
condition|(
name|xSupplier
operator|.
name|getReferenceMarks
argument_list|()
operator|.
name|hasByName
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|Object
name|o
init|=
name|xSupplier
operator|.
name|getReferenceMarks
argument_list|()
operator|.
name|getByName
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|XTextContent
name|bm
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XTextContent
operator|.
name|class
argument_list|,
name|o
argument_list|)
decl_stmt|;
name|text
operator|.
name|removeTextContent
argument_list|(
name|bm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Get the XTextRange corresponding to the named bookmark.      * @param name The name of the bookmark to find.      * @return The XTextRange for the bookmark.      * @throws WrappedTargetException      * @throws NoSuchElementException      * @throws Exception      */
DECL|method|getBookmarkRange (String name)
specifier|private
name|XTextRange
name|getBookmarkRange
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|NoSuchElementException
throws|,
name|WrappedTargetException
block|{
comment|// query XBookmarksSupplier from document model and get bookmarks collection
name|XBookmarksSupplier
name|xBookmarksSupplier
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XBookmarksSupplier
operator|.
name|class
argument_list|,
name|xCurrentComponent
argument_list|)
decl_stmt|;
name|XNameAccess
name|xNamedBookmarks
init|=
name|xBookmarksSupplier
operator|.
name|getBookmarks
argument_list|()
decl_stmt|;
comment|// retrieve bookmark by name
comment|//System.out.println("Name="+name+" : "+xNamedBookmarks.hasByName(name));
if|if
condition|(
operator|!
name|xNamedBookmarks
operator|.
name|hasByName
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Object
name|foundBookmark
init|=
name|xNamedBookmarks
operator|.
name|getByName
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|XTextContent
name|xFoundBookmark
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XTextContent
operator|.
name|class
argument_list|,
name|foundBookmark
argument_list|)
decl_stmt|;
return|return
name|xFoundBookmark
operator|.
name|getAnchor
argument_list|()
return|;
block|}
DECL|method|combineCiteMarkers (List<BibDatabase> databases, OOBibStyle style)
specifier|public
name|void
name|combineCiteMarkers
parameter_list|(
name|List
argument_list|<
name|BibDatabase
argument_list|>
name|databases
parameter_list|,
name|OOBibStyle
name|style
parameter_list|)
throws|throws
name|Exception
block|{
name|XReferenceMarksSupplier
name|supplier
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XReferenceMarksSupplier
operator|.
name|class
argument_list|,
name|xCurrentComponent
argument_list|)
decl_stmt|;
name|XNameAccess
name|nameAccess
init|=
name|supplier
operator|.
name|getReferenceMarks
argument_list|()
decl_stmt|;
comment|// TODO: doesn't work for citations in footnotes/tables
name|String
index|[]
name|names
init|=
name|getSortedReferenceMarks
argument_list|(
name|nameAccess
argument_list|)
decl_stmt|;
specifier|final
name|XTextRangeCompare
name|compare
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XTextRangeCompare
operator|.
name|class
argument_list|,
name|text
argument_list|)
decl_stmt|;
name|int
name|piv
init|=
literal|0
decl_stmt|;
name|boolean
name|madeModifications
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|piv
operator|<
operator|(
name|names
operator|.
name|length
operator|-
literal|1
operator|)
condition|)
block|{
name|XTextRange
name|r1
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XTextContent
operator|.
name|class
argument_list|,
name|nameAccess
operator|.
name|getByName
argument_list|(
name|names
index|[
name|piv
index|]
argument_list|)
argument_list|)
operator|.
name|getAnchor
argument_list|()
operator|.
name|getEnd
argument_list|()
decl_stmt|;
name|XTextRange
name|r2
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XTextContent
operator|.
name|class
argument_list|,
name|nameAccess
operator|.
name|getByName
argument_list|(
name|names
index|[
name|piv
operator|+
literal|1
index|]
argument_list|)
argument_list|)
operator|.
name|getAnchor
argument_list|()
operator|.
name|getStart
argument_list|()
decl_stmt|;
if|if
condition|(
name|r1
operator|.
name|getText
argument_list|()
operator|!=
name|r2
operator|.
name|getText
argument_list|()
condition|)
block|{
name|piv
operator|++
expr_stmt|;
continue|continue;
block|}
name|XTextCursor
name|mxDocCursor
init|=
name|r1
operator|.
name|getText
argument_list|()
operator|.
name|createTextCursorByRange
argument_list|(
name|r1
argument_list|)
decl_stmt|;
name|mxDocCursor
operator|.
name|goRight
argument_list|(
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|boolean
name|couldExpand
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|couldExpand
operator|&&
operator|(
name|compare
operator|.
name|compareRegionEnds
argument_list|(
name|mxDocCursor
argument_list|,
name|r2
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|couldExpand
operator|=
name|mxDocCursor
operator|.
name|goRight
argument_list|(
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|String
name|text
init|=
name|mxDocCursor
operator|.
name|getString
argument_list|()
decl_stmt|;
comment|// Check if the string contains no line breaks and only whitespace:
if|if
condition|(
operator|(
name|text
operator|.
name|indexOf
argument_list|(
literal|'\n'
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|&&
name|text
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If we are supposed to set character format for citations, test this before
comment|// making any changes. This way we can throw an exception before any reference
comment|// marks are removed, preventing damage to the user's document:
if|if
condition|(
name|style
operator|.
name|isFormatCitations
argument_list|()
condition|)
block|{
name|XPropertySet
name|xCursorProps
init|=
name|UnoRuntime
operator|.
name|queryInterface
argument_list|(
name|XPropertySet
operator|.
name|class
argument_list|,
name|mxDocCursor
argument_list|)
decl_stmt|;
name|String
name|charStyle
init|=
name|style
operator|.
name|getCitationCharacterFormat
argument_list|()
decl_stmt|;
try|try
block|{
name|xCursorProps
operator|.
name|setPropertyValue
argument_list|(
literal|"CharStyleName"
argument_list|,
name|charStyle
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownPropertyException
decl||
name|PropertyVetoException
decl||
name|IllegalArgumentException
decl||
name|WrappedTargetException
name|ex
parameter_list|)
block|{
comment|// Setting the character format failed, so we throw an exception that
comment|// will result in an error message for the user:
throw|throw
operator|new
name|UndefinedCharacterFormatException
argument_list|(
name|charStyle
argument_list|)
throw|;
block|}
block|}
name|List
argument_list|<
name|String
argument_list|>
name|keys
init|=
name|parseRefMarkName
argument_list|(
name|names
index|[
name|piv
index|]
argument_list|)
decl_stmt|;
name|keys
operator|.
name|addAll
argument_list|(
name|parseRefMarkName
argument_list|(
name|names
index|[
name|piv
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|removeReferenceMark
argument_list|(
name|names
index|[
name|piv
index|]
argument_list|)
expr_stmt|;
name|removeReferenceMark
argument_list|(
name|names
index|[
name|piv
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|BibEntry
argument_list|>
name|entries
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|keys
control|)
block|{
for|for
control|(
name|BibDatabase
name|database
range|:
name|databases
control|)
block|{
name|BibEntry
name|entry
init|=
name|database
operator|.
name|getEntryByKey
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|entries
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|entries
argument_list|,
operator|new
name|FieldComparator
argument_list|(
literal|"year"
argument_list|)
argument_list|)
expr_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BibEntry
name|entry
range|:
name|entries
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getCiteKey
argument_list|()
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|String
name|keyString
init|=
name|sb
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|// Insert bookmark:
name|String
name|bName
init|=
name|getUniqueReferenceMarkName
argument_list|(
name|keyString
argument_list|,
name|OOBibBase
operator|.
name|AUTHORYEAR_PAR
argument_list|)
decl_stmt|;
name|insertReferenceMark
argument_list|(
name|bName
argument_list|,
literal|"tmp"
argument_list|,
name|mxDocCursor
argument_list|,
literal|true
argument_list|,
name|style
argument_list|)
expr_stmt|;
name|names
index|[
name|piv
operator|+
literal|1
index|]
operator|=
name|bName
expr_stmt|;
name|madeModifications
operator|=
literal|true
expr_stmt|;
block|}
name|piv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|madeModifications
condition|)
block|{
name|updateSortedReferenceMarks
argument_list|()
expr_stmt|;
name|refreshCiteMarkers
argument_list|(
name|databases
argument_list|,
name|style
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

