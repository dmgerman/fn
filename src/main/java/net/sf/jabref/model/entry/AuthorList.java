begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003-2015 JabRef contributors.     This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License along     with this program; if not, write to the Free Software Foundation, Inc.,     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */
end_comment

begin_package
DECL|package|net.sf.jabref.model.entry
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|WeakHashMap
import|;
end_import

begin_comment
comment|/**  * This is an immutable class representing information of either<CODE>author</CODE>  * or<CODE>editor</CODE> field in bibtex record.  *<p>  * Constructor performs parsing of raw field text and stores preformatted data.  * Various accessor methods return author/editor field in different formats.  *<p>  * Parsing algorithm is designed to satisfy two requirements: (a) when author's  * name is typed correctly, the result should coincide with the one of BiBTeX;  * (b) for erroneous names, output should be reasonable (but may differ from  * BiBTeX output). The following rules are used:  *<ol>  *<li> 'author field' is a sequence of tokens;  *<ul>  *<li> tokens are separated by sequences of whitespaces (<CODE>Character.isWhitespace(c)==true</CODE>),  * commas (,), dashes (-), and tildas (~);  *<li> every comma separates tokens, while sequences of other separators are  * equivalent to a single separator; for example: "a - b" consists of 2 tokens  * ("a" and "b"), while "a,-,b" consists of 3 tokens ("a", "", and "b")  *<li> anything enclosed in braces belonges to a single token; for example:  * "abc x{a,b,-~ c}x" consists of 2 tokens, while "abc xa,b,-~ cx" consists of 4  * tokens ("abc", "xa","b", and "cx");  *<li> a token followed immediately by a dash is "dash-terminated" token, and  * all other tokens are "space-terminated" tokens; for example: in "a-b- c - d"  * tokens "a" and "b" are dash-terminated and "c" and "d" are space-terminated;  *<li> for the purposes of splitting of 'author name' into parts and  * construction of abbreviation of first name, one needs definitions of first  * latter of a token, case of a token, and abbreviation of a token:  *<ul>  *<li> 'first letter' of a token is the first letter character (<CODE>Character.isLetter(c)==true</CODE>)  * that does not belong to a sequence of letters that immediately follows "\"  * character, with one exception: if "\" is followed by "aa", "AA", "ae", "AE",  * "l", "L", "o", "O", "oe", "OE", "i", or "j" followed by non-letter, the  * 'first letter' of a token is a letter that follows "\"; for example: in  * "a{x}b" 'first letter' is "a", in "{\"{U}}bel" 'first letter' is "U", in  * "{\noopsort{\"o}}xyz" 'first letter' is "o", in "{\AE}x" 'first letter' is  * "A", in "\aex\ijk\Oe\j" 'first letter' is "j"; if there is no letter  * satisfying the above rule, 'first letter' is undefined;  *<li> token is "lower-case" token, if its first letter id defined and is  * lower-case (<CODE>Character.isLowerCase(c)==true</CODE>), and token is  * "upper-case" token otherwise;  *<li> 'abbreviation' of a token is the shortest prefix of the token that (a)  * contains 'first letter' and (b) is braces-balanced; if 'first letter' is  * undefined, 'abbreviation' is the token itself; in the above examples,  * 'abbreviation's are "a", "{\"{U}}", "{\noopsort{\"o}}", "{\AE}",  * "\aex\ijk\Oe\j";  *</ul>  *<li> the behavior based on the above definitions will be erroneous only in  * one case: if the first-name-token is "{\noopsort{A}}john", we abbreviate it  * as "{\noopsort{A}}.", while BiBTeX produces "j."; fixing this problem,  * however, requires processing of the preabmle;  *</ul>  *<li> 'author name's in 'author field' are subsequences of tokens separated by  * token "and" ("and" is case-insensitive); if 'author name' is an empty  * sequence of tokens, it is ignored; for examle, both "John Smith and Peter  * Black" and "and and John Smith and and Peter Black" consists of 2 'author  * name's "Johm Smith" and "Peter Black" (in erroneous situations, this is a bit  * different from BiBTeX behavior);  *<li> 'author name' consists of 'first-part', 'von-part', 'last-part', and  * 'junior-part', each of which is a sequence of tokens; how a sequence of  * tokens has to be splitted into these parts, depends the number of commas:  *<ul>  *<li> no commas, all tokens are upper-case: 'junior-part' and 'von-part' are  * empty, 'last-part' consist of the last token, 'first-part' consists of all  * other tokens ('first-part' is empty, if 'author name' consists of a single  * token); for example, in "John James Smith", 'last-part'="Smith" and  * 'first-part'="John James";  *<li> no commas, there exists lower-case token: 'junior-part' is empty,  * 'first-part' consists of all upper-case tokens before the first lower-case  * token, 'von-part' consists of lower-case tokens starting the first lower-case  * token and ending the lower-case token that is followed by upper-case token,  * 'last-part' consists of the rest of tokens; note that both 'first-part' and  * 'latst-part' may be empty and 'last-part' may contain lower-case tokens; for  * example: in "von der", 'first-part'='last-part'="", 'von-part'="von der"; in  * "Charles Louis Xavier Joseph de la Vall{\'e}e la Poussin",  * 'first-part'="Charles Louis Xavier Joseph", 'von-part'="de la",  * 'last-part'="Vall{\'e}e la Poussin";  *<li> one comma: 'junior-part' is empty, 'first-part' consists of all tokens  * after comma, 'von-part' consists of the longest sequence of lower-case tokens  * in the very beginning, 'last-part' consists of all tokens after 'von-part'  * and before comma; note that any part can be empty; for example: in "de la  * Vall{\'e}e la Poussin, Charles Louis Xavier Joseph", 'first-part'="Charles  * Louis Xavier Joseph", 'von-part'="de la", 'last-part'="Vall{\'e}e la  * Poussin"; in "Joseph de la Vall{\'e}e la Poussin, Charles Louis Xavier",  * 'first-part'="Charles Louis Xavier", 'von-part'="", 'last-part'="Joseph de la  * Vall{\'e}e la Poussin";  *<li> two or more commas (any comma after the second one is ignored; it merely  * separates tokens): 'junior-part' consists of all tokens between first and  * second commas, 'first-part' consists of all tokens after the second comma,  * tokens before the first comma are splitted into 'von-part' and 'last-part'  * similarly to the case of one comma; for example: in "de la Vall{\'e}e  * Poussin, Jr., Charles Louis Xavier Joseph", 'first-part'="Charles Louis  * Xavier Joseph", 'von-part'="de la", 'last-part'="Vall{\'e}e la Poussin", and  * 'junior-part'="Jr.";  *</ul>  *<li> when 'first-part', 'last-part', 'von-part', or 'junior-part' is  * reconstructed from tokens, tokens in a part are separated either by space or  * by dash, depending on whether the token before the separator was  * space-terminated or dash-terminated; for the last token in a part it does not  * matter whether it was dash- or space-terminated;  *<li> when 'first-part' is abbreviated, each token is replaced by its  * abbreviation followed by a period; separators are the same as in the case of  * non-abbreviated name; for example: in "Heinrich-{\"{U}}bel Kurt von Minich",  * 'first-part'="Heinrich-{\"{U}}bel Kurt", and its abbreviation is "H.-{\"{U}}.  * K."  *</ol>  */
end_comment

begin_class
DECL|class|AuthorList
specifier|public
class|class
name|AuthorList
block|{
DECL|field|authors
specifier|private
specifier|final
name|Vector
argument_list|<
name|Author
argument_list|>
name|authors
decl_stmt|;
comment|// Variables for storing computed strings, so they only need be created
comment|// once:
DECL|field|authorsNatbib
specifier|private
name|String
name|authorsNatbib
decl_stmt|;
DECL|field|authorsFirstFirstAnds
specifier|private
name|String
name|authorsFirstFirstAnds
decl_stmt|;
DECL|field|authorsAlph
specifier|private
name|String
name|authorsAlph
decl_stmt|;
DECL|field|authorsFirstFirst
specifier|private
specifier|final
name|String
index|[]
name|authorsFirstFirst
init|=
operator|new
name|String
index|[
literal|4
index|]
decl_stmt|;
DECL|field|authorsLastOnly
specifier|private
specifier|final
name|String
index|[]
name|authorsLastOnly
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
DECL|field|authorLastFirstAnds
specifier|private
specifier|final
name|String
index|[]
name|authorLastFirstAnds
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
DECL|field|authorsLastFirst
specifier|private
specifier|final
name|String
index|[]
name|authorsLastFirst
init|=
operator|new
name|String
index|[
literal|4
index|]
decl_stmt|;
DECL|field|authorsLastFirstFirstLast
specifier|private
specifier|final
name|String
index|[]
name|authorsLastFirstFirstLast
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
comment|// The following variables are used only during parsing
DECL|field|original
specifier|private
name|String
name|original
decl_stmt|;
comment|// the raw bibtex author/editor field
comment|// the following variables are updated by getToken procedure
DECL|field|tokenStart
specifier|private
name|int
name|tokenStart
decl_stmt|;
comment|// index in orig
DECL|field|tokenEnd
specifier|private
name|int
name|tokenEnd
decl_stmt|;
comment|// to point 'abc' in ' abc xyz', start=2 and end=5
comment|// the following variables are valid only if getToken returns TOKEN_WORD
DECL|field|tokenAbbr
specifier|private
name|int
name|tokenAbbr
decl_stmt|;
comment|// end of token abbreviation (always: token_start<
comment|// token_abbr<= token_end)
DECL|field|tokenTerm
specifier|private
name|char
name|tokenTerm
decl_stmt|;
comment|// either space or dash
DECL|field|tokenCase
specifier|private
name|boolean
name|tokenCase
decl_stmt|;
comment|// true if upper-case token, false if lower-case
comment|// token
comment|// Tokens of one author name.
comment|// Each token occupies TGL consecutive entries in this vector (as described
comment|// below)
DECL|field|tokens
specifier|private
name|Vector
argument_list|<
name|Object
argument_list|>
name|tokens
decl_stmt|;
DECL|field|TOKEN_GROUP_LENGTH
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_GROUP_LENGTH
init|=
literal|4
decl_stmt|;
comment|// number of entries for
comment|// a token
comment|// the following are offsets of an entry in a group of entries for one token
DECL|field|OFFSET_TOKEN
specifier|private
specifier|static
specifier|final
name|int
name|OFFSET_TOKEN
init|=
literal|0
decl_stmt|;
comment|// String -- token itself;
DECL|field|OFFSET_TOKEN_ABBR
specifier|private
specifier|static
specifier|final
name|int
name|OFFSET_TOKEN_ABBR
init|=
literal|1
decl_stmt|;
comment|// String -- token
comment|// abbreviation;
DECL|field|OFFSET_TOKEN_TERM
specifier|private
specifier|static
specifier|final
name|int
name|OFFSET_TOKEN_TERM
init|=
literal|2
decl_stmt|;
comment|// Character -- token
comment|// terminator (either " " or
comment|// "-")
comment|// comma)
comment|// Token types (returned by getToken procedure)
DECL|field|TOKEN_EOF
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_EOF
init|=
literal|0
decl_stmt|;
DECL|field|TOKEN_AND
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_AND
init|=
literal|1
decl_stmt|;
DECL|field|TOKEN_COMMA
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_COMMA
init|=
literal|2
decl_stmt|;
DECL|field|TOKEN_WORD
specifier|private
specifier|static
specifier|final
name|int
name|TOKEN_WORD
init|=
literal|3
decl_stmt|;
comment|// Constant Hashtable containing names of TeX special characters
DECL|field|TEX_NAMES
specifier|private
specifier|static
specifier|final
name|HashSet
argument_list|<
name|String
argument_list|>
name|TEX_NAMES
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// and static constructor to initialize it
static|static
block|{
name|TEX_NAMES
operator|.
name|add
argument_list|(
literal|"aa"
argument_list|)
expr_stmt|;
name|TEX_NAMES
operator|.
name|add
argument_list|(
literal|"ae"
argument_list|)
expr_stmt|;
name|TEX_NAMES
operator|.
name|add
argument_list|(
literal|"l"
argument_list|)
expr_stmt|;
name|TEX_NAMES
operator|.
name|add
argument_list|(
literal|"o"
argument_list|)
expr_stmt|;
name|TEX_NAMES
operator|.
name|add
argument_list|(
literal|"oe"
argument_list|)
expr_stmt|;
name|TEX_NAMES
operator|.
name|add
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
name|TEX_NAMES
operator|.
name|add
argument_list|(
literal|"AA"
argument_list|)
expr_stmt|;
name|TEX_NAMES
operator|.
name|add
argument_list|(
literal|"AE"
argument_list|)
expr_stmt|;
name|TEX_NAMES
operator|.
name|add
argument_list|(
literal|"L"
argument_list|)
expr_stmt|;
name|TEX_NAMES
operator|.
name|add
argument_list|(
literal|"O"
argument_list|)
expr_stmt|;
name|TEX_NAMES
operator|.
name|add
argument_list|(
literal|"OE"
argument_list|)
expr_stmt|;
name|TEX_NAMES
operator|.
name|add
argument_list|(
literal|"j"
argument_list|)
expr_stmt|;
block|}
DECL|field|AUTHOR_CACHE
specifier|private
specifier|static
specifier|final
name|WeakHashMap
argument_list|<
name|String
argument_list|,
name|AuthorList
argument_list|>
name|AUTHOR_CACHE
init|=
operator|new
name|WeakHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * Parses the parameter strings and stores preformatted author information.      *<p>      * Don't call this constructor directly but rather use the getAuthorList()      * method which caches its results.      *      * @param bibtexAuthors contents of either<CODE>author</CODE> or<CODE>editor</CODE>      *                      bibtex field.      */
DECL|method|AuthorList (String bibtexAuthors)
specifier|private
name|AuthorList
parameter_list|(
name|String
name|bibtexAuthors
parameter_list|)
block|{
name|authors
operator|=
operator|new
name|Vector
argument_list|<>
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|// 5 seems to be reasonable initial size
name|original
operator|=
name|bibtexAuthors
expr_stmt|;
comment|// initialization
name|tokenStart
operator|=
literal|0
expr_stmt|;
name|tokenEnd
operator|=
literal|0
expr_stmt|;
comment|// of parser
while|while
condition|(
name|tokenStart
operator|<
name|original
operator|.
name|length
argument_list|()
condition|)
block|{
name|Author
name|author
init|=
name|getAuthor
argument_list|()
decl_stmt|;
if|if
condition|(
name|author
operator|!=
literal|null
condition|)
block|{
name|authors
operator|.
name|add
argument_list|(
name|author
argument_list|)
expr_stmt|;
block|}
block|}
comment|// clean-up
name|original
operator|=
literal|null
expr_stmt|;
name|tokens
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * Retrieve an AuthorList for the given string of authors or editors.      *<p>      * This function tries to cache AuthorLists by string passed in.      *      * @param authors The string of authors or editors in bibtex format to parse.      * @return An AuthorList object representing the given authors.      */
DECL|method|getAuthorList (String authors)
specifier|public
specifier|static
name|AuthorList
name|getAuthorList
parameter_list|(
name|String
name|authors
parameter_list|)
block|{
name|AuthorList
name|authorList
init|=
name|AUTHOR_CACHE
operator|.
name|get
argument_list|(
name|authors
argument_list|)
decl_stmt|;
if|if
condition|(
name|authorList
operator|==
literal|null
condition|)
block|{
name|authorList
operator|=
operator|new
name|AuthorList
argument_list|(
name|authors
argument_list|)
expr_stmt|;
name|AUTHOR_CACHE
operator|.
name|put
argument_list|(
name|authors
argument_list|,
name|authorList
argument_list|)
expr_stmt|;
block|}
return|return
name|authorList
return|;
block|}
comment|/**      * This is a convenience method for getAuthorsFirstFirst()      *      * @see AuthorList#getAuthorsFirstFirst      */
DECL|method|fixAuthor_firstNameFirstCommas (String authors, boolean abbr, boolean oxfordComma)
specifier|public
specifier|static
name|String
name|fixAuthor_firstNameFirstCommas
parameter_list|(
name|String
name|authors
parameter_list|,
name|boolean
name|abbr
parameter_list|,
name|boolean
name|oxfordComma
parameter_list|)
block|{
return|return
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|authors
argument_list|)
operator|.
name|getAuthorsFirstFirst
argument_list|(
name|abbr
argument_list|,
name|oxfordComma
argument_list|)
return|;
block|}
comment|/**      * This is a convenience method for getAuthorsFirstFirstAnds()      *      * @see AuthorList#getAuthorsFirstFirstAnds      */
DECL|method|fixAuthor_firstNameFirst (String authors)
specifier|public
specifier|static
name|String
name|fixAuthor_firstNameFirst
parameter_list|(
name|String
name|authors
parameter_list|)
block|{
return|return
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|authors
argument_list|)
operator|.
name|getAuthorsFirstFirstAnds
argument_list|()
return|;
block|}
comment|/**      * This is a convenience method for getAuthorsLastFirst()      *      * @see AuthorList#getAuthorsLastFirst      */
DECL|method|fixAuthor_lastNameFirstCommas (String authors, boolean abbr, boolean oxfordComma)
specifier|public
specifier|static
name|String
name|fixAuthor_lastNameFirstCommas
parameter_list|(
name|String
name|authors
parameter_list|,
name|boolean
name|abbr
parameter_list|,
name|boolean
name|oxfordComma
parameter_list|)
block|{
return|return
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|authors
argument_list|)
operator|.
name|getAuthorsLastFirst
argument_list|(
name|abbr
argument_list|,
name|oxfordComma
argument_list|)
return|;
block|}
comment|/**      * This is a convenience method for getAuthorsLastFirstAnds(true)      *      * @see AuthorList#getAuthorsLastFirstAnds      */
DECL|method|fixAuthor_lastNameFirst (String authors)
specifier|public
specifier|static
name|String
name|fixAuthor_lastNameFirst
parameter_list|(
name|String
name|authors
parameter_list|)
block|{
return|return
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|authors
argument_list|)
operator|.
name|getAuthorsLastFirstAnds
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|/**      * This is a convenience method for getAuthorsLastFirstAnds()      *      * @see AuthorList#getAuthorsLastFirstAnds      */
DECL|method|fixAuthor_lastNameFirst (String authors, boolean abbreviate)
specifier|public
specifier|static
name|String
name|fixAuthor_lastNameFirst
parameter_list|(
name|String
name|authors
parameter_list|,
name|boolean
name|abbreviate
parameter_list|)
block|{
return|return
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|authors
argument_list|)
operator|.
name|getAuthorsLastFirstAnds
argument_list|(
name|abbreviate
argument_list|)
return|;
block|}
comment|/**      * This is a convenience method for getAuthorsLastOnly()      *      * @see AuthorList#getAuthorsLastOnly      */
DECL|method|fixAuthor_lastNameOnlyCommas (String authors, boolean oxfordComma)
specifier|public
specifier|static
name|String
name|fixAuthor_lastNameOnlyCommas
parameter_list|(
name|String
name|authors
parameter_list|,
name|boolean
name|oxfordComma
parameter_list|)
block|{
return|return
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|authors
argument_list|)
operator|.
name|getAuthorsLastOnly
argument_list|(
name|oxfordComma
argument_list|)
return|;
block|}
comment|/**      * This is a convenience method for getAuthorsForAlphabetization()      *      * @see AuthorList#getAuthorsForAlphabetization      */
DECL|method|fixAuthorForAlphabetization (String authors)
specifier|public
specifier|static
name|String
name|fixAuthorForAlphabetization
parameter_list|(
name|String
name|authors
parameter_list|)
block|{
return|return
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|authors
argument_list|)
operator|.
name|getAuthorsForAlphabetization
argument_list|()
return|;
block|}
comment|/**      * This is a convenience method for getAuthorsNatbib()      *      * @see AuthorList#getAuthorsNatbib      */
DECL|method|fixAuthor_Natbib (String authors)
specifier|public
specifier|static
name|String
name|fixAuthor_Natbib
parameter_list|(
name|String
name|authors
parameter_list|)
block|{
return|return
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|authors
argument_list|)
operator|.
name|getAuthorsNatbib
argument_list|()
return|;
block|}
comment|/**      * Parses one author name and returns preformatted information.      *      * @return Preformatted author name;<CODE>null</CODE> if author name is      * empty.      */
DECL|method|getAuthor ()
specifier|private
name|Author
name|getAuthor
parameter_list|()
block|{
name|tokens
operator|=
operator|new
name|Vector
argument_list|<>
argument_list|()
expr_stmt|;
comment|// initialization
name|int
name|von_start
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|last_start
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|comma_first
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|comma_second
init|=
operator|-
literal|1
decl_stmt|;
comment|// First step: collect tokens in 'tokens' Vector and calculate indices
name|token_loop
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|token
init|=
name|getToken
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|TOKEN_EOF
case|:
case|case
name|TOKEN_AND
case|:
break|break
name|token_loop
break|;
case|case
name|TOKEN_COMMA
case|:
if|if
condition|(
name|comma_first
operator|<
literal|0
condition|)
block|{
name|comma_first
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comma_second
operator|<
literal|0
condition|)
block|{
name|comma_second
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|TOKEN_WORD
case|:
name|tokens
operator|.
name|add
argument_list|(
name|original
operator|.
name|substring
argument_list|(
name|tokenStart
argument_list|,
name|tokenEnd
argument_list|)
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|original
operator|.
name|substring
argument_list|(
name|tokenStart
argument_list|,
name|tokenAbbr
argument_list|)
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|tokenTerm
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|tokenCase
argument_list|)
expr_stmt|;
if|if
condition|(
name|comma_first
operator|>=
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|last_start
operator|>=
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|von_start
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|tokenCase
condition|)
block|{
name|von_start
operator|=
name|tokens
operator|.
name|size
argument_list|()
operator|-
name|AuthorList
operator|.
name|TOKEN_GROUP_LENGTH
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|last_start
operator|<
literal|0
operator|)
operator|&&
name|tokenCase
condition|)
block|{
name|last_start
operator|=
name|tokens
operator|.
name|size
argument_list|()
operator|-
name|AuthorList
operator|.
name|TOKEN_GROUP_LENGTH
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// Second step: split name into parts (here: calculate indices
comment|// of parts in 'tokens' Vector)
if|if
condition|(
name|tokens
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
comment|// no author information
block|}
comment|// the following negatives indicate absence of the corresponding part
name|int
name|first_part_start
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|von_part_start
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|last_part_start
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|jr_part_start
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|first_part_end
decl_stmt|;
name|int
name|von_part_end
init|=
literal|0
decl_stmt|;
name|int
name|last_part_end
init|=
literal|0
decl_stmt|;
name|int
name|jr_part_end
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|comma_first
operator|<
literal|0
condition|)
block|{
comment|// no commas
if|if
condition|(
name|von_start
operator|<
literal|0
condition|)
block|{
comment|// no 'von part'
name|last_part_end
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
name|last_part_start
operator|=
name|tokens
operator|.
name|size
argument_list|()
operator|-
name|AuthorList
operator|.
name|TOKEN_GROUP_LENGTH
expr_stmt|;
name|int
name|index
init|=
operator|(
name|tokens
operator|.
name|size
argument_list|()
operator|-
operator|(
literal|2
operator|*
name|AuthorList
operator|.
name|TOKEN_GROUP_LENGTH
operator|)
operator|)
operator|+
name|AuthorList
operator|.
name|OFFSET_TOKEN_TERM
decl_stmt|;
if|if
condition|(
name|index
operator|>
literal|0
condition|)
block|{
name|Character
name|ch
init|=
operator|(
name|Character
operator|)
name|tokens
operator|.
name|elementAt
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'-'
condition|)
block|{
name|last_part_start
operator|-=
name|AuthorList
operator|.
name|TOKEN_GROUP_LENGTH
expr_stmt|;
block|}
block|}
name|first_part_end
operator|=
name|last_part_start
expr_stmt|;
if|if
condition|(
name|first_part_end
operator|>
literal|0
condition|)
block|{
name|first_part_start
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// 'von part' is present
if|if
condition|(
name|last_start
operator|>=
literal|0
condition|)
block|{
name|last_part_end
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
name|last_part_start
operator|=
name|last_start
expr_stmt|;
name|von_part_end
operator|=
name|last_part_start
expr_stmt|;
block|}
else|else
block|{
name|von_part_end
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|von_part_start
operator|=
name|von_start
expr_stmt|;
name|first_part_end
operator|=
name|von_part_start
expr_stmt|;
if|if
condition|(
name|first_part_end
operator|>
literal|0
condition|)
block|{
name|first_part_start
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// commas are present: it affects only 'first part' and
comment|// 'junior part'
name|first_part_end
operator|=
name|tokens
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|comma_second
operator|<
literal|0
condition|)
block|{
comment|// one comma
if|if
condition|(
name|comma_first
operator|<
name|first_part_end
condition|)
block|{
name|first_part_start
operator|=
name|comma_first
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// two or more commas
if|if
condition|(
name|comma_second
operator|<
name|first_part_end
condition|)
block|{
name|first_part_start
operator|=
name|comma_second
expr_stmt|;
block|}
name|jr_part_end
operator|=
name|comma_second
expr_stmt|;
if|if
condition|(
name|comma_first
operator|<
name|jr_part_end
condition|)
block|{
name|jr_part_start
operator|=
name|comma_first
expr_stmt|;
block|}
block|}
if|if
condition|(
name|von_start
operator|!=
literal|0
condition|)
block|{
comment|// no 'von part'
name|last_part_end
operator|=
name|comma_first
expr_stmt|;
if|if
condition|(
name|last_part_end
operator|>
literal|0
condition|)
block|{
name|last_part_start
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// 'von part' is present
if|if
condition|(
name|last_start
operator|<
literal|0
condition|)
block|{
name|von_part_end
operator|=
name|comma_first
expr_stmt|;
block|}
else|else
block|{
name|last_part_end
operator|=
name|comma_first
expr_stmt|;
name|last_part_start
operator|=
name|last_start
expr_stmt|;
name|von_part_end
operator|=
name|last_part_start
expr_stmt|;
block|}
name|von_part_start
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|first_part_start
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|last_part_start
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|von_part_start
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
comment|// There is no first or last name, but we have a von part. This is likely
comment|// to indicate a single-entry name without an initial capital letter, such
comment|// as "unknown".
comment|// We make the von part the last name, to facilitate handling by last-name formatters:
name|last_part_start
operator|=
name|von_part_start
expr_stmt|;
name|last_part_end
operator|=
name|von_part_end
expr_stmt|;
name|von_part_start
operator|=
operator|-
literal|1
expr_stmt|;
name|von_part_end
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|// Third step: do actual splitting, construct Author object
return|return
operator|new
name|Author
argument_list|(
name|first_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|first_part_start
argument_list|,
name|first_part_end
argument_list|,
name|AuthorList
operator|.
name|OFFSET_TOKEN
argument_list|,
literal|false
argument_list|)
argument_list|,
name|first_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|first_part_start
argument_list|,
name|first_part_end
argument_list|,
name|AuthorList
operator|.
name|OFFSET_TOKEN_ABBR
argument_list|,
literal|true
argument_list|)
argument_list|,
name|von_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|von_part_start
argument_list|,
name|von_part_end
argument_list|,
name|AuthorList
operator|.
name|OFFSET_TOKEN
argument_list|,
literal|false
argument_list|)
argument_list|,
name|last_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|last_part_start
argument_list|,
name|last_part_end
argument_list|,
name|AuthorList
operator|.
name|OFFSET_TOKEN
argument_list|,
literal|false
argument_list|)
argument_list|,
name|jr_part_start
operator|<
literal|0
condition|?
literal|null
else|:
name|concatTokens
argument_list|(
name|jr_part_start
argument_list|,
name|jr_part_end
argument_list|,
name|AuthorList
operator|.
name|OFFSET_TOKEN
argument_list|,
literal|false
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Concatenates list of tokens from 'tokens' Vector. Tokens are separated by      * spaces or dashes, dependeing on stored in 'tokens'. Callers always ensure      * that start< end; thus, there exists at least one token to be      * concatenated.      *      * @param start     index of the first token to be concatenated in 'tokens' Vector      *                  (always divisible by TOKEN_GROUP_LENGTH).      * @param end       index of the first token not to be concatenated in 'tokens'      *                  Vector (always divisible by TOKEN_GROUP_LENGTH).      * @param offset    offset within token group (used to request concatenation of      *                  either full tokens or abbreviation).      * @param dotAfter<CODE>true</CODE> -- add period after each token,<CODE>false</CODE> --      *                  do not add.      * @return the result of concatenation.      */
DECL|method|concatTokens (int start, int end, int offset, boolean dotAfter)
specifier|private
name|String
name|concatTokens
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|offset
parameter_list|,
name|boolean
name|dotAfter
parameter_list|)
block|{
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// Here we always have start< end
name|result
operator|.
name|append
argument_list|(
operator|(
name|String
operator|)
name|tokens
operator|.
name|get
argument_list|(
name|start
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dotAfter
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|start
operator|+=
name|AuthorList
operator|.
name|TOKEN_GROUP_LENGTH
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|tokens
operator|.
name|get
argument_list|(
operator|(
name|start
operator|-
name|AuthorList
operator|.
name|TOKEN_GROUP_LENGTH
operator|)
operator|+
name|AuthorList
operator|.
name|OFFSET_TOKEN_TERM
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
operator|(
name|String
operator|)
name|tokens
operator|.
name|get
argument_list|(
name|start
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dotAfter
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|start
operator|+=
name|AuthorList
operator|.
name|TOKEN_GROUP_LENGTH
expr_stmt|;
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Parses the next token.      *<p>      * The string being parsed is stored in global variable<CODE>orig</CODE>,      * and position which parsing has to start from is stored in global variable      *<CODE>token_end</CODE>; thus,<CODE>token_end</CODE> has to be set      * to 0 before the first invocation. Procedure updates<CODE>token_end</CODE>;      * thus, subsequent invocations do not require any additional variable      * settings.      *<p>      * The type of the token is returned; if it is<CODE>TOKEN_WORD</CODE>,      * additional information is given in global variables<CODE>token_start</CODE>,      *<CODE>token_end</CODE>,<CODE>token_abbr</CODE>,<CODE>token_term</CODE>,      * and<CODE>token_case</CODE>; namely:<CODE>orig.substring(token_start,token_end)</CODE>      * is the thext of the token,<CODE>orig.substring(token_start,token_abbr)</CODE>      * is the token abbreviation,<CODE>token_term</CODE> contains token      * terminator (space or dash), and<CODE>token_case</CODE> is<CODE>true</CODE>,      * if token is upper-case and<CODE>false</CODE> if token is lower-case.      *      * @return<CODE>TOKEN_EOF</CODE> -- no more tokens,<CODE>TOKEN_COMMA</CODE> --      * token is comma,<CODE>TOKEN_AND</CODE> -- token is the word      * "and" (or "And", or "aND", etc.),<CODE>TOKEN_WORD</CODE> --      * token is a word; additional information is given in global      * variables<CODE>token_start</CODE>,<CODE>token_end</CODE>,      *<CODE>token_abbr</CODE>,<CODE>token_term</CODE>, and      *<CODE>token_case</CODE>.      */
DECL|method|getToken ()
specifier|private
name|int
name|getToken
parameter_list|()
block|{
name|tokenStart
operator|=
name|tokenEnd
expr_stmt|;
while|while
condition|(
name|tokenStart
operator|<
name|original
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|original
operator|.
name|charAt
argument_list|(
name|tokenStart
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|c
operator|==
literal|'~'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'-'
operator|)
operator|||
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
name|tokenStart
operator|++
expr_stmt|;
block|}
name|tokenEnd
operator|=
name|tokenStart
expr_stmt|;
if|if
condition|(
name|tokenStart
operator|>=
name|original
operator|.
name|length
argument_list|()
condition|)
block|{
return|return
name|AuthorList
operator|.
name|TOKEN_EOF
return|;
block|}
if|if
condition|(
name|original
operator|.
name|charAt
argument_list|(
name|tokenStart
argument_list|)
operator|==
literal|','
condition|)
block|{
name|tokenEnd
operator|++
expr_stmt|;
return|return
name|AuthorList
operator|.
name|TOKEN_COMMA
return|;
block|}
name|tokenAbbr
operator|=
operator|-
literal|1
expr_stmt|;
name|tokenTerm
operator|=
literal|' '
expr_stmt|;
name|tokenCase
operator|=
literal|true
expr_stmt|;
name|int
name|braces_level
init|=
literal|0
decl_stmt|;
name|int
name|current_backslash
init|=
operator|-
literal|1
decl_stmt|;
name|boolean
name|first_letter_is_found
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|tokenEnd
operator|<
name|original
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|original
operator|.
name|charAt
argument_list|(
name|tokenEnd
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
name|braces_level
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|braces_level
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
block|{
name|braces_level
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first_letter_is_found
operator|&&
operator|(
name|tokenAbbr
operator|<
literal|0
operator|)
operator|&&
operator|(
name|braces_level
operator|==
literal|0
operator|)
condition|)
block|{
name|tokenAbbr
operator|=
name|tokenEnd
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first_letter_is_found
operator|&&
operator|(
name|current_backslash
operator|<
literal|0
operator|)
operator|&&
name|Character
operator|.
name|isLetter
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|braces_level
operator|==
literal|0
condition|)
block|{
name|tokenCase
operator|=
name|Character
operator|.
name|isUpperCase
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If this is a particle in braces, always treat it as if it starts with
comment|// an upper case letter. Otherwise a name such as "{van den Bergen}, Hans"
comment|// will not yield a proper last name:
name|tokenCase
operator|=
literal|true
expr_stmt|;
block|}
name|first_letter_is_found
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|current_backslash
operator|>=
literal|0
operator|)
operator|&&
operator|!
name|Character
operator|.
name|isLetter
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first_letter_is_found
condition|)
block|{
name|String
name|tex_cmd_name
init|=
name|original
operator|.
name|substring
argument_list|(
name|current_backslash
operator|+
literal|1
argument_list|,
name|tokenEnd
argument_list|)
decl_stmt|;
if|if
condition|(
name|AuthorList
operator|.
name|TEX_NAMES
operator|.
name|contains
argument_list|(
name|tex_cmd_name
argument_list|)
condition|)
block|{
name|tokenCase
operator|=
name|Character
operator|.
name|isUpperCase
argument_list|(
name|tex_cmd_name
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|first_letter_is_found
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|current_backslash
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|current_backslash
operator|=
name|tokenEnd
expr_stmt|;
block|}
if|if
condition|(
name|braces_level
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
literal|','
operator|)
operator|||
operator|(
name|c
operator|==
literal|'~'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'-'
operator|)
operator|||
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
comment|// Morten Alver 18 Apr 2006: Removed check for hyphen '-' above to
comment|// prevent
comment|// problems with names like Bailey-Jones getting broken up and
comment|// sorted wrong.
comment|// Aaron Chen 14 Sep 2008: Enable hyphen check for first names like Chang-Chin
name|tokenEnd
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tokenAbbr
operator|<
literal|0
condition|)
block|{
name|tokenAbbr
operator|=
name|tokenEnd
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tokenEnd
operator|<
name|original
operator|.
name|length
argument_list|()
operator|)
operator|&&
operator|(
name|original
operator|.
name|charAt
argument_list|(
name|tokenEnd
argument_list|)
operator|==
literal|'-'
operator|)
condition|)
block|{
name|tokenTerm
operator|=
literal|'-'
expr_stmt|;
block|}
if|if
condition|(
literal|"and"
operator|.
name|equalsIgnoreCase
argument_list|(
name|original
operator|.
name|substring
argument_list|(
name|tokenStart
argument_list|,
name|tokenEnd
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|AuthorList
operator|.
name|TOKEN_AND
return|;
block|}
else|else
block|{
return|return
name|AuthorList
operator|.
name|TOKEN_WORD
return|;
block|}
block|}
comment|/**      * Returns the number of author names in this object.      *      * @return the number of author names in this object.      */
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|authors
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Returns the<CODE>Author</CODE> object for the i-th author.      *      * @param i Index of the author (from 0 to<CODE>size()-1</CODE>).      * @return the<CODE>Author</CODE> object.      */
DECL|method|getAuthor (int i)
specifier|public
name|Author
name|getAuthor
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|authors
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/**      * Returns the list of authors in "natbib" format.      *<p>      *<ul>      *<li>"John Smith" -> "Smith"</li>      *<li>"John Smith and Black Brown, Peter" ==> "Smith and Black Brown"</li>      *<li>"John von Neumann and John Smith and Black Brown, Peter" ==> "von      * Neumann et al."</li>      *</ul>      *      * @return formatted list of authors.      */
DECL|method|getAuthorsNatbib ()
specifier|public
name|String
name|getAuthorsNatbib
parameter_list|()
block|{
comment|// Check if we've computed this before:
if|if
condition|(
name|authorsNatbib
operator|!=
literal|null
condition|)
block|{
return|return
name|authorsNatbib
return|;
block|}
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getLastOnly
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|1
argument_list|)
operator|.
name|getLastOnly
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|" et al."
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsNatbib
operator|=
name|res
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsNatbib
return|;
block|}
comment|/**      * Returns the list of authors separated by commas with last name only; If      * the list consists of three or more authors, "and" is inserted before the      * last author's name.      *<p>      *<p>      *<ul>      *<li> "John Smith" ==> "Smith"</li>      *<li> "John Smith and Black Brown, Peter" ==> "Smith and Black Brown"</li>      *<li> "John von Neumann and John Smith and Black Brown, Peter" ==> "von      * Neumann, Smith and Black Brown".</li>      *</ul>      *      * @param oxfordComma Whether to put a comma before the and at the end.      * @return formatted list of authors.      * @see<a href="http://en.wikipedia.org/wiki/Serial_comma">serial comma for an detailed explaination about the Oxford comma.</a>      */
DECL|method|getAuthorsLastOnly (boolean oxfordComma)
specifier|public
name|String
name|getAuthorsLastOnly
parameter_list|(
name|boolean
name|oxfordComma
parameter_list|)
block|{
name|int
name|abbrInt
init|=
name|oxfordComma
condition|?
literal|0
else|:
literal|1
decl_stmt|;
comment|// Check if we've computed this before:
if|if
condition|(
name|authorsLastOnly
index|[
name|abbrInt
index|]
operator|!=
literal|null
condition|)
block|{
return|return
name|authorsLastOnly
index|[
name|abbrInt
index|]
return|;
block|}
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getLastOnly
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
operator|(
name|size
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getLastOnly
argument_list|()
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size
argument_list|()
operator|>
literal|2
operator|)
operator|&&
name|oxfordComma
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getLastOnly
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsLastOnly
index|[
name|abbrInt
index|]
operator|=
name|result
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsLastOnly
index|[
name|abbrInt
index|]
return|;
block|}
comment|/**      * Returns the list of authors separated by commas with first names after      * last name; first names are abbreviated or not depending on parameter. If      * the list consists of three or more authors, "and" is inserted before the      * last author's name.      *<p>      *<p>      *<ul>      *<li> "John Smith" ==> "Smith, John" or "Smith, J."</li>      *<li> "John Smith and Black Brown, Peter" ==> "Smith, John and Black      * Brown, Peter" or "Smith, J. and Black Brown, P."</li>      *<li> "John von Neumann and John Smith and Black Brown, Peter" ==> "von      * Neumann, John, Smith, John and Black Brown, Peter" or "von Neumann, J.,      * Smith, J. and Black Brown, P.".</li>      *</ul>      *      * @param abbreviate  whether to abbreivate first names.      * @param oxfordComma Whether to put a comma before the and at the end.      * @return formatted list of authors.      * @see<a href="http://en.wikipedia.org/wiki/Serial_comma">serial comma for an detailed explaination about the Oxford comma.</a>      */
DECL|method|getAuthorsLastFirst (boolean abbreviate, boolean oxfordComma)
specifier|public
name|String
name|getAuthorsLastFirst
parameter_list|(
name|boolean
name|abbreviate
parameter_list|,
name|boolean
name|oxfordComma
parameter_list|)
block|{
name|int
name|abbrInt
init|=
name|abbreviate
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|abbrInt
operator|+=
name|oxfordComma
condition|?
literal|0
else|:
literal|2
expr_stmt|;
comment|// Check if we've computed this before:
if|if
condition|(
name|authorsLastFirst
index|[
name|abbrInt
index|]
operator|!=
literal|null
condition|)
block|{
return|return
name|authorsLastFirst
index|[
name|abbrInt
index|]
return|;
block|}
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getLastFirst
argument_list|(
name|abbreviate
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
operator|(
name|size
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getLastFirst
argument_list|(
name|abbreviate
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size
argument_list|()
operator|>
literal|2
operator|)
operator|&&
name|oxfordComma
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getLastFirst
argument_list|(
name|abbreviate
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsLastFirst
index|[
name|abbrInt
index|]
operator|=
name|result
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsLastFirst
index|[
name|abbrInt
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getAuthorsLastFirstAnds
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|/**      * Returns the list of authors separated by "and"s with first names after      * last name; first names are not abbreviated.      *<p>      *<ul>      *<li>"John Smith" ==> "Smith, John"</li>      *<li>"John Smith and Black Brown, Peter" ==> "Smith, John and Black      * Brown, Peter"</li>      *<li>"John von Neumann and John Smith and Black Brown, Peter" ==> "von      * Neumann, John and Smith, John and Black Brown, Peter".</li>      *</ul>      *      * @return formatted list of authors.      */
DECL|method|getAuthorsLastFirstAnds (boolean abbreviate)
specifier|public
name|String
name|getAuthorsLastFirstAnds
parameter_list|(
name|boolean
name|abbreviate
parameter_list|)
block|{
name|int
name|abbrInt
init|=
name|abbreviate
condition|?
literal|0
else|:
literal|1
decl_stmt|;
comment|// Check if we've computed this before:
if|if
condition|(
name|authorLastFirstAnds
index|[
name|abbrInt
index|]
operator|!=
literal|null
condition|)
block|{
return|return
name|authorLastFirstAnds
index|[
name|abbrInt
index|]
return|;
block|}
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getLastFirst
argument_list|(
name|abbreviate
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getLastFirst
argument_list|(
name|abbreviate
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|authorLastFirstAnds
index|[
name|abbrInt
index|]
operator|=
name|result
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorLastFirstAnds
index|[
name|abbrInt
index|]
return|;
block|}
DECL|method|getAuthorsLastFirstFirstLastAnds (boolean abbreviate)
specifier|public
name|String
name|getAuthorsLastFirstFirstLastAnds
parameter_list|(
name|boolean
name|abbreviate
parameter_list|)
block|{
name|int
name|abbrInt
init|=
name|abbreviate
condition|?
literal|0
else|:
literal|1
decl_stmt|;
comment|// Check if we've computed this before:
if|if
condition|(
name|authorsLastFirstFirstLast
index|[
name|abbrInt
index|]
operator|!=
literal|null
condition|)
block|{
return|return
name|authorsLastFirstFirstLast
index|[
name|abbrInt
index|]
return|;
block|}
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getLastFirst
argument_list|(
name|abbreviate
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getFirstLast
argument_list|(
name|abbreviate
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsLastFirstFirstLast
index|[
name|abbrInt
index|]
operator|=
name|result
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsLastFirstFirstLast
index|[
name|abbrInt
index|]
return|;
block|}
comment|/**      * Returns the list of authors separated by commas with first names before      * last name; first names are abbreviated or not depending on parameter. If      * the list consists of three or more authors, "and" is inserted before the      * last author's name.      *<p>      *<ul>      *<li>"John Smith" ==> "John Smith" or "J. Smith"</li>      *<li>"John Smith and Black Brown, Peter" ==> "John Smith and Peter Black      * Brown" or "J. Smith and P. Black Brown"</li>      *<li> "John von Neumann and John Smith and Black Brown, Peter" ==> "John      * von Neumann, John Smith and Peter Black Brown" or "J. von Neumann, J.      * Smith and P. Black Brown"</li>      *</ul>      *      * @param abbr        whether to abbreivate first names.      * @param oxfordComma Whether to put a comma before the and at the end.      * @return formatted list of authors.      * @see<a href="http://en.wikipedia.org/wiki/Serial_comma">serial comma for an detailed explaination about the Oxford comma.</a>      */
DECL|method|getAuthorsFirstFirst (boolean abbr, boolean oxfordComma)
specifier|public
name|String
name|getAuthorsFirstFirst
parameter_list|(
name|boolean
name|abbr
parameter_list|,
name|boolean
name|oxfordComma
parameter_list|)
block|{
name|int
name|abbrInt
init|=
name|abbr
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|abbrInt
operator|+=
name|oxfordComma
condition|?
literal|0
else|:
literal|2
expr_stmt|;
comment|// Check if we've computed this before:
if|if
condition|(
name|authorsFirstFirst
index|[
name|abbrInt
index|]
operator|!=
literal|null
condition|)
block|{
return|return
name|authorsFirstFirst
index|[
name|abbrInt
index|]
return|;
block|}
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getFirstLast
argument_list|(
name|abbr
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
operator|(
name|size
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getFirstLast
argument_list|(
name|abbr
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size
argument_list|()
operator|>
literal|2
operator|)
operator|&&
name|oxfordComma
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getFirstLast
argument_list|(
name|abbr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsFirstFirst
index|[
name|abbrInt
index|]
operator|=
name|result
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsFirstFirst
index|[
name|abbrInt
index|]
return|;
block|}
comment|/**      * Compare this object with the given one.      *<p>      * Will return true iff the other object is an Author and all fields are identical on a string comparison.      */
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|AuthorList
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|AuthorList
name|a
init|=
operator|(
name|AuthorList
operator|)
name|o
decl_stmt|;
return|return
name|this
operator|.
name|authors
operator|.
name|equals
argument_list|(
name|a
operator|.
name|authors
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
specifier|final
name|int
name|prime
init|=
literal|31
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|result
operator|=
operator|(
name|prime
operator|*
name|result
operator|)
operator|+
operator|(
name|authors
operator|==
literal|null
condition|?
literal|0
else|:
name|authors
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**      * Returns the list of authors separated by "and"s with first names before      * last name; first names are not abbreviated.      *<p>      *<ul>      *<li>"John Smith" ==> "John Smith"</li>      *<li>"John Smith and Black Brown, Peter" ==> "John Smith and Peter Black      * Brown"</li>      *<li>"John von Neumann and John Smith and Black Brown, Peter" ==> "John      * von Neumann and John Smith and Peter Black Brown"</li>      *</li>      *      * @return formatted list of authors.      */
DECL|method|getAuthorsFirstFirstAnds ()
specifier|public
name|String
name|getAuthorsFirstFirstAnds
parameter_list|()
block|{
comment|// Check if we've computed this before:
if|if
condition|(
name|authorsFirstFirstAnds
operator|!=
literal|null
condition|)
block|{
return|return
name|authorsFirstFirstAnds
return|;
block|}
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getFirstLast
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getFirstLast
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsFirstFirstAnds
operator|=
name|result
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsFirstFirstAnds
return|;
block|}
comment|/**      * Returns the list of authors in a form suitable for alphabetization. This      * means that last names come first, never preceded by "von" particles, and      * that any braces are removed. First names are abbreviated so the same name      * is treated similarly if abbreviated in one case and not in another. This      * form is not intended to be suitable for presentation, only for sorting.      *<p>      *<p>      *<ul>      *<li>"John Smith" ==> "Smith, J.";</li>      *      * @return formatted list of authors      */
DECL|method|getAuthorsForAlphabetization ()
specifier|public
name|String
name|getAuthorsForAlphabetization
parameter_list|()
block|{
if|if
condition|(
name|authorsAlph
operator|!=
literal|null
condition|)
block|{
return|return
name|authorsAlph
return|;
block|}
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
literal|0
argument_list|)
operator|.
name|getNameForAlphabetization
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|getAuthor
argument_list|(
name|i
argument_list|)
operator|.
name|getNameForAlphabetization
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|authorsAlph
operator|=
name|result
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|authorsAlph
return|;
block|}
comment|/**      * This is an immutable class that keeps information regarding single      * author. It is just a container for the information, with very simple      * methods to access it.      *<p>      * Current usage: only methods<code>getLastOnly</code>,      *<code>getFirstLast</code>, and<code>getLastFirst</code> are used;      * all other methods are provided for completeness.      */
DECL|class|Author
specifier|public
specifier|static
class|class
name|Author
block|{
DECL|field|firstPart
specifier|private
specifier|final
name|String
name|firstPart
decl_stmt|;
DECL|field|firstAbbr
specifier|private
specifier|final
name|String
name|firstAbbr
decl_stmt|;
DECL|field|vonPart
specifier|private
specifier|final
name|String
name|vonPart
decl_stmt|;
DECL|field|lastPart
specifier|private
specifier|final
name|String
name|lastPart
decl_stmt|;
DECL|field|jrPart
specifier|private
specifier|final
name|String
name|jrPart
decl_stmt|;
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
specifier|final
name|int
name|prime
init|=
literal|31
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|result
operator|=
operator|(
name|prime
operator|*
name|result
operator|)
operator|+
operator|(
name|firstAbbr
operator|==
literal|null
condition|?
literal|0
else|:
name|firstAbbr
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
name|result
operator|=
operator|(
name|prime
operator|*
name|result
operator|)
operator|+
operator|(
name|firstPart
operator|==
literal|null
condition|?
literal|0
else|:
name|firstPart
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
name|result
operator|=
operator|(
name|prime
operator|*
name|result
operator|)
operator|+
operator|(
name|jrPart
operator|==
literal|null
condition|?
literal|0
else|:
name|jrPart
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
name|result
operator|=
operator|(
name|prime
operator|*
name|result
operator|)
operator|+
operator|(
name|lastPart
operator|==
literal|null
condition|?
literal|0
else|:
name|lastPart
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
name|result
operator|=
operator|(
name|prime
operator|*
name|result
operator|)
operator|+
operator|(
name|vonPart
operator|==
literal|null
condition|?
literal|0
else|:
name|vonPart
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**          * Compare this object with the given one.          *<p>          * Will return true iff the other object is an Author and all fields are identical on a string comparison.          */
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Author
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Author
name|a
init|=
operator|(
name|Author
operator|)
name|o
decl_stmt|;
return|return
name|EntryUtil
operator|.
name|equals
argument_list|(
name|firstPart
argument_list|,
name|a
operator|.
name|firstPart
argument_list|)
operator|&&
name|EntryUtil
operator|.
name|equals
argument_list|(
name|firstAbbr
argument_list|,
name|a
operator|.
name|firstAbbr
argument_list|)
operator|&&
name|EntryUtil
operator|.
name|equals
argument_list|(
name|vonPart
argument_list|,
name|a
operator|.
name|vonPart
argument_list|)
operator|&&
name|EntryUtil
operator|.
name|equals
argument_list|(
name|lastPart
argument_list|,
name|a
operator|.
name|lastPart
argument_list|)
operator|&&
name|EntryUtil
operator|.
name|equals
argument_list|(
name|jrPart
argument_list|,
name|a
operator|.
name|jrPart
argument_list|)
return|;
block|}
comment|/**          * Creates the Author object. If any part of the name is absent,<CODE>null</CODE>          * must be passed; otherwise other methods may return erroneous results.          *          * @param first     the first name of the author (may consist of several          *                  tokens, like "Charles Louis Xavier Joseph" in "Charles          *                  Louis Xavier Joseph de la Vall{\'e}e Poussin")          * @param firstabbr the abbreviated first name of the author (may consist of          *                  several tokens, like "C. L. X. J." in "Charles Louis          *                  Xavier Joseph de la Vall{\'e}e Poussin"). It is a          *                  responsibility of the caller to create a reasonable          *                  abbreviation of the first name.          * @param von       the von part of the author's name (may consist of several          *                  tokens, like "de la" in "Charles Louis Xavier Joseph de la          *                  Vall{\'e}e Poussin")          * @param last      the lats name of the author (may consist of several          *                  tokens, like "Vall{\'e}e Poussin" in "Charles Louis Xavier          *                  Joseph de la Vall{\'e}e Poussin")          * @param jr        the junior part of the author's name (may consist of          *                  several tokens, like "Jr. III" in "Smith, Jr. III, John")          */
DECL|method|Author (String first, String firstabbr, String von, String last, String jr)
specifier|public
name|Author
parameter_list|(
name|String
name|first
parameter_list|,
name|String
name|firstabbr
parameter_list|,
name|String
name|von
parameter_list|,
name|String
name|last
parameter_list|,
name|String
name|jr
parameter_list|)
block|{
name|firstPart
operator|=
name|removeStartAndEndBraces
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|firstAbbr
operator|=
name|removeStartAndEndBraces
argument_list|(
name|firstabbr
argument_list|)
expr_stmt|;
name|vonPart
operator|=
name|removeStartAndEndBraces
argument_list|(
name|von
argument_list|)
expr_stmt|;
name|lastPart
operator|=
name|removeStartAndEndBraces
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|jrPart
operator|=
name|removeStartAndEndBraces
argument_list|(
name|jr
argument_list|)
expr_stmt|;
block|}
comment|/**          * @return true if the brackets in s are properly paired          */
DECL|method|properBrackets (String s)
specifier|private
name|boolean
name|properBrackets
parameter_list|(
name|String
name|s
parameter_list|)
block|{
comment|// nested construct is there, check for "proper" nesting
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|level
init|=
literal|0
decl_stmt|;
name|loop
label|:
while|while
condition|(
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'{'
case|:
name|level
operator|++
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|level
operator|--
expr_stmt|;
if|if
condition|(
name|level
operator|==
operator|-
literal|1
condition|)
block|{
comment|// the improper nesting
break|break
name|loop
break|;
block|}
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return
name|level
operator|==
literal|0
return|;
block|}
comment|/**          * Removes start and end brace at a string          *<p>          * E.g.,          * * {Vall{\'e}e Poussin} -> Vall{\'e}e Poussin          * * {Vall{\'e}e} {Poussin} -> Vall{\'e}e Poussin          * * Vall{\'e}e Poussin -> Vall{\'e}e Poussin          */
DECL|method|removeStartAndEndBraces (String name)
specifier|private
name|String
name|removeStartAndEndBraces
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|name
operator|.
name|contains
argument_list|(
literal|"{"
argument_list|)
condition|)
block|{
return|return
name|name
return|;
block|}
name|String
index|[]
name|split
init|=
name|name
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|split
control|)
block|{
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
literal|"{"
argument_list|)
operator|&&
name|s
operator|.
name|endsWith
argument_list|(
literal|"}"
argument_list|)
condition|)
block|{
comment|// quick solution (which we don't do: just remove first "{" and last "}"
comment|// however, it might be that s is like {A}bbb{c}, where braces may not be removed
comment|// inner
name|String
name|inner
init|=
name|s
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|inner
operator|.
name|contains
argument_list|(
literal|"}"
argument_list|)
condition|)
block|{
if|if
condition|(
name|properBrackets
argument_list|(
name|inner
argument_list|)
condition|)
block|{
name|s
operator|=
name|inner
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//  no inner curly brackets found, no check needed, inner can just be used as s
name|s
operator|=
name|inner
expr_stmt|;
block|}
block|}
block|}
name|b
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|// delete last
name|b
operator|.
name|deleteCharAt
argument_list|(
name|b
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// now, all inner words are cleared
comment|// case {word word word} remains
comment|// as above, we have to be aware of {w}ord word wor{d} and {{w}ord word word}
name|name
operator|=
name|b
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"{"
argument_list|)
operator|&&
name|name
operator|.
name|endsWith
argument_list|(
literal|"}"
argument_list|)
condition|)
block|{
name|String
name|inner
init|=
name|name
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|name
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|properBrackets
argument_list|(
name|inner
argument_list|)
condition|)
block|{
return|return
name|inner
return|;
block|}
else|else
block|{
return|return
name|name
return|;
block|}
block|}
else|else
block|{
return|return
name|name
return|;
block|}
block|}
comment|/**          * Returns the first name of the author stored in this object ("First").          *          * @return first name of the author (may consist of several tokens)          */
DECL|method|getFirst ()
specifier|public
name|String
name|getFirst
parameter_list|()
block|{
return|return
name|firstPart
return|;
block|}
comment|/**          * Returns the abbreviated first name of the author stored in this          * object ("F.").          *          * @return abbreviated first name of the author (may consist of several          * tokens)          */
DECL|method|getFirstAbbr ()
specifier|public
name|String
name|getFirstAbbr
parameter_list|()
block|{
return|return
name|firstAbbr
return|;
block|}
comment|/**          * Returns the von part of the author's name stored in this object          * ("von").          *          * @return von part of the author's name (may consist of several tokens)          */
DECL|method|getVon ()
specifier|public
name|String
name|getVon
parameter_list|()
block|{
return|return
name|vonPart
return|;
block|}
comment|/**          * Returns the last name of the author stored in this object ("Last").          *          * @return last name of the author (may consist of several tokens)          */
DECL|method|getLast ()
specifier|public
name|String
name|getLast
parameter_list|()
block|{
return|return
name|lastPart
return|;
block|}
comment|/**          * Returns the junior part of the author's name stored in this object          * ("Jr").          *          * @return junior part of the author's name (may consist of several          * tokens) or null if the author does not have a Jr. Part          */
DECL|method|getJr ()
specifier|public
name|String
name|getJr
parameter_list|()
block|{
return|return
name|jrPart
return|;
block|}
comment|/**          * Returns von-part followed by last name ("von Last"). If both fields          * were specified as<CODE>null</CODE>, the empty string<CODE>""</CODE>          * is returned.          *          * @return 'von Last'          */
DECL|method|getLastOnly ()
specifier|public
name|String
name|getLastOnly
parameter_list|()
block|{
if|if
condition|(
name|vonPart
operator|==
literal|null
condition|)
block|{
return|return
name|lastPart
operator|==
literal|null
condition|?
literal|""
else|:
name|lastPart
return|;
block|}
else|else
block|{
return|return
name|lastPart
operator|==
literal|null
condition|?
name|vonPart
else|:
name|vonPart
operator|+
literal|' '
operator|+
name|lastPart
return|;
block|}
block|}
comment|/**          * Returns the author's name in form 'von Last, Jr., First' with the          * first name full or abbreviated depending on parameter.          *          * @param abbr<CODE>true</CODE> - abbreviate first name,<CODE>false</CODE> -          *             do not abbreviate          * @return 'von Last, Jr., First' (if<CODE>abbr==false</CODE>) or          * 'von Last, Jr., F.' (if<CODE>abbr==true</CODE>)          */
DECL|method|getLastFirst (boolean abbr)
specifier|public
name|String
name|getLastFirst
parameter_list|(
name|boolean
name|abbr
parameter_list|)
block|{
name|String
name|res
init|=
name|getLastOnly
argument_list|()
decl_stmt|;
if|if
condition|(
name|jrPart
operator|!=
literal|null
condition|)
block|{
name|res
operator|+=
literal|", "
operator|+
name|jrPart
expr_stmt|;
block|}
if|if
condition|(
name|abbr
condition|)
block|{
if|if
condition|(
name|firstAbbr
operator|!=
literal|null
condition|)
block|{
name|res
operator|+=
literal|", "
operator|+
name|firstAbbr
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|firstPart
operator|!=
literal|null
condition|)
block|{
name|res
operator|+=
literal|", "
operator|+
name|firstPart
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
comment|/**          * Returns the author's name in form 'First von Last, Jr.' with the          * first name full or abbreviated depending on parameter.          *          * @param abbr<CODE>true</CODE> - abbreviate first name,<CODE>false</CODE> -          *             do not abbreviate          * @return 'First von Last, Jr.' (if<CODE>abbr==false</CODE>) or 'F.          * von Last, Jr.' (if<CODE>abbr==true</CODE>)          */
DECL|method|getFirstLast (boolean abbr)
specifier|public
name|String
name|getFirstLast
parameter_list|(
name|boolean
name|abbr
parameter_list|)
block|{
name|String
name|res
init|=
name|getLastOnly
argument_list|()
decl_stmt|;
if|if
condition|(
name|abbr
condition|)
block|{
name|res
operator|=
operator|(
name|firstAbbr
operator|==
literal|null
condition|?
literal|""
else|:
name|firstAbbr
operator|+
literal|' '
operator|)
operator|+
name|res
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
operator|(
name|firstPart
operator|==
literal|null
condition|?
literal|""
else|:
name|firstPart
operator|+
literal|' '
operator|)
operator|+
name|res
expr_stmt|;
block|}
if|if
condition|(
name|jrPart
operator|!=
literal|null
condition|)
block|{
name|res
operator|+=
literal|", "
operator|+
name|jrPart
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
comment|/**          * Returns the name as "Last, Jr, F." omitting the von-part and removing          * starting braces.          *          * @return "Last, Jr, F." as described above or "" if all these parts          * are empty.          */
DECL|method|getNameForAlphabetization ()
specifier|public
name|String
name|getNameForAlphabetization
parameter_list|()
block|{
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastPart
operator|!=
literal|null
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
name|lastPart
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|jrPart
operator|!=
literal|null
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|jrPart
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|firstAbbr
operator|!=
literal|null
condition|)
block|{
name|res
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|firstAbbr
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|res
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|res
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'{'
operator|)
condition|)
block|{
name|res
operator|.
name|deleteCharAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|res
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

