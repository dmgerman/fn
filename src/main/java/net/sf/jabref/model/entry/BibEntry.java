begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003-2015 JabRef contributors.     This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License along     with this program; if not, write to the Free Software Foundation, Inc.,     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */
end_comment

begin_package
DECL|package|net.sf.jabref.model.entry
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
package|;
end_package

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|FieldPosition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParsePosition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|Globals
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|JabRefPreferences
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|event
operator|.
name|FieldChangedEvent
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|FieldChange
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabase
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|eventbus
operator|.
name|EventBus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_class
DECL|class|BibEntry
specifier|public
class|class
name|BibEntry
implements|implements
name|Cloneable
block|{
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Log
name|LOGGER
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|BibEntry
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TYPE_HEADER
specifier|public
specifier|static
specifier|final
name|String
name|TYPE_HEADER
init|=
literal|"entrytype"
decl_stmt|;
DECL|field|KEY_FIELD
specifier|public
specifier|static
specifier|final
name|String
name|KEY_FIELD
init|=
literal|"bibtexkey"
decl_stmt|;
DECL|field|ID_FIELD
specifier|protected
specifier|static
specifier|final
name|String
name|ID_FIELD
init|=
literal|"id"
decl_stmt|;
DECL|field|KEYWORDS_FIELD
specifier|public
specifier|static
specifier|final
name|String
name|KEYWORDS_FIELD
init|=
literal|"keywords"
decl_stmt|;
DECL|field|DEFAULT_TYPE
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_TYPE
init|=
literal|"misc"
decl_stmt|;
DECL|field|id
specifier|private
name|String
name|id
decl_stmt|;
DECL|field|type
specifier|private
name|String
name|type
decl_stmt|;
DECL|field|fields
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|fields
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Search and grouping status is stored in boolean fields for quick reference:
DECL|field|searchHit
specifier|private
name|boolean
name|searchHit
decl_stmt|;
DECL|field|groupHit
specifier|private
name|boolean
name|groupHit
decl_stmt|;
DECL|field|parsedSerialization
specifier|private
name|String
name|parsedSerialization
decl_stmt|;
comment|/*      * Marks whether the complete serialization, which was read from file, should be used.      *      * Is set to false, if parts of the entry change. This causes the entry to be serialized based on the internal state (and not based on the old serialization)      */
DECL|field|changed
specifier|private
name|boolean
name|changed
decl_stmt|;
DECL|field|eventBus
specifier|private
specifier|final
name|EventBus
name|eventBus
init|=
operator|new
name|EventBus
argument_list|()
decl_stmt|;
comment|/**      * Constructs a new BibEntry. The internal ID is set to IdGenerator.next()      */
DECL|method|BibEntry ()
specifier|public
name|BibEntry
parameter_list|()
block|{
name|this
argument_list|(
name|IdGenerator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs a new BibEntry with the given ID and DEFAULT_TYPE      *      * @param id The ID to be used      */
DECL|method|BibEntry (String id)
specifier|public
name|BibEntry
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|this
argument_list|(
name|id
argument_list|,
name|DEFAULT_TYPE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs a new BibEntry with the given ID and given type      *      * @param id The ID to be used      * @param type The type to set. May be null or empty. In that case, DEFAULT_TYPE is used.      */
DECL|method|BibEntry (String id, String type)
specifier|public
name|BibEntry
parameter_list|(
name|String
name|id
parameter_list|,
name|String
name|type
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|id
argument_list|,
literal|"Every BibEntry must have an ID"
argument_list|)
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets this entry's ID, provided the database containing it      * doesn't veto the change.      *      * @param id The ID to be used      */
DECL|method|setId (String id)
specifier|public
name|void
name|setId
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|id
argument_list|,
literal|"Every BibEntry must have an ID"
argument_list|)
expr_stmt|;
name|eventBus
operator|.
name|post
argument_list|(
operator|new
name|FieldChangedEvent
argument_list|(
name|this
argument_list|,
name|BibEntry
operator|.
name|ID_FIELD
argument_list|,
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * Returns this entry's ID.      */
DECL|method|getId ()
specifier|public
name|String
name|getId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
comment|/**      * Sets the cite key AKA citation key AKA BibTeX key.      *      * Note: This is<emph>not</emph> the internal Id of this entry. The internal Id is always present, whereas the BibTeX key might not be present.      *      * @param newCiteKey The cite key to set. Must not be null, may be empty to remove it.      */
DECL|method|setCiteKey (String newCiteKey)
specifier|public
name|void
name|setCiteKey
parameter_list|(
name|String
name|newCiteKey
parameter_list|)
block|{
name|setField
argument_list|(
name|KEY_FIELD
argument_list|,
name|newCiteKey
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the cite key AKA citation key AKA BibTeX key, or null if it is not set.      *      * Note: this is<emph>not</emph> the internal Id of this entry. The internal Id is always present, whereas the BibTeX key might not be present.      */
DECL|method|getCiteKey ()
specifier|public
name|String
name|getCiteKey
parameter_list|()
block|{
return|return
name|fields
operator|.
name|get
argument_list|(
name|KEY_FIELD
argument_list|)
return|;
block|}
DECL|method|hasCiteKey ()
specifier|public
name|boolean
name|hasCiteKey
parameter_list|()
block|{
return|return
operator|!
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|getCiteKey
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns this entry's type.      */
DECL|method|getType ()
specifier|public
name|String
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
comment|/**      * Sets this entry's type.      */
DECL|method|setType (String type)
specifier|public
name|void
name|setType
parameter_list|(
name|String
name|type
parameter_list|)
block|{
name|String
name|newType
decl_stmt|;
if|if
condition|(
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|newType
operator|=
name|DEFAULT_TYPE
expr_stmt|;
block|}
else|else
block|{
name|newType
operator|=
name|type
expr_stmt|;
block|}
comment|// We set the type before throwing the changeEvent, to enable
comment|// the change listener to access the new value if the change
comment|// sets off a change in database sorting etc.
name|this
operator|.
name|type
operator|=
name|newType
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
name|eventBus
operator|.
name|post
argument_list|(
operator|new
name|FieldChangedEvent
argument_list|(
name|this
argument_list|,
name|TYPE_HEADER
argument_list|,
name|newType
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets this entry's type.      */
DECL|method|setType (EntryType type)
specifier|public
name|void
name|setType
parameter_list|(
name|EntryType
name|type
parameter_list|)
block|{
name|this
operator|.
name|setType
argument_list|(
name|type
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns an set containing the names of all fields that are      * set for this particular entry.      *      * @return a set of existing field names      */
DECL|method|getFieldNames ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getFieldNames
parameter_list|()
block|{
return|return
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|fields
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns the contents of the given field, or null if it is not set.      */
annotation|@
name|Deprecated
comment|//Use getFieldOptional instead
DECL|method|getField (String name)
specifier|public
name|String
name|getField
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|fields
operator|.
name|get
argument_list|(
name|toLowerCase
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Returns the contents of the given field as an Optional.      */
DECL|method|getFieldOptional (String name)
specifier|public
name|Optional
argument_list|<
name|String
argument_list|>
name|getFieldOptional
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|Optional
operator|.
name|ofNullable
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|toLowerCase
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Returns true if the entry has the given field, or false if it is not set.      */
DECL|method|hasField (String name)
specifier|public
name|boolean
name|hasField
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|fields
operator|.
name|containsKey
argument_list|(
name|toLowerCase
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
DECL|method|toLowerCase (String fieldName)
specifier|private
name|String
name|toLowerCase
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|fieldName
argument_list|,
literal|"field name must not be null"
argument_list|)
expr_stmt|;
return|return
name|fieldName
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
return|;
block|}
comment|/**      * Returns the contents of the given field, its alias or null if both are      * not set.      *<p>      * The following aliases are considered (old bibtex<-> new biblatex) based      * on the BibLatex documentation, chapter 2.2.5:      * address<-> location      * annote<-> annotation      * archiveprefix<-> eprinttype      * journal<-> journaltitle      * key<-> sortkey      * pdf<-> file      * primaryclass<-> eprintclass      * school<-> institution      * These work bidirectional.      *<p>      * Special attention is paid to dates: (see the BibLatex documentation,      * chapter 2.3.8)      * The fields 'year' and 'month' are used if the 'date'      * field is empty. Conversely, getFieldOrAlias("year") also tries to      * extract the year from the 'date' field (analogously for 'month').      */
DECL|method|getFieldOrAlias (String name)
specifier|public
name|String
name|getFieldOrAlias
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
name|fieldValue
init|=
name|getField
argument_list|(
name|toLowerCase
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|fieldValue
argument_list|)
condition|)
block|{
return|return
name|fieldValue
return|;
block|}
comment|// No value of this field found, so look at the alias
name|String
name|aliasForField
init|=
name|EntryConverter
operator|.
name|FIELD_ALIASES
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|aliasForField
operator|!=
literal|null
condition|)
block|{
return|return
name|getField
argument_list|(
name|aliasForField
argument_list|)
return|;
block|}
comment|// Finally, handle dates
if|if
condition|(
literal|"date"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|String
name|year
init|=
name|getField
argument_list|(
literal|"year"
argument_list|)
decl_stmt|;
name|MonthUtil
operator|.
name|Month
name|month
init|=
name|MonthUtil
operator|.
name|getMonth
argument_list|(
name|getField
argument_list|(
literal|"month"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|year
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|month
operator|.
name|isValid
argument_list|()
condition|)
block|{
return|return
name|year
operator|+
literal|'-'
operator|+
name|month
operator|.
name|twoDigitNumber
return|;
block|}
else|else
block|{
return|return
name|year
return|;
block|}
block|}
block|}
if|if
condition|(
literal|"year"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
operator|||
literal|"month"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|String
name|date
init|=
name|getField
argument_list|(
literal|"date"
argument_list|)
decl_stmt|;
if|if
condition|(
name|date
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Create date format matching dates with year and month
name|DateFormat
name|df
init|=
operator|new
name|DateFormat
argument_list|()
block|{
specifier|static
specifier|final
name|String
name|FORMAT1
init|=
literal|"yyyy-MM-dd"
decl_stmt|;
specifier|static
specifier|final
name|String
name|FORMAT2
init|=
literal|"yyyy-MM"
decl_stmt|;
specifier|final
name|SimpleDateFormat
name|sdf1
init|=
operator|new
name|SimpleDateFormat
argument_list|(
name|FORMAT1
argument_list|)
decl_stmt|;
specifier|final
name|SimpleDateFormat
name|sdf2
init|=
operator|new
name|SimpleDateFormat
argument_list|(
name|FORMAT2
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|StringBuffer
name|format
parameter_list|(
name|Date
name|dDate
parameter_list|,
name|StringBuffer
name|toAppendTo
parameter_list|,
name|FieldPosition
name|fieldPosition
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|Date
name|parse
parameter_list|(
name|String
name|source
parameter_list|,
name|ParsePosition
name|pos
parameter_list|)
block|{
if|if
condition|(
operator|(
name|source
operator|.
name|length
argument_list|()
operator|-
name|pos
operator|.
name|getIndex
argument_list|()
operator|)
operator|==
name|FORMAT1
operator|.
name|length
argument_list|()
condition|)
block|{
return|return
name|sdf1
operator|.
name|parse
argument_list|(
name|source
argument_list|,
name|pos
argument_list|)
return|;
block|}
return|return
name|sdf2
operator|.
name|parse
argument_list|(
name|source
argument_list|,
name|pos
argument_list|)
return|;
block|}
block|}
decl_stmt|;
try|try
block|{
name|Date
name|parsedDate
init|=
name|df
operator|.
name|parse
argument_list|(
name|date
argument_list|)
decl_stmt|;
name|Calendar
name|calendar
init|=
name|Calendar
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|calendar
operator|.
name|setTime
argument_list|(
name|parsedDate
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"year"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|Integer
operator|.
name|toString
argument_list|(
name|calendar
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
literal|"month"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|Integer
operator|.
name|toString
argument_list|(
name|calendar
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|)
operator|+
literal|1
argument_list|)
return|;
comment|// Shift by 1 since in this calendar Jan = 0
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
comment|// So not a date with year and month, try just to parse years
name|df
operator|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyy"
argument_list|)
expr_stmt|;
try|try
block|{
name|Date
name|parsedDate
init|=
name|df
operator|.
name|parse
argument_list|(
name|date
argument_list|)
decl_stmt|;
name|Calendar
name|calendar
init|=
name|Calendar
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|calendar
operator|.
name|setTime
argument_list|(
name|parsedDate
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"year"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|Integer
operator|.
name|toString
argument_list|(
name|calendar
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|e2
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Could not parse entry "
operator|+
name|name
argument_list|,
name|e2
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// Date field not in valid format
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Sets a number of fields simultaneously. The given HashMap contains field      * names as keys, each mapped to the value to set.      */
DECL|method|setField (Map<String, String> fields)
specifier|public
name|void
name|setField
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|fields
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|fields
argument_list|,
literal|"fields must not be null"
argument_list|)
expr_stmt|;
name|fields
operator|.
name|forEach
argument_list|(
name|this
operator|::
name|setField
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set a field, and notify listeners about the change.      *  @param name  The field to set.      * @param value The value to set.      */
DECL|method|setField (String name, String value)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|setField
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|name
argument_list|,
literal|"field name must not be null"
argument_list|)
expr_stmt|;
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|value
argument_list|,
literal|"field value must not be null"
argument_list|)
expr_stmt|;
name|String
name|fieldName
init|=
name|toLowerCase
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|clearField
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
name|String
name|oldValue
init|=
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|equals
argument_list|(
name|oldValue
argument_list|)
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
if|if
condition|(
name|BibEntry
operator|.
name|ID_FIELD
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The field name '"
operator|+
name|name
operator|+
literal|"' is reserved"
argument_list|)
throw|;
block|}
name|changed
operator|=
literal|true
expr_stmt|;
name|fields
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|FieldChange
name|change
init|=
operator|new
name|FieldChange
argument_list|(
name|this
argument_list|,
name|fieldName
argument_list|,
name|oldValue
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|eventBus
operator|.
name|post
argument_list|(
operator|new
name|FieldChangedEvent
argument_list|(
name|change
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Optional
operator|.
name|of
argument_list|(
name|change
argument_list|)
return|;
block|}
comment|/**      * Remove the mapping for the field name, and notify listeners about      * the change.      *      * @param name The field to clear.      */
DECL|method|clearField (String name)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|clearField
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
name|fieldName
init|=
name|toLowerCase
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|BibEntry
operator|.
name|ID_FIELD
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The field name '"
operator|+
name|name
operator|+
literal|"' is reserved"
argument_list|)
throw|;
block|}
name|Optional
argument_list|<
name|String
argument_list|>
name|oldValue
init|=
name|getFieldOptional
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|oldValue
operator|.
name|isPresent
argument_list|()
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
name|changed
operator|=
literal|true
expr_stmt|;
name|fields
operator|.
name|remove
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
name|FieldChange
name|change
init|=
operator|new
name|FieldChange
argument_list|(
name|this
argument_list|,
name|fieldName
argument_list|,
name|oldValue
operator|.
name|get
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|eventBus
operator|.
name|post
argument_list|(
operator|new
name|FieldChangedEvent
argument_list|(
name|change
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Optional
operator|.
name|of
argument_list|(
name|change
argument_list|)
return|;
block|}
comment|/**      * Determines whether this entry has all the given fields present. If a non-null      * database argument is given, this method will try to look up missing fields in      * entries linked by the "crossref" field, if any.      *      * @param allFields An array of field names to be checked.      * @param database  The database in which to look up crossref'd entries, if any. This      *                  argument can be null, meaning that no attempt will be made to follow crossrefs.      * @return true if all fields are set or could be resolved, false otherwise.      */
DECL|method|allFieldsPresent (List<String> allFields, BibDatabase database)
specifier|public
name|boolean
name|allFieldsPresent
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|allFields
parameter_list|,
name|BibDatabase
name|database
parameter_list|)
block|{
specifier|final
name|String
name|orSeparator
init|=
literal|"/"
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|allFields
control|)
block|{
name|String
name|fieldName
init|=
name|toLowerCase
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|// OR fields
if|if
condition|(
name|fieldName
operator|.
name|contains
argument_list|(
name|orSeparator
argument_list|)
condition|)
block|{
name|String
index|[]
name|altFields
init|=
name|field
operator|.
name|split
argument_list|(
name|orSeparator
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|atLeastOnePresent
argument_list|(
name|altFields
argument_list|,
name|database
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|BibDatabase
operator|.
name|getResolvedField
argument_list|(
name|fieldName
argument_list|,
name|this
argument_list|,
name|database
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|atLeastOnePresent (String[] fieldsToCheck, BibDatabase database)
specifier|private
name|boolean
name|atLeastOnePresent
parameter_list|(
name|String
index|[]
name|fieldsToCheck
parameter_list|,
name|BibDatabase
name|database
parameter_list|)
block|{
for|for
control|(
name|String
name|field
range|:
name|fieldsToCheck
control|)
block|{
name|String
name|fieldName
init|=
name|toLowerCase
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|BibDatabase
operator|.
name|getResolvedField
argument_list|(
name|fieldName
argument_list|,
name|this
argument_list|,
name|database
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|value
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Returns a clone of this entry. Useful for copying.      */
annotation|@
name|Override
DECL|method|clone ()
specifier|public
name|Object
name|clone
parameter_list|()
block|{
name|BibEntry
name|clone
init|=
operator|new
name|BibEntry
argument_list|(
name|id
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|clone
operator|.
name|fields
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|fields
argument_list|)
expr_stmt|;
return|return
name|clone
return|;
block|}
comment|/**      * This returns a canonical BibTeX serialization. Special characters such as "{" or "&" are NOT escaped, but written      * as is      *<p>      * Serializes all fields, even the JabRef internal ones. Does NOT serialize "KEY_FIELD" as field, but as key      */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|CanonicalBibtexEntry
operator|.
name|getCanonicalRepresentation
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|method|isSearchHit ()
specifier|public
name|boolean
name|isSearchHit
parameter_list|()
block|{
return|return
name|searchHit
return|;
block|}
DECL|method|setSearchHit (boolean searchHit)
specifier|public
name|void
name|setSearchHit
parameter_list|(
name|boolean
name|searchHit
parameter_list|)
block|{
name|this
operator|.
name|searchHit
operator|=
name|searchHit
expr_stmt|;
block|}
DECL|method|isGroupHit ()
specifier|public
name|boolean
name|isGroupHit
parameter_list|()
block|{
return|return
name|groupHit
return|;
block|}
DECL|method|setGroupHit (boolean groupHit)
specifier|public
name|void
name|setGroupHit
parameter_list|(
name|boolean
name|groupHit
parameter_list|)
block|{
name|this
operator|.
name|groupHit
operator|=
name|groupHit
expr_stmt|;
block|}
comment|/**      * @param maxCharacters The maximum number of characters (additional      *                      characters are replaced with "..."). Set to 0 to disable truncation.      * @return A short textual description of the entry in the format:      * Author1, Author2: Title (Year)      */
DECL|method|getAuthorTitleYear (int maxCharacters)
specifier|public
name|String
name|getAuthorTitleYear
parameter_list|(
name|int
name|maxCharacters
parameter_list|)
block|{
name|String
index|[]
name|s
init|=
operator|new
name|String
index|[]
block|{
name|getFieldOptional
argument_list|(
literal|"author"
argument_list|)
operator|.
name|orElse
argument_list|(
literal|"N/A"
argument_list|)
block|,
name|getFieldOptional
argument_list|(
literal|"title"
argument_list|)
operator|.
name|orElse
argument_list|(
literal|"N/A"
argument_list|)
block|,
name|getFieldOptional
argument_list|(
literal|"year"
argument_list|)
operator|.
name|orElse
argument_list|(
literal|"N/A"
argument_list|)
block|}
decl_stmt|;
name|String
name|text
init|=
name|s
index|[
literal|0
index|]
operator|+
literal|": \""
operator|+
name|s
index|[
literal|1
index|]
operator|+
literal|"\" ("
operator|+
name|s
index|[
literal|2
index|]
operator|+
literal|')'
decl_stmt|;
if|if
condition|(
operator|(
name|maxCharacters
operator|<=
literal|0
operator|)
operator|||
operator|(
name|text
operator|.
name|length
argument_list|()
operator|<=
name|maxCharacters
operator|)
condition|)
block|{
return|return
name|text
return|;
block|}
return|return
name|text
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|maxCharacters
operator|+
literal|1
argument_list|)
operator|+
literal|"..."
return|;
block|}
comment|/**      * Will return the publication date of the given bibtex entry conforming to ISO 8601, i.e. either YYYY or YYYY-MM.      *      * @return will return the publication date of the entry or null if no year was found.      */
DECL|method|getPublicationDate ()
specifier|public
name|String
name|getPublicationDate
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasField
argument_list|(
literal|"year"
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|year
init|=
name|getField
argument_list|(
literal|"year"
argument_list|)
decl_stmt|;
if|if
condition|(
name|hasField
argument_list|(
literal|"month"
argument_list|)
condition|)
block|{
name|MonthUtil
operator|.
name|Month
name|month
init|=
name|MonthUtil
operator|.
name|getMonth
argument_list|(
name|getField
argument_list|(
literal|"month"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|month
operator|.
name|isValid
argument_list|()
condition|)
block|{
return|return
name|year
operator|+
literal|"-"
operator|+
name|month
operator|.
name|twoDigitNumber
return|;
block|}
block|}
return|return
name|year
return|;
block|}
DECL|method|setParsedSerialization (String parsedSerialization)
specifier|public
name|void
name|setParsedSerialization
parameter_list|(
name|String
name|parsedSerialization
parameter_list|)
block|{
name|changed
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|parsedSerialization
operator|=
name|parsedSerialization
expr_stmt|;
block|}
DECL|method|getParsedSerialization ()
specifier|public
name|String
name|getParsedSerialization
parameter_list|()
block|{
return|return
name|parsedSerialization
return|;
block|}
DECL|method|hasChanged ()
specifier|public
name|boolean
name|hasChanged
parameter_list|()
block|{
return|return
name|changed
return|;
block|}
DECL|method|setChanged (boolean changed)
specifier|public
name|void
name|setChanged
parameter_list|(
name|boolean
name|changed
parameter_list|)
block|{
name|this
operator|.
name|changed
operator|=
name|changed
expr_stmt|;
block|}
DECL|method|putKeywords (Collection<String> keywords)
specifier|public
name|Optional
argument_list|<
name|FieldChange
argument_list|>
name|putKeywords
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|keywords
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|keywords
argument_list|)
expr_stmt|;
name|Optional
argument_list|<
name|String
argument_list|>
name|oldValue
init|=
name|this
operator|.
name|getFieldOptional
argument_list|(
name|KEYWORDS_FIELD
argument_list|)
decl_stmt|;
if|if
condition|(
name|keywords
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Clear keyword field
if|if
condition|(
name|oldValue
operator|.
name|isPresent
argument_list|()
condition|)
block|{
return|return
name|this
operator|.
name|clearField
argument_list|(
name|KEYWORDS_FIELD
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
block|}
comment|// Set new keyword field
name|String
name|newValue
init|=
name|String
operator|.
name|join
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|KEYWORD_SEPARATOR
argument_list|)
argument_list|,
name|keywords
argument_list|)
decl_stmt|;
return|return
name|this
operator|.
name|setField
argument_list|(
name|KEYWORDS_FIELD
argument_list|,
name|newValue
argument_list|)
return|;
block|}
comment|/**      * Check if a keyword already exists (case insensitive), if not: add it      *      * @param keyword Keyword to add      */
DECL|method|addKeyword (String keyword)
specifier|public
name|void
name|addKeyword
parameter_list|(
name|String
name|keyword
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|keyword
argument_list|,
literal|"keyword must not be null"
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyword
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|keywords
init|=
name|this
operator|.
name|getKeywords
argument_list|()
decl_stmt|;
name|keywords
operator|.
name|add
argument_list|(
name|keyword
argument_list|)
expr_stmt|;
name|this
operator|.
name|putKeywords
argument_list|(
name|keywords
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add multiple keywords to entry      *      * @param keywords Keywords to add      */
DECL|method|addKeywords (Collection<String> keywords)
specifier|public
name|void
name|addKeywords
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|keywords
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|keywords
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|keyword
range|:
name|keywords
control|)
block|{
name|this
operator|.
name|addKeyword
argument_list|(
name|keyword
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getKeywords ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getKeywords
parameter_list|()
block|{
return|return
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|EntryUtil
operator|.
name|getSeparatedKeywords
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|method|getFieldValues ()
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getFieldValues
parameter_list|()
block|{
return|return
name|fields
operator|.
name|values
argument_list|()
return|;
block|}
DECL|method|getFieldMap ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getFieldMap
parameter_list|()
block|{
return|return
name|fields
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|(
name|o
operator|==
literal|null
operator|)
operator|||
operator|(
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|BibEntry
name|entry
init|=
operator|(
name|BibEntry
operator|)
name|o
decl_stmt|;
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|type
argument_list|,
name|entry
operator|.
name|type
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|fields
argument_list|,
name|entry
operator|.
name|fields
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|type
argument_list|,
name|fields
argument_list|)
return|;
block|}
DECL|method|registerListener (Object object)
specifier|public
name|void
name|registerListener
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
name|this
operator|.
name|eventBus
operator|.
name|register
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
DECL|method|unregisterListener (Object object)
specifier|public
name|void
name|unregisterListener
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
name|this
operator|.
name|eventBus
operator|.
name|unregister
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
DECL|method|withField (String field, String value)
specifier|public
name|BibEntry
name|withField
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|setField
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
end_class

end_unit

