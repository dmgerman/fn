begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003-2011 JabRef contributors.     This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License along     with this program; if not, write to the Free Software Foundation, Inc.,     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */
end_comment

begin_package
DECL|package|net.sf.jabref
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_comment
comment|/**  * This class contains utility method for duplicate checking of entries.  */
end_comment

begin_class
DECL|class|DuplicateCheck
specifier|public
class|class
name|DuplicateCheck
block|{
DECL|field|duplicateThreshold
specifier|public
specifier|static
name|double
name|duplicateThreshold
init|=
literal|0.75
decl_stmt|;
comment|// The overall threshold to signal a duplicate pair
comment|// Non-required fields are investigated only if the required fields give a value within
comment|// the doubt range of the threshold:
DECL|field|doubtRange
specifier|private
specifier|static
specifier|final
name|double
name|doubtRange
init|=
literal|0.05
decl_stmt|;
DECL|field|reqWeight
specifier|private
specifier|final
specifier|static
name|double
name|reqWeight
init|=
literal|3
decl_stmt|;
comment|// Weighting of all required fields
comment|// Extra weighting of those fields that are most likely to provide correct duplicate detection:
DECL|field|fieldWeights
specifier|private
specifier|static
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
name|fieldWeights
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|DuplicateCheck
operator|.
name|fieldWeights
operator|.
name|put
argument_list|(
literal|"author"
argument_list|,
literal|2.5
argument_list|)
expr_stmt|;
name|DuplicateCheck
operator|.
name|fieldWeights
operator|.
name|put
argument_list|(
literal|"editor"
argument_list|,
literal|2.5
argument_list|)
expr_stmt|;
name|DuplicateCheck
operator|.
name|fieldWeights
operator|.
name|put
argument_list|(
literal|"title"
argument_list|,
literal|3.
argument_list|)
expr_stmt|;
name|DuplicateCheck
operator|.
name|fieldWeights
operator|.
name|put
argument_list|(
literal|"journal"
argument_list|,
literal|2.
argument_list|)
expr_stmt|;
block|}
comment|/**      * Checks if the two entries represent the same publication.      *      * @param one BibtexEntry      * @param two BibtexEntry      * @return boolean      */
DECL|method|isDuplicate (BibtexEntry one, BibtexEntry two)
specifier|public
specifier|static
name|boolean
name|isDuplicate
parameter_list|(
name|BibtexEntry
name|one
parameter_list|,
name|BibtexEntry
name|two
parameter_list|)
block|{
comment|// First check if they are of the same type - a necessary condition:
if|if
condition|(
name|one
operator|.
name|getType
argument_list|()
operator|!=
name|two
operator|.
name|getType
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// The check if they have the same required fields:
name|String
index|[]
name|fields
init|=
name|one
operator|.
name|getType
argument_list|()
operator|.
name|getRequiredFields
argument_list|()
decl_stmt|;
name|double
index|[]
name|req
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
name|req
operator|=
operator|new
name|double
index|[]
block|{
literal|0.
block|,
literal|0.
block|}
expr_stmt|;
block|}
else|else
block|{
name|req
operator|=
name|DuplicateCheck
operator|.
name|compareFieldSet
argument_list|(
name|fields
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|req
index|[
literal|0
index|]
operator|-
name|DuplicateCheck
operator|.
name|duplicateThreshold
argument_list|)
operator|>
name|DuplicateCheck
operator|.
name|doubtRange
condition|)
block|{
comment|// Far from the threshold value, so we base our decision on the req. fields only
return|return
name|req
index|[
literal|0
index|]
operator|>=
name|DuplicateCheck
operator|.
name|duplicateThreshold
return|;
block|}
else|else
block|{
comment|// Close to the threshold value, so we take a look at the optional fields, if any:
name|fields
operator|=
name|one
operator|.
name|getType
argument_list|()
operator|.
name|getOptionalFields
argument_list|()
expr_stmt|;
if|if
condition|(
name|fields
operator|!=
literal|null
condition|)
block|{
name|double
index|[]
name|opt
init|=
name|DuplicateCheck
operator|.
name|compareFieldSet
argument_list|(
name|fields
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
decl_stmt|;
name|double
name|totValue
init|=
operator|(
operator|(
name|DuplicateCheck
operator|.
name|reqWeight
operator|*
name|req
index|[
literal|0
index|]
operator|*
name|req
index|[
literal|1
index|]
operator|)
operator|+
operator|(
name|opt
index|[
literal|0
index|]
operator|*
name|opt
index|[
literal|1
index|]
operator|)
operator|)
operator|/
operator|(
operator|(
name|req
index|[
literal|1
index|]
operator|*
name|DuplicateCheck
operator|.
name|reqWeight
operator|)
operator|+
name|opt
index|[
literal|1
index|]
operator|)
decl_stmt|;
return|return
name|totValue
operator|>=
name|DuplicateCheck
operator|.
name|duplicateThreshold
return|;
block|}
else|else
block|{
return|return
operator|(
name|req
index|[
literal|0
index|]
operator|>=
name|DuplicateCheck
operator|.
name|duplicateThreshold
operator|)
return|;
block|}
block|}
block|}
DECL|method|compareFieldSet (String[] fields, BibtexEntry one, BibtexEntry two)
specifier|private
specifier|static
name|double
index|[]
name|compareFieldSet
parameter_list|(
name|String
index|[]
name|fields
parameter_list|,
name|BibtexEntry
name|one
parameter_list|,
name|BibtexEntry
name|two
parameter_list|)
block|{
name|double
name|res
init|=
literal|0
decl_stmt|;
name|double
name|totWeights
init|=
literal|0.
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
comment|// Util.pr(":"+compareSingleField(fields[i], one, two));
name|double
name|weight
decl_stmt|;
if|if
condition|(
name|DuplicateCheck
operator|.
name|fieldWeights
operator|.
name|containsKey
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|weight
operator|=
name|DuplicateCheck
operator|.
name|fieldWeights
operator|.
name|get
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|weight
operator|=
literal|1.0
expr_stmt|;
block|}
name|totWeights
operator|+=
name|weight
expr_stmt|;
name|int
name|result
init|=
name|DuplicateCheck
operator|.
name|compareSingleField
argument_list|(
name|field
argument_list|,
name|one
argument_list|,
name|two
argument_list|)
decl_stmt|;
comment|//System.out.println("Field: "+fields[i]+": "+result);
if|if
condition|(
name|result
operator|==
name|Util
operator|.
name|EQUAL
condition|)
block|{
name|res
operator|+=
name|weight
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|Util
operator|.
name|EMPTY_IN_BOTH
condition|)
block|{
name|totWeights
operator|-=
name|weight
expr_stmt|;
block|}
block|}
if|if
condition|(
name|totWeights
operator|>
literal|0
condition|)
block|{
return|return
operator|new
name|double
index|[]
block|{
name|res
operator|/
name|totWeights
block|,
name|totWeights
block|}
return|;
block|}
else|else
block|{
comment|// no fields present. This points to a possible duplicate?
return|return
operator|new
name|double
index|[]
block|{
literal|0.5
block|,
literal|0.0
block|}
return|;
block|}
block|}
DECL|method|compareSingleField (String field, BibtexEntry one, BibtexEntry two)
specifier|private
specifier|static
name|int
name|compareSingleField
parameter_list|(
name|String
name|field
parameter_list|,
name|BibtexEntry
name|one
parameter_list|,
name|BibtexEntry
name|two
parameter_list|)
block|{
name|String
name|s1
init|=
name|one
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|,
name|s2
init|=
name|two
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|s1
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|s2
operator|==
literal|null
condition|)
block|{
return|return
name|Util
operator|.
name|EMPTY_IN_BOTH
return|;
block|}
else|else
block|{
return|return
name|Util
operator|.
name|EMPTY_IN_ONE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|s2
operator|==
literal|null
condition|)
block|{
return|return
name|Util
operator|.
name|EMPTY_IN_TWO
return|;
block|}
comment|// Util.pr(field+": '"+s1+"' vs '"+s2+"'");
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"author"
argument_list|)
operator|||
name|field
operator|.
name|equals
argument_list|(
literal|"editor"
argument_list|)
condition|)
block|{
comment|// Specific for name fields.
comment|// Harmonise case:
name|String
name|auth1
init|=
name|AuthorList
operator|.
name|fixAuthor_lastNameOnlyCommas
argument_list|(
name|s1
argument_list|,
literal|false
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|" and "
argument_list|,
literal|" "
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|,
name|auth2
init|=
name|AuthorList
operator|.
name|fixAuthor_lastNameOnlyCommas
argument_list|(
name|s2
argument_list|,
literal|false
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|" and "
argument_list|,
literal|" "
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
comment|//System.out.println(auth1);
comment|//System.out.println(auth2);
comment|//System.out.println(correlateByWords(auth1, auth2));
name|double
name|similarity
init|=
name|DuplicateCheck
operator|.
name|correlateByWords
argument_list|(
name|auth1
argument_list|,
name|auth2
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|similarity
operator|>
literal|0.8
condition|)
block|{
return|return
name|Util
operator|.
name|EQUAL
return|;
block|}
else|else
block|{
return|return
name|Util
operator|.
name|NOT_EQUAL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"pages"
argument_list|)
condition|)
block|{
comment|// Pages can be given with a variety of delimiters, "-", "--", " - ", " -- ".
comment|// We do a replace to harmonize these to a simple "-":
comment|// After this, a simple test for equality should be enough:
name|s1
operator|=
name|s1
operator|.
name|replaceAll
argument_list|(
literal|"[- ]+"
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|s2
operator|=
name|s2
operator|.
name|replaceAll
argument_list|(
literal|"[- ]+"
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
operator|.
name|equals
argument_list|(
name|s2
argument_list|)
condition|)
block|{
return|return
name|Util
operator|.
name|EQUAL
return|;
block|}
else|else
block|{
return|return
name|Util
operator|.
name|NOT_EQUAL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"journal"
argument_list|)
condition|)
block|{
comment|// We do not attempt to harmonize abbreviation state of the journal names,
comment|// but we remove periods from the names in case they are abbreviated with
comment|// and without dots:
name|s1
operator|=
name|s1
operator|.
name|replaceAll
argument_list|(
literal|"\\."
argument_list|,
literal|""
argument_list|)
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|s2
operator|=
name|s2
operator|.
name|replaceAll
argument_list|(
literal|"\\."
argument_list|,
literal|""
argument_list|)
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
comment|//System.out.println(s1+" :: "+s2);
name|double
name|similarity
init|=
name|DuplicateCheck
operator|.
name|correlateByWords
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|similarity
operator|>
literal|0.8
condition|)
block|{
return|return
name|Util
operator|.
name|EQUAL
return|;
block|}
else|else
block|{
return|return
name|Util
operator|.
name|NOT_EQUAL
return|;
block|}
block|}
else|else
block|{
name|s1
operator|=
name|s1
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|s2
operator|=
name|s2
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|double
name|similarity
init|=
name|DuplicateCheck
operator|.
name|correlateByWords
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|similarity
operator|>
literal|0.8
condition|)
block|{
return|return
name|Util
operator|.
name|EQUAL
return|;
block|}
else|else
block|{
return|return
name|Util
operator|.
name|NOT_EQUAL
return|;
comment|/*if (s1.trim().equals(s2.trim()))                 return Util.EQUAL;             else                 return Util.NOT_EQUAL;*/
block|}
block|}
block|}
DECL|method|compareEntriesStrictly (BibtexEntry one, BibtexEntry two)
specifier|public
specifier|static
name|double
name|compareEntriesStrictly
parameter_list|(
name|BibtexEntry
name|one
parameter_list|,
name|BibtexEntry
name|two
parameter_list|)
block|{
name|HashSet
argument_list|<
name|String
argument_list|>
name|allFields
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// one.getAllFields());
name|allFields
operator|.
name|addAll
argument_list|(
name|one
operator|.
name|getAllFields
argument_list|()
argument_list|)
expr_stmt|;
name|allFields
operator|.
name|addAll
argument_list|(
name|two
operator|.
name|getAllFields
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|score
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|allFields
control|)
block|{
name|Object
name|en
init|=
name|one
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|,
name|to
init|=
name|two
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|en
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|to
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|en
operator|.
name|equals
argument_list|(
name|to
argument_list|)
operator|)
condition|)
block|{
name|score
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|en
operator|==
literal|null
operator|)
operator|&&
operator|(
name|to
operator|==
literal|null
operator|)
condition|)
block|{
name|score
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|score
operator|==
name|allFields
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|1.01
return|;
comment|// Just to make sure we can
comment|// use score>1 without
comment|// trouble.
block|}
else|else
block|{
return|return
operator|(
operator|(
name|double
operator|)
name|score
operator|)
operator|/
name|allFields
operator|.
name|size
argument_list|()
return|;
block|}
block|}
comment|/**      * Goes through all entries in the given database, and if at least one of      * them is a duplicate of the given entry, as per      * Util.isDuplicate(BibtexEntry, BibtexEntry), the duplicate is returned.      * The search is terminated when the first duplicate is found.      *      * @param database The database to search.      * @param entry    The entry of which we are looking for duplicates.      * @return The first duplicate entry found. null if no duplicates are found.      */
DECL|method|containsDuplicate (BibtexDatabase database, BibtexEntry entry)
specifier|public
specifier|static
name|BibtexEntry
name|containsDuplicate
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|)
block|{
for|for
control|(
name|BibtexEntry
name|other
range|:
name|database
operator|.
name|getEntries
argument_list|()
control|)
block|{
if|if
condition|(
name|DuplicateCheck
operator|.
name|isDuplicate
argument_list|(
name|entry
argument_list|,
name|other
argument_list|)
condition|)
block|{
return|return
name|other
return|;
comment|// Duplicate found.
block|}
block|}
return|return
literal|null
return|;
comment|// No duplicate found.
block|}
comment|/**      * Compare two strings on the basis of word-by-word correlation analysis.      * @param s1 The first string      * @param s2 The second string      * @param truncate if true, always truncate the longer of two words to be compared to      *   harmonize their length. If false, use interpolation to harmonize the strings.      * @return a value in the interval [0, 1] indicating the degree of match.      */
DECL|method|correlateByWords (String s1, String s2, boolean truncate)
specifier|private
specifier|static
name|double
name|correlateByWords
parameter_list|(
name|String
name|s1
parameter_list|,
name|String
name|s2
parameter_list|,
name|boolean
name|truncate
parameter_list|)
block|{
name|String
index|[]
name|w1
init|=
name|s1
operator|.
name|split
argument_list|(
literal|"\\s"
argument_list|)
decl_stmt|,
name|w2
init|=
name|s2
operator|.
name|split
argument_list|(
literal|"\\s"
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|Math
operator|.
name|min
argument_list|(
name|w1
operator|.
name|length
argument_list|,
name|w2
operator|.
name|length
argument_list|)
decl_stmt|;
name|int
name|misses
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/*if (!w1[i].equalsIgnoreCase(w2[i]))                 misses++;*/
name|double
name|corr
init|=
name|DuplicateCheck
operator|.
name|correlateStrings
argument_list|(
name|w1
index|[
name|i
index|]
argument_list|,
name|w2
index|[
name|i
index|]
argument_list|,
name|truncate
argument_list|)
decl_stmt|;
if|if
condition|(
name|corr
operator|<
literal|0.75
condition|)
block|{
name|misses
operator|++
expr_stmt|;
block|}
block|}
name|double
name|missRate
init|=
operator|(
operator|(
name|double
operator|)
name|misses
operator|)
operator|/
operator|(
operator|(
name|double
operator|)
name|n
operator|)
decl_stmt|;
return|return
literal|1
operator|-
name|missRate
return|;
block|}
DECL|method|correlateStrings (String s1, String s2, boolean truncate)
specifier|private
specifier|static
name|double
name|correlateStrings
parameter_list|(
name|String
name|s1
parameter_list|,
name|String
name|s2
parameter_list|,
name|boolean
name|truncate
parameter_list|)
block|{
name|int
name|minLength
init|=
name|Math
operator|.
name|min
argument_list|(
name|s1
operator|.
name|length
argument_list|()
argument_list|,
name|s2
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|truncate
operator|&&
operator|(
name|minLength
operator|==
literal|1
operator|)
condition|)
block|{
return|return
name|s1
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|s2
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|?
literal|1.0
else|:
literal|0.0
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|s1
operator|.
name|length
argument_list|()
operator|==
literal|1
operator|)
operator|&&
operator|(
name|s2
operator|.
name|length
argument_list|()
operator|==
literal|1
operator|)
condition|)
block|{
return|return
name|s1
operator|.
name|equals
argument_list|(
name|s2
argument_list|)
condition|?
literal|1.0
else|:
literal|0.0
return|;
block|}
elseif|else
if|if
condition|(
name|minLength
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|s1
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|(
name|s2
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
condition|?
literal|1.0
else|:
literal|0
return|;
block|}
comment|// Convert strings to numbers and harmonize length in a method dependent on truncate:
if|if
condition|(
name|truncate
condition|)
block|{
comment|// Harmonize length by truncation:
if|if
condition|(
name|s1
operator|.
name|length
argument_list|()
operator|>
name|minLength
condition|)
block|{
name|s1
operator|=
name|s1
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|minLength
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s2
operator|.
name|length
argument_list|()
operator|>
name|minLength
condition|)
block|{
name|s2
operator|=
name|s2
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|minLength
argument_list|)
expr_stmt|;
block|}
block|}
name|double
index|[]
name|n1
init|=
name|DuplicateCheck
operator|.
name|numberizeString
argument_list|(
name|s1
argument_list|)
decl_stmt|,
name|n2
init|=
name|DuplicateCheck
operator|.
name|numberizeString
argument_list|(
name|s2
argument_list|)
decl_stmt|;
comment|// If truncation is disabled, harmonize length by interpolation:
if|if
condition|(
operator|!
name|truncate
condition|)
block|{
if|if
condition|(
name|n1
operator|.
name|length
operator|<
name|n2
operator|.
name|length
condition|)
block|{
name|n1
operator|=
name|DuplicateCheck
operator|.
name|stretchArray
argument_list|(
name|n1
argument_list|,
name|n2
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n2
operator|.
name|length
operator|<
name|n1
operator|.
name|length
condition|)
block|{
name|n2
operator|=
name|DuplicateCheck
operator|.
name|stretchArray
argument_list|(
name|n2
argument_list|,
name|n1
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|DuplicateCheck
operator|.
name|corrCoef
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|)
return|;
block|}
DECL|method|corrCoef (double[] n1, double[] n2)
specifier|private
specifier|static
name|double
name|corrCoef
parameter_list|(
name|double
index|[]
name|n1
parameter_list|,
name|double
index|[]
name|n2
parameter_list|)
block|{
comment|// Calculate mean values:
name|double
name|mean1
init|=
literal|0
decl_stmt|,
name|mean2
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n1
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|mean1
operator|+=
name|n1
index|[
name|i
index|]
expr_stmt|;
name|mean2
operator|+=
name|n2
index|[
name|i
index|]
expr_stmt|;
block|}
name|mean1
operator|/=
name|n1
operator|.
name|length
expr_stmt|;
name|mean2
operator|/=
name|n2
operator|.
name|length
expr_stmt|;
name|double
name|sigma1
init|=
literal|0
decl_stmt|,
name|sigma2
init|=
literal|0
decl_stmt|;
comment|// Calculate correlation coefficient:
name|double
name|corr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n1
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sigma1
operator|+=
operator|(
name|n1
index|[
name|i
index|]
operator|-
name|mean1
operator|)
operator|*
operator|(
name|n1
index|[
name|i
index|]
operator|-
name|mean1
operator|)
expr_stmt|;
name|sigma2
operator|+=
operator|(
name|n2
index|[
name|i
index|]
operator|-
name|mean2
operator|)
operator|*
operator|(
name|n2
index|[
name|i
index|]
operator|-
name|mean2
operator|)
expr_stmt|;
name|corr
operator|+=
operator|(
name|n1
index|[
name|i
index|]
operator|-
name|mean1
operator|)
operator|*
operator|(
name|n2
index|[
name|i
index|]
operator|-
name|mean2
operator|)
expr_stmt|;
block|}
name|sigma1
operator|=
name|Math
operator|.
name|sqrt
argument_list|(
name|sigma1
argument_list|)
expr_stmt|;
name|sigma2
operator|=
name|Math
operator|.
name|sqrt
argument_list|(
name|sigma2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sigma1
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sigma2
operator|>
literal|0
operator|)
condition|)
block|{
return|return
name|corr
operator|/
operator|(
name|sigma1
operator|*
name|sigma2
operator|)
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|method|numberizeString (String s)
specifier|private
specifier|static
name|double
index|[]
name|numberizeString
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|double
index|[]
name|res
init|=
operator|new
name|double
index|[
name|s
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|res
index|[
name|i
index|]
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
DECL|method|stretchArray (double[] array, int length)
specifier|private
specifier|static
name|double
index|[]
name|stretchArray
parameter_list|(
name|double
index|[]
name|array
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
operator|(
name|length
operator|<=
name|array
operator|.
name|length
operator|)
operator|||
operator|(
name|array
operator|.
name|length
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|array
return|;
block|}
name|double
name|multip
init|=
operator|(
operator|(
name|double
operator|)
name|array
operator|.
name|length
operator|)
operator|/
operator|(
operator|(
name|double
operator|)
name|length
operator|)
decl_stmt|;
name|double
index|[]
name|newArray
init|=
operator|new
name|double
index|[
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newArray
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|double
name|index
init|=
operator|(
name|i
operator|)
operator|*
name|multip
decl_stmt|;
name|int
name|baseInd
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|double
name|dist
init|=
name|index
operator|-
name|Math
operator|.
name|floor
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|newArray
index|[
name|i
index|]
operator|=
operator|(
name|dist
operator|*
name|array
index|[
name|Math
operator|.
name|min
argument_list|(
name|array
operator|.
name|length
operator|-
literal|1
argument_list|,
name|baseInd
operator|+
literal|1
argument_list|)
index|]
operator|)
operator|+
operator|(
operator|(
literal|1.0
operator|-
name|dist
operator|)
operator|*
name|array
index|[
name|baseInd
index|]
operator|)
expr_stmt|;
block|}
return|return
name|newArray
return|;
block|}
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|String
name|d1
init|=
literal|"Characterization of Calanus finmarchicus habitat in the North Sea"
decl_stmt|,
name|d2
init|=
literal|"Characterization of Calunus finmarchicus habitat in the North Sea"
decl_stmt|,
name|d3
init|=
literal|"Characterization of Calanus glacialissss habitat in the South Sea"
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|DuplicateCheck
operator|.
name|correlateByWords
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|DuplicateCheck
operator|.
name|correlateByWords
argument_list|(
name|d1
argument_list|,
name|d3
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|DuplicateCheck
operator|.
name|correlateByWords
argument_list|(
name|d2
argument_list|,
name|d3
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

