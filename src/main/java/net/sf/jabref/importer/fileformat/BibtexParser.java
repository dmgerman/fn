begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003-2015 JabRef contributors.     This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License along     with this program; if not, write to the Free Software Foundation, Inc.,     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */
end_comment

begin_package
DECL|package|net.sf.jabref.importer.fileformat
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|importer
operator|.
name|fileformat
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PushbackReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|bibtex
operator|.
name|EntryTypes
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|CustomEntryTypesManager
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|KeyCollisionException
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|importer
operator|.
name|ParserResult
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|l10n
operator|.
name|Localization
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|logic
operator|.
name|util
operator|.
name|strings
operator|.
name|StringUtil
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|database
operator|.
name|BibDatabase
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|model
operator|.
name|entry
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_comment
comment|/**  * Class for importing BibTeX-files.  *<p>  * Use:  *<p>  * BibtexParser parser = new BibtexParser(reader);  *<p>  * ParserResult result = parser.parse();  *<p>  * or  *<p>  * ParserResult result = BibtexParser.parse(reader);  *<p>  * Can be used stand-alone.  */
end_comment

begin_class
DECL|class|BibtexParser
specifier|public
class|class
name|BibtexParser
block|{
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Log
name|LOGGER
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|BibtexParser
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|pushbackReader
specifier|private
specifier|final
name|PushbackReader
name|pushbackReader
decl_stmt|;
DECL|field|database
specifier|private
name|BibDatabase
name|database
decl_stmt|;
DECL|field|entryTypes
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|EntryType
argument_list|>
name|entryTypes
decl_stmt|;
DECL|field|eof
specifier|private
name|boolean
name|eof
decl_stmt|;
DECL|field|line
specifier|private
name|int
name|line
init|=
literal|1
decl_stmt|;
DECL|field|fieldContentParser
specifier|private
specifier|final
name|FieldContentParser
name|fieldContentParser
init|=
operator|new
name|FieldContentParser
argument_list|()
decl_stmt|;
DECL|field|parserResult
specifier|private
name|ParserResult
name|parserResult
decl_stmt|;
DECL|field|LOOKAHEAD
specifier|private
specifier|static
specifier|final
name|Integer
name|LOOKAHEAD
init|=
literal|64
decl_stmt|;
DECL|field|autoDoubleBraces
specifier|private
specifier|final
name|boolean
name|autoDoubleBraces
decl_stmt|;
DECL|field|pureTextFromFile
specifier|private
specifier|final
name|Deque
argument_list|<
name|Character
argument_list|>
name|pureTextFromFile
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|BibtexParser (Reader in)
specifier|public
name|BibtexParser
parameter_list|(
name|Reader
name|in
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|==
literal|null
condition|)
block|{
name|Globals
operator|.
name|prefs
operator|=
name|JabRefPreferences
operator|.
name|getInstance
argument_list|()
expr_stmt|;
block|}
name|autoDoubleBraces
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|AUTO_DOUBLE_BRACES
argument_list|)
expr_stmt|;
name|pushbackReader
operator|=
operator|new
name|PushbackReader
argument_list|(
name|in
argument_list|,
name|BibtexParser
operator|.
name|LOOKAHEAD
argument_list|)
expr_stmt|;
block|}
comment|/**      * Shortcut usage to create a Parser and read the input.      *      * @param in the Reader to read from      * @throws IOException      */
DECL|method|parse (Reader in)
specifier|public
specifier|static
name|ParserResult
name|parse
parameter_list|(
name|Reader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|BibtexParser
name|parser
init|=
operator|new
name|BibtexParser
argument_list|(
name|in
argument_list|)
decl_stmt|;
return|return
name|parser
operator|.
name|parse
argument_list|()
return|;
block|}
comment|/**      * Parses BibtexEntries from the given string and returns the collection of all entries found.      *      * @param bibtexString      * @return Returns null if an error occurred, returns an empty collection if no entries where found.      */
DECL|method|fromString (String bibtexString)
specifier|public
specifier|static
name|Collection
argument_list|<
name|BibEntry
argument_list|>
name|fromString
parameter_list|(
name|String
name|bibtexString
parameter_list|)
block|{
name|StringReader
name|reader
init|=
operator|new
name|StringReader
argument_list|(
name|bibtexString
argument_list|)
decl_stmt|;
name|BibtexParser
name|parser
init|=
operator|new
name|BibtexParser
argument_list|(
name|reader
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|parser
operator|.
name|parse
argument_list|()
operator|.
name|getDatabase
argument_list|()
operator|.
name|getEntries
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Parses BibtexEntries from the given string and returns one entry found (or null if none found)      *<p>      * It is undetermined which entry is returned, so use this in case you know there is only one entry in the string.      *      * @param bibtexString      * @return The BibEntry or null if non was found or an error occurred.      */
DECL|method|singleFromString (String bibtexString)
specifier|public
specifier|static
name|BibEntry
name|singleFromString
parameter_list|(
name|String
name|bibtexString
parameter_list|)
block|{
name|Collection
argument_list|<
name|BibEntry
argument_list|>
name|entries
init|=
name|BibtexParser
operator|.
name|fromString
argument_list|(
name|bibtexString
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|entries
operator|==
literal|null
operator|)
operator|||
name|entries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|entries
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
comment|/**      * Check whether the source is in the correct format for this importer.      */
DECL|method|isRecognizedFormat (Reader reader)
specifier|public
specifier|static
name|boolean
name|isRecognizedFormat
parameter_list|(
name|Reader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Our strategy is to look for the "@<type>    {" line.
name|BufferedReader
name|in
init|=
operator|new
name|BufferedReader
argument_list|(
name|reader
argument_list|)
decl_stmt|;
name|Pattern
name|formatPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"@[a-zA-Z]*\\s*\\{"
argument_list|)
decl_stmt|;
name|String
name|bibtexString
decl_stmt|;
while|while
condition|(
operator|(
name|bibtexString
operator|=
name|in
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|formatPattern
operator|.
name|matcher
argument_list|(
name|bibtexString
argument_list|)
operator|.
name|find
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Will parse the BibTex-Data found when reading from reader.      *<p>      * The reader will be consumed.      *<p>      * Multiple calls to parse() return the same results      *      * @return ParserResult      * @throws IOException      */
DECL|method|parse ()
specifier|public
name|ParserResult
name|parse
parameter_list|()
throws|throws
name|IOException
block|{
comment|// If we already parsed this, just return it.
if|if
condition|(
name|parserResult
operator|!=
literal|null
condition|)
block|{
return|return
name|parserResult
return|;
block|}
comment|// Bibtex related contents.
name|initializeParserResult
argument_list|()
expr_stmt|;
name|skipWhitespace
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|parseFileContent
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|KeyCollisionException
name|kce
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Duplicate ID in bibtex file: "
operator|+
name|kce
argument_list|)
throw|;
block|}
block|}
DECL|method|initializeParserResult ()
specifier|private
name|void
name|initializeParserResult
parameter_list|()
block|{
name|database
operator|=
operator|new
name|BibDatabase
argument_list|()
expr_stmt|;
name|entryTypes
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
comment|// To store custem entry types parsed.
name|parserResult
operator|=
operator|new
name|ParserResult
argument_list|(
name|database
argument_list|,
literal|null
argument_list|,
name|entryTypes
argument_list|)
expr_stmt|;
block|}
DECL|method|parseFileContent ()
specifier|private
name|ParserResult
name|parseFileContent
parameter_list|()
throws|throws
name|IOException
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|meta
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|eof
condition|)
block|{
name|boolean
name|found
init|=
name|consumeUncritically
argument_list|(
literal|'@'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
break|break;
block|}
name|skipWhitespace
argument_list|()
expr_stmt|;
comment|// try to read the entry type
name|String
name|entryType
init|=
name|parseTextToken
argument_list|()
decl_stmt|;
name|EntryType
name|type
init|=
name|EntryTypes
operator|.
name|getType
argument_list|(
name|entryType
argument_list|)
decl_stmt|;
name|boolean
name|isEntry
init|=
name|type
operator|!=
literal|null
decl_stmt|;
comment|// The entry type name was not recognized. This can mean
comment|// that it is a string, preamble, or comment. If so,
comment|// parse and set accordingly. If not, assume it is an entry
comment|// with an unknown type.
if|if
condition|(
operator|!
name|isEntry
condition|)
block|{
if|if
condition|(
literal|"preamble"
operator|.
name|equals
argument_list|(
name|entryType
operator|.
name|toLowerCase
argument_list|()
argument_list|)
condition|)
block|{
name|database
operator|.
name|setPreamble
argument_list|(
name|parsePreamble
argument_list|()
argument_list|)
expr_stmt|;
comment|// the preamble is saved verbatim anyways, so the text read so far can be dropped
name|dumpTextReadSoFarToString
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"string"
operator|.
name|equals
argument_list|(
name|entryType
operator|.
name|toLowerCase
argument_list|()
argument_list|)
condition|)
block|{
name|parseBibtexString
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"comment"
operator|.
name|equals
argument_list|(
name|entryType
operator|.
name|toLowerCase
argument_list|()
argument_list|)
condition|)
block|{
name|parseJabRefComment
argument_list|(
name|meta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The entry type was not recognized. This may mean that
comment|// it is a custom entry type whose definition will
comment|// appear
comment|// at the bottom of the file. So we use an
comment|// UnknownEntryType
comment|// to remember the type name by.
name|type
operator|=
operator|new
name|UnknownEntryType
argument_list|(
name|EntryUtil
operator|.
name|capitalizeFirst
argument_list|(
name|entryType
argument_list|)
argument_list|)
expr_stmt|;
name|isEntry
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// True if not comment, preamble or string.
if|if
condition|(
name|isEntry
condition|)
block|{
name|parseAndAddEntry
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|skipWhitespace
argument_list|()
expr_stmt|;
block|}
comment|// Before returning the database, update entries with unknown type
comment|// based on parsed type definitions, if possible.
name|checkEntryTypes
argument_list|(
name|parserResult
argument_list|)
expr_stmt|;
comment|// Instantiate meta data:
name|parserResult
operator|.
name|setMetaData
argument_list|(
operator|new
name|MetaData
argument_list|(
name|meta
argument_list|,
name|database
argument_list|)
argument_list|)
expr_stmt|;
name|parseRemainingContent
argument_list|()
expr_stmt|;
return|return
name|parserResult
return|;
block|}
DECL|method|parseRemainingContent ()
specifier|private
name|void
name|parseRemainingContent
parameter_list|()
block|{
name|database
operator|.
name|setEpilog
argument_list|(
name|dumpTextReadSoFarToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|parseAndAddEntry (EntryType type)
specifier|private
name|void
name|parseAndAddEntry
parameter_list|(
name|EntryType
name|type
parameter_list|)
block|{
comment|/**          * Morten Alver 13 Aug 2006: Trying to make the parser more          * robust. If an exception is thrown when parsing an entry,          * drop the entry and try to resume parsing. Add a warning          * for the user.          */
try|try
block|{
name|BibEntry
name|entry
init|=
name|parseEntry
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|boolean
name|duplicateKey
init|=
name|database
operator|.
name|insertEntry
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|entry
operator|.
name|setParsedSerialization
argument_list|(
name|dumpTextReadSoFarToString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|duplicateKey
condition|)
block|{
name|parserResult
operator|.
name|addDuplicateKey
argument_list|(
name|entry
operator|.
name|getCiteKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|entry
operator|.
name|getCiteKey
argument_list|()
operator|==
literal|null
operator|)
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|entry
operator|.
name|getCiteKey
argument_list|()
argument_list|)
condition|)
block|{
name|parserResult
operator|.
name|addWarning
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Empty BibTeX key"
argument_list|)
operator|+
literal|": "
operator|+
name|entry
operator|.
name|getAuthorTitleYear
argument_list|(
literal|40
argument_list|)
operator|+
literal|" ("
operator|+
name|Localization
operator|.
name|lang
argument_list|(
literal|"Grouping may not work for this entry."
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Could not parse entry"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|parserResult
operator|.
name|addWarning
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Error occurred when parsing entry"
argument_list|)
operator|+
literal|": '"
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
operator|+
literal|"'. "
operator|+
name|Localization
operator|.
name|lang
argument_list|(
literal|"Skipped entry."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|parseJabRefComment (HashMap<String, String> meta)
specifier|private
name|void
name|parseJabRefComment
parameter_list|(
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|meta
parameter_list|)
throws|throws
name|IOException
block|{
name|StringBuffer
name|buffer
init|=
name|parseBracketedTextExactly
argument_list|()
decl_stmt|;
comment|/**          *          * Metadata are used to store Bibkeeper-specific          * information in .bib files.          *          * Metadata are stored in bibtex files in the format          *          * @comment{jabref-meta: type:data0;data1;data2;...}          *          * Each comment that starts with the META_FLAG is stored          * in the meta HashMap, with type as key. Unluckily, the          * old META_FLAG bibkeeper-meta: was used in JabRef 1.0          * and 1.1, so we need to support it as well. At least          * for a while. We'll always save with the new one.          */
name|String
name|comment
init|=
name|buffer
operator|.
name|toString
argument_list|()
operator|.
name|replaceAll
argument_list|(
literal|"[\\x0d\\x0a]"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|comment
operator|.
name|length
argument_list|()
argument_list|,
name|MetaData
operator|.
name|META_FLAG
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
operator|.
name|equals
argument_list|(
name|MetaData
operator|.
name|META_FLAG
argument_list|)
condition|)
block|{
if|if
condition|(
name|comment
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|MetaData
operator|.
name|META_FLAG
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|MetaData
operator|.
name|META_FLAG
argument_list|)
condition|)
block|{
name|String
name|rest
init|=
name|comment
operator|.
name|substring
argument_list|(
name|MetaData
operator|.
name|META_FLAG
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|rest
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
block|{
comment|// We remove all line breaks in the metadata - these
comment|// will have been inserted
comment|// to prevent too long lines when the file was
comment|// saved, and are not part of the data.
name|meta
operator|.
name|put
argument_list|(
name|rest
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|pos
argument_list|)
argument_list|,
name|rest
operator|.
name|substring
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// meta comments are always re-written by JabRef and not stored in the file
name|dumpTextReadSoFarToString
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|comment
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|comment
operator|.
name|length
argument_list|()
argument_list|,
name|CustomEntryType
operator|.
name|ENTRYTYPE_FLAG
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
operator|.
name|equals
argument_list|(
name|CustomEntryType
operator|.
name|ENTRYTYPE_FLAG
argument_list|)
condition|)
block|{
comment|// A custom entry type can also be stored in a
comment|// "@comment"
name|CustomEntryType
name|typ
init|=
name|CustomEntryTypesManager
operator|.
name|parseEntryType
argument_list|(
name|comment
argument_list|)
decl_stmt|;
name|entryTypes
operator|.
name|put
argument_list|(
name|typ
operator|.
name|getName
argument_list|()
argument_list|,
name|typ
argument_list|)
expr_stmt|;
comment|// custom entry types are always re-written by JabRef and not stored in the file
name|dumpTextReadSoFarToString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// FIXME: user comments are simply dropped
comment|// at least, we log that we ignored the comment
name|LOGGER
operator|.
name|info
argument_list|(
literal|"Dropped comment from database: "
operator|+
name|comment
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|parseBibtexString ()
specifier|private
name|void
name|parseBibtexString
parameter_list|()
throws|throws
name|IOException
block|{
name|BibtexString
name|bibtexString
init|=
name|parseString
argument_list|()
decl_stmt|;
name|bibtexString
operator|.
name|setParsedSerialization
argument_list|(
name|dumpTextReadSoFarToString
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|database
operator|.
name|addString
argument_list|(
name|bibtexString
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeyCollisionException
name|ex
parameter_list|)
block|{
name|parserResult
operator|.
name|addWarning
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Duplicate string name"
argument_list|)
operator|+
literal|": "
operator|+
name|bibtexString
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Puts all text that has been read from the reader, including newlines, etc., since the last call of this method into a string.      * Removes the JabRef file header, if it is found      *      * @return the text read so far      */
DECL|method|dumpTextReadSoFarToString ()
specifier|private
name|String
name|dumpTextReadSoFarToString
parameter_list|()
block|{
name|StringBuilder
name|entry
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|pureTextFromFile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|entry
operator|.
name|append
argument_list|(
name|pureTextFromFile
operator|.
name|pollFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|result
init|=
name|entry
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|indexOfAt
init|=
name|entry
operator|.
name|indexOf
argument_list|(
literal|"@"
argument_list|)
decl_stmt|;
comment|// if there is no entry found, simply return the content (necessary to parse text remaining after the last entry)
if|if
condition|(
name|indexOfAt
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|purgeEOFCharacters
argument_list|(
name|entry
argument_list|)
return|;
block|}
else|else
block|{
comment|//skip all text except newlines and whitespaces before first @. This is necessary to remove the file header
name|int
name|runningIndex
init|=
name|indexOfAt
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|runningIndex
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|result
operator|.
name|charAt
argument_list|(
name|runningIndex
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
name|runningIndex
operator|--
expr_stmt|;
block|}
name|result
operator|=
name|result
operator|.
name|substring
argument_list|(
name|runningIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|/**      * Removes all eof characters from a StringBuilder and returns a new String with the resulting content      *      * @return a String without eof characters      */
DECL|method|purgeEOFCharacters (StringBuilder input)
specifier|private
name|String
name|purgeEOFCharacters
parameter_list|(
name|StringBuilder
name|input
parameter_list|)
block|{
name|StringBuilder
name|remainingText
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Character
name|character
range|:
name|input
operator|.
name|toString
argument_list|()
operator|.
name|toCharArray
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|isEOFCharacter
argument_list|(
name|character
argument_list|)
operator|)
condition|)
block|{
name|remainingText
operator|.
name|append
argument_list|(
name|character
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|remainingText
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|skipWhitespace ()
specifier|private
name|void
name|skipWhitespace
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|character
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|character
operator|=
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|isEOFCharacter
argument_list|(
name|character
argument_list|)
condition|)
block|{
name|eof
operator|=
literal|true
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
condition|)
block|{
continue|continue;
block|}
else|else
block|{
comment|// found non-whitespace char
name|unread
argument_list|(
name|character
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
DECL|method|isEOFCharacter (int character)
specifier|private
name|boolean
name|isEOFCharacter
parameter_list|(
name|int
name|character
parameter_list|)
block|{
return|return
operator|(
name|character
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|character
operator|==
literal|65535
operator|)
return|;
block|}
DECL|method|skipAndRecordWhitespace (int character)
specifier|private
name|String
name|skipAndRecordWhitespace
parameter_list|(
name|int
name|character
parameter_list|)
throws|throws
name|IOException
block|{
name|StringBuilder
name|stringBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|character
operator|!=
literal|' '
condition|)
block|{
name|stringBuilder
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|nextCharacter
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|isEOFCharacter
argument_list|(
name|nextCharacter
argument_list|)
condition|)
block|{
name|eof
operator|=
literal|true
expr_stmt|;
return|return
name|stringBuilder
operator|.
name|toString
argument_list|()
return|;
block|}
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
operator|(
name|char
operator|)
name|nextCharacter
argument_list|)
condition|)
block|{
if|if
condition|(
name|nextCharacter
operator|!=
literal|' '
condition|)
block|{
name|stringBuilder
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|nextCharacter
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
else|else
block|{
comment|// found non-whitespace char
name|unread
argument_list|(
name|nextCharacter
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|stringBuilder
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|peek ()
specifier|private
name|int
name|peek
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|character
init|=
name|read
argument_list|()
decl_stmt|;
name|unread
argument_list|(
name|character
argument_list|)
expr_stmt|;
return|return
name|character
return|;
block|}
DECL|method|read ()
specifier|private
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|character
init|=
name|pushbackReader
operator|.
name|read
argument_list|()
decl_stmt|;
name|pureTextFromFile
operator|.
name|offerLast
argument_list|(
name|Character
operator|.
name|valueOf
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|character
operator|==
literal|'\n'
condition|)
block|{
name|line
operator|++
expr_stmt|;
block|}
return|return
name|character
return|;
block|}
DECL|method|unread (int character)
specifier|private
name|void
name|unread
parameter_list|(
name|int
name|character
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|character
operator|==
literal|'\n'
condition|)
block|{
name|line
operator|--
expr_stmt|;
block|}
name|pushbackReader
operator|.
name|unread
argument_list|(
name|character
argument_list|)
expr_stmt|;
name|pureTextFromFile
operator|.
name|pollLast
argument_list|()
expr_stmt|;
block|}
DECL|method|parseString ()
specifier|private
name|BibtexString
name|parseString
parameter_list|()
throws|throws
name|IOException
block|{
name|skipWhitespace
argument_list|()
expr_stmt|;
name|consume
argument_list|(
literal|'{'
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
comment|// while (read() != '}');
name|skipWhitespace
argument_list|()
expr_stmt|;
comment|// Util.pr("Parsing string name");
name|String
name|name
init|=
name|parseTextToken
argument_list|()
decl_stmt|;
comment|// Util.pr("Parsed string name");
name|skipWhitespace
argument_list|()
expr_stmt|;
comment|// Util.pr("Now the contents");
name|consume
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|String
name|content
init|=
name|parseFieldContent
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|// Util.pr("Now I'm going to consume a }");
name|consume
argument_list|(
literal|'}'
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
comment|// Util.pr("Finished string parsing.");
name|String
name|id
init|=
name|IdGenerator
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
operator|new
name|BibtexString
argument_list|(
name|id
argument_list|,
name|name
argument_list|,
name|content
argument_list|)
return|;
block|}
DECL|method|parsePreamble ()
specifier|private
name|String
name|parsePreamble
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|parseBracketedText
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|parseEntry (EntryType entryType)
specifier|private
name|BibEntry
name|parseEntry
parameter_list|(
name|EntryType
name|entryType
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|id
init|=
name|IdGenerator
operator|.
name|next
argument_list|()
decl_stmt|;
name|BibEntry
name|result
init|=
operator|new
name|BibEntry
argument_list|(
name|id
argument_list|,
name|entryType
argument_list|)
decl_stmt|;
name|skipWhitespace
argument_list|()
expr_stmt|;
name|consume
argument_list|(
literal|'{'
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|int
name|character
init|=
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|character
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|character
operator|!=
literal|'\r'
operator|)
condition|)
block|{
name|skipWhitespace
argument_list|()
expr_stmt|;
block|}
name|String
name|key
init|=
name|parseKey
argument_list|()
decl_stmt|;
name|result
operator|.
name|setField
argument_list|(
name|BibEntry
operator|.
name|KEY_FIELD
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|skipWhitespace
argument_list|()
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|character
operator|=
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|character
operator|==
literal|'}'
operator|)
operator|||
operator|(
name|character
operator|==
literal|')'
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|character
operator|==
literal|','
condition|)
block|{
name|consume
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|skipWhitespace
argument_list|()
expr_stmt|;
name|character
operator|=
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|character
operator|==
literal|'}'
operator|)
operator|||
operator|(
name|character
operator|==
literal|')'
operator|)
condition|)
block|{
break|break;
block|}
name|parseField
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|consume
argument_list|(
literal|'}'
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|method|parseField (BibEntry entry)
specifier|private
name|void
name|parseField
parameter_list|(
name|BibEntry
name|entry
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|key
init|=
name|parseTextToken
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
comment|// Util.pr("Field: _"+key+"_");
name|skipWhitespace
argument_list|()
expr_stmt|;
name|consume
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|String
name|content
init|=
name|parseFieldContent
argument_list|(
name|key
argument_list|)
decl_stmt|;
comment|// Now, if the field in question is set up to be fitted automatically
comment|// with braces around
comment|// capitals, we should remove those now when reading the field:
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|putBracesAroundCapitals
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|content
operator|=
name|StringUtil
operator|.
name|removeBracesAroundCapitals
argument_list|(
name|content
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|content
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|entry
operator|.
name|getField
argument_list|(
name|key
argument_list|)
operator|==
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|key
argument_list|,
name|content
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The following hack enables the parser to deal with multiple
comment|// author or
comment|// editor lines, stringing them together instead of getting just
comment|// one of them.
comment|// Multiple author or editor lines are not allowed by the bibtex
comment|// format, but
comment|// at least one online database exports bibtex like that, making
comment|// it inconvenient
comment|// for users if JabRef didn't accept it.
if|if
condition|(
literal|"author"
operator|.
name|equals
argument_list|(
name|key
argument_list|)
operator|||
literal|"editor"
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|key
argument_list|,
name|entry
operator|.
name|getField
argument_list|(
name|key
argument_list|)
operator|+
literal|" and "
operator|+
name|content
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|parseFieldContent (String key)
specifier|private
name|String
name|parseFieldContent
parameter_list|(
name|String
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|skipWhitespace
argument_list|()
expr_stmt|;
name|StringBuilder
name|value
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|character
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|character
operator|=
name|peek
argument_list|()
operator|)
operator|!=
literal|','
operator|)
operator|&&
operator|(
name|character
operator|!=
literal|'}'
operator|)
operator|&&
operator|(
name|character
operator|!=
literal|')'
operator|)
condition|)
block|{
if|if
condition|(
name|eof
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|": EOF in mid-string"
argument_list|)
throw|;
block|}
if|if
condition|(
name|character
operator|==
literal|'"'
condition|)
block|{
name|StringBuffer
name|text
init|=
name|parseQuotedFieldExactly
argument_list|()
decl_stmt|;
name|value
operator|.
name|append
argument_list|(
name|fieldContentParser
operator|.
name|format
argument_list|(
name|text
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
comment|/*                  *                  * The following code doesn't handle {"} correctly: // value is                  * a string consume('"');                  *                  * while (!((peek() == '"')&& (j != '\\'))) { j = read(); if                  * (_eof || (j == -1) || (j == 65535)) { throw new                  * RuntimeException("Error in line "+line+ ": EOF in                  * mid-string"); }                  *                  * value.append((char) j); }                  *                  * consume('"');                  */
block|}
elseif|else
if|if
condition|(
name|character
operator|==
literal|'{'
condition|)
block|{
comment|// Value is a string enclosed in brackets. There can be pairs
comment|// of brackets inside of a field, so we need to count the
comment|// brackets to know when the string is finished.
name|StringBuffer
name|text
init|=
name|parseBracketedTextExactly
argument_list|()
decl_stmt|;
name|value
operator|.
name|append
argument_list|(
name|fieldContentParser
operator|.
name|format
argument_list|(
name|text
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Character
operator|.
name|isDigit
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
condition|)
block|{
comment|// value is a number
name|String
name|number
init|=
name|parseTextToken
argument_list|()
decl_stmt|;
name|value
operator|.
name|append
argument_list|(
name|number
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|character
operator|==
literal|'#'
condition|)
block|{
name|consume
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|textToken
init|=
name|parseTextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|textToken
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|" or above: "
operator|+
literal|"Empty text token.\nThis could be caused "
operator|+
literal|"by a missing comma between two fields."
argument_list|)
throw|;
block|}
name|value
operator|.
name|append
argument_list|(
literal|"#"
argument_list|)
operator|.
name|append
argument_list|(
name|textToken
argument_list|)
operator|.
name|append
argument_list|(
literal|"#"
argument_list|)
expr_stmt|;
block|}
name|skipWhitespace
argument_list|()
expr_stmt|;
block|}
comment|// Check if we are to strip extra pairs of braces before returning:
if|if
condition|(
name|autoDoubleBraces
condition|)
block|{
comment|// Do it:
while|while
condition|(
operator|(
name|value
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|)
operator|&&
operator|(
name|value
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'{'
operator|)
operator|&&
operator|(
name|value
operator|.
name|charAt
argument_list|(
name|value
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'}'
operator|)
condition|)
block|{
name|value
operator|.
name|deleteCharAt
argument_list|(
name|value
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|value
operator|.
name|deleteCharAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// Problem: if the field content is "{DNA} blahblah {EPA}", one pair
comment|// too much will be removed.
comment|// Check if this is the case, and re-add as many pairs as needed.
while|while
condition|(
name|hasNegativeBraceCount
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|value
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|value
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|value
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Check if a string at any point has had more ending braces (}) than      * opening ones ({). Will e.g. return true for the string "DNA} blahblal      * {EPA"      *      * @param toCheck The string to check.      * @return true if at any index the brace count is negative.      */
DECL|method|hasNegativeBraceCount (String toCheck)
specifier|private
name|boolean
name|hasNegativeBraceCount
parameter_list|(
name|String
name|toCheck
parameter_list|)
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|braceCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|index
operator|<
name|toCheck
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
name|toCheck
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
operator|==
literal|'{'
condition|)
block|{
name|braceCount
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toCheck
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
operator|==
literal|'}'
condition|)
block|{
name|braceCount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|braceCount
operator|<
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|index
operator|++
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * This method is used to parse string labels, field names, entry type and      * numbers outside brackets.      */
DECL|method|parseTextToken ()
specifier|private
name|String
name|parseTextToken
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuilder
name|token
init|=
operator|new
name|StringBuilder
argument_list|(
literal|20
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|character
init|=
name|read
argument_list|()
decl_stmt|;
comment|// Util.pr(".. "+c);
if|if
condition|(
name|character
operator|==
operator|-
literal|1
condition|)
block|{
name|eof
operator|=
literal|true
expr_stmt|;
return|return
name|token
operator|.
name|toString
argument_list|()
return|;
block|}
if|if
condition|(
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
operator|||
operator|(
name|character
operator|==
literal|':'
operator|)
operator|||
operator|(
name|character
operator|==
literal|'-'
operator|)
operator|||
operator|(
name|character
operator|==
literal|'_'
operator|)
operator|||
operator|(
name|character
operator|==
literal|'*'
operator|)
operator|||
operator|(
name|character
operator|==
literal|'+'
operator|)
operator|||
operator|(
name|character
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|character
operator|==
literal|'/'
operator|)
operator|||
operator|(
name|character
operator|==
literal|'\''
operator|)
condition|)
block|{
name|token
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unread
argument_list|(
name|character
argument_list|)
expr_stmt|;
return|return
name|token
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
comment|/**      * Tries to restore the key      *      * @return rest of key on success, otherwise empty string      * @throws IOException on Reader-Error      */
DECL|method|fixKey ()
specifier|private
name|String
name|fixKey
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuilder
name|key
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|lookaheadUsed
init|=
literal|0
decl_stmt|;
name|char
name|currentChar
decl_stmt|;
comment|// Find a char which ends key (','&&'\n') or entryfield ('='):
do|do
block|{
name|currentChar
operator|=
operator|(
name|char
operator|)
name|read
argument_list|()
expr_stmt|;
name|key
operator|.
name|append
argument_list|(
name|currentChar
argument_list|)
expr_stmt|;
name|lookaheadUsed
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|currentChar
operator|!=
literal|','
operator|)
operator|&&
operator|(
name|currentChar
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|currentChar
operator|!=
literal|'='
operator|)
operator|&&
operator|(
name|lookaheadUsed
operator|<
name|BibtexParser
operator|.
name|LOOKAHEAD
operator|)
condition|)
do|;
comment|// Consumed a char too much, back into reader and remove from key:
name|unread
argument_list|(
name|currentChar
argument_list|)
expr_stmt|;
name|key
operator|.
name|deleteCharAt
argument_list|(
name|key
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Restore if possible:
switch|switch
condition|(
name|currentChar
condition|)
block|{
case|case
literal|'='
case|:
comment|// Get entryfieldname, push it back and take rest as key
name|key
operator|=
name|key
operator|.
name|reverse
argument_list|()
expr_stmt|;
name|boolean
name|matchedAlpha
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|key
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|currentChar
operator|=
name|key
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/// Skip spaces:
if|if
condition|(
operator|!
name|matchedAlpha
operator|&&
operator|(
name|currentChar
operator|==
literal|' '
operator|)
condition|)
block|{
continue|continue;
block|}
name|matchedAlpha
operator|=
literal|true
expr_stmt|;
comment|// Begin of entryfieldname (e.g. author) -> push back:
name|unread
argument_list|(
name|currentChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|currentChar
operator|==
literal|' '
operator|)
operator|||
operator|(
name|currentChar
operator|==
literal|'\n'
operator|)
condition|)
block|{
comment|/*                      * found whitespaces, entryfieldname completed -> key in                      * keybuffer, skip whitespaces                      */
name|StringBuilder
name|newKey
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|<
name|key
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|currentChar
operator|=
name|key
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|currentChar
argument_list|)
condition|)
block|{
name|newKey
operator|.
name|append
argument_list|(
name|currentChar
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Finished, now reverse newKey and remove whitespaces:
name|parserResult
operator|.
name|addWarning
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Line %0: Found corrupted BibTeX-key."
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|line
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|=
name|newKey
operator|.
name|reverse
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|','
case|:
name|parserResult
operator|.
name|addWarning
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Line %0: Found corrupted BibTeX-key (contains whitespaces)."
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|line
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
literal|'\n'
case|:
name|parserResult
operator|.
name|addWarning
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Line %0: Found corrupted BibTeX-key (comma missing)."
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|line
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// No more lookahead, give up:
name|unreadBuffer
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
return|return
name|removeWhitespaces
argument_list|(
name|key
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * returns a new<code>StringBuilder</code> which corresponds to<code>toRemove</code> without whitespaces      *      * @param toRemove      * @return      */
DECL|method|removeWhitespaces (StringBuilder toRemove)
specifier|private
name|StringBuilder
name|removeWhitespaces
parameter_list|(
name|StringBuilder
name|toRemove
parameter_list|)
block|{
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|char
name|current
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toRemove
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|current
operator|=
name|toRemove
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|current
argument_list|)
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**      * pushes buffer back into input      *      * @param stringBuilder      * @throws IOException can be thrown if buffer is bigger than LOOKAHEAD      */
DECL|method|unreadBuffer (StringBuilder stringBuilder)
specifier|private
name|void
name|unreadBuffer
parameter_list|(
name|StringBuilder
name|stringBuilder
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
name|stringBuilder
operator|.
name|length
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|unread
argument_list|(
name|stringBuilder
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This method is used to parse the bibtex key for an entry.      */
DECL|method|parseKey ()
specifier|private
name|String
name|parseKey
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuilder
name|token
init|=
operator|new
name|StringBuilder
argument_list|(
literal|20
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|character
init|=
name|read
argument_list|()
decl_stmt|;
comment|// Util.pr(".. '"+(char)c+"'\t"+c);
if|if
condition|(
name|character
operator|==
operator|-
literal|1
condition|)
block|{
name|eof
operator|=
literal|true
expr_stmt|;
return|return
name|token
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// Ikke: #{}\uFFFD~\uFFFD
comment|//
comment|// G\uFFFDr: $_*+.-\/?"^
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
operator|&&
operator|(
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
operator|||
operator|(
name|character
operator|==
literal|':'
operator|)
operator|||
operator|(
operator|(
name|character
operator|!=
literal|'#'
operator|)
operator|&&
operator|(
name|character
operator|!=
literal|'{'
operator|)
operator|&&
operator|(
name|character
operator|!=
literal|'}'
operator|)
operator|&&
operator|(
name|character
operator|!=
literal|'\uFFFD'
operator|)
operator|&&
operator|(
name|character
operator|!=
literal|'~'
operator|)
operator|&&
operator|(
name|character
operator|!=
literal|'\uFFFD'
operator|)
operator|&&
operator|(
name|character
operator|!=
literal|','
operator|)
operator|&&
operator|(
name|character
operator|!=
literal|'='
operator|)
operator|)
operator|)
condition|)
block|{
name|token
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
condition|)
block|{
comment|// We have encountered white space instead of the comma at
comment|// the end of
comment|// the key. Possibly the comma is missing, so we try to
comment|// return what we
comment|// have found, as the key and try to restore the rest in fixKey().
return|return
name|token
operator|+
name|fixKey
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|character
operator|==
literal|','
condition|)
block|{
name|unread
argument_list|(
name|character
argument_list|)
expr_stmt|;
return|return
name|token
operator|.
name|toString
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|character
operator|==
literal|'='
condition|)
block|{
comment|// If we find a '=' sign, it is either an error, or
comment|// the entry lacked a comma signifying the end of the key.
return|return
name|token
operator|.
name|toString
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|":"
operator|+
literal|"Character '"
operator|+
operator|(
name|char
operator|)
name|character
operator|+
literal|"' is not "
operator|+
literal|"allowed in bibtex keys."
argument_list|)
throw|;
block|}
block|}
block|}
block|}
DECL|method|parseBracketedText ()
specifier|private
name|StringBuffer
name|parseBracketedText
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuffer
name|value
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|consume
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|int
name|brackets
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|peek
argument_list|()
operator|==
literal|'}'
operator|)
operator|&&
operator|(
name|brackets
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|int
name|character
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|isEOFCharacter
argument_list|(
name|character
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|": EOF in mid-string"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|character
operator|==
literal|'{'
condition|)
block|{
name|brackets
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|character
operator|==
literal|'}'
condition|)
block|{
name|brackets
operator|--
expr_stmt|;
block|}
comment|// If we encounter whitespace of any kind, read it as a
comment|// simple space, and ignore any others that follow immediately.
comment|/*              * if (j == '\n') { if (peek() == '\n') value.append('\n'); } else              */
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
condition|)
block|{
name|String
name|whitespacesReduced
init|=
name|skipAndRecordWhitespace
argument_list|(
name|character
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
literal|""
operator|.
name|equals
argument_list|(
name|whitespacesReduced
argument_list|)
operator|&&
operator|!
literal|"\n\t"
operator|.
name|equals
argument_list|(
name|whitespacesReduced
argument_list|)
condition|)
block|{
comment|//&&
name|whitespacesReduced
operator|=
name|whitespacesReduced
operator|.
name|replaceAll
argument_list|(
literal|"\t"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|// Remove tabulators.
name|value
operator|.
name|append
argument_list|(
name|whitespacesReduced
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|value
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
expr_stmt|;
block|}
block|}
name|consume
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
DECL|method|parseBracketedTextExactly ()
specifier|private
name|StringBuffer
name|parseBracketedTextExactly
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuffer
name|value
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|consume
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|int
name|brackets
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|peek
argument_list|()
operator|==
literal|'}'
operator|)
operator|&&
operator|(
name|brackets
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|int
name|character
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|isEOFCharacter
argument_list|(
name|character
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|": EOF in mid-string"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|character
operator|==
literal|'{'
condition|)
block|{
name|brackets
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|character
operator|==
literal|'}'
condition|)
block|{
name|brackets
operator|--
expr_stmt|;
block|}
name|value
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|character
argument_list|)
expr_stmt|;
block|}
name|consume
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
DECL|method|parseQuotedFieldExactly ()
specifier|private
name|StringBuffer
name|parseQuotedFieldExactly
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuffer
name|value
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|consume
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|int
name|brackets
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|peek
argument_list|()
operator|==
literal|'"'
operator|)
operator|&&
operator|(
name|brackets
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|int
name|j
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|isEOFCharacter
argument_list|(
name|j
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|": EOF in mid-string"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|j
operator|==
literal|'{'
condition|)
block|{
name|brackets
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|==
literal|'}'
condition|)
block|{
name|brackets
operator|--
expr_stmt|;
block|}
name|value
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|j
argument_list|)
expr_stmt|;
block|}
name|consume
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
DECL|method|consume (char expected)
specifier|private
name|void
name|consume
parameter_list|(
name|char
name|expected
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|character
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|character
operator|!=
name|expected
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|": Expected "
operator|+
name|expected
operator|+
literal|" but received "
operator|+
operator|(
name|char
operator|)
name|character
argument_list|)
throw|;
block|}
block|}
DECL|method|consumeUncritically (char expected)
specifier|private
name|boolean
name|consumeUncritically
parameter_list|(
name|char
name|expected
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|character
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|character
operator|=
name|read
argument_list|()
operator|)
operator|!=
name|expected
operator|)
operator|&&
operator|(
name|character
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|character
operator|!=
literal|65535
operator|)
condition|)
block|{
comment|// do nothing
block|}
if|if
condition|(
name|isEOFCharacter
argument_list|(
name|character
argument_list|)
condition|)
block|{
name|eof
operator|=
literal|true
expr_stmt|;
block|}
comment|// Return true if we actually found the character we were looking for:
return|return
name|character
operator|==
name|expected
return|;
block|}
DECL|method|consume (char firstOption, char secondOption)
specifier|private
name|void
name|consume
parameter_list|(
name|char
name|firstOption
parameter_list|,
name|char
name|secondOption
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Consumes one of the two, doesn't care which appears.
name|int
name|character
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|character
operator|!=
name|firstOption
operator|)
operator|&&
operator|(
name|character
operator|!=
name|secondOption
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error in line "
operator|+
name|line
operator|+
literal|": Expected "
operator|+
name|firstOption
operator|+
literal|" or "
operator|+
name|secondOption
operator|+
literal|" but received "
operator|+
name|character
argument_list|)
throw|;
block|}
block|}
DECL|method|checkEntryTypes (ParserResult parserResult)
specifier|private
name|void
name|checkEntryTypes
parameter_list|(
name|ParserResult
name|parserResult
parameter_list|)
block|{
for|for
control|(
name|BibEntry
name|bibEntry
range|:
name|database
operator|.
name|getEntries
argument_list|()
control|)
block|{
if|if
condition|(
name|bibEntry
operator|.
name|getType
argument_list|()
operator|instanceof
name|UnknownEntryType
condition|)
block|{
comment|// Look up the unknown type name in our map of parsed types:
name|String
name|name
init|=
name|bibEntry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|EntryType
name|type
init|=
name|entryTypes
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
name|bibEntry
operator|.
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parserResult
operator|.
name|addWarning
argument_list|(
name|Localization
operator|.
name|lang
argument_list|(
literal|"Unknown entry type"
argument_list|)
operator|+
literal|": "
operator|+
name|name
operator|+
literal|"; key: "
operator|+
name|bibEntry
operator|.
name|getCiteKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

