begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003-2012 JabRef contributors.     Copyright (C) 2015 Oliver Kopp      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License along     with this program; if not, write to the Free Software Foundation, Inc.,     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */
end_comment

begin_comment
comment|// created by : Morten O. Alver 2003
end_comment

begin_package
DECL|package|net.sf.jabref
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|BorderLayout
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|CardLayout
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Color
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Desktop
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Dimension
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Font
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|ActionEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|ActionListener
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLDecoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharsetEncoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|Action
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|ActionMap
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|BorderFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|Box
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|InputMap
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JButton
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JComponent
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JDialog
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JFrame
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JLabel
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JOptionPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JPanel
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JProgressBar
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JRootPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JScrollPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JTextArea
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|SwingUtilities
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|undo
operator|.
name|AbstractUndoableEdit
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|undo
operator|.
name|UndoableEdit
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|autocompleter
operator|.
name|AutoCompleter
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|SaveSession
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|Layout
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|LayoutHelper
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|ExternalFileType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|ExternalFileTypeEntryEditor
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|RegExpFileSearch
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|UnknownExternalFileType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|AbstractGroup
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|KeywordGroup
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|FileListEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|FileListEntryEditor
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|FileListTableModel
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|labelPattern
operator|.
name|LabelPatternUtil
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|net
operator|.
name|URLDownload
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|NamedCompound
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|UndoableFieldChange
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|util
operator|.
name|FileNameCleaner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jgoodies
operator|.
name|forms
operator|.
name|builder
operator|.
name|DefaultFormBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jgoodies
operator|.
name|forms
operator|.
name|layout
operator|.
name|FormLayout
import|;
end_import

begin_comment
comment|/**  * utility functions  */
end_comment

begin_class
DECL|class|Util
specifier|public
class|class
name|Util
block|{
comment|/**      * A static Object for date formatting. Please do not create the object      * here, because there are some references from the Globals class.....      *       */
DECL|field|dateFormatter
specifier|private
specifier|static
name|SimpleDateFormat
name|dateFormatter
init|=
literal|null
decl_stmt|;
comment|/*      * Colors are defined here.      *        */
DECL|field|fieldsCol
specifier|public
specifier|static
name|Color
name|fieldsCol
init|=
operator|new
name|Color
argument_list|(
literal|180
argument_list|,
literal|180
argument_list|,
literal|200
argument_list|)
decl_stmt|;
comment|/*      * Integer values for indicating result of duplicate check (for entries):      *       */
DECL|field|TYPE_MISMATCH
DECL|field|NOT_EQUAL
DECL|field|EQUAL
DECL|field|EMPTY_IN_ONE
specifier|final
specifier|static
name|int
name|TYPE_MISMATCH
init|=
operator|-
literal|1
decl_stmt|,
name|NOT_EQUAL
init|=
literal|0
decl_stmt|,
name|EQUAL
init|=
literal|1
decl_stmt|,
name|EMPTY_IN_ONE
init|=
literal|2
decl_stmt|,
DECL|field|EMPTY_IN_TWO
DECL|field|EMPTY_IN_BOTH
name|EMPTY_IN_TWO
init|=
literal|3
decl_stmt|,
name|EMPTY_IN_BOTH
init|=
literal|4
decl_stmt|;
DECL|field|idFormat
specifier|private
specifier|final
specifier|static
name|NumberFormat
name|idFormat
decl_stmt|;
DECL|field|remoteLinkPattern
specifier|private
specifier|static
specifier|final
name|Pattern
name|remoteLinkPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[a-z]+://.*"
argument_list|)
decl_stmt|;
DECL|field|MARK_COLOR_LEVELS
specifier|public
specifier|static
specifier|final
name|int
name|MARK_COLOR_LEVELS
init|=
literal|6
decl_stmt|;
DECL|field|MAX_MARKING_LEVEL
specifier|public
specifier|static
specifier|final
name|int
name|MAX_MARKING_LEVEL
init|=
name|Util
operator|.
name|MARK_COLOR_LEVELS
operator|-
literal|1
decl_stmt|;
DECL|field|IMPORT_MARK_LEVEL
specifier|private
specifier|static
specifier|final
name|int
name|IMPORT_MARK_LEVEL
init|=
name|Util
operator|.
name|MARK_COLOR_LEVELS
decl_stmt|;
DECL|field|markNumberPattern
specifier|private
specifier|static
specifier|final
name|Pattern
name|markNumberPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|JabRefPreferences
operator|.
name|getInstance
argument_list|()
operator|.
name|MARKING_WITH_NUMBER_PATTERN
argument_list|)
decl_stmt|;
static|static
block|{
name|idFormat
operator|=
name|NumberFormat
operator|.
name|getInstance
argument_list|()
expr_stmt|;
name|Util
operator|.
name|idFormat
operator|.
name|setMinimumIntegerDigits
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|Util
operator|.
name|idFormat
operator|.
name|setGroupingUsed
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|getMinimumIntegerDigits ()
specifier|public
specifier|static
name|int
name|getMinimumIntegerDigits
parameter_list|()
block|{
return|return
name|Util
operator|.
name|idFormat
operator|.
name|getMinimumIntegerDigits
argument_list|()
return|;
block|}
DECL|method|pr (String s)
specifier|public
specifier|static
name|void
name|pr
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|Globals
operator|.
name|logger
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
DECL|method|nCase (String s)
specifier|public
specifier|static
name|String
name|nCase
parameter_list|(
name|String
name|s
parameter_list|)
block|{
comment|// Make first character of String uppercase, and the
comment|// rest lowercase.
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
return|return
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|.
name|toUpperCase
argument_list|()
operator|+
name|s
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|s
operator|.
name|toUpperCase
argument_list|()
return|;
block|}
block|}
DECL|method|checkName (String s)
specifier|public
specifier|static
name|String
name|checkName
parameter_list|(
name|String
name|s
parameter_list|)
block|{
comment|// Append '.bib' to the string unless it ends with that.
if|if
condition|(
operator|(
name|s
operator|.
name|length
argument_list|()
operator|<
literal|4
operator|)
operator|||
operator|!
name|s
operator|.
name|substring
argument_list|(
name|s
operator|.
name|length
argument_list|()
operator|-
literal|4
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|".bib"
argument_list|)
condition|)
block|{
return|return
name|s
operator|+
literal|".bib"
return|;
block|}
return|return
name|s
return|;
block|}
DECL|field|idCounter
specifier|private
specifier|static
name|int
name|idCounter
init|=
literal|0
decl_stmt|;
DECL|method|createNeutralId ()
specifier|public
specifier|synchronized
specifier|static
name|String
name|createNeutralId
parameter_list|()
block|{
return|return
name|Util
operator|.
name|idFormat
operator|.
name|format
argument_list|(
name|Util
operator|.
name|idCounter
operator|++
argument_list|)
return|;
block|}
comment|/**      * This method sets the location of a Dialog such that it is centered with      * regard to another window, but not outside the screen on the left and the      * top.      */
DECL|method|placeDialog (java.awt.Dialog diag, java.awt.Container win)
specifier|public
specifier|static
name|void
name|placeDialog
parameter_list|(
name|java
operator|.
name|awt
operator|.
name|Dialog
name|diag
parameter_list|,
name|java
operator|.
name|awt
operator|.
name|Container
name|win
parameter_list|)
block|{
name|diag
operator|.
name|setLocationRelativeTo
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method translates a field or string from Bibtex notation, with      * possibly text contained in " " or { }, and string references,      * concatenated by '#' characters, into Bibkeeper notation, where string      * references are enclosed in a pair of '#' characters.      */
DECL|method|parseField (String content)
specifier|public
specifier|static
name|String
name|parseField
parameter_list|(
name|String
name|content
parameter_list|)
block|{
if|if
condition|(
name|content
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|content
return|;
block|}
name|String
index|[]
name|strings
init|=
name|content
operator|.
name|split
argument_list|(
literal|"#"
argument_list|)
decl_stmt|;
name|StringBuffer
name|result
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|string
range|:
name|strings
control|)
block|{
name|String
name|s
init|=
name|string
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// String reference or not?
if|if
condition|(
operator|(
name|c
operator|==
literal|'{'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'"'
operator|)
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|Util
operator|.
name|shaveString
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This part should normally be a string reference, but if it's
comment|// a pure number, it is not.
name|String
name|s2
init|=
name|Util
operator|.
name|shaveString
argument_list|(
name|s
argument_list|)
decl_stmt|;
try|try
block|{
name|Integer
operator|.
name|parseInt
argument_list|(
name|s2
argument_list|)
expr_stmt|;
comment|// If there's no exception, it's a number.
name|result
operator|.
name|append
argument_list|(
name|s2
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|ex
parameter_list|)
block|{
comment|// otherwise append with hashes...
name|result
operator|.
name|append
argument_list|(
literal|"#"
argument_list|)
operator|.
name|append
argument_list|(
name|s2
argument_list|)
operator|.
name|append
argument_list|(
literal|"#"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Will return the publication date of the given bibtex entry in conformance      * to ISO 8601, i.e. either YYYY or YYYY-MM.      *       * @param entry      * @return will return the publication date of the entry or null if no year      *         was found.      */
DECL|method|getPublicationDate (BibtexEntry entry)
specifier|public
specifier|static
name|String
name|getPublicationDate
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|)
block|{
name|Object
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
literal|"year"
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|year
init|=
name|YearUtil
operator|.
name|toFourDigitYear
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|o
operator|=
name|entry
operator|.
name|getField
argument_list|(
literal|"month"
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|MonthUtil
operator|.
name|Month
name|month
init|=
name|MonthUtil
operator|.
name|getMonth
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|month
operator|.
name|isValid
argument_list|()
condition|)
block|{
return|return
name|year
operator|+
literal|"-"
operator|+
name|month
operator|.
name|twoDigitNumber
return|;
block|}
block|}
return|return
name|year
return|;
block|}
DECL|method|shaveString (String s)
specifier|public
specifier|static
name|String
name|shaveString
parameter_list|(
name|String
name|s
parameter_list|)
block|{
comment|// returns the string, after shaving off whitespace at the beginning
comment|// and end, and removing (at most) one pair of braces or " surrounding
comment|// it.
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|char
name|ch
decl_stmt|,
name|ch2
decl_stmt|;
name|int
name|beg
init|=
literal|0
decl_stmt|,
name|end
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// We start out assuming nothing will be removed.
name|boolean
name|begok
init|=
literal|false
decl_stmt|,
name|endok
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|begok
condition|)
block|{
if|if
condition|(
name|beg
operator|<
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|beg
argument_list|)
expr_stmt|;
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|beg
operator|++
expr_stmt|;
block|}
else|else
block|{
name|begok
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|begok
operator|=
literal|true
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
name|endok
condition|)
block|{
if|if
condition|(
name|end
operator|>
operator|(
name|beg
operator|+
literal|1
operator|)
condition|)
block|{
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|end
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|end
operator|--
expr_stmt|;
block|}
else|else
block|{
name|endok
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|endok
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|end
operator|>
operator|(
name|beg
operator|+
literal|1
operator|)
condition|)
block|{
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|beg
argument_list|)
expr_stmt|;
name|ch2
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|end
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ch
operator|==
literal|'{'
operator|)
operator|&&
operator|(
name|ch2
operator|==
literal|'}'
operator|)
operator|)
operator|||
operator|(
operator|(
name|ch
operator|==
literal|'"'
operator|)
operator|&&
operator|(
name|ch2
operator|==
literal|'"'
operator|)
operator|)
condition|)
block|{
name|beg
operator|++
expr_stmt|;
name|end
operator|--
expr_stmt|;
block|}
block|}
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
name|beg
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
DECL|method|rtrim (String s)
specifier|public
specifier|static
name|String
name|rtrim
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|s
operator|.
name|replaceAll
argument_list|(
literal|"\\s+$"
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**      * This method returns a String similar to the one passed in, except that it      * is molded into a form that is acceptable for bibtex.      *       * Watch-out that the returned string might be of length 0 afterwards.      *       * @param key      *            mayBeNull      */
DECL|method|checkLegalKey (String key)
specifier|public
specifier|static
name|String
name|checkLegalKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|JabRefPreferences
operator|.
name|getInstance
argument_list|()
operator|.
name|getBoolean
argument_list|(
literal|"enforceLegalBibtexKey"
argument_list|)
condition|)
block|{
comment|// User doesn't want us to enforce legal characters. We must still look
comment|// for whitespace and some characters such as commas, since these would
comment|// interfere with parsing:
name|StringBuilder
name|newKey
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|key
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|key
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|c
operator|!=
literal|'{'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\\'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'"'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'}'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|','
operator|)
condition|)
block|{
name|newKey
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|newKey
operator|.
name|toString
argument_list|()
return|;
block|}
name|StringBuilder
name|newKey
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|key
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|key
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|c
operator|!=
literal|'#'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'{'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\\'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'"'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'}'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'~'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|','
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'^'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\''
operator|)
condition|)
block|{
name|newKey
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Replace non-english characters like umlauts etc. with a sensible
comment|// letter or letter combination that bibtex can accept.
return|return
name|Util
operator|.
name|replaceSpecialCharacters
argument_list|(
name|newKey
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Replace non-english characters like umlauts etc. with a sensible letter      * or letter combination that bibtex can accept. The basis for replacement      * is the HashMap GLobals.UNICODE_CHARS.      */
DECL|method|replaceSpecialCharacters (String s)
specifier|public
specifier|static
name|String
name|replaceSpecialCharacters
parameter_list|(
name|String
name|s
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|chrAndReplace
range|:
name|Globals
operator|.
name|UNICODE_CHARS
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|s
operator|=
name|s
operator|.
name|replaceAll
argument_list|(
name|chrAndReplace
operator|.
name|getKey
argument_list|()
argument_list|,
name|chrAndReplace
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
DECL|method|_wrap2 (String in, int wrapAmount)
specifier|static
specifier|public
name|String
name|_wrap2
parameter_list|(
name|String
name|in
parameter_list|,
name|int
name|wrapAmount
parameter_list|)
block|{
comment|// The following line cuts out all whitespace and replaces them with
comment|// single
comment|// spaces:
comment|// in = in.replaceAll("[ ]+"," ").replaceAll("[\\t]+"," ");
comment|// StringBuffer out = new StringBuffer(in);
name|StringBuffer
name|out
init|=
operator|new
name|StringBuffer
argument_list|(
name|in
operator|.
name|replaceAll
argument_list|(
literal|"[ \\t\\r]+"
argument_list|,
literal|" "
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|p
init|=
name|in
operator|.
name|length
argument_list|()
operator|-
name|wrapAmount
decl_stmt|;
name|int
name|lastInserted
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|p
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|out
operator|.
name|lastIndexOf
argument_list|(
literal|" "
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|<=
literal|0
operator|)
operator|||
operator|(
name|p
operator|<=
literal|20
operator|)
condition|)
block|{
break|break;
block|}
name|int
name|lbreak
init|=
name|out
operator|.
name|indexOf
argument_list|(
literal|"\n"
argument_list|,
name|p
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|lbreak
operator|+
literal|" "
operator|+
name|lastInserted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lbreak
operator|>
name|p
operator|)
operator|&&
operator|(
operator|(
name|lastInserted
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|lbreak
operator|<
name|lastInserted
operator|)
operator|)
condition|)
block|{
name|p
operator|=
name|lbreak
operator|-
name|wrapAmount
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|insert
argument_list|(
name|p
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|lastInserted
operator|=
name|p
expr_stmt|;
name|p
operator|-=
name|wrapAmount
expr_stmt|;
block|}
block|}
return|return
name|out
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|wrap2 (String in, int wrapAmount)
specifier|static
specifier|public
name|String
name|wrap2
parameter_list|(
name|String
name|in
parameter_list|,
name|int
name|wrapAmount
parameter_list|)
block|{
return|return
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|imports
operator|.
name|FieldContentParser
operator|.
name|wrap
argument_list|(
name|in
argument_list|,
name|wrapAmount
argument_list|)
return|;
block|}
DECL|method|__wrap2 (String in, int wrapAmount)
specifier|static
specifier|public
name|String
name|__wrap2
parameter_list|(
name|String
name|in
parameter_list|,
name|int
name|wrapAmount
parameter_list|)
block|{
comment|// The following line cuts out all whitespace except line breaks, and
comment|// replaces
comment|// with single spaces. Line breaks are padded with a tab character:
name|StringBuffer
name|out
init|=
operator|new
name|StringBuffer
argument_list|(
name|in
operator|.
name|replaceAll
argument_list|(
literal|"[ \\t\\r]+"
argument_list|,
literal|" "
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|p
init|=
literal|0
decl_stmt|;
comment|// int lastInserted = -1;
while|while
condition|(
name|p
operator|<
name|out
operator|.
name|length
argument_list|()
condition|)
block|{
name|int
name|q
init|=
name|out
operator|.
name|indexOf
argument_list|(
literal|" "
argument_list|,
name|p
operator|+
name|wrapAmount
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|q
operator|<
literal|0
operator|)
operator|||
operator|(
name|q
operator|>=
name|out
operator|.
name|length
argument_list|()
operator|)
condition|)
block|{
break|break;
block|}
name|int
name|lbreak
init|=
name|out
operator|.
name|indexOf
argument_list|(
literal|"\n"
argument_list|,
name|p
argument_list|)
decl_stmt|;
comment|// System.out.println(lbreak);
if|if
condition|(
operator|(
name|lbreak
operator|>
name|p
operator|)
operator|&&
operator|(
name|lbreak
operator|<
name|q
operator|)
condition|)
block|{
name|p
operator|=
name|lbreak
operator|+
literal|1
expr_stmt|;
name|int
name|piv
init|=
name|lbreak
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|out
operator|.
name|length
argument_list|()
operator|>
name|piv
operator|)
operator|&&
operator|!
operator|(
name|out
operator|.
name|charAt
argument_list|(
name|piv
argument_list|)
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|out
operator|.
name|insert
argument_list|(
name|piv
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// System.out.println(q+" "+out.length());
name|out
operator|.
name|deleteCharAt
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|out
operator|.
name|insert
argument_list|(
name|q
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
name|out
operator|.
name|toString
argument_list|()
return|;
comment|// .replaceAll("\n", "\n\t");
block|}
DECL|method|findDeliminatedWordsInField (BibtexDatabase db, String field, String deliminator)
specifier|public
specifier|static
name|TreeSet
argument_list|<
name|String
argument_list|>
name|findDeliminatedWordsInField
parameter_list|(
name|BibtexDatabase
name|db
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|deliminator
parameter_list|)
block|{
name|TreeSet
argument_list|<
name|String
argument_list|>
name|res
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|db
operator|.
name|getKeySet
argument_list|()
control|)
block|{
name|BibtexEntry
name|be
init|=
name|db
operator|.
name|getEntryById
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|Object
name|o
init|=
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|String
name|fieldValue
init|=
name|o
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|StringTokenizer
name|tok
init|=
operator|new
name|StringTokenizer
argument_list|(
name|fieldValue
argument_list|,
name|deliminator
argument_list|)
decl_stmt|;
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|res
operator|.
name|add
argument_list|(
name|Util
operator|.
name|nCase
argument_list|(
name|tok
operator|.
name|nextToken
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|res
return|;
block|}
comment|/**      * Returns a HashMap containing all words used in the database in the given      * field type. Characters in<code>remove</code> are not included.      *       * @param db      *            a<code>BibtexDatabase</code> value      * @param field      *            a<code>String</code> value      * @param remove      *            a<code>String</code> value      * @return a<code>HashSet</code> value      */
DECL|method|findAllWordsInField (BibtexDatabase db, String field, String remove)
specifier|public
specifier|static
name|TreeSet
argument_list|<
name|String
argument_list|>
name|findAllWordsInField
parameter_list|(
name|BibtexDatabase
name|db
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|remove
parameter_list|)
block|{
name|TreeSet
argument_list|<
name|String
argument_list|>
name|res
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|StringTokenizer
name|tok
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|db
operator|.
name|getKeySet
argument_list|()
control|)
block|{
name|BibtexEntry
name|be
init|=
name|db
operator|.
name|getEntryById
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|Object
name|o
init|=
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|tok
operator|=
operator|new
name|StringTokenizer
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|,
name|remove
argument_list|,
literal|false
argument_list|)
expr_stmt|;
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|res
operator|.
name|add
argument_list|(
name|Util
operator|.
name|nCase
argument_list|(
name|tok
operator|.
name|nextToken
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|res
return|;
block|}
comment|/**      * Finds all authors' last names in all the given fields for the given database.      * @param db The database.      * @param fields The fields to look in.      * @return a set containing the names.      */
DECL|method|findAuthorLastNames (BibtexDatabase db, List<String> fields)
specifier|public
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|findAuthorLastNames
parameter_list|(
name|BibtexDatabase
name|db
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|res
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|db
operator|.
name|getKeySet
argument_list|()
control|)
block|{
name|BibtexEntry
name|be
init|=
name|db
operator|.
name|getEntryById
argument_list|(
name|s
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
name|String
name|val
init|=
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|val
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|AuthorList
name|al
init|=
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|val
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|al
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|AuthorList
operator|.
name|Author
name|a
init|=
name|al
operator|.
name|getAuthor
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|lastName
init|=
name|a
operator|.
name|getLast
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|lastName
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|lastName
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|res
operator|.
name|add
argument_list|(
name|lastName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|res
return|;
block|}
comment|/**      * Takes a String array and returns a string with the array's elements      * delimited by a certain String.      *       * @param strs      *            String array to convert.      * @param delimiter      *            String to use as delimiter.      * @return Delimited String.      */
DECL|method|stringArrayToDelimited (String[] strs, String delimiter)
specifier|public
specifier|static
name|String
name|stringArrayToDelimited
parameter_list|(
name|String
index|[]
name|strs
parameter_list|,
name|String
name|delimiter
parameter_list|)
block|{
if|if
condition|(
operator|(
name|strs
operator|==
literal|null
operator|)
operator|||
operator|(
name|strs
operator|.
name|length
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|""
return|;
block|}
if|if
condition|(
name|strs
operator|.
name|length
operator|==
literal|1
condition|)
block|{
return|return
name|strs
index|[
literal|0
index|]
return|;
block|}
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|strs
operator|.
name|length
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|strs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|delimiter
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|strs
index|[
name|strs
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Takes a delimited string, splits it and returns      *       * @param names      *            a<code>String</code> value      * @return a<code>String[]</code> value      */
DECL|method|delimToStringArray (String names, String delimiter)
specifier|public
specifier|static
name|String
index|[]
name|delimToStringArray
parameter_list|(
name|String
name|names
parameter_list|,
name|String
name|delimiter
parameter_list|)
block|{
if|if
condition|(
name|names
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|names
operator|.
name|split
argument_list|(
name|delimiter
argument_list|)
return|;
block|}
comment|/**      * Creates a substring from a text      *      * @param text      * @param i      * @param terminateOnEndBraceOnly      * @return      */
DECL|method|getPart (String text, int i, boolean terminateOnEndBraceOnly)
specifier|public
specifier|static
name|String
name|getPart
parameter_list|(
name|String
name|text
parameter_list|,
name|int
name|i
parameter_list|,
name|boolean
name|terminateOnEndBraceOnly
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|StringBuffer
name|part
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
comment|// advance to first char and skip whitespace
name|i
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
name|text
operator|.
name|length
argument_list|()
operator|)
operator|&&
name|Character
operator|.
name|isWhitespace
argument_list|(
name|text
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
comment|// then grab whathever is the first token (counting braces)
while|while
condition|(
name|i
operator|<
name|text
operator|.
name|length
argument_list|()
condition|)
block|{
name|c
operator|=
name|text
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|terminateOnEndBraceOnly
operator|&&
operator|(
name|count
operator|==
literal|0
operator|)
operator|&&
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|i
operator|--
expr_stmt|;
comment|// end argument and leave whitespace for further
comment|// processing
break|break;
block|}
if|if
condition|(
operator|(
name|c
operator|==
literal|'}'
operator|)
operator|&&
operator|(
operator|--
name|count
operator|<
literal|0
operator|)
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
name|part
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
name|part
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Open a http/pdf/ps viewer for the given link string.      */
DECL|method|openExternalViewer (MetaData metaData, String link, String fieldName)
specifier|public
specifier|static
name|void
name|openExternalViewer
parameter_list|(
name|MetaData
name|metaData
parameter_list|,
name|String
name|link
parameter_list|,
name|String
name|fieldName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"ps"
argument_list|)
operator|||
name|fieldName
operator|.
name|equals
argument_list|(
literal|"pdf"
argument_list|)
condition|)
block|{
comment|// Find the default directory for this field type:
name|String
index|[]
name|dir
init|=
name|metaData
operator|.
name|getFileDirectory
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|File
name|file
init|=
name|Util
operator|.
name|expandFilename
argument_list|(
name|link
argument_list|,
name|dir
argument_list|)
decl_stmt|;
comment|// Check that the file exists:
if|if
condition|(
operator|(
name|file
operator|==
literal|null
operator|)
operator|||
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"File not found"
argument_list|)
operator|+
literal|" ("
operator|+
name|fieldName
operator|+
literal|"): '"
operator|+
name|link
operator|+
literal|"'."
argument_list|)
throw|;
block|}
name|link
operator|=
name|file
operator|.
name|getCanonicalPath
argument_list|()
expr_stmt|;
comment|// Use the correct viewer even if pdf and ps are mixed up:
name|String
index|[]
name|split
init|=
name|file
operator|.
name|getName
argument_list|()
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
decl_stmt|;
if|if
condition|(
name|split
operator|.
name|length
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|split
index|[
name|split
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"pdf"
argument_list|)
condition|)
block|{
name|fieldName
operator|=
literal|"pdf"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|split
index|[
name|split
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"ps"
argument_list|)
operator|||
operator|(
operator|(
name|split
operator|.
name|length
operator|>=
literal|3
operator|)
operator|&&
name|split
index|[
name|split
operator|.
name|length
operator|-
literal|2
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"ps"
argument_list|)
operator|)
condition|)
block|{
name|fieldName
operator|=
literal|"ps"
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"doi"
argument_list|)
condition|)
block|{
name|fieldName
operator|=
literal|"url"
expr_stmt|;
comment|// sanitizing is done below at the treatment of "URL"
comment|// in sanatizeUrl a doi-link is correctly treated
block|}
elseif|else
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"eprint"
argument_list|)
condition|)
block|{
name|fieldName
operator|=
literal|"url"
expr_stmt|;
name|link
operator|=
name|Util
operator|.
name|sanitizeUrl
argument_list|(
name|link
argument_list|)
expr_stmt|;
comment|// Check to see if link field already contains a well formated URL
if|if
condition|(
operator|!
name|link
operator|.
name|startsWith
argument_list|(
literal|"http://"
argument_list|)
condition|)
block|{
name|link
operator|=
name|Globals
operator|.
name|ARXIV_LOOKUP_PREFIX
operator|+
name|link
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"url"
argument_list|)
condition|)
block|{
comment|// html
try|try
block|{
name|Util
operator|.
name|openBrowser
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Error_opening_file_'%0'."
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"ps"
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
name|Globals
operator|.
name|ON_MAC
condition|)
block|{
name|ExternalFileType
name|type
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeByExt
argument_list|(
literal|"ps"
argument_list|)
decl_stmt|;
name|String
name|viewer
init|=
name|type
operator|!=
literal|null
condition|?
name|type
operator|.
name|getOpenWith
argument_list|()
else|:
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"psviewer"
argument_list|)
decl_stmt|;
name|String
index|[]
name|cmd
init|=
block|{
literal|"/usr/bin/open"
block|,
literal|"-a"
block|,
name|viewer
block|,
name|link
block|}
decl_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Globals
operator|.
name|ON_WIN
condition|)
block|{
name|Util
operator|.
name|openFileOnWindows
argument_list|(
name|link
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|/*                      * cmdArray[0] = Globals.prefs.get("psviewer"); cmdArray[1] =                      * link; Process child = Runtime.getRuntime().exec(                      * cmdArray[0] + " " + cmdArray[1]);                      */
block|}
else|else
block|{
name|ExternalFileType
name|type
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeByExt
argument_list|(
literal|"ps"
argument_list|)
decl_stmt|;
name|String
name|viewer
init|=
name|type
operator|!=
literal|null
condition|?
name|type
operator|.
name|getOpenWith
argument_list|()
else|:
literal|"xdg-open"
decl_stmt|;
name|String
index|[]
name|cmdArray
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
name|cmdArray
index|[
literal|0
index|]
operator|=
name|viewer
expr_stmt|;
name|cmdArray
index|[
literal|1
index|]
operator|=
name|link
expr_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmdArray
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"An error occured on the command: "
operator|+
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"psviewer"
argument_list|)
operator|+
literal|" "
operator|+
name|link
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"pdf"
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
name|Globals
operator|.
name|ON_MAC
condition|)
block|{
name|ExternalFileType
name|type
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeByExt
argument_list|(
literal|"pdf"
argument_list|)
decl_stmt|;
name|String
name|viewer
init|=
name|type
operator|!=
literal|null
condition|?
name|type
operator|.
name|getOpenWith
argument_list|()
else|:
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"psviewer"
argument_list|)
decl_stmt|;
name|String
index|[]
name|cmd
init|=
block|{
literal|"/usr/bin/open"
block|,
literal|"-a"
block|,
name|viewer
block|,
name|link
block|}
decl_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Globals
operator|.
name|ON_WIN
condition|)
block|{
name|Util
operator|.
name|openFileOnWindows
argument_list|(
name|link
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|/*                      * String[] spl = link.split("\\\\"); StringBuffer sb = new                      * StringBuffer(); for (int i = 0; i< spl.length; i++) { if                      * (i> 0) sb.append("\\"); if (spl[i].indexOf(" ")>= 0)                      * spl[i] = "\"" + spl[i] + "\""; sb.append(spl[i]); }                      * //pr(sb.toString()); link = sb.toString();                      *                       * String cmd = "cmd.exe /c start " + link;                      *                       * Process child = Runtime.getRuntime().exec(cmd);                      */
block|}
else|else
block|{
name|ExternalFileType
name|type
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeByExt
argument_list|(
literal|"pdf"
argument_list|)
decl_stmt|;
name|String
name|viewer
init|=
name|type
operator|!=
literal|null
condition|?
name|type
operator|.
name|getOpenWith
argument_list|()
else|:
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"psviewer"
argument_list|)
decl_stmt|;
name|String
index|[]
name|cmdArray
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
name|cmdArray
index|[
literal|0
index|]
operator|=
name|viewer
expr_stmt|;
name|cmdArray
index|[
literal|1
index|]
operator|=
name|link
expr_stmt|;
comment|// Process child = Runtime.getRuntime().exec(cmdArray[0]+"
comment|// "+cmdArray[1]);
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmdArray
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"An error occured on the command: "
operator|+
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"pdfviewer"
argument_list|)
operator|+
literal|" #"
operator|+
name|link
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Message: currently only PDF, PS and HTML files can be opened by double clicking"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Opens a file on a Windows system, using its default viewer.      *       * @param link      *            The file name.      * @param localFile      *            true if it is a local file, not an URL.      * @throws IOException      */
DECL|method|openFileOnWindows (String link, boolean localFile)
specifier|private
specifier|static
name|void
name|openFileOnWindows
parameter_list|(
name|String
name|link
parameter_list|,
name|boolean
name|localFile
parameter_list|)
throws|throws
name|IOException
block|{
comment|/*          * if (localFile) { String[] spl = link.split("\\\\"); StringBuffer sb =          * new StringBuffer(); for (int i = 0; i< spl.length; i++) { if (i> 0)          * sb.append("\\"); if (spl[i].indexOf(" ")>= 0) spl[i] = "\"" + spl[i] +          * "\""; sb.append(spl[i]); } link = sb.toString(); }          */
name|link
operator|=
name|link
operator|.
name|replaceAll
argument_list|(
literal|"&"
argument_list|,
literal|"\"&\""
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|" "
argument_list|,
literal|"\" \""
argument_list|)
expr_stmt|;
comment|// Bug fix for:
comment|// http://sourceforge.net/tracker/index.php?func=detail&aid=1489454&group_id=92314&atid=600306
name|String
name|cmd
decl_stmt|;
if|if
condition|(
name|Globals
operator|.
name|osName
operator|.
name|startsWith
argument_list|(
literal|"Windows 9"
argument_list|)
condition|)
block|{
name|cmd
operator|=
literal|"command.com /c start "
operator|+
name|link
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
literal|"cmd.exe /c start "
operator|+
name|link
expr_stmt|;
block|}
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|/**      * Opens a file on a Windows system, using the given application.      *      * @param link The file name.      * @param application Link to the app that opens the file.      * @throws IOException      */
DECL|method|openFileWithApplicationOnWindows (String link, String application)
specifier|private
specifier|static
name|void
name|openFileWithApplicationOnWindows
parameter_list|(
name|String
name|link
parameter_list|,
name|String
name|application
parameter_list|)
throws|throws
name|IOException
block|{
name|link
operator|=
name|link
operator|.
name|replaceAll
argument_list|(
literal|"&"
argument_list|,
literal|"\"&\""
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|" "
argument_list|,
literal|"\" \""
argument_list|)
expr_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|application
operator|+
literal|" "
operator|+
name|link
argument_list|)
expr_stmt|;
block|}
comment|/**      * Open an external file, attempting to use the correct viewer for it.      *       * @param metaData      *            The MetaData for the database this file belongs to.      * @param link      *            The file name.      * @return false if the link couldn't be resolved, true otherwise.      */
DECL|method|openExternalFileAnyFormat (final MetaData metaData, String link, final ExternalFileType fileType)
specifier|public
specifier|static
name|boolean
name|openExternalFileAnyFormat
parameter_list|(
specifier|final
name|MetaData
name|metaData
parameter_list|,
name|String
name|link
parameter_list|,
specifier|final
name|ExternalFileType
name|fileType
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|httpLink
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|Util
operator|.
name|remoteLinkPattern
operator|.
name|matcher
argument_list|(
name|link
operator|.
name|toLowerCase
argument_list|()
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|httpLink
operator|=
literal|true
expr_stmt|;
block|}
comment|/*if (link.toLowerCase().startsWith("file://")) {             link = link.substring(7);         }         final String ln = link;         if (remoteLinkPattern.matcher(link.toLowerCase()).matches()) {             (new Thread(new Runnable() {                 public void run() {                     openRemoteExternalFile(metaData, ln, fileType);                 }             })).start();              return true;         }*/
comment|//boolean httpLink = link.toLowerCase().startsWith("http:")
comment|//        || link.toLowerCase().startsWith("ftp:");
comment|// For other platforms we'll try to find the file type:
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|httpLink
condition|)
block|{
name|File
name|tmp
init|=
name|Util
operator|.
name|expandFilename
argument_list|(
name|metaData
argument_list|,
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|null
condition|)
block|{
name|file
operator|=
name|tmp
expr_stmt|;
block|}
block|}
comment|// Check if we have arrived at a file type, and either an http link or an existing file:
if|if
condition|(
operator|(
name|httpLink
operator|||
name|file
operator|.
name|exists
argument_list|()
operator|)
operator|&&
operator|(
name|fileType
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// Open the file:
name|String
name|filePath
init|=
name|httpLink
condition|?
name|link
else|:
name|file
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|Util
operator|.
name|openExternalFilePlatformIndependent
argument_list|(
name|fileType
argument_list|,
name|filePath
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
comment|// No file matched the name, or we didn't know the file type.
block|}
block|}
DECL|method|openExternalFilePlatformIndependent (ExternalFileType fileType, String filePath)
specifier|private
specifier|static
name|void
name|openExternalFilePlatformIndependent
parameter_list|(
name|ExternalFileType
name|fileType
parameter_list|,
name|String
name|filePath
parameter_list|)
throws|throws
name|IOException
block|{
comment|// For URLs, other solutions are
comment|//  * https://github.com/rajing/browserlauncher2, but it is not available in maven
comment|//  * a the solution combining http://stackoverflow.com/a/5226244/873282 and http://stackoverflow.com/a/28807079/873282
if|if
condition|(
name|Globals
operator|.
name|ON_MAC
condition|)
block|{
comment|// Use "-a<application>" if the app is specified, and just "open<filename>" otherwise:
name|String
index|[]
name|cmd
init|=
operator|(
operator|(
name|fileType
operator|.
name|getOpenWith
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|fileType
operator|.
name|getOpenWith
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
operator|)
condition|?
operator|new
name|String
index|[]
block|{
literal|"/usr/bin/open"
block|,
literal|"-a"
block|,
name|fileType
operator|.
name|getOpenWith
argument_list|()
block|,
name|filePath
block|}
else|:
operator|new
name|String
index|[]
block|{
literal|"/usr/bin/open"
block|,
name|filePath
block|}
decl_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Globals
operator|.
name|ON_WIN
condition|)
block|{
if|if
condition|(
operator|(
name|fileType
operator|.
name|getOpenWith
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|fileType
operator|.
name|getOpenWith
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
comment|// Application is specified. Use it:
name|Util
operator|.
name|openFileWithApplicationOnWindows
argument_list|(
name|filePath
argument_list|,
name|fileType
operator|.
name|getOpenWith
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Util
operator|.
name|openFileOnWindows
argument_list|(
name|filePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Use the given app if specified, and the universal "xdg-open" otherwise:
name|String
index|[]
name|openWith
decl_stmt|;
if|if
condition|(
operator|(
name|fileType
operator|.
name|getOpenWith
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|fileType
operator|.
name|getOpenWith
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|openWith
operator|=
name|fileType
operator|.
name|getOpenWith
argument_list|()
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|openWith
operator|=
operator|new
name|String
index|[]
block|{
literal|"xdg-open"
block|}
expr_stmt|;
block|}
name|String
index|[]
name|cmdArray
init|=
operator|new
name|String
index|[
name|openWith
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|openWith
argument_list|,
literal|0
argument_list|,
name|cmdArray
argument_list|,
literal|0
argument_list|,
name|openWith
operator|.
name|length
argument_list|)
expr_stmt|;
name|cmdArray
index|[
name|cmdArray
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|filePath
expr_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmdArray
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|openRemoteExternalFile (final MetaData metaData, final String link, final ExternalFileType fileType)
specifier|public
specifier|static
name|void
name|openRemoteExternalFile
parameter_list|(
specifier|final
name|MetaData
name|metaData
parameter_list|,
specifier|final
name|String
name|link
parameter_list|,
specifier|final
name|ExternalFileType
name|fileType
parameter_list|)
block|{
name|File
name|temp
init|=
literal|null
decl_stmt|;
try|try
block|{
name|temp
operator|=
name|File
operator|.
name|createTempFile
argument_list|(
literal|"jabref-link"
argument_list|,
literal|"."
operator|+
name|fileType
operator|.
name|getExtension
argument_list|()
argument_list|)
expr_stmt|;
name|temp
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Downloading to '"
operator|+
name|temp
operator|.
name|getPath
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
operator|new
name|URLDownload
argument_list|(
operator|new
name|URL
argument_list|(
name|link
argument_list|)
argument_list|)
operator|.
name|downloadToFile
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Done"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
specifier|final
name|String
name|ln
init|=
name|temp
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|SwingUtilities
operator|.
name|invokeLater
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|Util
operator|.
name|openExternalFileAnyFormat
argument_list|(
name|metaData
argument_list|,
name|ln
argument_list|,
name|fileType
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|openExternalFileUnknown (JabRefFrame frame, BibtexEntry entry, MetaData metaData, String link, UnknownExternalFileType fileType)
specifier|public
specifier|static
name|boolean
name|openExternalFileUnknown
parameter_list|(
name|JabRefFrame
name|frame
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|,
name|MetaData
name|metaData
parameter_list|,
name|String
name|link
parameter_list|,
name|UnknownExternalFileType
name|fileType
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|cancelMessage
init|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Unable to open file."
argument_list|)
decl_stmt|;
name|String
index|[]
name|options
init|=
operator|new
name|String
index|[]
block|{
name|Globals
operator|.
name|lang
argument_list|(
literal|"Define '%0'"
argument_list|,
name|fileType
operator|.
name|getName
argument_list|()
argument_list|)
block|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Change file type"
argument_list|)
block|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Cancel"
argument_list|)
block|}
decl_stmt|;
name|String
name|defOption
init|=
name|options
index|[
literal|0
index|]
decl_stmt|;
name|int
name|answer
init|=
name|JOptionPane
operator|.
name|showOptionDialog
argument_list|(
name|frame
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"This external link is of the type '%0', which is undefined. What do you want to do?"
argument_list|,
name|fileType
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Undefined file type"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_CANCEL_OPTION
argument_list|,
name|JOptionPane
operator|.
name|QUESTION_MESSAGE
argument_list|,
literal|null
argument_list|,
name|options
argument_list|,
name|defOption
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|==
name|JOptionPane
operator|.
name|CANCEL_OPTION
condition|)
block|{
name|frame
operator|.
name|output
argument_list|(
name|cancelMessage
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|answer
operator|==
name|JOptionPane
operator|.
name|YES_OPTION
condition|)
block|{
comment|// User wants to define the new file type. Show the dialog:
name|ExternalFileType
name|newType
init|=
operator|new
name|ExternalFileType
argument_list|(
name|fileType
operator|.
name|getName
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"new"
argument_list|)
decl_stmt|;
name|ExternalFileTypeEntryEditor
name|editor
init|=
operator|new
name|ExternalFileTypeEntryEditor
argument_list|(
name|frame
argument_list|,
name|newType
argument_list|)
decl_stmt|;
name|editor
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|editor
operator|.
name|okPressed
argument_list|()
condition|)
block|{
comment|// Get the old list of types, add this one, and update the list in prefs:
name|List
argument_list|<
name|ExternalFileType
argument_list|>
name|fileTypes
init|=
operator|new
name|ArrayList
argument_list|<
name|ExternalFileType
argument_list|>
argument_list|()
decl_stmt|;
name|ExternalFileType
index|[]
name|oldTypes
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeSelection
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|fileTypes
argument_list|,
name|oldTypes
argument_list|)
expr_stmt|;
name|fileTypes
operator|.
name|add
argument_list|(
name|newType
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|fileTypes
argument_list|)
expr_stmt|;
name|Globals
operator|.
name|prefs
operator|.
name|setExternalFileTypes
argument_list|(
name|fileTypes
argument_list|)
expr_stmt|;
comment|// Finally, open the file:
return|return
name|Util
operator|.
name|openExternalFileAnyFormat
argument_list|(
name|metaData
argument_list|,
name|link
argument_list|,
name|newType
argument_list|)
return|;
block|}
else|else
block|{
comment|// Cancelled:
name|frame
operator|.
name|output
argument_list|(
name|cancelMessage
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
comment|// User wants to change the type of this link.
comment|// First get a model of all file links for this entry:
name|FileListTableModel
name|tModel
init|=
operator|new
name|FileListTableModel
argument_list|()
decl_stmt|;
name|String
name|oldValue
init|=
name|entry
operator|.
name|getField
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|)
decl_stmt|;
name|tModel
operator|.
name|setContent
argument_list|(
name|oldValue
argument_list|)
expr_stmt|;
name|FileListEntry
name|flEntry
init|=
literal|null
decl_stmt|;
comment|// Then find which one we are looking at:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tModel
operator|.
name|getRowCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|FileListEntry
name|iEntry
init|=
name|tModel
operator|.
name|getEntry
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|iEntry
operator|.
name|getLink
argument_list|()
operator|.
name|equals
argument_list|(
name|link
argument_list|)
condition|)
block|{
name|flEntry
operator|=
name|iEntry
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|flEntry
operator|==
literal|null
condition|)
block|{
comment|// This shouldn't happen, so I'm not sure what to put in here:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not find the file list entry "
operator|+
name|link
operator|+
literal|" in "
operator|+
name|entry
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|FileListEntryEditor
name|editor
init|=
operator|new
name|FileListEntryEditor
argument_list|(
name|frame
argument_list|,
name|flEntry
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
name|metaData
argument_list|)
decl_stmt|;
name|editor
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|editor
operator|.
name|okPressed
argument_list|()
condition|)
block|{
comment|// Store the changes and add an undo edit:
name|String
name|newValue
init|=
name|tModel
operator|.
name|getStringRepresentation
argument_list|()
decl_stmt|;
name|UndoableFieldChange
name|ce
init|=
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
decl_stmt|;
name|entry
operator|.
name|setField
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
name|frame
operator|.
name|basePanel
argument_list|()
operator|.
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|frame
operator|.
name|basePanel
argument_list|()
operator|.
name|markBaseChanged
argument_list|()
expr_stmt|;
comment|// Finally, open the link:
return|return
name|Util
operator|.
name|openExternalFileAnyFormat
argument_list|(
name|metaData
argument_list|,
name|flEntry
operator|.
name|getLink
argument_list|()
argument_list|,
name|flEntry
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// Cancelled:
name|frame
operator|.
name|output
argument_list|(
name|cancelMessage
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
comment|/**      * Make sure an URL is "portable", in that it doesn't contain bad characters      * that break the open command in some OSes.      *       * A call to this method will also remove \\url{} enclosings and clean DOI links. 	 *  	 * @param link :the URL to sanitize. 	 * @return Sanitized URL 	 */
DECL|method|sanitizeUrl (String link)
specifier|public
specifier|static
name|String
name|sanitizeUrl
parameter_list|(
name|String
name|link
parameter_list|)
block|{
name|link
operator|=
name|link
operator|.
name|trim
argument_list|()
expr_stmt|;
comment|// First check if it is enclosed in \\url{}. If so, remove
comment|// the wrapper.
if|if
condition|(
name|link
operator|.
name|startsWith
argument_list|(
literal|"\\url{"
argument_list|)
operator|&&
name|link
operator|.
name|endsWith
argument_list|(
literal|"}"
argument_list|)
condition|)
block|{
name|link
operator|=
name|link
operator|.
name|substring
argument_list|(
literal|5
argument_list|,
name|link
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|link
operator|.
name|matches
argument_list|(
literal|"^doi:/*.*"
argument_list|)
condition|)
block|{
comment|// Remove 'doi:'
name|link
operator|=
name|link
operator|.
name|replaceFirst
argument_list|(
literal|"^doi:/*"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|link
operator|=
name|Globals
operator|.
name|DOI_LOOKUP_PREFIX
operator|+
name|link
expr_stmt|;
block|}
comment|// converts doi-only link to full http address
comment|// Morten Alver 6 Nov 2012: this extracts a nonfunctional DOI from some complete
comment|// http addresses (e.g. http://onlinelibrary.wiley.com/doi/10.1002/rra.999/abstract, where
comment|// the trailing "/abstract" is included but doesn't lead to a resolvable DOI).
comment|// To prevent mangling of working URLs I'm disabling this check if the link is already
comment|// a full http link:
if|if
condition|(
name|Util
operator|.
name|checkForPlainDOI
argument_list|(
name|link
argument_list|)
operator|&&
operator|!
name|link
operator|.
name|startsWith
argument_list|(
literal|"http://"
argument_list|)
condition|)
block|{
name|link
operator|=
name|Globals
operator|.
name|DOI_LOOKUP_PREFIX
operator|+
name|Util
operator|.
name|getDOI
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
name|link
operator|=
name|link
operator|.
name|replaceAll
argument_list|(
literal|"\\+"
argument_list|,
literal|"%2B"
argument_list|)
expr_stmt|;
try|try
block|{
name|link
operator|=
name|URLDecoder
operator|.
name|decode
argument_list|(
name|link
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|ignored
parameter_list|)
block|{         }
comment|/**          * Fix for: [ 1574773 ] sanitizeUrl() breaks ftp:// and file:///          *           * http://sourceforge.net/tracker/index.php?func=detail&aid=1574773&group_id=92314&atid=600306          */
try|try
block|{
return|return
operator|new
name|URI
argument_list|(
literal|null
argument_list|,
name|link
argument_list|,
literal|null
argument_list|)
operator|.
name|toASCIIString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
return|return
name|link
return|;
block|}
block|}
comment|/**      * Returns the extension of a file or null if the file does not have one (no . in name).      *       * @param file      *       * @return The extension, trimmed and in lowercase.      */
DECL|method|getFileExtension (File file)
specifier|public
specifier|static
name|String
name|getFileExtension
parameter_list|(
name|File
name|file
parameter_list|)
block|{
name|String
name|name
init|=
name|file
operator|.
name|getName
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|pos
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|pos
operator|<
operator|(
name|name
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
operator|)
operator|)
condition|?
name|name
operator|.
name|substring
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|.
name|trim
argument_list|()
operator|.
name|toLowerCase
argument_list|()
else|:
literal|null
return|;
block|}
DECL|method|parseMethodsCalls (String calls)
specifier|public
specifier|static
name|ArrayList
argument_list|<
name|String
index|[]
argument_list|>
name|parseMethodsCalls
parameter_list|(
name|String
name|calls
parameter_list|)
throws|throws
name|RuntimeException
block|{
name|ArrayList
argument_list|<
name|String
index|[]
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|String
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|char
index|[]
name|c
init|=
name|calls
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|c
operator|.
name|length
condition|)
block|{
name|int
name|start
init|=
name|i
decl_stmt|;
if|if
condition|(
name|Character
operator|.
name|isJavaIdentifierStart
argument_list|(
name|c
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
name|c
operator|.
name|length
operator|)
operator|&&
operator|(
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|c
index|[
name|i
index|]
argument_list|)
operator|||
operator|(
name|c
index|[
name|i
index|]
operator|==
literal|'.'
operator|)
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|<
name|c
operator|.
name|length
operator|)
operator|&&
operator|(
name|c
index|[
name|i
index|]
operator|==
literal|'('
operator|)
condition|)
block|{
name|String
name|method
init|=
name|calls
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|// Skip the brace
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|c
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|c
index|[
name|i
index|]
operator|==
literal|'"'
condition|)
block|{
comment|// Parameter is in format "xxx"
comment|// Skip "
name|i
operator|++
expr_stmt|;
name|int
name|startParam
init|=
name|i
decl_stmt|;
name|i
operator|++
expr_stmt|;
name|boolean
name|escaped
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|c
operator|.
name|length
operator|)
operator|&&
operator|!
operator|(
operator|!
name|escaped
operator|&&
operator|(
name|c
index|[
name|i
index|]
operator|==
literal|'"'
operator|)
operator|&&
operator|(
name|c
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|')'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|c
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
name|escaped
operator|=
operator|!
name|escaped
expr_stmt|;
block|}
else|else
block|{
name|escaped
operator|=
literal|false
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|String
name|param
init|=
name|calls
operator|.
name|substring
argument_list|(
name|startParam
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
operator|new
name|String
index|[]
block|{
name|method
block|,
name|param
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Parameter is in format xxx
name|int
name|startParam
init|=
name|i
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
name|c
operator|.
name|length
operator|)
operator|&&
operator|(
name|c
index|[
name|i
index|]
operator|!=
literal|')'
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
name|String
name|param
init|=
name|calls
operator|.
name|substring
argument_list|(
name|startParam
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
operator|new
name|String
index|[]
block|{
name|method
block|,
name|param
block|}
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Incorrecly terminated open brace
name|result
operator|.
name|add
argument_list|(
operator|new
name|String
index|[]
block|{
name|method
block|}
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
name|method
init|=
name|calls
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
operator|new
name|String
index|[]
block|{
name|method
block|}
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|field|squareBracketsPattern
specifier|private
specifier|static
specifier|final
name|Pattern
name|squareBracketsPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\[.*?\\]"
argument_list|)
decl_stmt|;
comment|/**      * Takes a string that contains bracketed expression and expands each of      * these using getFieldAndFormat.      *      * Unknown Bracket expressions are silently dropped.      *      * @param bracketString      * @param entry      * @param database      * @return      */
DECL|method|expandBrackets (String bracketString, BibtexEntry entry, BibtexDatabase database)
specifier|public
specifier|static
name|String
name|expandBrackets
parameter_list|(
name|String
name|bracketString
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
block|{
name|Matcher
name|m
init|=
name|Util
operator|.
name|squareBracketsPattern
operator|.
name|matcher
argument_list|(
name|bracketString
argument_list|)
decl_stmt|;
name|StringBuffer
name|s
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|replacement
init|=
name|Util
operator|.
name|getFieldAndFormat
argument_list|(
name|m
operator|.
name|group
argument_list|()
argument_list|,
name|entry
argument_list|,
name|database
argument_list|)
decl_stmt|;
if|if
condition|(
name|replacement
operator|==
literal|null
condition|)
block|{
name|replacement
operator|=
literal|""
expr_stmt|;
block|}
name|m
operator|.
name|appendReplacement
argument_list|(
name|s
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
block|}
name|m
operator|.
name|appendTail
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Concatenate all strings in the array from index 'from' to 'to' (excluding      * to) with the given separator.      *       * Example:      *       * String[] s = "ab/cd/ed".split("/"); join(s, "\\", 0, s.length) ->      * "ab\\cd\\ed"      *       * @param strings      * @param separator      * @param from      * @param to      *            Excluding strings[to]      * @return      */
DECL|method|join (String[] strings, String separator, int from, int to)
specifier|public
specifier|static
name|String
name|join
parameter_list|(
name|String
index|[]
name|strings
parameter_list|,
name|String
name|separator
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
if|if
condition|(
operator|(
name|strings
operator|.
name|length
operator|==
literal|0
operator|)
operator|||
operator|(
name|from
operator|>=
name|to
operator|)
condition|)
block|{
return|return
literal|""
return|;
block|}
name|from
operator|=
name|Math
operator|.
name|max
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|to
operator|=
name|Math
operator|.
name|min
argument_list|(
name|strings
operator|.
name|length
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|from
init|;
name|i
operator|<
operator|(
name|to
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|strings
index|[
name|i
index|]
argument_list|)
operator|.
name|append
argument_list|(
name|separator
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|append
argument_list|(
name|strings
index|[
name|to
operator|-
literal|1
index|]
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|join (String[] strings, String separator)
specifier|public
specifier|static
name|String
name|join
parameter_list|(
name|String
index|[]
name|strings
parameter_list|,
name|String
name|separator
parameter_list|)
block|{
return|return
name|Util
operator|.
name|join
argument_list|(
name|strings
argument_list|,
name|separator
argument_list|,
literal|0
argument_list|,
name|strings
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**      * Converts a relative filename to an absolute one, if necessary. Returns      * null if the file does not exist.<br/>      *       * Uses<ul>      *<li>the default directory associated with the extension of the file</li>      *<li>the standard file directory</li>      *<li>the directory of the bib file</li>      *</ul>      *       * @param metaData      *            The MetaData for the database this file belongs to.      * @param name      *            The file name, may also be a relative path to the file      */
DECL|method|expandFilename (final MetaData metaData, String name)
specifier|public
specifier|static
name|File
name|expandFilename
parameter_list|(
specifier|final
name|MetaData
name|metaData
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|int
name|pos
init|=
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|String
name|extension
init|=
operator|(
operator|(
name|pos
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|pos
operator|<
operator|(
name|name
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
operator|)
operator|)
condition|?
name|name
operator|.
name|substring
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|.
name|trim
argument_list|()
operator|.
name|toLowerCase
argument_list|()
else|:
literal|null
decl_stmt|;
comment|// Find the default directory for this field type, if any:
name|String
index|[]
name|dir
init|=
name|metaData
operator|.
name|getFileDirectory
argument_list|(
name|extension
argument_list|)
decl_stmt|;
comment|// Include the standard "file" directory:
name|String
index|[]
name|fileDir
init|=
name|metaData
operator|.
name|getFileDirectory
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|)
decl_stmt|;
comment|// Include the directory of the bib file:
name|ArrayList
argument_list|<
name|String
argument_list|>
name|al
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|aDir
range|:
name|dir
control|)
block|{
if|if
condition|(
operator|!
name|al
operator|.
name|contains
argument_list|(
name|aDir
argument_list|)
condition|)
block|{
name|al
operator|.
name|add
argument_list|(
name|aDir
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|String
name|aFileDir
range|:
name|fileDir
control|)
block|{
if|if
condition|(
operator|!
name|al
operator|.
name|contains
argument_list|(
name|aFileDir
argument_list|)
condition|)
block|{
name|al
operator|.
name|add
argument_list|(
name|aFileDir
argument_list|)
expr_stmt|;
block|}
block|}
name|String
index|[]
name|dirs
init|=
name|al
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|al
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
return|return
name|Util
operator|.
name|expandFilename
argument_list|(
name|name
argument_list|,
name|dirs
argument_list|)
return|;
block|}
comment|/**      * Converts a relative filename to an absolute one, if necessary. Returns      * null if the file does not exist.      *       * Will look in each of the given dirs starting from the beginning and      * returning the first found file to match if any.      */
DECL|method|expandFilename (String name, String[] dir)
specifier|public
specifier|static
name|File
name|expandFilename
parameter_list|(
name|String
name|name
parameter_list|,
name|String
index|[]
name|dir
parameter_list|)
block|{
for|for
control|(
name|String
name|aDir
range|:
name|dir
control|)
block|{
if|if
condition|(
name|aDir
operator|!=
literal|null
condition|)
block|{
name|File
name|result
init|=
name|Util
operator|.
name|expandFilename
argument_list|(
name|name
argument_list|,
name|aDir
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Converts a relative filename to an absolute one, if necessary. Returns      * null if the file does not exist.      */
DECL|method|expandFilename (String name, String dir)
specifier|public
specifier|static
name|File
name|expandFilename
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|dir
parameter_list|)
block|{
name|File
name|file
decl_stmt|;
if|if
condition|(
operator|(
name|name
operator|==
literal|null
operator|)
operator|||
operator|(
name|name
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|file
operator|=
operator|new
name|File
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
operator|&&
operator|(
name|dir
operator|!=
literal|null
operator|)
condition|)
block|{
if|if
condition|(
name|dir
operator|.
name|endsWith
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
argument_list|)
condition|)
block|{
name|name
operator|=
name|dir
operator|+
name|name
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|dir
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
operator|+
name|name
expr_stmt|;
block|}
comment|// System.out.println("expanded to: "+name);
comment|// if (name.startsWith("ftp"))
name|file
operator|=
operator|new
name|File
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
name|file
return|;
block|}
comment|// Ok, try to fix / and \ problems:
if|if
condition|(
name|Globals
operator|.
name|ON_WIN
condition|)
block|{
comment|// workaround for catching Java bug in regexp replacer
comment|// and, why, why, why ... I don't get it - wegner 2006/01/22
try|try
block|{
name|name
operator|=
name|name
operator|.
name|replaceAll
argument_list|(
literal|"/"
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|StringIndexOutOfBoundsException
name|exc
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"An internal Java error was caused by the entry "
operator|+
literal|"\""
operator|+
name|name
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|name
operator|=
name|name
operator|.
name|replaceAll
argument_list|(
literal|"\\\\"
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
comment|// System.out.println("expandFilename: "+name);
name|file
operator|=
operator|new
name|File
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
name|file
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|return
name|file
return|;
block|}
comment|/**      * Converts an absolute filename to a relative one, if necessary.      * Returns the parameter fileName itself if no shortening is possible       *       * This method works correctly only if dirs are sorted decent in their length      * i.e. /home/user/literature/important before /home/user/literature       *      * @param fileName the file name to be shortened      * @param dirs directories to check.      */
DECL|method|shortenFileName (File fileName, String[] dirs)
specifier|public
specifier|static
name|File
name|shortenFileName
parameter_list|(
name|File
name|fileName
parameter_list|,
name|String
index|[]
name|dirs
parameter_list|)
block|{
if|if
condition|(
operator|(
name|fileName
operator|==
literal|null
operator|)
operator|||
operator|(
name|fileName
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|fileName
return|;
block|}
if|if
condition|(
operator|!
name|fileName
operator|.
name|isAbsolute
argument_list|()
operator|||
operator|(
name|dirs
operator|==
literal|null
operator|)
condition|)
block|{
return|return
name|fileName
return|;
block|}
for|for
control|(
name|String
name|dir
range|:
name|dirs
control|)
block|{
if|if
condition|(
name|dir
operator|!=
literal|null
condition|)
block|{
name|File
name|result
init|=
name|Util
operator|.
name|shortenFileName
argument_list|(
name|fileName
argument_list|,
name|dir
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|result
operator|.
name|equals
argument_list|(
name|fileName
argument_list|)
operator|)
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
block|}
return|return
name|fileName
return|;
block|}
DECL|method|shortenFileName (File fileName, String dir)
specifier|private
specifier|static
name|File
name|shortenFileName
parameter_list|(
name|File
name|fileName
parameter_list|,
name|String
name|dir
parameter_list|)
block|{
if|if
condition|(
operator|(
name|fileName
operator|==
literal|null
operator|)
operator|||
operator|(
name|fileName
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|fileName
return|;
block|}
if|if
condition|(
operator|!
name|fileName
operator|.
name|isAbsolute
argument_list|()
operator|||
operator|(
name|dir
operator|==
literal|null
operator|)
condition|)
block|{
return|return
name|fileName
return|;
block|}
name|String
name|longName
decl_stmt|;
if|if
condition|(
name|Globals
operator|.
name|ON_WIN
condition|)
block|{
comment|// case-insensitive matching on Windows
name|longName
operator|=
name|fileName
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|dir
operator|=
name|dir
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|longName
operator|=
name|fileName
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dir
operator|.
name|endsWith
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
argument_list|)
condition|)
block|{
name|dir
operator|=
name|dir
operator|.
name|concat
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|longName
operator|.
name|startsWith
argument_list|(
name|dir
argument_list|)
condition|)
block|{
comment|// result is based on original name, not on lower-cased name
name|String
name|newName
init|=
name|fileName
operator|.
name|toString
argument_list|()
operator|.
name|substring
argument_list|(
name|dir
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|File
argument_list|(
name|newName
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|fileName
return|;
block|}
block|}
comment|/**      * Sets empty or non-existing owner fields of bibtex entries inside a List      * to a specified default value. Timestamp field is also set. Preferences      * are checked to see if these options are enabled.      *       * @param bibs      *            List of bibtex entries      */
DECL|method|setAutomaticFields (Collection<BibtexEntry> bibs, boolean overwriteOwner, boolean overwriteTimestamp, boolean markEntries)
specifier|public
specifier|static
name|void
name|setAutomaticFields
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|bibs
parameter_list|,
name|boolean
name|overwriteOwner
parameter_list|,
name|boolean
name|overwriteTimestamp
parameter_list|,
name|boolean
name|markEntries
parameter_list|)
block|{
name|String
name|timeStampField
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"timeStampField"
argument_list|)
decl_stmt|;
name|String
name|defaultOwner
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"defaultOwner"
argument_list|)
decl_stmt|;
name|String
name|timestamp
init|=
name|Util
operator|.
name|easyDateFormat
argument_list|()
decl_stmt|;
name|boolean
name|globalSetOwner
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"useOwner"
argument_list|)
decl_stmt|,
name|globalSetTimeStamp
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"useTimeStamp"
argument_list|)
decl_stmt|;
comment|// Do not need to do anything if all options are disabled
if|if
condition|(
operator|!
operator|(
name|globalSetOwner
operator|||
name|globalSetTimeStamp
operator|||
name|markEntries
operator|)
condition|)
block|{
return|return;
block|}
comment|// Iterate through all entries
for|for
control|(
name|BibtexEntry
name|curEntry
range|:
name|bibs
control|)
block|{
name|boolean
name|setOwner
init|=
name|globalSetOwner
operator|&&
operator|(
name|overwriteOwner
operator|||
operator|(
name|curEntry
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|OWNER
argument_list|)
operator|==
literal|null
operator|)
operator|)
decl_stmt|;
name|boolean
name|setTimeStamp
init|=
name|globalSetTimeStamp
operator|&&
operator|(
name|overwriteTimestamp
operator|||
operator|(
name|curEntry
operator|.
name|getField
argument_list|(
name|timeStampField
argument_list|)
operator|==
literal|null
operator|)
operator|)
decl_stmt|;
name|Util
operator|.
name|setAutomaticFields
argument_list|(
name|curEntry
argument_list|,
name|setOwner
argument_list|,
name|defaultOwner
argument_list|,
name|setTimeStamp
argument_list|,
name|timeStampField
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|markEntries
condition|)
block|{
name|Util
operator|.
name|markEntry
argument_list|(
name|curEntry
argument_list|,
name|Util
operator|.
name|IMPORT_MARK_LEVEL
argument_list|,
literal|false
argument_list|,
operator|new
name|NamedCompound
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Sets empty or non-existing owner fields of a bibtex entry to a specified      * default value. Timestamp field is also set. Preferences are checked to      * see if these options are enabled.      *       * @param entry      *            The entry to set fields for.      * @param overwriteOwner      *              Indicates whether owner should be set if it is already set.      * @param overwriteTimestamp      *              Indicates whether timestamp should be set if it is already set.      */
DECL|method|setAutomaticFields (BibtexEntry entry, boolean overwriteOwner, boolean overwriteTimestamp)
specifier|public
specifier|static
name|void
name|setAutomaticFields
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|boolean
name|overwriteOwner
parameter_list|,
name|boolean
name|overwriteTimestamp
parameter_list|)
block|{
name|String
name|defaultOwner
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"defaultOwner"
argument_list|)
decl_stmt|;
name|String
name|timestamp
init|=
name|Util
operator|.
name|easyDateFormat
argument_list|()
decl_stmt|;
name|String
name|timeStampField
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"timeStampField"
argument_list|)
decl_stmt|;
name|boolean
name|setOwner
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"useOwner"
argument_list|)
operator|&&
operator|(
name|overwriteOwner
operator|||
operator|(
name|entry
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|OWNER
argument_list|)
operator|==
literal|null
operator|)
operator|)
decl_stmt|;
name|boolean
name|setTimeStamp
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"useTimeStamp"
argument_list|)
operator|&&
operator|(
name|overwriteTimestamp
operator|||
operator|(
name|entry
operator|.
name|getField
argument_list|(
name|timeStampField
argument_list|)
operator|==
literal|null
operator|)
operator|)
decl_stmt|;
name|Util
operator|.
name|setAutomaticFields
argument_list|(
name|entry
argument_list|,
name|setOwner
argument_list|,
name|defaultOwner
argument_list|,
name|setTimeStamp
argument_list|,
name|timeStampField
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
block|}
DECL|method|setAutomaticFields (BibtexEntry entry, boolean setOwner, String owner, boolean setTimeStamp, String timeStampField, String timeStamp)
specifier|private
specifier|static
name|void
name|setAutomaticFields
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|boolean
name|setOwner
parameter_list|,
name|String
name|owner
parameter_list|,
name|boolean
name|setTimeStamp
parameter_list|,
name|String
name|timeStampField
parameter_list|,
name|String
name|timeStamp
parameter_list|)
block|{
comment|// Set owner field if this option is enabled:
if|if
condition|(
name|setOwner
condition|)
block|{
comment|// No or empty owner field?
comment|// if (entry.getField(Globals.OWNER) == null
comment|// || ((String) entry.getField(Globals.OWNER)).length() == 0) {
comment|// Set owner field to default value
name|entry
operator|.
name|setField
argument_list|(
name|BibtexFields
operator|.
name|OWNER
argument_list|,
name|owner
argument_list|)
expr_stmt|;
comment|// }
block|}
if|if
condition|(
name|setTimeStamp
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|timeStampField
argument_list|,
name|timeStamp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Copies a file.      *       * @param source      *            File Source file      * @param dest      *            File Destination file      * @param deleteIfExists      *            boolean Determines whether the copy goes on even if the file      *            exists.      * @throws IOException      * @return boolean Whether the copy succeeded, or was stopped due to the      *         file already existing.      */
DECL|method|copyFile (File source, File dest, boolean deleteIfExists)
specifier|public
specifier|static
name|boolean
name|copyFile
parameter_list|(
name|File
name|source
parameter_list|,
name|File
name|dest
parameter_list|,
name|boolean
name|deleteIfExists
parameter_list|)
throws|throws
name|IOException
block|{
name|BufferedInputStream
name|in
init|=
literal|null
decl_stmt|;
name|BufferedOutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// Check if the file already exists.
if|if
condition|(
name|dest
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|deleteIfExists
condition|)
block|{
return|return
literal|false
return|;
comment|// else dest.delete();
block|}
block|}
name|in
operator|=
operator|new
name|BufferedInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|=
operator|new
name|BufferedOutputStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|el
decl_stmt|;
comment|// int tell = 0;
while|while
condition|(
operator|(
name|el
operator|=
name|in
operator|.
name|read
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|el
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * This method is called at startup, and makes necessary adaptations to      * preferences for users from an earlier version of Jabref.      */
DECL|method|performCompatibilityUpdate ()
specifier|public
specifier|static
name|void
name|performCompatibilityUpdate
parameter_list|()
block|{
comment|// Make sure "abstract" is not in General fields, because
comment|// Jabref 1.55 moves the abstract to its own tab.
name|String
name|genFields
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"generalFields"
argument_list|)
decl_stmt|;
comment|// pr(genFields+"\t"+genFields.indexOf("abstract"));
if|if
condition|(
name|genFields
operator|.
name|contains
argument_list|(
literal|"abstract"
argument_list|)
condition|)
block|{
comment|// pr(genFields+"\t"+genFields.indexOf("abstract"));
name|String
name|newGen
decl_stmt|;
if|if
condition|(
name|genFields
operator|.
name|equals
argument_list|(
literal|"abstract"
argument_list|)
condition|)
block|{
name|newGen
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|genFields
operator|.
name|contains
argument_list|(
literal|";abstract;"
argument_list|)
condition|)
block|{
name|newGen
operator|=
name|genFields
operator|.
name|replaceAll
argument_list|(
literal|";abstract;"
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|genFields
operator|.
name|indexOf
argument_list|(
literal|"abstract;"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newGen
operator|=
name|genFields
operator|.
name|replaceAll
argument_list|(
literal|"abstract;"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|genFields
operator|.
name|indexOf
argument_list|(
literal|";abstract"
argument_list|)
operator|==
operator|(
name|genFields
operator|.
name|length
argument_list|()
operator|-
literal|9
operator|)
condition|)
block|{
name|newGen
operator|=
name|genFields
operator|.
name|replaceAll
argument_list|(
literal|";abstract"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newGen
operator|=
name|genFields
expr_stmt|;
block|}
comment|// pr(newGen);
name|Globals
operator|.
name|prefs
operator|.
name|put
argument_list|(
literal|"generalFields"
argument_list|,
name|newGen
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Collect file links from the given set of fields, and add them to the list contained      * in the field GUIGlobals.FILE_FIELD.      * @param database The database to modify.      * @param fields The fields to find links in.      * @return A CompoundEdit specifying the undo operation for the whole operation.      */
DECL|method|upgradePdfPsToFile (BibtexDatabase database, String[] fields)
specifier|public
specifier|static
name|NamedCompound
name|upgradePdfPsToFile
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|String
index|[]
name|fields
parameter_list|)
block|{
return|return
name|Util
operator|.
name|upgradePdfPsToFile
argument_list|(
name|database
operator|.
name|getEntryMap
argument_list|()
operator|.
name|values
argument_list|()
argument_list|,
name|fields
argument_list|)
return|;
block|}
comment|/**      * Collect file links from the given set of fields, and add them to the list contained      * in the field GUIGlobals.FILE_FIELD.      * @param entries The entries to modify.      * @param fields The fields to find links in.      * @return A CompoundEdit specifying the undo operation for the whole operation.      */
DECL|method|upgradePdfPsToFile (Collection<BibtexEntry> entries, String[] fields)
specifier|public
specifier|static
name|NamedCompound
name|upgradePdfPsToFile
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
name|String
index|[]
name|fields
parameter_list|)
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Move external links to 'file' field"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|FileListTableModel
name|tableModel
init|=
operator|new
name|FileListTableModel
argument_list|()
decl_stmt|;
comment|// If there are already links in the file field, keep those on top:
name|String
name|oldFileContent
init|=
name|entry
operator|.
name|getField
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldFileContent
operator|!=
literal|null
condition|)
block|{
name|tableModel
operator|.
name|setContent
argument_list|(
name|oldFileContent
argument_list|)
expr_stmt|;
block|}
name|int
name|oldRowCount
init|=
name|tableModel
operator|.
name|getRowCount
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
name|String
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|o
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|FileListEntry
name|flEntry
init|=
operator|new
name|FileListEntry
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|o
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeByExt
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
name|tableModel
operator|.
name|addEntry
argument_list|(
name|tableModel
operator|.
name|getRowCount
argument_list|()
argument_list|,
name|flEntry
argument_list|)
expr_stmt|;
name|entry
operator|.
name|clearField
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|field
argument_list|,
name|o
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tableModel
operator|.
name|getRowCount
argument_list|()
operator|!=
name|oldRowCount
condition|)
block|{
name|String
name|newValue
init|=
name|tableModel
operator|.
name|getStringRepresentation
argument_list|()
decl_stmt|;
name|entry
operator|.
name|setField
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|,
name|oldFileContent
argument_list|,
name|newValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
return|return
name|ce
return|;
block|}
comment|// -------------------------------------------------------------------------------
comment|/**      * extends the filename with a default Extension, if no Extension '.x' could      * be found      */
DECL|method|getCorrectFileName (String orgName, String defaultExtension)
specifier|public
specifier|static
name|String
name|getCorrectFileName
parameter_list|(
name|String
name|orgName
parameter_list|,
name|String
name|defaultExtension
parameter_list|)
block|{
if|if
condition|(
name|orgName
operator|==
literal|null
condition|)
block|{
return|return
literal|""
return|;
block|}
name|String
name|back
init|=
name|orgName
decl_stmt|;
name|int
name|t
init|=
name|orgName
operator|.
name|indexOf
argument_list|(
literal|"."
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// hidden files Linux/Unix (?)
if|if
condition|(
name|t
operator|<
literal|1
condition|)
block|{
name|back
operator|=
name|back
operator|+
literal|"."
operator|+
name|defaultExtension
expr_stmt|;
block|}
return|return
name|back
return|;
block|}
comment|/**      * Quotes each and every character, e.g. '!' as&#33;. Used for verbatim      * display of arbitrary strings that may contain HTML entities.      */
DECL|method|quoteForHTML (String s)
specifier|public
specifier|static
name|String
name|quoteForHTML
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"&#"
argument_list|)
operator|.
name|append
argument_list|(
operator|(
name|int
operator|)
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|quote (String s, String specials, char quoteChar)
specifier|public
specifier|static
name|String
name|quote
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|specials
parameter_list|,
name|char
name|quoteChar
parameter_list|)
block|{
return|return
name|Util
operator|.
name|quote
argument_list|(
name|s
argument_list|,
name|specials
argument_list|,
name|quoteChar
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**      * Quote special characters.      *       * @param s      *            The String which may contain special characters.      * @param specials      *            A String containing all special characters except the quoting      *            character itself, which is automatically quoted.      * @param quoteChar      *            The quoting character.      * @param linewrap      *            The number of characters after which a linebreak is inserted      *            (this linebreak is undone by unquote()). Set to 0 to disable.      * @return A String with every special character (including the quoting      *         character itself) quoted.      */
DECL|method|quote (String s, String specials, char quoteChar, int linewrap)
specifier|private
specifier|static
name|String
name|quote
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|specials
parameter_list|,
name|char
name|quoteChar
parameter_list|,
name|int
name|linewrap
parameter_list|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|linelength
init|=
literal|0
decl_stmt|;
name|boolean
name|isSpecial
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|c
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|isSpecial
operator|=
operator|(
name|specials
operator|.
name|indexOf
argument_list|(
name|c
argument_list|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|c
operator|==
name|quoteChar
operator|)
expr_stmt|;
comment|// linebreak?
if|if
condition|(
operator|(
name|linewrap
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|++
name|linelength
operator|>=
name|linewrap
operator|)
operator|||
operator|(
name|isSpecial
operator|&&
operator|(
name|linelength
operator|>=
operator|(
name|linewrap
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|quoteChar
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|linelength
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|isSpecial
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|quoteChar
argument_list|)
expr_stmt|;
operator|++
name|linelength
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Unquote special characters.      *       * @param s      *            The String which may contain quoted special characters.      * @param quoteChar      *            The quoting character.      * @return A String with all quoted characters unquoted.      */
DECL|method|unquote (String s, char quoteChar)
specifier|public
specifier|static
name|String
name|unquote
parameter_list|(
name|String
name|s
parameter_list|,
name|char
name|quoteChar
parameter_list|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|char
name|c
decl_stmt|;
name|boolean
name|quoted
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|c
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|quoted
condition|)
block|{
comment|// append literally...
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|quoted
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
name|quoteChar
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// quote char
name|quoted
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Quote all regular expression meta characters in s, in order to search for      * s literally.      */
DECL|method|quoteMeta (String s)
specifier|public
specifier|static
name|String
name|quoteMeta
parameter_list|(
name|String
name|s
parameter_list|)
block|{
comment|// work around a bug: trailing backslashes have to be quoted
comment|// individually
name|int
name|i
init|=
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
name|StringBuffer
name|bs
init|=
operator|new
name|StringBuffer
argument_list|(
literal|""
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'\\'
operator|)
condition|)
block|{
operator|--
name|i
expr_stmt|;
name|bs
operator|.
name|append
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|"\\Q"
operator|+
name|s
operator|.
name|replaceAll
argument_list|(
literal|"\\\\E"
argument_list|,
literal|"\\\\E\\\\\\\\E\\\\Q"
argument_list|)
operator|+
literal|"\\E"
operator|+
name|bs
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This method "tidies" up e.g. a keyword string, by alphabetizing the words      * and removing all duplicates.      *      * Currently not used anywhere      */
DECL|method|sortWordsAndRemoveDuplicates (String text)
specifier|public
specifier|static
name|String
name|sortWordsAndRemoveDuplicates
parameter_list|(
name|String
name|text
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|words
init|=
name|Util
operator|.
name|getSeparatedKeywords
argument_list|(
name|text
argument_list|)
decl_stmt|;
comment|// by adding the words to a set, they are automatically sorted
name|TreeSet
argument_list|<
name|String
argument_list|>
name|set
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|words
argument_list|)
decl_stmt|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|aSet
range|:
name|set
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|aSet
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|2
condition|)
block|{
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|result
init|=
name|sb
operator|.
name|toString
argument_list|()
decl_stmt|;
return|return
name|result
operator|.
name|length
argument_list|()
operator|>
literal|2
condition|?
name|result
else|:
literal|""
return|;
block|}
comment|/**      * Warns the user of undesired side effects of an explicit      * assignment/removal of entries to/from this group. Currently there are      * four types of groups: AllEntriesGroup, SearchGroup - do not support      * explicit assignment. ExplicitGroup - never modifies entries. KeywordGroup -      * only this modifies entries upon assignment/removal. Modifications are      * acceptable unless they affect a standard field (such as "author") besides      * the "keywords" field.      *       * @param parent      *            The Component used as a parent when displaying a confirmation      *            dialog.      * @return true if the assignment has no undesired side effects, or the user      *         chose to perform it anyway. false otherwise (this indicates that      *         the user has aborted the assignment).      */
DECL|method|warnAssignmentSideEffects (AbstractGroup[] groups, BibtexEntry[] entries, BibtexDatabase db, Component parent)
specifier|public
specifier|static
name|boolean
name|warnAssignmentSideEffects
parameter_list|(
name|AbstractGroup
index|[]
name|groups
parameter_list|,
name|BibtexEntry
index|[]
name|entries
parameter_list|,
name|BibtexDatabase
name|db
parameter_list|,
name|Component
name|parent
parameter_list|)
block|{
name|Vector
argument_list|<
name|String
argument_list|>
name|affectedFields
init|=
operator|new
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|AbstractGroup
name|group
range|:
name|groups
control|)
block|{
if|if
condition|(
name|group
operator|instanceof
name|KeywordGroup
condition|)
block|{
name|KeywordGroup
name|kg
init|=
operator|(
name|KeywordGroup
operator|)
name|group
decl_stmt|;
name|String
name|field
init|=
name|kg
operator|.
name|getSearchField
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
literal|"keywords"
argument_list|)
condition|)
block|{
continue|continue;
comment|// this is not undesired
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|BibtexFields
operator|.
name|numberOfPublicFields
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
name|BibtexFields
operator|.
name|getFieldName
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|affectedFields
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|affectedFields
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
comment|// no side effects
block|}
comment|// show a warning, then return
name|StringBuffer
name|message
init|=
comment|// JZTODO lyrics...
operator|new
name|StringBuffer
argument_list|(
literal|"This action will modify the following field(s)\n"
operator|+
literal|"in at least one entry each:\n"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|affectedFields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|message
operator|.
name|append
argument_list|(
name|affectedFields
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|message
operator|.
name|append
argument_list|(
literal|"This could cause undesired changes to "
operator|+
literal|"your entries, so it is\nrecommended that you change the grouping field "
operator|+
literal|"in your group\ndefinition to \"keywords\" or a non-standard name."
operator|+
literal|"\n\nDo you still want to continue?"
argument_list|)
expr_stmt|;
name|int
name|choice
init|=
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|parent
argument_list|,
name|message
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Warning"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_OPTION
argument_list|,
name|JOptionPane
operator|.
name|WARNING_MESSAGE
argument_list|)
decl_stmt|;
return|return
name|choice
operator|!=
name|JOptionPane
operator|.
name|NO_OPTION
return|;
comment|// if (groups instanceof KeywordGroup) {
comment|// KeywordGroup kg = (KeywordGroup) groups;
comment|// String field = kg.getSearchField().toLowerCase();
comment|// if (field.equals("keywords"))
comment|// return true; // this is not undesired
comment|// for (int i = 0; i< GUIGlobals.ALL_FIELDS.length; ++i) {
comment|// if (field.equals(GUIGlobals.ALL_FIELDS[i])) {
comment|// // show a warning, then return
comment|// String message = Globals // JZTODO lyrics...
comment|// .lang(
comment|// "This action will modify the \"%0\" field "
comment|// + "of your entries.\nThis could cause undesired changes to "
comment|// + "your entries, so it is\nrecommended that you change the grouping
comment|// field "
comment|// + "in your group\ndefinition to \"keywords\" or a non-standard name."
comment|// + "\n\nDo you still want to continue?",
comment|// field);
comment|// int choice = JOptionPane.showConfirmDialog(parent, message,
comment|// Globals.lang("Warning"), JOptionPane.YES_NO_OPTION,
comment|// JOptionPane.WARNING_MESSAGE);
comment|// return choice != JOptionPane.NO_OPTION;
comment|// }
comment|// }
comment|// }
comment|// return true; // found no side effects
block|}
comment|// ========================================================
comment|// lot of abreviations in medline
comment|// PKC etc convert to {PKC} ...
comment|// ========================================================
DECL|field|titleCapitalPattern
specifier|static
name|Pattern
name|titleCapitalPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[A-Z]+"
argument_list|)
decl_stmt|;
comment|/**      * Wrap all uppercase letters, or sequences of uppercase letters, in curly      * braces. Ignore letters within a pair of # character, as these are part of      * a string label that should not be modified.      *       * @param s      *            The string to modify.      * @return The resulting string after wrapping capitals.      */
DECL|method|putBracesAroundCapitals (String s)
specifier|public
specifier|static
name|String
name|putBracesAroundCapitals
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|boolean
name|inString
init|=
literal|false
decl_stmt|,
name|isBracing
init|=
literal|false
decl_stmt|,
name|escaped
init|=
literal|false
decl_stmt|;
name|int
name|inBrace
init|=
literal|0
decl_stmt|;
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// Update variables based on special characters:
name|int
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
name|inBrace
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
block|{
name|inBrace
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|escaped
operator|&&
operator|(
name|c
operator|==
literal|'#'
operator|)
condition|)
block|{
name|inString
operator|=
operator|!
name|inString
expr_stmt|;
block|}
comment|// See if we should start bracing:
if|if
condition|(
operator|(
name|inBrace
operator|==
literal|0
operator|)
operator|&&
operator|!
name|isBracing
operator|&&
operator|!
name|inString
operator|&&
name|Character
operator|.
name|isLetter
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|&&
name|Character
operator|.
name|isUpperCase
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|isBracing
operator|=
literal|true
expr_stmt|;
block|}
comment|// See if we should close a brace set:
if|if
condition|(
name|isBracing
operator|&&
operator|!
operator|(
name|Character
operator|.
name|isLetter
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|&&
name|Character
operator|.
name|isUpperCase
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|isBracing
operator|=
literal|false
expr_stmt|;
block|}
comment|// Add the current character:
name|buf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
comment|// Check if we are entering an escape sequence:
name|escaped
operator|=
operator|(
name|c
operator|==
literal|'\\'
operator|)
operator|&&
operator|!
name|escaped
expr_stmt|;
block|}
comment|// Check if we have an unclosed brace:
if|if
condition|(
name|isBracing
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
comment|/*          * if (s.length() == 0) return s; // Protect against ArrayIndexOutOf....          * StringBuffer buf = new StringBuffer();          *           * Matcher mcr = titleCapitalPattern.matcher(s.substring(1)); while          * (mcr.find()) { String replaceStr = mcr.group();          * mcr.appendReplacement(buf, "{" + replaceStr + "}"); }          * mcr.appendTail(buf); return s.substring(0, 1) + buf.toString();          */
block|}
DECL|field|bracedTitleCapitalPattern
specifier|private
specifier|static
specifier|final
name|Pattern
name|bracedTitleCapitalPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\{[A-Z]+\\}"
argument_list|)
decl_stmt|;
comment|/**      * This method looks for occurences of capital letters enclosed in an      * arbitrary number of pairs of braces, e.g. "{AB}" or "{{T}}". All of these      * pairs of braces are removed.      *       * @param s      *            The String to analyze.      * @return A new String with braces removed.      */
DECL|method|removeBracesAroundCapitals (String s)
specifier|public
specifier|static
name|String
name|removeBracesAroundCapitals
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|String
name|previous
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|Util
operator|.
name|removeSingleBracesAroundCapitals
argument_list|(
name|s
argument_list|)
operator|)
operator|.
name|length
argument_list|()
operator|<
name|previous
operator|.
name|length
argument_list|()
condition|)
block|{
name|previous
operator|=
name|s
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/**      * This method looks for occurences of capital letters enclosed in one pair      * of braces, e.g. "{AB}". All these are replaced by only the capitals in      * between the braces.      *       * @param s      *            The String to analyze.      * @return A new String with braces removed.      */
DECL|method|removeSingleBracesAroundCapitals (String s)
specifier|private
specifier|static
name|String
name|removeSingleBracesAroundCapitals
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|Matcher
name|mcr
init|=
name|Util
operator|.
name|bracedTitleCapitalPattern
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
name|mcr
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|replaceStr
init|=
name|mcr
operator|.
name|group
argument_list|()
decl_stmt|;
name|mcr
operator|.
name|appendReplacement
argument_list|(
name|buf
argument_list|,
name|replaceStr
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|replaceStr
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mcr
operator|.
name|appendTail
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This method looks up what kind of external binding is used for the given      * field, and constructs on OpenFileFilter suitable for browsing for an      * external file.      *       * @param fieldName      *            The BibTeX field in question.      * @return The file filter.      */
DECL|method|getFileFilterForField (String fieldName)
specifier|public
specifier|static
name|OpenFileFilter
name|getFileFilterForField
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|String
name|s
init|=
name|BibtexFields
operator|.
name|getFieldExtras
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
specifier|final
name|String
name|ext
init|=
literal|"."
operator|+
name|fieldName
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
specifier|final
name|OpenFileFilter
name|off
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"browseDocZip"
argument_list|)
condition|)
block|{
name|off
operator|=
operator|new
name|OpenFileFilter
argument_list|(
operator|new
name|String
index|[]
block|{
name|ext
block|,
name|ext
operator|+
literal|".gz"
block|,
name|ext
operator|+
literal|".bz2"
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|off
operator|=
operator|new
name|OpenFileFilter
argument_list|(
operator|new
name|String
index|[]
block|{
name|ext
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|off
return|;
block|}
comment|/**      * This method can be used to display a "rich" error dialog which offers the      * entire stack trace for an exception.      *       * @param parent      * @param e      */
DECL|method|showQuickErrorDialog (JFrame parent, String title, Exception e)
specifier|public
specifier|static
name|void
name|showQuickErrorDialog
parameter_list|(
name|JFrame
name|parent
parameter_list|,
name|String
name|title
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
comment|// create and configure a text area - fill it with exception text.
specifier|final
name|JPanel
name|pan
init|=
operator|new
name|JPanel
argument_list|()
decl_stmt|,
name|details
init|=
operator|new
name|JPanel
argument_list|()
decl_stmt|;
specifier|final
name|CardLayout
name|crd
init|=
operator|new
name|CardLayout
argument_list|()
decl_stmt|;
name|pan
operator|.
name|setLayout
argument_list|(
name|crd
argument_list|)
expr_stmt|;
specifier|final
name|JTextArea
name|textArea
init|=
operator|new
name|JTextArea
argument_list|()
decl_stmt|;
name|textArea
operator|.
name|setFont
argument_list|(
operator|new
name|Font
argument_list|(
literal|"Sans-Serif"
argument_list|,
name|Font
operator|.
name|PLAIN
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|textArea
operator|.
name|setEditable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|StringWriter
name|writer
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|(
operator|new
name|PrintWriter
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
name|textArea
operator|.
name|setText
argument_list|(
name|writer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|JLabel
name|lab
init|=
operator|new
name|JLabel
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
name|JButton
name|flip
init|=
operator|new
name|JButton
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Details"
argument_list|)
argument_list|)
decl_stmt|;
name|FormLayout
name|layout
init|=
operator|new
name|FormLayout
argument_list|(
literal|"left:pref"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|DefaultFormBuilder
name|builder
init|=
operator|new
name|DefaultFormBuilder
argument_list|(
name|layout
argument_list|)
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|builder
operator|.
name|nextLine
argument_list|()
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|Box
operator|.
name|createVerticalGlue
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|nextLine
argument_list|()
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|flip
argument_list|)
expr_stmt|;
specifier|final
name|JPanel
name|simple
init|=
name|builder
operator|.
name|getPanel
argument_list|()
decl_stmt|;
comment|// stuff it in a scrollpane with a controlled size.
name|JScrollPane
name|scrollPane
init|=
operator|new
name|JScrollPane
argument_list|(
name|textArea
argument_list|)
decl_stmt|;
name|scrollPane
operator|.
name|setPreferredSize
argument_list|(
operator|new
name|Dimension
argument_list|(
literal|350
argument_list|,
literal|150
argument_list|)
argument_list|)
expr_stmt|;
name|details
operator|.
name|setLayout
argument_list|(
operator|new
name|BorderLayout
argument_list|()
argument_list|)
expr_stmt|;
name|details
operator|.
name|add
argument_list|(
name|scrollPane
argument_list|,
name|BorderLayout
operator|.
name|CENTER
argument_list|)
expr_stmt|;
name|flip
operator|.
name|addActionListener
argument_list|(
operator|new
name|ActionListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|actionPerformed
parameter_list|(
name|ActionEvent
name|event
parameter_list|)
block|{
name|crd
operator|.
name|show
argument_list|(
name|pan
argument_list|,
literal|"details"
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|pan
operator|.
name|add
argument_list|(
name|simple
argument_list|,
literal|"simple"
argument_list|)
expr_stmt|;
name|pan
operator|.
name|add
argument_list|(
name|details
argument_list|,
literal|"details"
argument_list|)
expr_stmt|;
comment|// pass the scrollpane to the joptionpane.
name|JOptionPane
operator|.
name|showMessageDialog
argument_list|(
name|parent
argument_list|,
name|pan
argument_list|,
name|title
argument_list|,
name|JOptionPane
operator|.
name|ERROR_MESSAGE
argument_list|)
expr_stmt|;
block|}
DECL|method|wrapHTML (String s, final int lineWidth)
specifier|public
specifier|static
name|String
name|wrapHTML
parameter_list|(
name|String
name|s
parameter_list|,
specifier|final
name|int
name|lineWidth
parameter_list|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|StringTokenizer
name|tok
init|=
operator|new
name|StringTokenizer
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|charsLeft
init|=
name|lineWidth
decl_stmt|;
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|word
init|=
name|tok
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|charsLeft
operator|==
name|lineWidth
condition|)
block|{
comment|// fresh line
name|sb
operator|.
name|append
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|charsLeft
operator|-=
name|word
operator|.
name|length
argument_list|()
expr_stmt|;
if|if
condition|(
name|charsLeft
operator|<=
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"<br>\n"
argument_list|)
expr_stmt|;
name|charsLeft
operator|=
name|lineWidth
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// continue previous line
if|if
condition|(
name|charsLeft
operator|<
operator|(
name|word
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"<br>\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|word
operator|.
name|length
argument_list|()
operator|>=
operator|(
name|lineWidth
operator|-
literal|1
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"<br>\n"
argument_list|)
expr_stmt|;
name|charsLeft
operator|=
name|lineWidth
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|charsLeft
operator|=
name|lineWidth
operator|-
name|word
operator|.
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
operator|.
name|append
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|charsLeft
operator|-=
name|word
operator|.
name|length
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Creates a String containing the current date (and possibly time),      * formatted according to the format set in preferences under the key      * "timeStampFormat".      *       * @return The date string.      */
DECL|method|easyDateFormat ()
specifier|public
specifier|static
name|String
name|easyDateFormat
parameter_list|()
block|{
comment|// Date today = new Date();
return|return
name|Util
operator|.
name|easyDateFormat
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Creates a readable Date string from the parameter date. The format is set      * in preferences under the key "timeStampFormat".      *       * @return The formatted date string.      */
DECL|method|easyDateFormat (Date date)
specifier|public
specifier|static
name|String
name|easyDateFormat
parameter_list|(
name|Date
name|date
parameter_list|)
block|{
comment|// first use, create an instance
if|if
condition|(
name|Util
operator|.
name|dateFormatter
operator|==
literal|null
condition|)
block|{
name|String
name|format
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"timeStampFormat"
argument_list|)
decl_stmt|;
name|Util
operator|.
name|dateFormatter
operator|=
operator|new
name|SimpleDateFormat
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
return|return
name|Util
operator|.
name|dateFormatter
operator|.
name|format
argument_list|(
name|date
argument_list|)
return|;
block|}
comment|/**      * @param increment whether the given increment should be added to the current one. Currently never used in JabRef      */
DECL|method|markEntry (BibtexEntry be, int markIncrement, boolean increment, NamedCompound ce)
specifier|public
specifier|static
name|void
name|markEntry
parameter_list|(
name|BibtexEntry
name|be
parameter_list|,
name|int
name|markIncrement
parameter_list|,
name|boolean
name|increment
parameter_list|,
name|NamedCompound
name|ce
parameter_list|)
block|{
name|Object
name|o
init|=
name|be
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|MARKED
argument_list|)
decl_stmt|;
name|int
name|prevMarkLevel
decl_stmt|;
name|String
name|newValue
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|String
name|s
init|=
name|o
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|index
init|=
name|s
operator|.
name|indexOf
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|WRAPPED_USERNAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
comment|// Already marked 1 for this user.
name|prevMarkLevel
operator|=
literal|1
expr_stmt|;
name|newValue
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
operator|+
name|s
operator|.
name|substring
argument_list|(
name|index
operator|+
name|Globals
operator|.
name|prefs
operator|.
name|WRAPPED_USERNAME
operator|.
name|length
argument_list|()
argument_list|)
operator|+
name|Globals
operator|.
name|prefs
operator|.
name|WRAPPED_USERNAME
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|WRAPPED_USERNAME
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|+
literal|":"
operator|+
operator|(
name|increment
condition|?
name|Math
operator|.
name|min
argument_list|(
name|Util
operator|.
name|MAX_MARKING_LEVEL
argument_list|,
name|prevMarkLevel
operator|+
name|markIncrement
argument_list|)
else|:
name|markIncrement
operator|)
operator|+
literal|"]"
expr_stmt|;
block|}
else|else
block|{
name|Matcher
name|m
init|=
name|Util
operator|.
name|markNumberPattern
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
try|try
block|{
name|prevMarkLevel
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|m
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|newValue
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|m
operator|.
name|start
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|+
operator|(
name|increment
condition|?
name|Math
operator|.
name|min
argument_list|(
name|Util
operator|.
name|MAX_MARKING_LEVEL
argument_list|,
name|prevMarkLevel
operator|+
name|markIncrement
argument_list|)
else|:
name|markIncrement
operator|)
operator|+
name|s
operator|.
name|substring
argument_list|(
name|m
operator|.
name|end
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|ex
parameter_list|)
block|{
comment|// Do nothing.
block|}
block|}
block|}
block|}
if|if
condition|(
name|newValue
operator|==
literal|null
condition|)
block|{
name|newValue
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|WRAPPED_USERNAME
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|WRAPPED_USERNAME
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|+
literal|":"
operator|+
name|markIncrement
operator|+
literal|"]"
expr_stmt|;
block|}
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|be
argument_list|,
name|BibtexFields
operator|.
name|MARKED
argument_list|,
name|be
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|MARKED
argument_list|)
argument_list|,
name|newValue
argument_list|)
argument_list|)
expr_stmt|;
name|be
operator|.
name|setField
argument_list|(
name|BibtexFields
operator|.
name|MARKED
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
block|}
comment|/**      * SIDE EFFECT: Unselectes given entry      */
DECL|method|unmarkEntry (BibtexEntry be, boolean onlyMaxLevel, BibtexDatabase database, NamedCompound ce)
specifier|public
specifier|static
name|void
name|unmarkEntry
parameter_list|(
name|BibtexEntry
name|be
parameter_list|,
name|boolean
name|onlyMaxLevel
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|,
name|NamedCompound
name|ce
parameter_list|)
block|{
name|Object
name|o
init|=
name|be
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|MARKED
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|String
name|s
init|=
name|o
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"0"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|onlyMaxLevel
condition|)
block|{
name|Util
operator|.
name|unmarkOldStyle
argument_list|(
name|be
argument_list|,
name|database
argument_list|,
name|ce
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|String
name|newValue
init|=
literal|null
decl_stmt|;
name|int
name|index
init|=
name|s
operator|.
name|indexOf
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|WRAPPED_USERNAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
comment|// Marked 1 for this user.
if|if
condition|(
operator|!
name|onlyMaxLevel
condition|)
block|{
name|newValue
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
operator|+
name|s
operator|.
name|substring
argument_list|(
name|index
operator|+
name|Globals
operator|.
name|prefs
operator|.
name|WRAPPED_USERNAME
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
block|}
else|else
block|{
name|Matcher
name|m
init|=
name|Util
operator|.
name|markNumberPattern
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
try|try
block|{
name|int
name|prevMarkLevel
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|m
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|onlyMaxLevel
operator|||
operator|(
name|prevMarkLevel
operator|==
name|Util
operator|.
name|MARK_COLOR_LEVELS
operator|)
condition|)
block|{
if|if
condition|(
name|prevMarkLevel
operator|>
literal|1
condition|)
block|{
name|newValue
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|m
operator|.
name|start
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|+
name|s
operator|.
name|substring
argument_list|(
name|m
operator|.
name|end
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|toRemove
init|=
name|Globals
operator|.
name|prefs
operator|.
name|WRAPPED_USERNAME
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|WRAPPED_USERNAME
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|+
literal|":1]"
decl_stmt|;
name|index
operator|=
name|s
operator|.
name|indexOf
argument_list|(
name|toRemove
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|newValue
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
operator|+
name|s
operator|.
name|substring
argument_list|(
name|index
operator|+
name|toRemove
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|ex
parameter_list|)
block|{
comment|// Do nothing.
block|}
block|}
block|}
comment|/*int piv = 0, hit;             StringBuffer sb = new StringBuffer();             while ((hit = s.indexOf(G047749118118             1110lobals.prefs.WRAPPED_USERNAME, piv))>= 0) {             	if (hit> 0)             		sb.append(s.substring(piv, hit));             	piv = hit + Globals.prefs.WRAPPED_USERNAME.length();             }             if (piv< s.length() - 1) {             	sb.append(s.substring(piv));             }             String newVal = sb.length()> 0 ? sb.toString() : null;*/
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|be
argument_list|,
name|BibtexFields
operator|.
name|MARKED
argument_list|,
name|be
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|MARKED
argument_list|)
argument_list|,
name|newValue
argument_list|)
argument_list|)
expr_stmt|;
name|be
operator|.
name|setField
argument_list|(
name|BibtexFields
operator|.
name|MARKED
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * An entry is marked with a "0", not in the new style with user names. We      * want to unmark it as transparently as possible. Since this shouldn't      * happen too often, we do it by scanning the "owner" fields of the entire      * database, collecting all user names. We then mark the entry for all users      * except the current one. Thus only the user who unmarks will see that it      * is unmarked, and we get rid of the old-style marking.      *       * @param be      * @param ce      */
DECL|method|unmarkOldStyle (BibtexEntry be, BibtexDatabase database, NamedCompound ce)
specifier|private
specifier|static
name|void
name|unmarkOldStyle
parameter_list|(
name|BibtexEntry
name|be
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|,
name|NamedCompound
name|ce
parameter_list|)
block|{
name|TreeSet
argument_list|<
name|Object
argument_list|>
name|owners
init|=
operator|new
name|TreeSet
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|database
operator|.
name|getEntries
argument_list|()
control|)
block|{
name|Object
name|o
init|=
name|entry
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|OWNER
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|owners
operator|.
name|add
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|// System.out.println("Owner: "+entry.getField(Globals.OWNER));
block|}
block|}
name|owners
operator|.
name|remove
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"defaultOwner"
argument_list|)
argument_list|)
expr_stmt|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|owner
range|:
name|owners
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|owner
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|String
name|newVal
init|=
name|sb
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|newVal
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|newVal
operator|=
literal|null
expr_stmt|;
block|}
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|be
argument_list|,
name|BibtexFields
operator|.
name|MARKED
argument_list|,
name|be
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|MARKED
argument_list|)
argument_list|,
name|newVal
argument_list|)
argument_list|)
expr_stmt|;
name|be
operator|.
name|setField
argument_list|(
name|BibtexFields
operator|.
name|MARKED
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
block|}
DECL|method|isMarked (BibtexEntry be)
specifier|public
specifier|static
name|int
name|isMarked
parameter_list|(
name|BibtexEntry
name|be
parameter_list|)
block|{
name|Object
name|fieldVal
init|=
name|be
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|MARKED
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldVal
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
name|String
name|s
init|=
operator|(
name|String
operator|)
name|fieldVal
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|"0"
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
name|int
name|index
init|=
name|s
operator|.
name|indexOf
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|WRAPPED_USERNAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
name|Matcher
name|m
init|=
name|Util
operator|.
name|markNumberPattern
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
try|try
block|{
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|m
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|ex
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/**      * Set a given field to a given value for all entries in a Collection. This      * method DOES NOT update any UndoManager, but returns a relevant      * CompoundEdit that should be registered by the caller.      *       * @param entries      *            The entries to set the field for.      * @param field      *            The name of the field to set.      * @param text      *            The value to set. This value can be null, indicating that the      *            field should be cleared.      * @param overwriteValues      *            Indicate whether the value should be set even if an entry      *            already has the field set.      * @return A CompoundEdit for the entire operation.      */
DECL|method|massSetField (Collection<BibtexEntry> entries, String field, String text, boolean overwriteValues)
specifier|public
specifier|static
name|UndoableEdit
name|massSetField
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|text
parameter_list|,
name|boolean
name|overwriteValues
parameter_list|)
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Set field"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|String
name|oldVal
init|=
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|// If we are not allowed to overwrite values, check if there is a
comment|// nonempty
comment|// value already for this entry:
if|if
condition|(
operator|!
name|overwriteValues
operator|&&
operator|(
name|oldVal
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|(
name|oldVal
operator|)
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|text
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|.
name|clearField
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|field
argument_list|,
name|oldVal
argument_list|,
name|text
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
return|return
name|ce
return|;
block|}
comment|/**      * Move contents from one field to another for a Collection of entries.      * @param entries The entries to do this operation for.      * @param field The field to move contents from.      * @param newField The field to move contents into.      * @param overwriteValues If true, overwrites any existing values in the new field.      *          If false, makes no change for entries with existing value in the new field.      * @return A CompoundEdit for the entire operation.      */
DECL|method|massRenameField (Collection<BibtexEntry> entries, String field, String newField, boolean overwriteValues)
specifier|public
specifier|static
name|UndoableEdit
name|massRenameField
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|newField
parameter_list|,
name|boolean
name|overwriteValues
parameter_list|)
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Rename field"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|String
name|valToMove
init|=
name|entry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|// If there is no value, do nothing:
if|if
condition|(
operator|(
name|valToMove
operator|==
literal|null
operator|)
operator|||
operator|(
name|valToMove
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
comment|// If we are not allowed to overwrite values, check if there is a
comment|// nonempy value already for this entry for the new field:
name|String
name|valInNewField
init|=
name|entry
operator|.
name|getField
argument_list|(
name|newField
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|overwriteValues
operator|&&
operator|(
name|valInNewField
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|valInNewField
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
name|entry
operator|.
name|setField
argument_list|(
name|newField
argument_list|,
name|valToMove
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|newField
argument_list|,
name|valInNewField
argument_list|,
name|valToMove
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|clearField
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
name|field
argument_list|,
name|valToMove
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
return|return
name|ce
return|;
block|}
comment|/**      * Make a list of supported character encodings that can encode all      * characters in the given String.      *       * @param characters      *            A String of characters that should be supported by the      *            encodings.      * @return A List of character encodings      */
DECL|method|findEncodingsForString (String characters)
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|findEncodingsForString
parameter_list|(
name|String
name|characters
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|encodings
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Globals
operator|.
name|ENCODINGS
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|CharsetEncoder
name|encoder
init|=
name|Charset
operator|.
name|forName
argument_list|(
name|Globals
operator|.
name|ENCODINGS
index|[
name|i
index|]
argument_list|)
operator|.
name|newEncoder
argument_list|()
decl_stmt|;
if|if
condition|(
name|encoder
operator|.
name|canEncode
argument_list|(
name|characters
argument_list|)
condition|)
block|{
name|encodings
operator|.
name|add
argument_list|(
name|Globals
operator|.
name|ENCODINGS
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|encodings
return|;
block|}
comment|/**      * From http://stackoverflow.com/questions/1030479/most-efficient-way-of-converting-string-to-integer-in-java      *      * @param str      * @return      */
DECL|method|intValueOf (String str)
specifier|public
specifier|static
name|int
name|intValueOf
parameter_list|(
name|String
name|str
parameter_list|)
block|{
name|int
name|ival
init|=
literal|0
decl_stmt|,
name|idx
init|=
literal|0
decl_stmt|,
name|end
decl_stmt|;
name|boolean
name|sign
init|=
literal|false
decl_stmt|;
name|char
name|ch
decl_stmt|;
if|if
condition|(
operator|(
name|str
operator|==
literal|null
operator|)
operator|||
operator|(
operator|(
name|end
operator|=
name|str
operator|.
name|length
argument_list|()
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
operator|(
name|ch
operator|=
name|str
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|)
operator|<
literal|'0'
operator|)
operator|||
operator|(
name|ch
operator|>
literal|'9'
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|sign
operator|=
name|ch
operator|==
literal|'-'
operator|)
operator|||
operator|(
operator|++
name|idx
operator|==
name|end
operator|)
operator|||
operator|(
operator|(
operator|(
name|ch
operator|=
name|str
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
operator|)
operator|<
literal|'0'
operator|)
operator|||
operator|(
name|ch
operator|>
literal|'9'
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
name|str
argument_list|)
throw|;
block|}
for|for
control|(
init|;
condition|;
name|ival
operator|*=
literal|10
control|)
block|{
name|ival
operator|+=
literal|'0'
operator|-
name|ch
expr_stmt|;
if|if
condition|(
operator|++
name|idx
operator|==
name|end
condition|)
block|{
return|return
name|sign
condition|?
name|ival
else|:
operator|-
name|ival
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|ch
operator|=
name|str
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
operator|)
operator|<
literal|'0'
operator|)
operator|||
operator|(
name|ch
operator|>
literal|'9'
operator|)
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
name|str
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Encodes a two-dimensional String array into a single string, using ':' and      * ';' as separators. The characters ':' and ';' are escaped with '\'.      * @param values The String array.      * @return The encoded String.      */
DECL|method|encodeStringArray (String[][] values)
specifier|public
specifier|static
name|String
name|encodeStringArray
parameter_list|(
name|String
index|[]
index|[]
name|values
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|Util
operator|.
name|encodeStringArray
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|values
operator|.
name|length
operator|-
literal|1
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Encodes a String array into a single string, using ':' as separator.      * The characters ':' and ';' are escaped with '\'.      * @param entry The String array.      * @return The encoded String.      */
DECL|method|encodeStringArray (String[] entry)
specifier|private
specifier|static
name|String
name|encodeStringArray
parameter_list|(
name|String
index|[]
name|entry
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|entry
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|Util
operator|.
name|encodeString
argument_list|(
name|entry
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|entry
operator|.
name|length
operator|-
literal|1
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Decodes an encoded double String array back into array form. The array      * is assumed to be square, and delimited by the characters ';' (first dim) and      * ':' (second dim).      * @param value The encoded String to be decoded.      * @return The decoded String array.      */
DECL|method|decodeStringDoubleArray (String value)
specifier|public
specifier|static
name|String
index|[]
index|[]
name|decodeStringDoubleArray
parameter_list|(
name|String
name|value
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|newList
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|thisEntry
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|escaped
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|value
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|value
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|escaped
operator|&&
operator|(
name|c
operator|==
literal|'\\'
operator|)
condition|)
block|{
name|escaped
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|escaped
operator|&&
operator|(
name|c
operator|==
literal|':'
operator|)
condition|)
block|{
name|thisEntry
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|escaped
operator|&&
operator|(
name|c
operator|==
literal|';'
operator|)
condition|)
block|{
name|thisEntry
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
name|newList
operator|.
name|add
argument_list|(
name|thisEntry
argument_list|)
expr_stmt|;
name|thisEntry
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|escaped
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|thisEntry
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|thisEntry
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|newList
operator|.
name|add
argument_list|(
name|thisEntry
argument_list|)
expr_stmt|;
block|}
comment|// Convert to String[][]:
name|String
index|[]
index|[]
name|res
init|=
operator|new
name|String
index|[
name|newList
operator|.
name|size
argument_list|()
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|res
index|[
name|i
index|]
operator|=
operator|new
name|String
index|[
name|newList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|res
index|[
name|i
index|]
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|res
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|newList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
DECL|method|encodeString (String s)
specifier|public
specifier|static
name|String
name|encodeString
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|';'
operator|)
operator|||
operator|(
name|c
operator|==
literal|':'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\\'
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Static equals that can also return the right result when one of the      * objects is null.      *       * @param one      *            The object whose equals method is called if the first is not      *            null.      * @param two      *            The object passed to the first one if the first is not null.      * @return<code>one == null ? two == null : one.equals(two);</code>      */
DECL|method|equals (Object one, Object two)
specifier|public
specifier|static
name|boolean
name|equals
parameter_list|(
name|Object
name|one
parameter_list|,
name|Object
name|two
parameter_list|)
block|{
return|return
name|one
operator|==
literal|null
condition|?
name|two
operator|==
literal|null
else|:
name|one
operator|.
name|equals
argument_list|(
name|two
argument_list|)
return|;
block|}
comment|/**      * Returns the given string but with the first character turned into an      * upper case character.      *       * Example: testTest becomes TestTest      *       * @param string      *            The string to change the first character to upper case to.      * @return A string has the first character turned to upper case and the      *         rest unchanged from the given one.      */
DECL|method|toUpperFirstLetter (String string)
specifier|public
specifier|static
name|String
name|toUpperFirstLetter
parameter_list|(
name|String
name|string
parameter_list|)
block|{
if|if
condition|(
name|string
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
if|if
condition|(
name|string
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|string
return|;
block|}
return|return
name|Character
operator|.
name|toUpperCase
argument_list|(
name|string
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
name|string
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
return|;
block|}
comment|/**      * Run an AbstractWorker's methods using Spin features to put each method      * on the correct thread.      * @param worker The worker to run.      * @throws Throwable       */
DECL|method|runAbstractWorker (AbstractWorker worker)
specifier|public
specifier|static
name|void
name|runAbstractWorker
parameter_list|(
name|AbstractWorker
name|worker
parameter_list|)
throws|throws
name|Throwable
block|{
comment|// This part uses Spin's features:
name|Worker
name|wrk
init|=
name|worker
operator|.
name|getWorker
argument_list|()
decl_stmt|;
comment|// The Worker returned by getWorker() has been wrapped
comment|// by Spin.off(), which makes its methods be run in
comment|// a different thread from the EDT.
name|CallBack
name|clb
init|=
name|worker
operator|.
name|getCallBack
argument_list|()
decl_stmt|;
name|worker
operator|.
name|init
argument_list|()
expr_stmt|;
comment|// This method runs in this same thread, the EDT.
comment|// Useful for initial GUI actions, like printing a message.
comment|// The CallBack returned by getCallBack() has been wrapped
comment|// by Spin.over(), which makes its methods be run on
comment|// the EDT.
name|wrk
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// Runs the potentially time-consuming action
comment|// without freezing the GUI. The magic is that THIS line
comment|// of execution will not continue until run() is finished.
name|clb
operator|.
name|update
argument_list|()
expr_stmt|;
comment|// Runs the update() method on the EDT.
block|}
comment|/**      * This method checks whether there is a lock file for the given file. If      * there is, it waits for 500 ms. This is repeated until the lock is gone      * or we have waited the maximum number of times.      *      * @param file The file to check the lock for.      * @param maxWaitCount The maximum number of times to wait.      * @return true if the lock file is gone, false if it is still there.      */
DECL|method|waitForFileLock (File file, int maxWaitCount)
specifier|public
specifier|static
name|boolean
name|waitForFileLock
parameter_list|(
name|File
name|file
parameter_list|,
name|int
name|maxWaitCount
parameter_list|)
block|{
comment|// Check if the file is locked by another JabRef user:
name|int
name|lockCheckCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|Util
operator|.
name|hasLockFile
argument_list|(
name|file
argument_list|)
condition|)
block|{
if|if
condition|(
name|lockCheckCount
operator|++
operator|==
name|maxWaitCount
condition|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|500
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{             }
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Check whether a lock file exists for this file.      * @param file The file to check.      * @return true if a lock file exists, false otherwise.      */
DECL|method|hasLockFile (File file)
specifier|public
specifier|static
name|boolean
name|hasLockFile
parameter_list|(
name|File
name|file
parameter_list|)
block|{
name|File
name|lock
init|=
operator|new
name|File
argument_list|(
name|file
operator|.
name|getPath
argument_list|()
operator|+
name|SaveSession
operator|.
name|LOCKFILE_SUFFIX
argument_list|)
decl_stmt|;
return|return
name|lock
operator|.
name|exists
argument_list|()
return|;
block|}
comment|/**      * Find the lock file's last modified time, if it has a lock file.      * @param file The file to check.      * @return the last modified time if lock file exists, -1 otherwise.      */
DECL|method|getLockFileTimeStamp (File file)
specifier|public
specifier|static
name|long
name|getLockFileTimeStamp
parameter_list|(
name|File
name|file
parameter_list|)
block|{
name|File
name|lock
init|=
operator|new
name|File
argument_list|(
name|file
operator|.
name|getPath
argument_list|()
operator|+
name|SaveSession
operator|.
name|LOCKFILE_SUFFIX
argument_list|)
decl_stmt|;
return|return
name|lock
operator|.
name|exists
argument_list|()
condition|?
name|lock
operator|.
name|lastModified
argument_list|()
else|:
operator|-
literal|1
return|;
block|}
comment|/**      * Check if a lock file exists, and delete it if it does.      * @return true if the lock file existed, false otherwise.      * @throws IOException if something goes wrong.      */
DECL|method|deleteLockFile (File file)
specifier|public
specifier|static
name|boolean
name|deleteLockFile
parameter_list|(
name|File
name|file
parameter_list|)
block|{
name|File
name|lock
init|=
operator|new
name|File
argument_list|(
name|file
operator|.
name|getPath
argument_list|()
operator|+
name|SaveSession
operator|.
name|LOCKFILE_SUFFIX
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lock
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|lock
operator|.
name|delete
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Build a String array containing all those elements of all that are not      * in subset.      * @param all The array of all values.      * @param subset The subset of values.      * @return The remainder that is not part of the subset.      */
DECL|method|getRemainder (String[] all, String[] subset)
specifier|public
specifier|static
name|String
index|[]
name|getRemainder
parameter_list|(
name|String
index|[]
name|all
parameter_list|,
name|String
index|[]
name|subset
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|al
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|anAll
range|:
name|all
control|)
block|{
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|aSubset
range|:
name|subset
control|)
block|{
if|if
condition|(
name|aSubset
operator|.
name|equals
argument_list|(
name|anAll
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|al
operator|.
name|add
argument_list|(
name|anAll
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|al
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|al
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
DECL|method|concat (T[] first, T[] second)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|concat
parameter_list|(
name|T
index|[]
name|first
parameter_list|,
name|T
index|[]
name|second
parameter_list|)
block|{
name|T
index|[]
name|result
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|first
argument_list|,
name|first
operator|.
name|length
operator|+
name|second
operator|.
name|length
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|second
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
name|first
operator|.
name|length
argument_list|,
name|second
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**      * Determines filename provided by an entry in a database      *      * @param database the database, where the entry is located      * @param entry the entry to which the file should be linked to      * @return a suggested fileName      */
DECL|method|getLinkedFileName (BibtexDatabase database, BibtexEntry entry)
specifier|public
specifier|static
name|String
name|getLinkedFileName
parameter_list|(
name|BibtexDatabase
name|database
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|)
block|{
name|String
name|targetName
init|=
name|entry
operator|.
name|getCiteKey
argument_list|()
operator|==
literal|null
condition|?
literal|"default"
else|:
name|entry
operator|.
name|getCiteKey
argument_list|()
decl_stmt|;
name|StringReader
name|sr
init|=
operator|new
name|StringReader
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|ImportSettingsTab
operator|.
name|PREF_IMPORT_FILENAMEPATTERN
argument_list|)
argument_list|)
decl_stmt|;
name|Layout
name|layout
init|=
literal|null
decl_stmt|;
try|try
block|{
name|layout
operator|=
operator|new
name|LayoutHelper
argument_list|(
name|sr
argument_list|)
operator|.
name|getLayoutFromText
argument_list|(
name|Globals
operator|.
name|FORMATTER_PACKAGE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Globals
operator|.
name|logger
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Wrong Format"
argument_list|)
operator|.
name|concat
argument_list|(
literal|" "
argument_list|)
operator|.
name|concat
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|layout
operator|!=
literal|null
condition|)
block|{
name|targetName
operator|=
name|layout
operator|.
name|doLayout
argument_list|(
name|entry
argument_list|,
name|database
argument_list|)
expr_stmt|;
block|}
comment|//Removes illegal characters from filename
name|targetName
operator|=
name|FileNameCleaner
operator|.
name|cleanFileName
argument_list|(
name|targetName
argument_list|)
expr_stmt|;
return|return
name|targetName
return|;
block|}
comment|// DOI-regexp provided by http://stackoverflow.com/a/10324802/873282
comment|// Some DOI's are not caught by the regexp in the above link, i.e. 10.1002/(SICI)1522-2594(199911)42:5<952::AID-MRM16>3.0.CO;2-S
comment|// Removed<> from non-permitted characters
DECL|field|REGEXP_PLAINDOI
specifier|private
specifier|static
specifier|final
name|String
name|REGEXP_PLAINDOI
init|=
literal|"\\b(10[.][0-9]{4,}(?:[.][0-9]+)*/(?:(?![\"&\\'])\\S)+)\\b"
decl_stmt|;
DECL|field|REGEXP_DOI_WITH_HTTP_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|REGEXP_DOI_WITH_HTTP_PREFIX
init|=
literal|"http[s]?://[^\\s]*?"
operator|+
name|Util
operator|.
name|REGEXP_PLAINDOI
decl_stmt|;
DECL|field|PATTERN_PLAINDOI
specifier|private
specifier|static
specifier|final
name|Pattern
name|PATTERN_PLAINDOI
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|Util
operator|.
name|REGEXP_PLAINDOI
argument_list|)
decl_stmt|;
comment|/**      * Check if the String matches a DOI (with http://...)      */
DECL|method|checkForDOIwithHTTPprefix (String check)
specifier|public
specifier|static
name|boolean
name|checkForDOIwithHTTPprefix
parameter_list|(
name|String
name|check
parameter_list|)
block|{
return|return
operator|(
name|check
operator|!=
literal|null
operator|)
operator|&&
name|check
operator|.
name|matches
argument_list|(
literal|".*"
operator|+
name|Util
operator|.
name|REGEXP_DOI_WITH_HTTP_PREFIX
operator|+
literal|".*"
argument_list|)
return|;
block|}
comment|/**      *       * @param check - string to check      * @return true if "check" contains a DOI      */
DECL|method|checkForPlainDOI (String check)
specifier|public
specifier|static
name|boolean
name|checkForPlainDOI
parameter_list|(
name|String
name|check
parameter_list|)
block|{
return|return
operator|(
name|check
operator|!=
literal|null
operator|)
operator|&&
name|check
operator|.
name|matches
argument_list|(
literal|".*"
operator|+
name|Util
operator|.
name|REGEXP_PLAINDOI
operator|+
literal|".*"
argument_list|)
return|;
block|}
comment|/**      * Remove the http://... from DOI      *       * @param doi - may not be null      * @return first DOI in the given String (without http://... prefix). If no DOI exists, the complete string is returned      */
DECL|method|getDOI (String doi)
specifier|public
specifier|static
name|String
name|getDOI
parameter_list|(
name|String
name|doi
parameter_list|)
block|{
name|Matcher
name|matcher
init|=
name|Util
operator|.
name|PATTERN_PLAINDOI
operator|.
name|matcher
argument_list|(
name|doi
argument_list|)
decl_stmt|;
if|if
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
return|return
name|matcher
operator|.
name|group
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|doi
return|;
block|}
block|}
DECL|method|removeDOIfromBibtexEntryField (BibtexEntry bes, String fieldName, NamedCompound ce)
specifier|public
specifier|static
name|void
name|removeDOIfromBibtexEntryField
parameter_list|(
name|BibtexEntry
name|bes
parameter_list|,
name|String
name|fieldName
parameter_list|,
name|NamedCompound
name|ce
parameter_list|)
block|{
name|String
name|origValue
init|=
name|bes
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|origValue
decl_stmt|;
name|value
operator|=
name|value
operator|.
name|replaceAll
argument_list|(
name|Util
operator|.
name|REGEXP_DOI_WITH_HTTP_PREFIX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|value
operator|=
name|value
operator|.
name|replaceAll
argument_list|(
name|Util
operator|.
name|REGEXP_PLAINDOI
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|value
operator|=
name|value
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|value
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|origValue
operator|.
name|equals
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|bes
argument_list|,
name|fieldName
argument_list|,
name|origValue
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|bes
operator|.
name|setField
argument_list|(
name|fieldName
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      *       * @param fileName      * @param destFilename      * @return      */
DECL|method|renameFile (String fileName, String destFilename)
specifier|public
specifier|static
name|boolean
name|renameFile
parameter_list|(
name|String
name|fileName
parameter_list|,
name|String
name|destFilename
parameter_list|)
block|{
comment|// File (or directory) with old name
name|File
name|fromFile
init|=
operator|new
name|File
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
comment|// File (or directory) with new name
name|File
name|toFile
init|=
operator|new
name|File
argument_list|(
name|destFilename
argument_list|)
decl_stmt|;
comment|// Rename file (or directory)
return|return
name|fromFile
operator|.
name|renameTo
argument_list|(
name|toFile
argument_list|)
return|;
block|}
DECL|method|getSeparatedKeywords (String keywords)
specifier|public
specifier|static
name|ArrayList
argument_list|<
name|String
argument_list|>
name|getSeparatedKeywords
parameter_list|(
name|String
name|keywords
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|res
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|keywords
operator|==
literal|null
condition|)
block|{
return|return
name|res
return|;
block|}
comment|// _NOSPACE is a hack to support keywords such as "choreography transactions"
comment|// a more intelligent algorithm would check for the separator chosen (SEPARATING_CHARS_NOSPACE)
comment|// if nothing is found, " " is likely to be the separating char.
comment|// solution by RisKeywords.java: s.split(",[ ]*")
name|StringTokenizer
name|tok
init|=
operator|new
name|StringTokenizer
argument_list|(
name|keywords
argument_list|,
name|Globals
operator|.
name|SEPARATING_CHARS_NOSPACE
argument_list|)
decl_stmt|;
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|word
init|=
name|tok
operator|.
name|nextToken
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|res
operator|.
name|add
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
DECL|method|getSeparatedKeywords (BibtexEntry be)
specifier|public
specifier|static
name|ArrayList
argument_list|<
name|String
argument_list|>
name|getSeparatedKeywords
parameter_list|(
name|BibtexEntry
name|be
parameter_list|)
block|{
return|return
name|Util
operator|.
name|getSeparatedKeywords
argument_list|(
name|be
operator|.
name|getField
argument_list|(
literal|"keywords"
argument_list|)
argument_list|)
return|;
block|}
DECL|method|putKeywords (BibtexEntry entry, ArrayList<String> keywords, NamedCompound ce)
specifier|public
specifier|static
name|void
name|putKeywords
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|keywords
parameter_list|,
name|NamedCompound
name|ce
parameter_list|)
block|{
comment|// Set Keyword Field
name|String
name|oldValue
init|=
name|entry
operator|.
name|getField
argument_list|(
literal|"keywords"
argument_list|)
decl_stmt|;
name|String
name|newValue
decl_stmt|;
if|if
condition|(
name|keywords
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|keyword
range|:
name|keywords
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|keyword
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|newValue
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|newValue
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|oldValue
operator|==
literal|null
operator|)
operator|&&
operator|(
name|newValue
operator|==
literal|null
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|oldValue
operator|==
literal|null
operator|)
operator|||
operator|(
operator|!
name|oldValue
operator|.
name|equals
argument_list|(
name|newValue
argument_list|)
operator|)
condition|)
block|{
name|entry
operator|.
name|setField
argument_list|(
literal|"keywords"
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
operator|!=
literal|null
condition|)
block|{
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|entry
argument_list|,
literal|"keywords"
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * @param ce indicates the undo named compound. May be null      */
DECL|method|updateField (BibtexEntry be, String field, String newValue, NamedCompound ce)
specifier|public
specifier|static
name|void
name|updateField
parameter_list|(
name|BibtexEntry
name|be
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|newValue
parameter_list|,
name|NamedCompound
name|ce
parameter_list|)
block|{
name|Util
operator|.
name|updateField
argument_list|(
name|be
argument_list|,
name|field
argument_list|,
name|newValue
argument_list|,
name|ce
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param ce indicates the undo named compound. May be null      */
DECL|method|updateField (BibtexEntry be, String field, String newValue, NamedCompound ce, Boolean nullFieldIfValueIsTheSame)
specifier|public
specifier|static
name|void
name|updateField
parameter_list|(
name|BibtexEntry
name|be
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|newValue
parameter_list|,
name|NamedCompound
name|ce
parameter_list|,
name|Boolean
name|nullFieldIfValueIsTheSame
parameter_list|)
block|{
name|String
name|oldValue
init|=
name|be
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|nullFieldIfValueIsTheSame
operator|&&
operator|(
name|oldValue
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|oldValue
operator|.
name|equals
argument_list|(
name|newValue
argument_list|)
operator|)
condition|)
block|{
comment|// if oldValue == newValue then reset field if required by parameter
name|newValue
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|oldValue
operator|==
literal|null
operator|)
operator|&&
operator|(
name|newValue
operator|==
literal|null
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|oldValue
operator|==
literal|null
operator|)
operator|||
operator|(
operator|!
name|oldValue
operator|.
name|equals
argument_list|(
name|newValue
argument_list|)
operator|)
condition|)
block|{
name|be
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
operator|!=
literal|null
condition|)
block|{
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableFieldChange
argument_list|(
name|be
argument_list|,
name|field
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Binds ESC-Key to cancel button      * @param rootPane the pane to bind the action to. Typically, this variable is retrieved by this.getRootPane();      * @param cancelAction the action to bind      */
DECL|method|bindCloseDialogKeyToCancelAction (JRootPane rootPane, Action cancelAction)
specifier|public
specifier|static
name|void
name|bindCloseDialogKeyToCancelAction
parameter_list|(
name|JRootPane
name|rootPane
parameter_list|,
name|Action
name|cancelAction
parameter_list|)
block|{
name|InputMap
name|im
init|=
name|rootPane
operator|.
name|getInputMap
argument_list|(
name|JComponent
operator|.
name|WHEN_IN_FOCUSED_WINDOW
argument_list|)
decl_stmt|;
name|ActionMap
name|am
init|=
name|rootPane
operator|.
name|getActionMap
argument_list|()
decl_stmt|;
name|im
operator|.
name|put
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|getKey
argument_list|(
literal|"Close dialog"
argument_list|)
argument_list|,
literal|"close"
argument_list|)
expr_stmt|;
name|am
operator|.
name|put
argument_list|(
literal|"close"
argument_list|,
name|cancelAction
argument_list|)
expr_stmt|;
block|}
comment|/**      * Download the URL and return contents as a String.      * @param source      * @return      * @throws IOException      */
DECL|method|getResults (URLConnection source)
specifier|public
specifier|static
name|String
name|getResults
parameter_list|(
name|URLConnection
name|source
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|Util
operator|.
name|getResultsWithEncoding
argument_list|(
name|source
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Download the URL using specified encoding and return contents as a String.      * @param source      * encoding      * @return      * @throws IOException      */
DECL|method|getResultsWithEncoding (URLConnection source, String encoding)
specifier|public
specifier|static
name|String
name|getResultsWithEncoding
parameter_list|(
name|URLConnection
name|source
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStreamReader
name|in
decl_stmt|;
if|if
condition|(
name|encoding
operator|!=
literal|null
condition|)
block|{
name|in
operator|=
operator|new
name|InputStreamReader
argument_list|(
name|source
operator|.
name|getInputStream
argument_list|()
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|=
operator|new
name|InputStreamReader
argument_list|(
name|source
operator|.
name|getInputStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|byteRead
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|byteRead
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|byteRead
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|updateTimeStampIsSet ()
specifier|public
specifier|static
name|boolean
name|updateTimeStampIsSet
parameter_list|()
block|{
return|return
operator|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"useTimeStamp"
argument_list|)
operator|&&
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|UPDATE_TIMESTAMP
argument_list|)
operator|)
return|;
block|}
comment|/**      * Updates the timestamp of the given entry,      * nests the given undaoableEdit in a named compound,      * and returns that named compound      */
DECL|method|doUpdateTimeStamp (BibtexEntry entry, AbstractUndoableEdit undoableEdit)
specifier|public
specifier|static
name|NamedCompound
name|doUpdateTimeStamp
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|AbstractUndoableEdit
name|undoableEdit
parameter_list|)
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|undoableEdit
operator|.
name|getPresentationName
argument_list|()
argument_list|)
decl_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
name|undoableEdit
argument_list|)
expr_stmt|;
name|String
name|timeStampField
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"timeStampField"
argument_list|)
decl_stmt|;
name|String
name|timestamp
init|=
name|Util
operator|.
name|easyDateFormat
argument_list|()
decl_stmt|;
name|Util
operator|.
name|updateField
argument_list|(
name|entry
argument_list|,
name|timeStampField
argument_list|,
name|timestamp
argument_list|,
name|ce
argument_list|)
expr_stmt|;
return|return
name|ce
return|;
block|}
comment|/**      * Automatically add links for this set of entries, based on the globally stored list of      * external file types. The entries are modified, and corresponding UndoEdit elements      * added to the NamedCompound given as argument. Furthermore, all entries which are modified      * are added to the Set of entries given as an argument.      *      * The entries' bibtex keys must have been set - entries lacking key are ignored.      * The operation is done in a new thread, which is returned for the caller to wait for      * if needed.      *      * @param entries A collection of BibtexEntry objects to find links for.      * @param ce A NamedCompound to add UndoEdit elements to.      * @param changedEntries MODIFIED, optional. A Set of BibtexEntry objects to which all modified entries is added. This is used for status output and debugging      * @param singleTableModel UGLY HACK. The table model to insert links into. Already existing links are not duplicated or removed. This parameter has to be null if entries.count() != 1.      *   The hack has been introduced as a bibtexentry does not (yet) support the function getListTableModel() and the FileListEntryEditor editor holds an instance of that table model and does not reconstruct it after the search has succeeded.      * @param metaData The MetaData providing the relevant file directory, if any.      * @param callback An ActionListener that is notified (on the event dispatch thread) when the search is      *  finished. The ActionEvent has id=0 if no new links were added, and id=1 if one or more links were added.      *  This parameter can be null, which means that no callback will be notified.      * @param diag An instantiated modal JDialog which will be used to display the progress of the autosetting.      *      This parameter can be null, which means that no progress update will be shown.      * @return the thread performing the autosetting      */
DECL|method|autoSetLinks (final Collection<BibtexEntry> entries, final NamedCompound ce, final Set<BibtexEntry> changedEntries, final FileListTableModel singleTableModel, final MetaData metaData, final ActionListener callback, final JDialog diag)
specifier|public
specifier|static
name|Runnable
name|autoSetLinks
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
specifier|final
name|NamedCompound
name|ce
parameter_list|,
specifier|final
name|Set
argument_list|<
name|BibtexEntry
argument_list|>
name|changedEntries
parameter_list|,
specifier|final
name|FileListTableModel
name|singleTableModel
parameter_list|,
specifier|final
name|MetaData
name|metaData
parameter_list|,
specifier|final
name|ActionListener
name|callback
parameter_list|,
specifier|final
name|JDialog
name|diag
parameter_list|)
block|{
specifier|final
name|ExternalFileType
index|[]
name|types
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeSelection
argument_list|()
decl_stmt|;
if|if
condition|(
name|diag
operator|!=
literal|null
condition|)
block|{
specifier|final
name|JProgressBar
name|prog
init|=
operator|new
name|JProgressBar
argument_list|(
name|JProgressBar
operator|.
name|HORIZONTAL
argument_list|,
literal|0
argument_list|,
name|types
operator|.
name|length
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|JLabel
name|label
init|=
operator|new
name|JLabel
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Searching for files"
argument_list|)
argument_list|)
decl_stmt|;
name|prog
operator|.
name|setIndeterminate
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|prog
operator|.
name|setBorder
argument_list|(
name|BorderFactory
operator|.
name|createEmptyBorder
argument_list|(
literal|5
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|diag
operator|.
name|setTitle
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Autosetting links"
argument_list|)
argument_list|)
expr_stmt|;
name|diag
operator|.
name|getContentPane
argument_list|()
operator|.
name|add
argument_list|(
name|prog
argument_list|,
name|BorderLayout
operator|.
name|CENTER
argument_list|)
expr_stmt|;
name|diag
operator|.
name|getContentPane
argument_list|()
operator|.
name|add
argument_list|(
name|label
argument_list|,
name|BorderLayout
operator|.
name|SOUTH
argument_list|)
expr_stmt|;
name|diag
operator|.
name|pack
argument_list|()
expr_stmt|;
name|diag
operator|.
name|setLocationRelativeTo
argument_list|(
name|diag
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Runnable
name|r
init|=
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// determine directories to search in
name|ArrayList
argument_list|<
name|File
argument_list|>
name|dirs
init|=
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|()
decl_stmt|;
name|String
index|[]
name|dirsS
init|=
name|metaData
operator|.
name|getFileDirectory
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|dirs1
range|:
name|dirsS
control|)
block|{
name|dirs
operator|.
name|add
argument_list|(
operator|new
name|File
argument_list|(
name|dirs1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// determine extensions
name|Collection
argument_list|<
name|String
argument_list|>
name|extensions
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|ExternalFileType
name|type
range|:
name|types
control|)
block|{
name|extensions
operator|.
name|add
argument_list|(
name|type
operator|.
name|getExtension
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Run the search operation:
name|Map
argument_list|<
name|BibtexEntry
argument_list|,
name|java
operator|.
name|util
operator|.
name|List
argument_list|<
name|File
argument_list|>
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|USE_REG_EXP_SEARCH_KEY
argument_list|)
condition|)
block|{
name|String
name|regExp
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|REG_EXP_SEARCH_EXPRESSION_KEY
argument_list|)
decl_stmt|;
name|result
operator|=
name|RegExpFileSearch
operator|.
name|findFilesForSet
argument_list|(
name|entries
argument_list|,
name|extensions
argument_list|,
name|dirs
argument_list|,
name|regExp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Util
operator|.
name|findAssociatedFiles
argument_list|(
name|entries
argument_list|,
name|extensions
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
block|}
name|boolean
name|foundAny
init|=
literal|false
decl_stmt|;
comment|// Iterate over the entries:
for|for
control|(
name|BibtexEntry
name|anEntry
range|:
name|result
operator|.
name|keySet
argument_list|()
control|)
block|{
name|FileListTableModel
name|tableModel
decl_stmt|;
name|String
name|oldVal
init|=
name|anEntry
operator|.
name|getField
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|)
decl_stmt|;
if|if
condition|(
name|singleTableModel
operator|==
literal|null
condition|)
block|{
name|tableModel
operator|=
operator|new
name|FileListTableModel
argument_list|()
expr_stmt|;
if|if
condition|(
name|oldVal
operator|!=
literal|null
condition|)
block|{
name|tableModel
operator|.
name|setContent
argument_list|(
name|oldVal
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
operator|(
name|entries
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
assert|;
name|tableModel
operator|=
name|singleTableModel
expr_stmt|;
block|}
name|List
argument_list|<
name|File
argument_list|>
name|files
init|=
name|result
operator|.
name|get
argument_list|(
name|anEntry
argument_list|)
decl_stmt|;
for|for
control|(
name|File
name|f
range|:
name|files
control|)
block|{
name|f
operator|=
name|Util
operator|.
name|shortenFileName
argument_list|(
name|f
argument_list|,
name|dirsS
argument_list|)
expr_stmt|;
name|boolean
name|alreadyHas
init|=
literal|false
decl_stmt|;
comment|//System.out.println("File: "+f.getPath());
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|tableModel
operator|.
name|getRowCount
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|FileListEntry
name|existingEntry
init|=
name|tableModel
operator|.
name|getEntry
argument_list|(
name|j
argument_list|)
decl_stmt|;
comment|//System.out.println("Comp: "+existingEntry.getLink());
if|if
condition|(
operator|new
name|File
argument_list|(
name|existingEntry
operator|.
name|getLink
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|alreadyHas
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|alreadyHas
condition|)
block|{
name|foundAny
operator|=
literal|true
expr_stmt|;
name|ExternalFileType
name|type
decl_stmt|;
name|int
name|index
init|=
name|f
operator|.
name|getPath
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|index
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|index
operator|<
operator|(
name|f
operator|.
name|getPath
argument_list|()
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|type
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeByExt
argument_list|(
name|f
operator|.
name|getPath
argument_list|()
operator|.
name|substring
argument_list|(
name|index
operator|+
literal|1
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
operator|new
name|UnknownExternalFileType
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|FileListEntry
name|flEntry
init|=
operator|new
name|FileListEntry
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|f
operator|.
name|getPath
argument_list|()
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tableModel
operator|.
name|addEntry
argument_list|(
name|tableModel
operator|.
name|getRowCount
argument_list|()
argument_list|,
name|flEntry
argument_list|)
expr_stmt|;
name|String
name|newVal
init|=
name|tableModel
operator|.
name|getStringRepresentation
argument_list|()
decl_stmt|;
if|if
condition|(
name|newVal
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|newVal
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|ce
operator|!=
literal|null
condition|)
block|{
comment|// store undo information
name|UndoableFieldChange
name|change
init|=
operator|new
name|UndoableFieldChange
argument_list|(
name|anEntry
argument_list|,
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|,
name|oldVal
argument_list|,
name|newVal
argument_list|)
decl_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
name|change
argument_list|)
expr_stmt|;
block|}
comment|// hack: if table model is given, do NOT modify entry
if|if
condition|(
name|singleTableModel
operator|==
literal|null
condition|)
block|{
name|anEntry
operator|.
name|setField
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changedEntries
operator|!=
literal|null
condition|)
block|{
name|changedEntries
operator|.
name|add
argument_list|(
name|anEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// handle callbacks and dialog
specifier|final
name|int
name|id
init|=
name|foundAny
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|SwingUtilities
operator|.
name|invokeLater
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|diag
operator|!=
literal|null
condition|)
block|{
name|diag
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
block|{
name|callback
operator|.
name|actionPerformed
argument_list|(
operator|new
name|ActionEvent
argument_list|(
name|this
argument_list|,
name|id
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
if|if
condition|(
name|diag
operator|!=
literal|null
condition|)
block|{
name|diag
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
comment|/**      * Automatically add links for this entry to the table model given as an argument, based on      * the globally stored list of external file types. The entry itself is not modified. The entry's      * bibtex key must have been set.      *      * @param entry The BibtexEntry to find links for.      * @param singleTableModel The table model to insert links into. Already existing links are not duplicated or removed.      * @param metaData The MetaData providing the relevant file directory, if any.      * @param callback An ActionListener that is notified (on the event dispatch thread) when the search is      *  finished. The ActionEvent has id=0 if no new links were added, and id=1 if one or more links were added.      *  This parameter can be null, which means that no callback will be notified. The passed ActionEvent is constructed with      *  (this, id, ""), where id is 1 if something has been done and 0 if nothing has been done.      * @param diag An instantiated modal JDialog which will be used to display the progress of the autosetting.      *      This parameter can be null, which means that no progress update will be shown.      * @return the runnable able to perform the autosetting      */
DECL|method|autoSetLinks ( final BibtexEntry entry, final FileListTableModel singleTableModel, final MetaData metaData, final ActionListener callback, final JDialog diag)
specifier|public
specifier|static
name|Runnable
name|autoSetLinks
parameter_list|(
specifier|final
name|BibtexEntry
name|entry
parameter_list|,
specifier|final
name|FileListTableModel
name|singleTableModel
parameter_list|,
specifier|final
name|MetaData
name|metaData
parameter_list|,
specifier|final
name|ActionListener
name|callback
parameter_list|,
specifier|final
name|JDialog
name|diag
parameter_list|)
block|{
specifier|final
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
init|=
operator|new
name|ArrayList
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|()
decl_stmt|;
name|entries
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
name|Util
operator|.
name|autoSetLinks
argument_list|(
name|entries
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|singleTableModel
argument_list|,
name|metaData
argument_list|,
name|callback
argument_list|,
name|diag
argument_list|)
return|;
block|}
comment|/**      * Opens a file browser of the folder of the given file. If possible, the file is selected      * @param fileLink the location of the file      * @throws IOException      */
DECL|method|openFolderAndSelectFile (String fileLink)
specifier|public
specifier|static
name|void
name|openFolderAndSelectFile
parameter_list|(
name|String
name|fileLink
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|Globals
operator|.
name|ON_WIN
condition|)
block|{
name|Util
operator|.
name|openFolderAndSelectFileOnWindows
argument_list|(
name|fileLink
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Globals
operator|.
name|ON_LINUX
condition|)
block|{
name|Util
operator|.
name|openFolderAndSelectFileOnLinux
argument_list|(
name|fileLink
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Util
operator|.
name|openFolderAndSelectFileGeneric
argument_list|(
name|fileLink
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|openFolderAndSelectFileOnLinux (String fileLink)
specifier|private
specifier|static
name|void
name|openFolderAndSelectFileOnLinux
parameter_list|(
name|String
name|fileLink
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|desktopSession
init|=
name|System
operator|.
name|getenv
argument_list|(
literal|"DESKTOP_SESSION"
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|cmd
decl_stmt|;
if|if
condition|(
name|desktopSession
operator|.
name|contains
argument_list|(
literal|"gnome"
argument_list|)
condition|)
block|{
name|cmd
operator|=
literal|"nautilus "
operator|+
name|fileLink
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|desktopSession
operator|.
name|contains
argument_list|(
literal|"kde"
argument_list|)
condition|)
block|{
name|cmd
operator|=
literal|"dolphin --select "
operator|+
name|fileLink
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
literal|"xdg-open "
operator|+
name|fileLink
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|fileLink
operator|.
name|lastIndexOf
argument_list|(
name|File
operator|.
name|separator
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
DECL|method|openFolderAndSelectFileGeneric (String fileLink)
specifier|private
specifier|static
name|void
name|openFolderAndSelectFileGeneric
parameter_list|(
name|String
name|fileLink
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|fileLink
argument_list|)
decl_stmt|;
name|Desktop
operator|.
name|getDesktop
argument_list|()
operator|.
name|open
argument_list|(
name|f
operator|.
name|getParentFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|openFolderAndSelectFileOnWindows (String link)
specifier|private
specifier|static
name|void
name|openFolderAndSelectFileOnWindows
parameter_list|(
name|String
name|link
parameter_list|)
throws|throws
name|IOException
block|{
name|link
operator|=
name|link
operator|.
name|replace
argument_list|(
literal|"&"
argument_list|,
literal|"\"&\""
argument_list|)
expr_stmt|;
name|String
name|cmd
init|=
literal|"explorer.exe /select,\""
operator|+
name|link
operator|+
literal|"\""
decl_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the list of linked files. The files have the absolute filename      *       * @param bes list of BibTeX entries      * @param fileDirs list of directories to try for expansion      *       * @return list of files. May be empty      */
DECL|method|getListOfLinkedFiles (BibtexEntry[] bes, String[] fileDirs)
specifier|public
specifier|static
name|List
argument_list|<
name|File
argument_list|>
name|getListOfLinkedFiles
parameter_list|(
name|BibtexEntry
index|[]
name|bes
parameter_list|,
name|String
index|[]
name|fileDirs
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|File
argument_list|>
name|res
init|=
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|bes
control|)
block|{
name|FileListTableModel
name|tm
init|=
operator|new
name|FileListTableModel
argument_list|()
decl_stmt|;
name|tm
operator|.
name|setContent
argument_list|(
name|entry
operator|.
name|getField
argument_list|(
literal|"file"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tm
operator|.
name|getRowCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|FileListEntry
name|flEntry
init|=
name|tm
operator|.
name|getEntry
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|File
name|f
init|=
name|Util
operator|.
name|expandFilename
argument_list|(
name|flEntry
operator|.
name|getLink
argument_list|()
argument_list|,
name|fileDirs
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
block|{
name|res
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|res
return|;
block|}
DECL|method|findAssociatedFiles (Collection<BibtexEntry> entries, Collection<String> extensions, Collection<File> directories)
specifier|public
specifier|static
name|Map
argument_list|<
name|BibtexEntry
argument_list|,
name|List
argument_list|<
name|File
argument_list|>
argument_list|>
name|findAssociatedFiles
parameter_list|(
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|extensions
parameter_list|,
name|Collection
argument_list|<
name|File
argument_list|>
name|directories
parameter_list|)
block|{
name|HashMap
argument_list|<
name|BibtexEntry
argument_list|,
name|List
argument_list|<
name|File
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|BibtexEntry
argument_list|,
name|List
argument_list|<
name|File
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// First scan directories
name|Set
argument_list|<
name|File
argument_list|>
name|filesWithExtension
init|=
name|UtilFindFiles
operator|.
name|findFiles
argument_list|(
name|extensions
argument_list|,
name|directories
argument_list|)
decl_stmt|;
comment|// Initialize Result-Set
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|result
operator|.
name|put
argument_list|(
name|entry
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|boolean
name|exactOnly
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|AUTOLINK_EXACT_KEY_ONLY
argument_list|)
decl_stmt|;
comment|// Now look for keys
name|nextFile
label|:
for|for
control|(
name|File
name|file
range|:
name|filesWithExtension
control|)
block|{
name|String
name|name
init|=
name|file
operator|.
name|getName
argument_list|()
decl_stmt|;
name|int
name|dot
init|=
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
comment|// First, look for exact matches:
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|String
name|citeKey
init|=
name|entry
operator|.
name|getCiteKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|citeKey
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|citeKey
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|dot
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|dot
argument_list|)
operator|.
name|equals
argument_list|(
name|citeKey
argument_list|)
condition|)
block|{
name|result
operator|.
name|get
argument_list|(
name|entry
argument_list|)
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
continue|continue
name|nextFile
continue|;
block|}
block|}
block|}
block|}
comment|// If we get here, we didn't find any exact matches. If non-exact
comment|// matches are allowed, try to find one:
if|if
condition|(
operator|!
name|exactOnly
condition|)
block|{
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|String
name|citeKey
init|=
name|entry
operator|.
name|getCiteKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|citeKey
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|citeKey
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|citeKey
argument_list|)
condition|)
block|{
name|result
operator|.
name|get
argument_list|(
name|entry
argument_list|)
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
continue|continue
name|nextFile
continue|;
block|}
block|}
block|}
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**      * Accepts a string like [author:lower] or [title:abbr] or [auth],      * whereas the first part signifies the bibtex-field to get, or the key generator      * field marker to use, while the others are the modifiers that will be applied.      *      * @param fieldAndFormat      * @param entry      * @param database      * @return      */
DECL|method|getFieldAndFormat (String fieldAndFormat, BibtexEntry entry, BibtexDatabase database)
specifier|public
specifier|static
name|String
name|getFieldAndFormat
parameter_list|(
name|String
name|fieldAndFormat
parameter_list|,
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|)
block|{
name|fieldAndFormat
operator|=
name|Util
operator|.
name|stripBrackets
argument_list|(
name|fieldAndFormat
argument_list|)
expr_stmt|;
name|int
name|colon
init|=
name|fieldAndFormat
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
name|String
name|beforeColon
decl_stmt|,
name|afterColon
decl_stmt|;
if|if
condition|(
name|colon
operator|==
operator|-
literal|1
condition|)
block|{
name|beforeColon
operator|=
name|fieldAndFormat
expr_stmt|;
name|afterColon
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|beforeColon
operator|=
name|fieldAndFormat
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|afterColon
operator|=
name|fieldAndFormat
operator|.
name|substring
argument_list|(
name|colon
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|beforeColon
operator|=
name|beforeColon
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|beforeColon
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|fieldValue
init|=
name|BibtexDatabase
operator|.
name|getResolvedField
argument_list|(
name|beforeColon
argument_list|,
name|entry
argument_list|,
name|database
argument_list|)
decl_stmt|;
comment|// If no field value was found, try to interpret it as a key generator field marker:
if|if
condition|(
name|fieldValue
operator|==
literal|null
condition|)
block|{
name|fieldValue
operator|=
name|LabelPatternUtil
operator|.
name|makeLabel
argument_list|(
name|entry
argument_list|,
name|beforeColon
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fieldValue
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|(
name|afterColon
operator|==
literal|null
operator|)
operator|||
operator|(
name|afterColon
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|fieldValue
return|;
block|}
name|String
index|[]
name|parts
init|=
name|afterColon
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|fieldValue
operator|=
name|LabelPatternUtil
operator|.
name|applyModifiers
argument_list|(
name|fieldValue
argument_list|,
name|parts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fieldValue
return|;
block|}
comment|/**      * Removes optional square brackets from the string s      *      * @param s      * @return      */
DECL|method|stripBrackets (String s)
specifier|public
specifier|static
name|String
name|stripBrackets
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|int
name|beginIndex
init|=
operator|(
name|s
operator|.
name|startsWith
argument_list|(
literal|"["
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|endIndex
init|=
operator|(
name|s
operator|.
name|endsWith
argument_list|(
literal|"]"
argument_list|)
condition|?
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
else|:
name|s
operator|.
name|length
argument_list|()
operator|)
decl_stmt|;
return|return
name|s
operator|.
name|substring
argument_list|(
name|beginIndex
argument_list|,
name|endIndex
argument_list|)
return|;
block|}
comment|/**      * Opens the given URL using the system browser      *       * @param url the URL to open      * @throws IOException      */
DECL|method|openBrowser (String url)
specifier|public
specifier|static
name|void
name|openBrowser
parameter_list|(
name|String
name|url
parameter_list|)
throws|throws
name|IOException
block|{
name|url
operator|=
name|Util
operator|.
name|sanitizeUrl
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|ExternalFileType
name|fileType
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeByExt
argument_list|(
literal|"html"
argument_list|)
decl_stmt|;
name|Util
operator|.
name|openExternalFilePlatformIndependent
argument_list|(
name|fileType
argument_list|,
name|url
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

