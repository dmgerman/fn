begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003 Nathan Dunn, Morten O. Alver   All programs in this directory and  subdirectories are published under the GNU General Public License as  described below.   This program is free software; you can redistribute it and/or modify  it under the terms of the GNU General Public License as published by  the Free Software Foundation; either version 2 of the License, or (at  your option) any later version.   This program is distributed in the hope that it will be useful, but  WITHOUT ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  General Public License for more details.   You should have received a copy of the GNU General Public License  along with this program; if not, write to the Free Software  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA   Further information about the GNU GPL is available at:  http://www.gnu.org/copyleft/gpl.ja.html   */
end_comment

begin_package
DECL|package|net.sf.jabref
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|PatternSyntaxException
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|format
operator|.
name|RemoveLatexCommands
import|;
end_import

begin_class
DECL|class|RegExpRule
specifier|public
class|class
name|RegExpRule
implements|implements
name|SearchRule
block|{
DECL|field|m_caseSensitiveSearch
specifier|private
specifier|final
name|boolean
name|m_caseSensitiveSearch
decl_stmt|;
comment|//static RemoveBrackets removeBrackets = new RemoveBrackets();
DECL|field|removeBrackets
specifier|private
specifier|static
specifier|final
name|RemoveLatexCommands
name|removeBrackets
init|=
operator|new
name|RemoveLatexCommands
argument_list|()
decl_stmt|;
DECL|method|RegExpRule (boolean caseSensitive)
specifier|public
name|RegExpRule
parameter_list|(
name|boolean
name|caseSensitive
parameter_list|)
block|{
name|m_caseSensitiveSearch
operator|=
name|caseSensitive
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|validateSearchStrings (Map<String, String> searchStrings)
specifier|public
name|boolean
name|validateSearchStrings
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|searchStrings
parameter_list|)
block|{
name|int
name|score
init|=
literal|0
decl_stmt|;
name|String
name|searchString
init|=
name|searchStrings
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|m_caseSensitiveSearch
condition|)
block|{
name|flags
operator|=
name|Pattern
operator|.
name|CASE_INSENSITIVE
expr_stmt|;
comment|// testing
block|}
try|try
block|{
name|Pattern
name|pattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|searchString
argument_list|,
name|flags
argument_list|)
decl_stmt|;
block|}
catch|catch
parameter_list|(
name|PatternSyntaxException
name|ex
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|applyRule (Map<String, String> searchStrings, BibtexEntry bibtexEntry)
specifier|public
name|int
name|applyRule
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|searchStrings
parameter_list|,
name|BibtexEntry
name|bibtexEntry
parameter_list|)
throws|throws
name|PatternSyntaxException
block|{
name|int
name|score
init|=
literal|0
decl_stmt|;
name|String
name|searchString
init|=
name|searchStrings
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|m_caseSensitiveSearch
condition|)
block|{
name|flags
operator|=
name|Pattern
operator|.
name|CASE_INSENSITIVE
expr_stmt|;
comment|// testing
block|}
comment|//System.out.println(searchString);
name|Pattern
name|pattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|searchString
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|score
operator|+=
name|searchFields
argument_list|(
name|bibtexEntry
operator|.
name|getAllFields
argument_list|()
argument_list|,
name|bibtexEntry
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
return|return
name|score
return|;
block|}
DECL|method|searchFields (Set<String> fields, BibtexEntry bibtexEntry, Pattern pattern)
specifier|private
name|int
name|searchFields
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|,
name|BibtexEntry
name|bibtexEntry
parameter_list|,
name|Pattern
name|pattern
parameter_list|)
block|{
name|int
name|score
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fields
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
try|try
block|{
name|Object
name|value
init|=
name|bibtexEntry
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|Matcher
name|m
init|=
name|pattern
operator|.
name|matcher
argument_list|(
name|RegExpRule
operator|.
name|removeBrackets
operator|.
name|format
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
name|score
operator|++
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Searching error: "
operator|+
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|score
return|;
block|}
block|}
end_class

end_unit

