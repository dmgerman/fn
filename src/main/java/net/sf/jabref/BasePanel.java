begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003-2015 JabRef contributors.     This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License along     with this program; if not, write to the Free Software Foundation, Inc.,     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */
end_comment

begin_package
DECL|package|net.sf.jabref
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|BorderLayout
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|GridBagConstraints
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|GridBagLayout
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Toolkit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|datatransfer
operator|.
name|Clipboard
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|datatransfer
operator|.
name|ClipboardOwner
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|datatransfer
operator|.
name|DataFlavor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|datatransfer
operator|.
name|StringSelection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|datatransfer
operator|.
name|Transferable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|datatransfer
operator|.
name|UnsupportedFlavorException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|ActionEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|KeyAdapter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|KeyEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|UnsupportedCharsetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|AbstractAction
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|BorderFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JComponent
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JFileChooser
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JOptionPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JPanel
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JSplitPane
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|JTextArea
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|SwingUtilities
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|tree
operator|.
name|TreePath
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|undo
operator|.
name|CannotRedoException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|undo
operator|.
name|CannotUndoException
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|DatabaseChangeEvent
operator|.
name|ChangeType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|autocompleter
operator|.
name|AbstractAutoCompleter
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|autocompleter
operator|.
name|AutoCompleterFactory
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|autocompleter
operator|.
name|NameFieldAutoCompleter
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|collab
operator|.
name|ChangeScanner
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|collab
operator|.
name|FileUpdateListener
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|collab
operator|.
name|FileUpdatePanel
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|ExportToClipboardAction
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|FileActions
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|SaveDatabaseAction
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|SaveException
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|SaveSession
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|FileActions
operator|.
name|DatabaseSaveType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|Layout
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|LayoutHelper
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|AttachFileAction
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|AutoSetExternalFileForEntries
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|ExternalFileMenuItem
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|ExternalFileType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|FindFullTextAction
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|RegExpFileSearch
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|SynchronizeFileField
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|external
operator|.
name|WriteXMPAction
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|GroupSelector
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|groups
operator|.
name|GroupTreeNode
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|gui
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|imports
operator|.
name|AppendDatabaseAction
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|imports
operator|.
name|BibtexParser
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|imports
operator|.
name|SPIRESFetcher
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|journals
operator|.
name|AbbreviateAction
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|journals
operator|.
name|UnabbreviateAction
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|labelPattern
operator|.
name|LabelPatternUtil
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|labelPattern
operator|.
name|SearchFixDuplicateLabels
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|search
operator|.
name|NoSearchMatcher
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|search
operator|.
name|SearchMatcher
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|specialfields
operator|.
name|Printed
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|specialfields
operator|.
name|Priority
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|specialfields
operator|.
name|Quality
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|specialfields
operator|.
name|Rank
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|specialfields
operator|.
name|ReadStatus
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|specialfields
operator|.
name|Relevance
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|specialfields
operator|.
name|SpecialFieldAction
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|specialfields
operator|.
name|SpecialFieldDatabaseChangeListener
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|specialfields
operator|.
name|SpecialFieldValue
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|sql
operator|.
name|DBConnectDialog
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|sql
operator|.
name|DBExporterAndImporterFactory
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|sql
operator|.
name|DBStrings
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|sql
operator|.
name|DbConnectAction
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|sql
operator|.
name|SQLUtil
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|sql
operator|.
name|exporter
operator|.
name|DBExporter
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|CountingUndoManager
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|NamedCompound
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|UndoableChangeType
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|UndoableInsertEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|UndoableKeyChange
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|undo
operator|.
name|UndoableRemoveEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|wizard
operator|.
name|text
operator|.
name|gui
operator|.
name|TextInputDialog
import|;
end_import

begin_import
import|import
name|ca
operator|.
name|odell
operator|.
name|glazedlists
operator|.
name|FilterList
import|;
end_import

begin_import
import|import
name|ca
operator|.
name|odell
operator|.
name|glazedlists
operator|.
name|event
operator|.
name|ListEvent
import|;
end_import

begin_import
import|import
name|ca
operator|.
name|odell
operator|.
name|glazedlists
operator|.
name|event
operator|.
name|ListEventListener
import|;
end_import

begin_import
import|import
name|ca
operator|.
name|odell
operator|.
name|glazedlists
operator|.
name|matchers
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jgoodies
operator|.
name|forms
operator|.
name|builder
operator|.
name|DefaultFormBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jgoodies
operator|.
name|forms
operator|.
name|layout
operator|.
name|FormLayout
import|;
end_import

begin_import
import|import
name|com
operator|.
name|jgoodies
operator|.
name|uif_lite
operator|.
name|component
operator|.
name|UIFSplitPane
import|;
end_import

begin_class
DECL|class|BasePanel
specifier|public
class|class
name|BasePanel
extends|extends
name|JPanel
implements|implements
name|ClipboardOwner
implements|,
name|FileUpdateListener
block|{
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|BasePanel
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|SHOWING_NOTHING
DECL|field|SHOWING_PREVIEW
DECL|field|SHOWING_EDITOR
DECL|field|WILL_SHOW_EDITOR
specifier|public
specifier|final
specifier|static
name|int
name|SHOWING_NOTHING
init|=
literal|0
decl_stmt|,
name|SHOWING_PREVIEW
init|=
literal|1
decl_stmt|,
name|SHOWING_EDITOR
init|=
literal|2
decl_stmt|,
name|WILL_SHOW_EDITOR
init|=
literal|3
decl_stmt|;
comment|/*       * The database shown in this panel.      */
DECL|field|database
name|BibtexDatabase
name|database
decl_stmt|;
DECL|field|mode
specifier|private
name|int
name|mode
init|=
literal|0
decl_stmt|;
DECL|field|currentEditor
specifier|private
name|EntryEditor
name|currentEditor
init|=
literal|null
decl_stmt|;
DECL|field|currentPreview
specifier|private
name|PreviewPanel
name|currentPreview
init|=
literal|null
decl_stmt|;
DECL|field|tmp
name|boolean
name|tmp
init|=
literal|true
decl_stmt|;
DECL|field|selectionListener
specifier|private
name|MainTableSelectionListener
name|selectionListener
init|=
literal|null
decl_stmt|;
DECL|field|groupsHighlightListener
specifier|private
name|ListEventListener
argument_list|<
name|BibtexEntry
argument_list|>
name|groupsHighlightListener
decl_stmt|;
DECL|field|contentPane
name|UIFSplitPane
name|contentPane
init|=
operator|new
name|UIFSplitPane
argument_list|()
decl_stmt|;
DECL|field|splitPane
name|JSplitPane
name|splitPane
decl_stmt|;
DECL|field|frame
name|JabRefFrame
name|frame
decl_stmt|;
DECL|field|fileMonitorHandle
name|String
name|fileMonitorHandle
init|=
literal|null
decl_stmt|;
DECL|field|saving
DECL|field|updatedExternally
name|boolean
name|saving
init|=
literal|false
decl_stmt|,
name|updatedExternally
init|=
literal|false
decl_stmt|;
DECL|field|encoding
specifier|private
name|String
name|encoding
decl_stmt|;
DECL|field|gbl
name|GridBagLayout
name|gbl
init|=
operator|new
name|GridBagLayout
argument_list|()
decl_stmt|;
DECL|field|con
name|GridBagConstraints
name|con
init|=
operator|new
name|GridBagConstraints
argument_list|()
decl_stmt|;
comment|// Hashtable indexing the only search auto completer
comment|// required for the SearchAutoCompleterUpdater
DECL|field|searchAutoCompleterHM
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|AbstractAutoCompleter
argument_list|>
name|searchAutoCompleterHM
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|AbstractAutoCompleter
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|autoCompleters
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|AbstractAutoCompleter
argument_list|>
name|autoCompleters
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|AbstractAutoCompleter
argument_list|>
argument_list|()
decl_stmt|;
comment|// Hashtable that holds as keys the names of the fields where
comment|// autocomplete is active, and references to the autocompleter objects.
DECL|field|searchCompleter
name|NameFieldAutoCompleter
name|searchCompleter
init|=
literal|null
decl_stmt|;
DECL|field|searchCompleteListener
name|AutoCompleteListener
name|searchCompleteListener
init|=
literal|null
decl_stmt|;
comment|// The undo manager.
DECL|field|undoManager
specifier|public
specifier|final
name|CountingUndoManager
name|undoManager
init|=
operator|new
name|CountingUndoManager
argument_list|(
name|this
argument_list|)
decl_stmt|;
DECL|field|undoAction
specifier|final
name|UndoAction
name|undoAction
init|=
operator|new
name|UndoAction
argument_list|()
decl_stmt|;
DECL|field|redoAction
specifier|final
name|RedoAction
name|redoAction
init|=
operator|new
name|RedoAction
argument_list|()
decl_stmt|;
DECL|field|previousEntries
specifier|private
specifier|final
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|previousEntries
init|=
operator|new
name|ArrayList
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|nextEntries
specifier|private
specifier|final
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|nextEntries
init|=
operator|new
name|ArrayList
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|()
decl_stmt|;
comment|//ExampleFileFilter fileFilter;
comment|// File filter for .bib files.
DECL|field|baseChanged
specifier|private
name|boolean
name|baseChanged
init|=
literal|false
decl_stmt|;
DECL|field|nonUndoableChange
specifier|private
name|boolean
name|nonUndoableChange
init|=
literal|false
decl_stmt|;
comment|// Used to track whether the base has changed since last save.
comment|//EntryTableModel tableModel = null;
comment|//public EntryTable entryTable = null;
DECL|field|mainTable
specifier|public
name|MainTable
name|mainTable
init|=
literal|null
decl_stmt|;
DECL|field|tableFormat
specifier|public
name|MainTableFormat
name|tableFormat
init|=
literal|null
decl_stmt|;
DECL|field|searchFilterList
DECL|field|groupFilterList
specifier|public
name|FilterList
argument_list|<
name|BibtexEntry
argument_list|>
name|searchFilterList
init|=
literal|null
decl_stmt|,
name|groupFilterList
init|=
literal|null
decl_stmt|;
DECL|field|rcm
specifier|public
name|RightClickMenu
name|rcm
decl_stmt|;
DECL|field|showing
name|BibtexEntry
name|showing
init|=
literal|null
decl_stmt|;
comment|// Variable to prevent erroneous update of back/forward histories at the time
comment|// when a Back or Forward operation is being processed:
DECL|field|backOrForwardInProgress
specifier|private
name|boolean
name|backOrForwardInProgress
init|=
literal|false
decl_stmt|;
comment|// To indicate which entry is currently shown.
DECL|field|entryEditors
specifier|public
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|EntryEditor
argument_list|>
name|entryEditors
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|EntryEditor
argument_list|>
argument_list|()
decl_stmt|;
comment|// To contain instantiated entry editors. This is to save time
comment|// in switching between entries.
comment|//HashMap entryTypeForms = new HashMap();
comment|// Hashmap to keep track of which entries currently have open
comment|// EntryTypeForm dialogs.
DECL|field|preambleEditor
name|PreambleEditor
name|preambleEditor
init|=
literal|null
decl_stmt|;
comment|// Keeps track of the preamble dialog if it is open.
DECL|field|stringDialog
name|StringDialog
name|stringDialog
init|=
literal|null
decl_stmt|;
comment|// Keeps track of the string dialog if it is open.
DECL|field|saveAction
name|SaveDatabaseAction
name|saveAction
decl_stmt|;
DECL|field|cleanUpAction
name|CleanUpAction
name|cleanUpAction
decl_stmt|;
comment|/**      * The group selector component for this database. Instantiated by the      * SidePaneManager if necessary, or from this class if merging groups from a      * different database.      */
comment|//GroupSelector groupSelector;
specifier|public
name|boolean
DECL|field|showingSearch
name|showingSearch
init|=
literal|false
decl_stmt|,
DECL|field|showingGroup
name|showingGroup
init|=
literal|false
decl_stmt|,
DECL|field|sortingBySearchResults
name|sortingBySearchResults
init|=
literal|false
decl_stmt|,
DECL|field|coloringBySearchResults
name|coloringBySearchResults
init|=
literal|false
decl_stmt|,
DECL|field|hidingNonHits
name|hidingNonHits
init|=
literal|false
decl_stmt|,
DECL|field|sortingByGroup
name|sortingByGroup
init|=
literal|false
decl_stmt|,
DECL|field|sortingByCiteSeerResults
name|sortingByCiteSeerResults
init|=
literal|false
decl_stmt|,
DECL|field|coloringByGroup
name|coloringByGroup
init|=
literal|false
decl_stmt|;
DECL|field|lastSearchHits
name|int
name|lastSearchHits
init|=
operator|-
literal|1
decl_stmt|;
comment|// The number of hits in the latest search.
comment|// Potential use in hiding non-hits completely.
comment|// MetaData parses, keeps and writes meta data.
DECL|field|metaData
name|MetaData
name|metaData
decl_stmt|;
DECL|field|actions
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|actions
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|sidePaneManager
specifier|private
name|SidePaneManager
name|sidePaneManager
decl_stmt|;
comment|/**      * Create a new BasePanel with an empty database.      * @param frame The application window.      */
DECL|method|BasePanel (JabRefFrame frame)
specifier|public
name|BasePanel
parameter_list|(
name|JabRefFrame
name|frame
parameter_list|)
block|{
name|this
operator|.
name|sidePaneManager
operator|=
name|Globals
operator|.
name|sidePaneManager
expr_stmt|;
name|database
operator|=
operator|new
name|BibtexDatabase
argument_list|()
expr_stmt|;
name|metaData
operator|=
operator|new
name|MetaData
argument_list|()
expr_stmt|;
name|metaData
operator|.
name|initializeNewDatabase
argument_list|()
expr_stmt|;
name|this
operator|.
name|frame
operator|=
name|frame
expr_stmt|;
name|setupActions
argument_list|()
expr_stmt|;
name|setupMainPanel
argument_list|()
expr_stmt|;
name|encoding
operator|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"defaultEncoding"
argument_list|)
expr_stmt|;
comment|//System.out.println("Default: "+encoding);
block|}
DECL|method|BasePanel (JabRefFrame frame, BibtexDatabase db, File file, MetaData metaData, String encoding)
specifier|public
name|BasePanel
parameter_list|(
name|JabRefFrame
name|frame
parameter_list|,
name|BibtexDatabase
name|db
parameter_list|,
name|File
name|file
parameter_list|,
name|MetaData
name|metaData
parameter_list|,
name|String
name|encoding
parameter_list|)
block|{
name|init
argument_list|(
name|frame
argument_list|,
name|db
argument_list|,
name|file
argument_list|,
name|metaData
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
DECL|method|init (JabRefFrame frame, BibtexDatabase db, File file, MetaData metaData, String encoding)
specifier|private
name|void
name|init
parameter_list|(
name|JabRefFrame
name|frame
parameter_list|,
name|BibtexDatabase
name|db
parameter_list|,
name|File
name|file
parameter_list|,
name|MetaData
name|metaData
parameter_list|,
name|String
name|encoding
parameter_list|)
block|{
assert|assert
operator|(
name|frame
operator|!=
literal|null
operator|)
assert|;
assert|assert
operator|(
name|db
operator|!=
literal|null
operator|)
assert|;
comment|//file may be null
assert|assert
operator|(
name|encoding
operator|!=
literal|null
operator|)
assert|;
assert|assert
operator|(
name|metaData
operator|!=
literal|null
operator|)
assert|;
name|this
operator|.
name|encoding
operator|=
name|encoding
expr_stmt|;
name|this
operator|.
name|metaData
operator|=
name|metaData
expr_stmt|;
comment|// System.out.println(encoding);
comment|//super(JSplitPane.HORIZONTAL_SPLIT, true);
name|this
operator|.
name|sidePaneManager
operator|=
name|Globals
operator|.
name|sidePaneManager
expr_stmt|;
name|this
operator|.
name|frame
operator|=
name|frame
expr_stmt|;
name|database
operator|=
name|db
expr_stmt|;
name|setupActions
argument_list|()
expr_stmt|;
name|setupMainPanel
argument_list|()
expr_stmt|;
name|metaData
operator|.
name|setFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|// ensure that at each addition of a new entry, the entry is added to the groups interface
name|db
operator|.
name|addDatabaseChangeListener
argument_list|(
operator|new
name|GroupTreeUpdater
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|database
operator|.
name|getEntries
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// if the database is not empty and no file is assigned,
comment|// the database came from an import and has to be treated somehow
comment|// -> mark as changed
name|this
operator|.
name|baseChanged
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Register so we get notifications about outside changes to the file.
try|try
block|{
name|fileMonitorHandle
operator|=
name|Globals
operator|.
name|fileUpdateMonitor
operator|.
name|addUpdateListener
argument_list|(
name|this
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warning
argument_list|(
name|ex
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|isBaseChanged ()
specifier|public
name|boolean
name|isBaseChanged
parameter_list|()
block|{
return|return
name|baseChanged
return|;
block|}
DECL|method|getMode ()
specifier|public
name|int
name|getMode
parameter_list|()
block|{
return|return
name|mode
return|;
block|}
comment|//Done by MrDlib
DECL|method|setMode (int mode)
specifier|public
name|void
name|setMode
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|this
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
block|}
comment|//Done by MrDlib
DECL|method|database ()
specifier|public
name|BibtexDatabase
name|database
parameter_list|()
block|{
return|return
name|database
return|;
block|}
DECL|method|metaData ()
specifier|public
name|MetaData
name|metaData
parameter_list|()
block|{
return|return
name|metaData
return|;
block|}
DECL|method|frame ()
specifier|public
name|JabRefFrame
name|frame
parameter_list|()
block|{
return|return
name|frame
return|;
block|}
DECL|method|prefs ()
specifier|public
name|JabRefPreferences
name|prefs
parameter_list|()
block|{
return|return
name|Globals
operator|.
name|prefs
return|;
block|}
DECL|method|getEncoding ()
specifier|public
name|String
name|getEncoding
parameter_list|()
block|{
return|return
name|encoding
return|;
block|}
DECL|method|setEncoding (String encoding)
specifier|public
name|void
name|setEncoding
parameter_list|(
name|String
name|encoding
parameter_list|)
block|{
name|this
operator|.
name|encoding
operator|=
name|encoding
expr_stmt|;
block|}
DECL|method|output (String s)
specifier|public
name|void
name|output
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|boolean
name|suppressOutput
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|suppressOutput
condition|)
name|frame
operator|.
name|output
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
DECL|method|setupActions ()
specifier|private
name|void
name|setupActions
parameter_list|()
block|{
name|saveAction
operator|=
operator|new
name|SaveDatabaseAction
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|cleanUpAction
operator|=
operator|new
name|CleanUpAction
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"undo"
argument_list|,
name|undoAction
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"redo"
argument_list|,
name|redoAction
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"focusTable"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
throws|throws
name|Throwable
block|{
operator|new
name|FocusRequester
argument_list|(
name|mainTable
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for opening an entry editor.
name|actions
operator|.
name|put
argument_list|(
literal|"edit"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
comment|/*System.out.println(Globals.focusListener.getFocused().getClass().getName());                 if (Globals.focusListener.getFocused() instanceof FieldEditor)                     new FocusRequester(mainTable);                 else*/
name|selectionListener
operator|.
name|editSignalled
argument_list|()
expr_stmt|;
block|}
comment|/*               if (isShowingEditor()) {                   new FocusRequester(splitPane.getBottomComponent());                   return;               }                frame.block();             //(new Thread() {             //public void run() {             int clickedOn = -1;             // We demand that one and only one row is selected.             if (entryTable.getSelectedRowCount() == 1) {               clickedOn = entryTable.getSelectedRow();             }             if (clickedOn>= 0) {               String id = tableModel.getIdForRow(clickedOn);               BibtexEntry be = database.getEntryById(id);               showEntry(be);                if (splitPane.getBottomComponent() != null) {                   new FocusRequester(splitPane.getBottomComponent());               }              }             frame.unblock();             }             */
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"test"
argument_list|,
comment|// new AccessLinksForEntries.SaveWithLinkedFiles(this));
operator|new
name|FindFullTextAction
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
comment|// The action for saving a database.
name|actions
operator|.
name|put
argument_list|(
literal|"save"
argument_list|,
name|saveAction
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"saveAs"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
throws|throws
name|Throwable
block|{
name|saveAction
operator|.
name|saveAs
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"saveSelectedAs"
argument_list|,
operator|new
name|SaveSelectedAction
argument_list|(
name|FileActions
operator|.
name|DatabaseSaveType
operator|.
name|DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"saveSelectedAsPlain"
argument_list|,
operator|new
name|SaveSelectedAction
argument_list|(
name|FileActions
operator|.
name|DatabaseSaveType
operator|.
name|PLAIN_BIBTEX
argument_list|)
argument_list|)
expr_stmt|;
comment|// The action for copying selected entries.
name|actions
operator|.
name|put
argument_list|(
literal|"copy"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|TransferableBibtexEntry
name|trbe
init|=
operator|new
name|TransferableBibtexEntry
argument_list|(
name|bes
argument_list|)
decl_stmt|;
comment|// ! look at ClipBoardManager
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
operator|.
name|getSystemClipboard
argument_list|()
operator|.
name|setContents
argument_list|(
name|trbe
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Copied"
argument_list|)
operator|+
literal|" "
operator|+
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
else|:
literal|"1 "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|+
literal|"."
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The user maybe selected a single cell.
name|int
index|[]
name|rows
init|=
name|mainTable
operator|.
name|getSelectedRows
argument_list|()
decl_stmt|,
name|cols
init|=
name|mainTable
operator|.
name|getSelectedColumns
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|cols
operator|.
name|length
operator|==
literal|1
operator|)
operator|&&
operator|(
name|rows
operator|.
name|length
operator|==
literal|1
operator|)
condition|)
block|{
comment|// Copy single value.
name|Object
name|o
init|=
name|mainTable
operator|.
name|getValueAt
argument_list|(
name|rows
index|[
literal|0
index|]
argument_list|,
name|cols
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|StringSelection
name|ss
init|=
operator|new
name|StringSelection
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
operator|.
name|getSystemClipboard
argument_list|()
operator|.
name|setContents
argument_list|(
name|ss
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Copied cell contents"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"cut"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
throws|throws
name|Throwable
block|{
name|runCommand
argument_list|(
literal|"copy"
argument_list|)
expr_stmt|;
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
comment|//int row0 = mainTable.getSelectedRow();
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
comment|// Create a CompoundEdit to make the action undoable.
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
literal|"cut entries"
else|:
literal|"cut entry"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Loop through the array of entries, and delete them.
for|for
control|(
name|BibtexEntry
name|be
range|:
name|bes
control|)
block|{
name|database
operator|.
name|removeEntry
argument_list|(
name|be
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|ensureNotShowing
argument_list|(
name|be
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableRemoveEntry
argument_list|(
name|database
argument_list|,
name|be
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//entryTable.clearSelection();
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Cut_pr"
argument_list|)
operator|+
literal|" "
operator|+
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
else|:
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
comment|// Reselect the entry in the first prev. selected position:
comment|/*if (row0>= entryTable.getRowCount())                         row0 = entryTable.getRowCount()-1;                     if (row0>= 0)                         entryTable.addRowSelectionInterval(row0, row0);*/
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"delete"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|boolean
name|goOn
init|=
name|showDeleteConfirmationDialog
argument_list|(
name|bes
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|goOn
condition|)
block|{
comment|// Create a CompoundEdit to make the action undoable.
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
literal|"delete entries"
else|:
literal|"delete entry"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Loop through the array of entries, and delete them.
for|for
control|(
name|BibtexEntry
name|be
range|:
name|bes
control|)
block|{
name|database
operator|.
name|removeEntry
argument_list|(
name|be
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|ensureNotShowing
argument_list|(
name|be
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableRemoveEntry
argument_list|(
name|database
argument_list|,
name|be
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|markBaseChanged
argument_list|()
expr_stmt|;
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Deleted"
argument_list|)
operator|+
literal|" "
operator|+
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
else|:
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
comment|//entryTable.clearSelection();
block|}
comment|// Reselect the entry in the first prev. selected position:
comment|/*if (row0>= entryTable.getRowCount())                         row0 = entryTable.getRowCount()-1;                     if (row0>= 0) {                        final int toSel = row0;                       //                         SwingUtilities.invokeLater(new Runnable() {                           public void run() {                               entryTable.addRowSelectionInterval(toSel, toSel);                               //entryTable.ensureVisible(toSel);                           }                         });                       */
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for pasting entries or cell contents.
comment|// Edited by Seb Wills<saw27@mrao.cam.ac.uk> on 14-Apr-04:
comment|//  - more robust detection of available content flavors (doesn't only look at first one offered)
comment|//  - support for parsing string-flavor clipboard contents which are bibtex entries.
comment|//    This allows you to (a) paste entire bibtex entries from a text editor, web browser, etc
comment|//                       (b) copy and paste entries between multiple instances of JabRef (since
comment|//         only the text representation seems to get as far as the X clipboard, at least on my system)
name|actions
operator|.
name|put
argument_list|(
literal|"paste"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
comment|// Get clipboard contents, and see if TransferableBibtexEntry is among the content flavors offered
name|Transferable
name|content
init|=
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
operator|.
name|getSystemClipboard
argument_list|()
operator|.
name|getContents
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|content
operator|!=
literal|null
condition|)
block|{
name|BibtexEntry
index|[]
name|bes
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|content
operator|.
name|isDataFlavorSupported
argument_list|(
name|TransferableBibtexEntry
operator|.
name|entryFlavor
argument_list|)
condition|)
block|{
comment|// We have determined that the clipboard data is a set of entries.
try|try
block|{
name|bes
operator|=
operator|(
name|BibtexEntry
index|[]
operator|)
operator|(
name|content
operator|.
name|getTransferData
argument_list|(
name|TransferableBibtexEntry
operator|.
name|entryFlavor
argument_list|)
operator|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedFlavorException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|content
operator|.
name|isDataFlavorSupported
argument_list|(
name|DataFlavor
operator|.
name|stringFlavor
argument_list|)
condition|)
block|{
try|try
block|{
name|BibtexParser
name|bp
init|=
operator|new
name|BibtexParser
argument_list|(
operator|new
name|java
operator|.
name|io
operator|.
name|StringReader
argument_list|(
call|(
name|String
call|)
argument_list|(
name|content
operator|.
name|getTransferData
argument_list|(
name|DataFlavor
operator|.
name|stringFlavor
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|BibtexDatabase
name|db
init|=
name|bp
operator|.
name|parse
argument_list|()
operator|.
name|getDatabase
argument_list|()
decl_stmt|;
name|Util
operator|.
name|pr
argument_list|(
literal|"Parsed "
operator|+
name|db
operator|.
name|getEntryCount
argument_list|()
operator|+
literal|" entries from clipboard text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|.
name|getEntryCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|bes
operator|=
name|db
operator|.
name|getEntries
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|BibtexEntry
index|[
name|db
operator|.
name|getEntryCount
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|UnsupportedFlavorException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|// finally we paste in the entries (if any), which either came from TransferableBibtexEntries
comment|// or were parsed from a string
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
literal|"paste entries"
else|:
literal|"paste entry"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Store the first inserted bibtexentry.
comment|// bes[0] does not work as bes[0] is first clonded,
comment|// then inserted.
comment|// This entry is used to open up an entry editor
comment|// for the first inserted entry.
name|BibtexEntry
name|firstBE
init|=
literal|null
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|be1
range|:
name|bes
control|)
block|{
try|try
block|{
name|BibtexEntry
name|be
init|=
call|(
name|BibtexEntry
call|)
argument_list|(
name|be1
operator|.
name|clone
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstBE
operator|==
literal|null
condition|)
name|firstBE
operator|=
name|be
expr_stmt|;
name|Util
operator|.
name|setAutomaticFields
argument_list|(
name|be
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"overwriteOwner"
argument_list|)
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"overwriteTimeStamp"
argument_list|)
argument_list|)
expr_stmt|;
comment|// We have to clone the
comment|// entries, since the pasted
comment|// entries must exist
comment|// independently of the copied
comment|// ones.
name|be
operator|.
name|setId
argument_list|(
name|Util
operator|.
name|createNeutralId
argument_list|()
argument_list|)
expr_stmt|;
name|database
operator|.
name|insertEntry
argument_list|(
name|be
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableInsertEntry
argument_list|(
name|database
argument_list|,
name|be
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeyCollisionException
name|ex
parameter_list|)
block|{
name|Util
operator|.
name|pr
argument_list|(
literal|"KeyCollisionException... this shouldn't happen."
argument_list|)
expr_stmt|;
block|}
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
comment|//entryTable.clearSelection();
comment|//entryTable.revalidate();
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Pasted"
argument_list|)
operator|+
literal|" "
operator|+
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
else|:
literal|"1 "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"autoOpenForm"
argument_list|)
condition|)
block|{
name|selectionListener
operator|.
name|editSignalled
argument_list|(
name|firstBE
argument_list|)
expr_stmt|;
block|}
name|highlightEntry
argument_list|(
name|firstBE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"selectAll"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|mainTable
operator|.
name|selectAll
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for opening the preamble editor
name|actions
operator|.
name|put
argument_list|(
literal|"editPreamble"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
if|if
condition|(
name|preambleEditor
operator|==
literal|null
condition|)
block|{
name|PreambleEditor
name|form
init|=
operator|new
name|PreambleEditor
argument_list|(
name|frame
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|,
name|database
argument_list|,
name|Globals
operator|.
name|prefs
argument_list|)
decl_stmt|;
name|Util
operator|.
name|placeDialog
argument_list|(
name|form
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|form
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|preambleEditor
operator|=
name|form
expr_stmt|;
block|}
else|else
block|{
name|preambleEditor
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for opening the string editor
name|actions
operator|.
name|put
argument_list|(
literal|"editStrings"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
if|if
condition|(
name|stringDialog
operator|==
literal|null
condition|)
block|{
name|StringDialog
name|form
init|=
operator|new
name|StringDialog
argument_list|(
name|frame
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|,
name|database
argument_list|,
name|Globals
operator|.
name|prefs
argument_list|)
decl_stmt|;
name|Util
operator|.
name|placeDialog
argument_list|(
name|form
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|form
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|stringDialog
operator|=
name|form
expr_stmt|;
block|}
else|else
block|{
name|stringDialog
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for toggling the groups interface
name|actions
operator|.
name|put
argument_list|(
literal|"toggleGroups"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|sidePaneManager
operator|.
name|toggle
argument_list|(
literal|"groups"
argument_list|)
expr_stmt|;
name|frame
operator|.
name|groupToggle
operator|.
name|setSelected
argument_list|(
name|sidePaneManager
operator|.
name|isComponentVisible
argument_list|(
literal|"groups"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for toggling the visibility of the toolbar
name|actions
operator|.
name|put
argument_list|(
literal|"toggleToolbar"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|frame
operator|.
name|tlb
operator|.
name|setVisible
argument_list|(
operator|!
name|frame
operator|.
name|tlb
operator|.
name|isVisible
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// action for collecting database strings from user
name|actions
operator|.
name|put
argument_list|(
literal|"dbConnect"
argument_list|,
operator|new
name|DbConnectAction
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
comment|// action for exporting database to external SQL database
name|actions
operator|.
name|put
argument_list|(
literal|"dbExport"
argument_list|,
operator|new
name|AbstractWorker
argument_list|()
block|{
name|String
name|errorMessage
init|=
literal|null
decl_stmt|;
name|boolean
name|connectToDB
init|=
literal|false
decl_stmt|;
comment|// run first, in EDT:
specifier|public
name|void
name|init
parameter_list|()
block|{
name|DBStrings
name|dbs
init|=
name|metaData
operator|.
name|getDBStrings
argument_list|()
decl_stmt|;
comment|// get DBStrings from user if necessary
if|if
condition|(
operator|!
name|dbs
operator|.
name|isConfigValid
argument_list|()
condition|)
block|{
comment|// init DB strings if necessary
if|if
condition|(
operator|!
name|dbs
operator|.
name|isInitialized
argument_list|()
condition|)
block|{
name|dbs
operator|.
name|initialize
argument_list|()
expr_stmt|;
block|}
comment|// show connection dialog
name|DBConnectDialog
name|dbd
init|=
operator|new
name|DBConnectDialog
argument_list|(
name|frame
argument_list|()
argument_list|,
name|dbs
argument_list|)
decl_stmt|;
name|Util
operator|.
name|placeDialog
argument_list|(
name|dbd
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
expr_stmt|;
name|dbd
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|connectToDB
operator|=
name|dbd
operator|.
name|getConnectToDB
argument_list|()
expr_stmt|;
comment|// store database strings
if|if
condition|(
name|connectToDB
condition|)
block|{
name|dbs
operator|=
name|dbd
operator|.
name|getDBStrings
argument_list|()
expr_stmt|;
name|metaData
operator|.
name|setDBStrings
argument_list|(
name|dbs
argument_list|)
expr_stmt|;
name|dbd
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|connectToDB
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// run second, on a different thread:
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|connectToDB
condition|)
block|{
name|DBStrings
name|dbs
init|=
name|metaData
operator|.
name|getDBStrings
argument_list|()
decl_stmt|;
try|try
block|{
comment|/*boolean okToExport = null!=metaData.getFile();                         if (!okToExport)                         {                         	okToExport = false;                         	int response = JOptionPane.showConfirmDialog(null, "You need to save your database in the disk \n" +                         			"before saving. Save it now?", "Database is not saved",                         	        JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);                         		if(response == JOptionPane.YES_OPTION)                         		{                         			try {                         				saveAction.saveAs();                         				okToExport = (null!=metaData.getFile());                         			} catch (Throwable e) {                         			e.printStackTrace();                         		}                         	}                         }                         if (okToExport)                         {*/
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Attempting SQL export..."
argument_list|)
argument_list|)
expr_stmt|;
name|DBExporterAndImporterFactory
name|factory
init|=
operator|new
name|DBExporterAndImporterFactory
argument_list|()
decl_stmt|;
name|DBExporter
name|exporter
init|=
name|factory
operator|.
name|getExporter
argument_list|(
name|dbs
operator|.
name|getServerType
argument_list|()
argument_list|)
decl_stmt|;
name|exporter
operator|.
name|exportDatabaseToDBMS
argument_list|(
name|database
argument_list|,
name|metaData
argument_list|,
literal|null
argument_list|,
name|dbs
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|dbs
operator|.
name|isConfigValid
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|//}
comment|//else
comment|//	errorMessage = "Database was not exported. Your database must be saved \nbefore exporting to a SQL database";
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|String
name|preamble
init|=
literal|"Could not export to SQL database for the following reason:"
decl_stmt|;
name|errorMessage
operator|=
name|SQLUtil
operator|.
name|getExceptionMessage
argument_list|(
name|ex
argument_list|)
expr_stmt|;
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|dbs
operator|.
name|isConfigValid
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|JOptionPane
operator|.
name|showMessageDialog
argument_list|(
name|frame
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
name|preamble
argument_list|)
operator|+
literal|"\n"
operator|+
name|errorMessage
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Export to SQL database"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|ERROR_MESSAGE
argument_list|)
expr_stmt|;
block|}
name|metaData
operator|.
name|setDBStrings
argument_list|(
name|dbs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// run third, on EDT:
specifier|public
name|void
name|update
parameter_list|()
block|{
comment|// if no error, report success
if|if
condition|(
name|errorMessage
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|connectToDB
condition|)
block|{
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"%0 export successful"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// show an error dialog if an error occurred
else|else
block|{
name|String
name|preamble
init|=
literal|"Could not export to SQL database for the following reason:"
decl_stmt|;
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
name|preamble
argument_list|)
operator|+
literal|"  "
operator|+
name|errorMessage
argument_list|)
expr_stmt|;
name|JOptionPane
operator|.
name|showMessageDialog
argument_list|(
name|frame
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
name|preamble
argument_list|)
operator|+
literal|"\n"
operator|+
name|errorMessage
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Export to SQL database"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|ERROR_MESSAGE
argument_list|)
expr_stmt|;
name|errorMessage
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
name|FindUnlinkedFilesDialog
operator|.
name|ACTION_COMMAND
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|action
parameter_list|()
throws|throws
name|Throwable
block|{
name|FindUnlinkedFilesDialog
name|dialog
init|=
operator|new
name|FindUnlinkedFilesDialog
argument_list|(
name|frame
argument_list|,
name|frame
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
decl_stmt|;
name|Util
operator|.
name|placeDialog
argument_list|(
name|dialog
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|dialog
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for auto-generating keys.
name|actions
operator|.
name|put
argument_list|(
literal|"makeKey"
argument_list|,
operator|new
name|AbstractWorker
argument_list|()
block|{
comment|//int[] rows;
name|List
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
decl_stmt|;
name|int
name|numSelected
decl_stmt|;
name|boolean
name|cancelled
init|=
literal|false
decl_stmt|;
comment|// Run first, in EDT:
specifier|public
name|void
name|init
parameter_list|()
block|{
name|entries
operator|=
operator|new
name|ArrayList
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|getSelectedEntries
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//rows = entryTable.getSelectedRows() ;
name|numSelected
operator|=
name|entries
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|entries
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// None selected. Inform the user to select entries first.
name|JOptionPane
operator|.
name|showMessageDialog
argument_list|(
name|frame
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"First select the entries you want keys to be generated for."
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Autogenerate BibTeX key"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|INFORMATION_MESSAGE
argument_list|)
expr_stmt|;
return|return;
block|}
name|frame
operator|.
name|block
argument_list|()
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Generating BibTeX key for"
argument_list|)
operator|+
literal|" "
operator|+
name|numSelected
operator|+
literal|" "
operator|+
operator|(
name|numSelected
operator|>
literal|1
condition|?
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
else|:
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|)
operator|+
literal|"..."
argument_list|)
expr_stmt|;
block|}
comment|// Run second, on a different thread:
specifier|public
name|void
name|run
parameter_list|()
block|{
name|BibtexEntry
name|bes
decl_stmt|;
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"autogenerate keys"
argument_list|)
argument_list|)
decl_stmt|;
comment|// First check if any entries have keys set already. If so, possibly remove
comment|// them from consideration, or warn about overwriting keys.
for|for
control|(
name|Iterator
argument_list|<
name|BibtexEntry
argument_list|>
name|i
init|=
name|entries
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|bes
operator|=
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|bes
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"avoidOverwritingKey"
argument_list|)
condition|)
comment|// Remove the entry, because its key is already set:
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"warnBeforeOverwritingKey"
argument_list|)
condition|)
block|{
comment|// Ask if the user wants to cancel the operation:
name|CheckBoxMessage
name|cbm
init|=
operator|new
name|CheckBoxMessage
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"One or more keys will be overwritten. Continue?"
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Disable this confirmation dialog"
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|answer
init|=
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|frame
argument_list|,
name|cbm
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Overwrite keys"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_OPTION
argument_list|)
decl_stmt|;
if|if
condition|(
name|cbm
operator|.
name|isSelected
argument_list|()
condition|)
name|Globals
operator|.
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"warnBeforeOverwritingKey"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|==
name|JOptionPane
operator|.
name|NO_OPTION
condition|)
block|{
comment|// Ok, break off the operation.
name|cancelled
operator|=
literal|true
expr_stmt|;
return|return;
block|}
comment|// No need to check more entries, because the user has already confirmed
comment|// that it's ok to overwrite keys:
break|break;
block|}
block|}
block|}
name|HashMap
argument_list|<
name|BibtexEntry
argument_list|,
name|Object
argument_list|>
name|oldvals
init|=
operator|new
name|HashMap
argument_list|<
name|BibtexEntry
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
comment|// Iterate again, removing already set keys. This is skipped if overwriting
comment|// is disabled, since all entries with keys set will have been removed.
if|if
condition|(
operator|!
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"avoidOverwritingKey"
argument_list|)
condition|)
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|bes
operator|=
name|entry
expr_stmt|;
comment|// Store the old value:
name|oldvals
operator|.
name|put
argument_list|(
name|bes
argument_list|,
name|bes
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
argument_list|)
expr_stmt|;
name|database
operator|.
name|setCiteKeyForEntry
argument_list|(
name|bes
operator|.
name|getId
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// Finally, set the new keys:
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|entries
control|)
block|{
name|bes
operator|=
name|entry
expr_stmt|;
name|bes
operator|=
name|LabelPatternUtil
operator|.
name|makeLabel
argument_list|(
name|metaData
argument_list|,
name|database
argument_list|,
name|bes
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableKeyChange
argument_list|(
name|database
argument_list|,
name|bes
operator|.
name|getId
argument_list|()
argument_list|,
operator|(
name|String
operator|)
name|oldvals
operator|.
name|get
argument_list|(
name|bes
argument_list|)
argument_list|,
name|bes
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
block|}
comment|// Run third, on EDT:
specifier|public
name|void
name|update
parameter_list|()
block|{
name|database
operator|.
name|setFollowCrossrefs
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancelled
condition|)
block|{
name|frame
operator|.
name|unblock
argument_list|()
expr_stmt|;
return|return;
block|}
name|markBaseChanged
argument_list|()
expr_stmt|;
name|numSelected
operator|=
name|entries
operator|.
name|size
argument_list|()
expr_stmt|;
comment|////////////////////////////////////////////////////////////////////////////////
comment|//          Prevent selection loss for autogenerated BibTeX-Keys
comment|////////////////////////////////////////////////////////////////////////////////
for|for
control|(
specifier|final
name|BibtexEntry
name|bibEntry
range|:
name|entries
control|)
block|{
name|SwingUtilities
operator|.
name|invokeLater
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
specifier|final
name|int
name|row
init|=
name|mainTable
operator|.
name|findEntry
argument_list|(
name|bibEntry
argument_list|)
decl_stmt|;
if|if
condition|(
name|row
operator|>=
literal|0
operator|&&
name|mainTable
operator|.
name|getSelectedRowCount
argument_list|()
operator|<
name|entries
operator|.
name|size
argument_list|()
condition|)
name|mainTable
operator|.
name|addRowSelectionInterval
argument_list|(
name|row
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|////////////////////////////////////////////////////////////////////////////////
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Generated BibTeX key for"
argument_list|)
operator|+
literal|" "
operator|+
name|numSelected
operator|+
literal|" "
operator|+
operator|(
name|numSelected
operator|!=
literal|1
condition|?
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
else|:
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|frame
operator|.
name|unblock
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for cleaning up entry.
name|actions
operator|.
name|put
argument_list|(
literal|"Cleanup"
argument_list|,
name|cleanUpAction
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"mergeEntries"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
operator|new
name|MergeEntriesDialog
argument_list|(
name|BasePanel
operator|.
name|this
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"search"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
comment|//sidePaneManager.togglePanel("search");
name|sidePaneManager
operator|.
name|show
argument_list|(
literal|"search"
argument_list|)
expr_stmt|;
comment|//boolean on = sidePaneManager.isPanelVisible("search");
name|frame
operator|.
name|searchToggle
operator|.
name|setSelected
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|frame
operator|.
name|getSearchManager
argument_list|()
operator|.
name|startSearch
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"toggleSearch"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
comment|//sidePaneManager.togglePanel("search");
name|sidePaneManager
operator|.
name|toggle
argument_list|(
literal|"search"
argument_list|)
expr_stmt|;
name|boolean
name|on
init|=
name|sidePaneManager
operator|.
name|isComponentVisible
argument_list|(
literal|"search"
argument_list|)
decl_stmt|;
name|frame
operator|.
name|searchToggle
operator|.
name|setSelected
argument_list|(
name|on
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
name|frame
operator|.
name|getSearchManager
argument_list|()
operator|.
name|startSearch
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"incSearch"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|sidePaneManager
operator|.
name|show
argument_list|(
literal|"search"
argument_list|)
expr_stmt|;
name|frame
operator|.
name|searchToggle
operator|.
name|setSelected
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|frame
operator|.
name|getSearchManager
argument_list|()
operator|.
name|startIncrementalSearch
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for copying the selected entry's key.
name|actions
operator|.
name|put
argument_list|(
literal|"copyKey"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|storeCurrentEdit
argument_list|()
expr_stmt|;
comment|//String[] keys = new String[bes.length];
name|Vector
argument_list|<
name|Object
argument_list|>
name|keys
init|=
operator|new
name|Vector
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
comment|// Collect all non-null keys.
for|for
control|(
name|BibtexEntry
name|be
range|:
name|bes
control|)
if|if
condition|(
name|be
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
operator|!=
literal|null
condition|)
name|keys
operator|.
name|add
argument_list|(
name|be
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|output
argument_list|(
literal|"None of the selected entries have BibTeX keys."
argument_list|)
expr_stmt|;
return|return;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
operator|(
name|String
operator|)
name|keys
operator|.
name|elementAt
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|keys
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
operator|(
name|String
operator|)
name|keys
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|StringSelection
name|ss
init|=
operator|new
name|StringSelection
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
operator|.
name|getSystemClipboard
argument_list|()
operator|.
name|setContents
argument_list|(
name|ss
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys
operator|.
name|size
argument_list|()
operator|==
name|bes
operator|.
name|length
condition|)
comment|// All entries had keys.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
operator|)
condition|?
literal|"Copied keys"
else|:
literal|"Copied key"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Warning"
argument_list|)
operator|+
literal|": "
operator|+
operator|(
name|bes
operator|.
name|length
operator|-
name|keys
operator|.
name|size
argument_list|()
operator|)
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"out of"
argument_list|)
operator|+
literal|" "
operator|+
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries have undefined BibTeX key"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for copying a cite for the selected entry.
name|actions
operator|.
name|put
argument_list|(
literal|"copyCiteKey"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|storeCurrentEdit
argument_list|()
expr_stmt|;
comment|//String[] keys = new String[bes.length];
name|Vector
argument_list|<
name|Object
argument_list|>
name|keys
init|=
operator|new
name|Vector
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
comment|// Collect all non-null keys.
for|for
control|(
name|BibtexEntry
name|be
range|:
name|bes
control|)
if|if
condition|(
name|be
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
operator|!=
literal|null
condition|)
name|keys
operator|.
name|add
argument_list|(
name|be
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|output
argument_list|(
literal|"None of the selected entries have BibTeX keys."
argument_list|)
expr_stmt|;
return|return;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
operator|(
name|String
operator|)
name|keys
operator|.
name|elementAt
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|keys
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
operator|(
name|String
operator|)
name|keys
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|StringSelection
name|ss
init|=
operator|new
name|StringSelection
argument_list|(
literal|"\\cite{"
operator|+
name|sb
operator|.
name|toString
argument_list|()
operator|+
literal|"}"
argument_list|)
decl_stmt|;
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
operator|.
name|getSystemClipboard
argument_list|()
operator|.
name|setContents
argument_list|(
name|ss
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys
operator|.
name|size
argument_list|()
operator|==
name|bes
operator|.
name|length
condition|)
comment|// All entries had keys.
name|output
argument_list|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|?
name|Globals
operator|.
name|lang
argument_list|(
literal|"Copied keys"
argument_list|)
else|:
name|Globals
operator|.
name|lang
argument_list|(
literal|"Copied key"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Warning"
argument_list|)
operator|+
literal|": "
operator|+
operator|(
name|bes
operator|.
name|length
operator|-
name|keys
operator|.
name|size
argument_list|()
operator|)
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"out of"
argument_list|)
operator|+
literal|" "
operator|+
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries have undefined BibTeX key"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action for copying the BibTeX key and the title for the first selected entry
name|actions
operator|.
name|put
argument_list|(
literal|"copyKeyAndTitle"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|storeCurrentEdit
argument_list|()
expr_stmt|;
comment|// OK: in a future version, this string should be configurable to allow arbitrary exports
name|StringReader
name|sr
init|=
operator|new
name|StringReader
argument_list|(
literal|"\\bibtexkey - \\begin{title}\\format[RemoveBrackets]{\\title}\\end{title}\n"
argument_list|)
decl_stmt|;
name|Layout
name|layout
decl_stmt|;
try|try
block|{
name|layout
operator|=
operator|new
name|LayoutHelper
argument_list|(
name|sr
argument_list|)
operator|.
name|getLayoutFromText
argument_list|(
name|Globals
operator|.
name|FORMATTER_PACKAGE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
return|return;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|copied
init|=
literal|0
decl_stmt|;
comment|// Collect all non-null keys.
for|for
control|(
name|BibtexEntry
name|be
range|:
name|bes
control|)
if|if
condition|(
name|be
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|copied
operator|++
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|layout
operator|.
name|doLayout
argument_list|(
name|be
argument_list|,
name|database
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copied
operator|==
literal|0
condition|)
block|{
name|output
argument_list|(
literal|"None of the selected entries have BibTeX keys."
argument_list|)
expr_stmt|;
return|return;
block|}
name|StringSelection
name|ss
init|=
operator|new
name|StringSelection
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
operator|.
name|getSystemClipboard
argument_list|()
operator|.
name|setContents
argument_list|(
name|ss
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|copied
operator|==
name|bes
operator|.
name|length
condition|)
comment|// All entries had keys.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
operator|(
name|bes
operator|.
name|length
operator|>
literal|1
operator|)
condition|?
literal|"Copied keys"
else|:
literal|"Copied key"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Warning"
argument_list|)
operator|+
literal|": "
operator|+
operator|(
name|copied
operator|)
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"out of"
argument_list|)
operator|+
literal|" "
operator|+
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries have undefined BibTeX key"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"mergeDatabase"
argument_list|,
operator|new
name|AppendDatabaseAction
argument_list|(
name|frame
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"openFile"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|JabRefExecutorService
operator|.
name|INSTANCE
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
name|String
name|field
init|=
literal|"ps"
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|==
literal|1
operator|)
condition|)
block|{
name|FileListEntry
name|entry
init|=
literal|null
decl_stmt|;
name|FileListTableModel
name|tm
init|=
operator|new
name|FileListTableModel
argument_list|()
decl_stmt|;
name|tm
operator|.
name|setContent
argument_list|(
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"file"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tm
operator|.
name|getRowCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|FileListEntry
name|flEntry
init|=
name|tm
operator|.
name|getEntry
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|flEntry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
literal|"pdf"
argument_list|)
operator|||
name|flEntry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
literal|"ps"
argument_list|)
condition|)
block|{
name|entry
operator|=
name|flEntry
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|Util
operator|.
name|openExternalFileAnyFormat
argument_list|(
name|metaData
argument_list|,
name|entry
operator|.
name|getLink
argument_list|()
argument_list|,
name|entry
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"External viewer called"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Could not open link"
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
comment|// If we didn't find anything in the "file" field, check "ps" and "pdf" fields:
name|Object
name|link
init|=
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"ps"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"pdf"
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|link
operator|=
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"pdf"
argument_list|)
expr_stmt|;
name|field
operator|=
literal|"pdf"
expr_stmt|;
block|}
name|String
name|filepath
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|link
operator|!=
literal|null
condition|)
block|{
name|filepath
operator|=
name|link
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"runAutomaticFileSearch"
argument_list|)
condition|)
block|{
comment|/*  The search can lead to an unexpected 100% CPU usage which is perceived                                         as a bug, if the search incidentally starts at a directory with lots                                         of stuff below. It is now disabled by default. */
comment|// see if we can fall back to a filename based on the bibtex key
specifier|final
name|Collection
argument_list|<
name|BibtexEntry
argument_list|>
name|entries
init|=
operator|new
name|ArrayList
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|()
decl_stmt|;
name|entries
operator|.
name|add
argument_list|(
name|bes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ExternalFileType
index|[]
name|types
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeSelection
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|File
argument_list|>
name|dirs
init|=
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|metaData
operator|.
name|getFileDirectory
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|)
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|String
index|[]
name|mdDirs
init|=
name|metaData
operator|.
name|getFileDirectory
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|mdDir
range|:
name|mdDirs
control|)
block|{
name|dirs
operator|.
name|add
argument_list|(
operator|new
name|File
argument_list|(
name|mdDir
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Collection
argument_list|<
name|String
argument_list|>
name|extensions
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|ExternalFileType
name|type
range|:
name|types
control|)
block|{
name|extensions
operator|.
name|add
argument_list|(
name|type
operator|.
name|getExtension
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Run the search operation:
name|Map
argument_list|<
name|BibtexEntry
argument_list|,
name|List
argument_list|<
name|File
argument_list|>
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
name|JabRefPreferences
operator|.
name|USE_REG_EXP_SEARCH_KEY
argument_list|)
condition|)
block|{
name|String
name|regExp
init|=
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
name|JabRefPreferences
operator|.
name|REG_EXP_SEARCH_EXPRESSION_KEY
argument_list|)
decl_stmt|;
name|result
operator|=
name|RegExpFileSearch
operator|.
name|findFilesForSet
argument_list|(
name|entries
argument_list|,
name|extensions
argument_list|,
name|dirs
argument_list|,
name|regExp
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|Util
operator|.
name|findAssociatedFiles
argument_list|(
name|entries
argument_list|,
name|extensions
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|get
argument_list|(
name|bes
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|File
argument_list|>
name|res
init|=
name|result
operator|.
name|get
argument_list|(
name|bes
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|filepath
operator|=
name|res
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getPath
argument_list|()
expr_stmt|;
name|int
name|index
init|=
name|filepath
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|index
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|index
operator|<
name|filepath
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
name|String
name|extension
init|=
name|filepath
operator|.
name|substring
argument_list|(
name|index
operator|+
literal|1
argument_list|)
decl_stmt|;
name|ExternalFileType
name|type
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getExternalFileTypeByExt
argument_list|(
name|extension
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|Util
operator|.
name|openExternalFileAnyFormat
argument_list|(
name|metaData
argument_list|,
name|filepath
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"External viewer called"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Error"
argument_list|)
operator|+
literal|": "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// TODO: add code for opening the file
block|}
block|}
comment|/*String basefile;                                     Object key = bes[0].getField(BibtexFields.KEY_FIELD);                                     if (key != null) {                                         basefile = key.toString();                                         final ExternalFileType[] types = Globals.prefs.getExternalFileTypeSelection();                                         final String sep = System.getProperty("file.separator");                                         String dir = metaData.getFileDirectory(GUIGlobals.FILE_FIELD);                                         if ((dir != null)&& (dir.length()> 0)) {                                             if (dir.endsWith(sep)) {                                                 dir = dir.substring(0, dir.length() - sep.length());                                             }                                             for (int i = 0; i< types.length; i++) {                                                 String found = Util.findPdf(basefile, types[i].getExtension(),                                                         dir, new OpenFileFilter("." + types[i].getExtension()));                                                 if (found != null) {                                                     filepath = dir + sep + found;                                                     break;                                                 }                                             }                                         }                                     }*/
block|}
block|}
if|if
condition|(
name|filepath
operator|!=
literal|null
condition|)
block|{
comment|//output(Globals.lang("Calling external viewer..."));
try|try
block|{
name|Util
operator|.
name|openExternalViewer
argument_list|(
name|metaData
argument_list|()
argument_list|,
name|filepath
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"External viewer called"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Error"
argument_list|)
operator|+
literal|": "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"No pdf or ps defined, and no file matching Bibtex key found"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"No entries or multiple entries selected."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"addFileLink"
argument_list|,
operator|new
name|AttachFileAction
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"openExternalFile"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|JabRefExecutorService
operator|.
name|INSTANCE
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
name|String
name|field
init|=
name|GUIGlobals
operator|.
name|FILE_FIELD
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|==
literal|1
operator|)
condition|)
block|{
name|Object
name|link
init|=
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|link
operator|==
literal|null
condition|)
block|{
name|runCommand
argument_list|(
literal|"openFile"
argument_list|)
expr_stmt|;
comment|// Fall back on PDF/PS fields???
return|return;
block|}
name|FileListTableModel
name|tableModel
init|=
operator|new
name|FileListTableModel
argument_list|()
decl_stmt|;
name|tableModel
operator|.
name|setContent
argument_list|(
operator|(
name|String
operator|)
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|tableModel
operator|.
name|getRowCount
argument_list|()
operator|==
literal|0
condition|)
block|{
name|runCommand
argument_list|(
literal|"openFile"
argument_list|)
expr_stmt|;
comment|// Fall back on PDF/PS fields???
return|return;
block|}
name|FileListEntry
name|flEntry
init|=
name|tableModel
operator|.
name|getEntry
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ExternalFileMenuItem
name|item
init|=
operator|new
name|ExternalFileMenuItem
argument_list|(
name|frame
argument_list|()
argument_list|,
name|bes
index|[
literal|0
index|]
argument_list|,
literal|""
argument_list|,
name|flEntry
operator|.
name|getLink
argument_list|()
argument_list|,
name|flEntry
operator|.
name|getType
argument_list|()
operator|.
name|getIcon
argument_list|()
argument_list|,
name|metaData
argument_list|()
argument_list|,
name|flEntry
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|item
operator|.
name|openLink
argument_list|()
expr_stmt|;
block|}
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"No entries or multiple entries selected."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"openFolder"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|JabRefExecutorService
operator|.
name|INSTANCE
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|File
argument_list|>
name|files
init|=
name|Util
operator|.
name|getListOfLinkedFiles
argument_list|(
name|bes
argument_list|,
name|metaData
argument_list|()
operator|.
name|getFileDirectory
argument_list|(
name|GUIGlobals
operator|.
name|FILE_FIELD
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|File
name|f
range|:
name|files
control|)
block|{
try|try
block|{
name|Util
operator|.
name|openFolderAndSelectFile
argument_list|(
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|fine
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"openUrl"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
name|String
name|field
init|=
literal|"doi"
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|==
literal|1
operator|)
condition|)
block|{
name|Object
name|link
init|=
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"doi"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"url"
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|link
operator|=
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"url"
argument_list|)
expr_stmt|;
name|field
operator|=
literal|"url"
expr_stmt|;
block|}
if|if
condition|(
name|link
operator|!=
literal|null
condition|)
block|{
comment|//output(Globals.lang("Calling external viewer..."));
try|try
block|{
name|Util
operator|.
name|openExternalViewer
argument_list|(
name|metaData
argument_list|()
argument_list|,
name|link
operator|.
name|toString
argument_list|()
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"External viewer called"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Error"
argument_list|)
operator|+
literal|": "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// No URL or DOI found in the "url" and "doi" fields.
comment|// Look for web links in the "file" field as a fallback:
name|FileListEntry
name|entry
init|=
literal|null
decl_stmt|;
name|FileListTableModel
name|tm
init|=
operator|new
name|FileListTableModel
argument_list|()
decl_stmt|;
name|tm
operator|.
name|setContent
argument_list|(
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"file"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tm
operator|.
name|getRowCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|FileListEntry
name|flEntry
init|=
name|tm
operator|.
name|getEntry
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|flEntry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
literal|"url"
argument_list|)
operator|||
name|flEntry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
literal|"ps"
argument_list|)
condition|)
block|{
name|entry
operator|=
name|flEntry
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|Util
operator|.
name|openExternalFileAnyFormat
argument_list|(
name|metaData
argument_list|,
name|entry
operator|.
name|getLink
argument_list|()
argument_list|,
name|entry
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"External viewer called"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Could not open link"
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"No url defined"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"No entries or multiple entries selected."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"openSpires"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bes
operator|.
name|length
operator|==
literal|1
operator|)
condition|)
block|{
name|Object
name|link
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"eprint"
argument_list|)
operator|!=
literal|null
condition|)
name|link
operator|=
name|SPIRESFetcher
operator|.
name|constructUrlFromEprint
argument_list|(
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"eprint"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"slaccitation"
argument_list|)
operator|!=
literal|null
condition|)
name|link
operator|=
name|SPIRESFetcher
operator|.
name|constructUrlFromSlaccitation
argument_list|(
name|bes
index|[
literal|0
index|]
operator|.
name|getField
argument_list|(
literal|"slaccitation"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|!=
literal|null
condition|)
block|{
comment|//output(Globals.lang("Calling external viewer..."));
try|try
block|{
name|Util
operator|.
name|openExternalViewer
argument_list|(
name|metaData
argument_list|()
argument_list|,
name|link
operator|.
name|toString
argument_list|()
argument_list|,
literal|"url"
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"External viewer called"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Error"
argument_list|)
operator|+
literal|": "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"No url defined"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
else|else
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"No entries or multiple entries selected."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|/*          *  It looks like this action was not being supported for SPIRES anyway          *  so we don't bother to implement it.         actions.put("openInspire", new BaseAction() {         	public void action() {         		BibtexEntry[] bes = mainTable.getSelectedEntries();                 if ((bes != null)&& (bes.length == 1)) {                 	Object link = null;                     if (bes[0].getField("eprint") != null)                       link = INSPIREFetcher.constructUrlFromEprint(bes[0].getField("eprint").toString());                     else if (bes[0].getField("slaccitation") != null)                         link = INSPIREFetcher.constructUrlFromSlaccitation(bes[0].getField("slaccitation").toString());                     if (link != null) {                       //output(Globals.lang("Calling external viewer..."));                       try {                         Util.openExternalViewer(metaData(), link.toString(), "url");                         output(Globals.lang("External viewer called")+".");                       } catch (IOException ex) {                           output(Globals.lang("Error") + ": " + ex.getMessage());                       }                     }                     else                         output(Globals.lang("No url defined")+".");                 } else                   output(Globals.lang("No entries or multiple entries selected."));             }         	});         	*/
name|actions
operator|.
name|put
argument_list|(
literal|"replaceAll"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|ReplaceStringDialog
name|rsd
init|=
operator|new
name|ReplaceStringDialog
argument_list|(
name|frame
argument_list|)
decl_stmt|;
name|rsd
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rsd
operator|.
name|okPressed
argument_list|()
condition|)
return|return;
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Replace string"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rsd
operator|.
name|selOnly
argument_list|()
condition|)
block|{
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|database
operator|.
name|getEntries
argument_list|()
control|)
block|{
name|counter
operator|+=
name|rsd
operator|.
name|replace
argument_list|(
name|entry
argument_list|,
name|ce
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|be
range|:
name|bes
control|)
name|counter
operator|+=
name|rsd
operator|.
name|replace
argument_list|(
name|be
argument_list|,
name|ce
argument_list|)
expr_stmt|;
block|}
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Replaced"
argument_list|)
operator|+
literal|" "
operator|+
name|counter
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
name|counter
operator|==
literal|1
condition|?
literal|"occurence"
else|:
literal|"occurences"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|counter
operator|>
literal|0
condition|)
block|{
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"dupliCheck"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|JabRefExecutorService
operator|.
name|INSTANCE
operator|.
name|execute
argument_list|(
operator|new
name|DuplicateSearch
argument_list|(
name|BasePanel
operator|.
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"plainTextImport"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
comment|// get Type of new entry
name|EntryTypeDialog
name|etd
init|=
operator|new
name|EntryTypeDialog
argument_list|(
name|frame
argument_list|)
decl_stmt|;
name|Util
operator|.
name|placeDialog
argument_list|(
name|etd
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
expr_stmt|;
name|etd
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|BibtexEntryType
name|tp
init|=
name|etd
operator|.
name|getChoice
argument_list|()
decl_stmt|;
if|if
condition|(
name|tp
operator|==
literal|null
condition|)
return|return;
name|String
name|id
init|=
name|Util
operator|.
name|createNeutralId
argument_list|()
decl_stmt|;
name|BibtexEntry
name|bibEntry
init|=
operator|new
name|BibtexEntry
argument_list|(
name|id
argument_list|,
name|tp
argument_list|)
decl_stmt|;
name|TextInputDialog
name|tidialog
init|=
operator|new
name|TextInputDialog
argument_list|(
name|frame
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|,
literal|"import"
argument_list|,
literal|true
argument_list|,
name|bibEntry
argument_list|)
decl_stmt|;
name|Util
operator|.
name|placeDialog
argument_list|(
name|tidialog
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
expr_stmt|;
name|tidialog
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|tidialog
operator|.
name|okPressed
argument_list|()
condition|)
block|{
name|Util
operator|.
name|setAutomaticFields
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|bibEntry
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|insertEntry
argument_list|(
name|bibEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// The action starts the "import from plain text" dialog
comment|/*actions.put("importPlainText", new BaseAction() {                 public void action()                 {                   BibtexEntry bibEntry = null ;                   // try to get the first marked entry                   BibtexEntry[] bes = entryTable.getSelectedEntries();                   if ((bes != null)&& (bes.length> 0))                     bibEntry = bes[0] ;                    if (bibEntry != null)                   {                     // Create an UndoableInsertEntry object.                     undoManager.addEdit(new UndoableInsertEntry(database, bibEntry, BasePanel.this));                      TextInputDialog tidialog = new TextInputDialog(frame, BasePanel.this,                                                                    "import", true,                                                                    bibEntry) ;                     Util.placeDialog(tidialog, BasePanel.this);                     tidialog.setVisible(true);                      if (tidialog.okPressed())                     {                       output(Globals.lang("changed ")+" '"                              +bibEntry.getType().getName().toLowerCase()+"' "                              +Globals.lang("entry")+".");                       refreshTable();                       int row = tableModel.getNumberFromName(bibEntry.getId());                        entryTable.clearSelection();                       entryTable.scrollTo(row);                       markBaseChanged(); // The database just changed.                       if (Globals.prefs.getBoolean("autoOpenForm"))                       {                             showEntry(bibEntry);                       }                     }                   }                 }             });           */
name|actions
operator|.
name|put
argument_list|(
literal|"markEntries"
argument_list|,
operator|new
name|MarkEntriesAction
argument_list|(
name|frame
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"unmarkEntries"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
try|try
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
if|if
condition|(
name|bes
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"No entries selected."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Unmark entries"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|be
range|:
name|bes
control|)
block|{
name|Util
operator|.
name|unmarkEntry
argument_list|(
name|be
argument_list|,
literal|false
argument_list|,
name|database
argument_list|,
name|ce
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|String
name|outputStr
decl_stmt|;
if|if
condition|(
name|bes
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|outputStr
operator|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Unmarked selected entry"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputStr
operator|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Unmarked all %0 selected entries"
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|bes
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|output
argument_list|(
name|outputStr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"unmarkAll"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Unmark all"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|be
range|:
name|database
operator|.
name|getEntries
argument_list|()
control|)
block|{
name|Util
operator|.
name|unmarkEntry
argument_list|(
name|be
argument_list|,
literal|false
argument_list|,
name|database
argument_list|,
name|ce
argument_list|)
expr_stmt|;
block|}
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Unmarked all entries"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Note that we can't put the number of entries that have been reverted into the undoText as the concrete number cannot be injected
name|actions
operator|.
name|put
argument_list|(
name|Relevance
operator|.
name|getInstance
argument_list|()
operator|.
name|getValues
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getActionName
argument_list|()
argument_list|,
operator|new
name|SpecialFieldAction
argument_list|(
name|frame
argument_list|,
name|Relevance
operator|.
name|getInstance
argument_list|()
argument_list|,
name|Relevance
operator|.
name|getInstance
argument_list|()
operator|.
name|getValues
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getFieldValue
argument_list|()
argument_list|,
literal|true
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Toggle relevance"
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Toggled relevance for %0 entries"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
name|Quality
operator|.
name|getInstance
argument_list|()
operator|.
name|getValues
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getActionName
argument_list|()
argument_list|,
operator|new
name|SpecialFieldAction
argument_list|(
name|frame
argument_list|,
name|Quality
operator|.
name|getInstance
argument_list|()
argument_list|,
name|Quality
operator|.
name|getInstance
argument_list|()
operator|.
name|getValues
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getFieldValue
argument_list|()
argument_list|,
literal|true
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Toggle quality"
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Toggled quality for %0 entries"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
name|Printed
operator|.
name|getInstance
argument_list|()
operator|.
name|getValues
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getActionName
argument_list|()
argument_list|,
operator|new
name|SpecialFieldAction
argument_list|(
name|frame
argument_list|,
name|Printed
operator|.
name|getInstance
argument_list|()
argument_list|,
name|Printed
operator|.
name|getInstance
argument_list|()
operator|.
name|getValues
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getFieldValue
argument_list|()
argument_list|,
literal|true
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Toggle print status"
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Toggled print status for %0 entries"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|SpecialFieldValue
name|prio
range|:
name|Priority
operator|.
name|getInstance
argument_list|()
operator|.
name|getValues
argument_list|()
control|)
block|{
name|actions
operator|.
name|put
argument_list|(
name|prio
operator|.
name|getActionName
argument_list|()
argument_list|,
name|prio
operator|.
name|getAction
argument_list|(
name|this
operator|.
name|frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SpecialFieldValue
name|rank
range|:
name|Rank
operator|.
name|getInstance
argument_list|()
operator|.
name|getValues
argument_list|()
control|)
block|{
name|actions
operator|.
name|put
argument_list|(
name|rank
operator|.
name|getActionName
argument_list|()
argument_list|,
name|rank
operator|.
name|getAction
argument_list|(
name|this
operator|.
name|frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SpecialFieldValue
name|status
range|:
name|ReadStatus
operator|.
name|getInstance
argument_list|()
operator|.
name|getValues
argument_list|()
control|)
block|{
name|actions
operator|.
name|put
argument_list|(
name|status
operator|.
name|getActionName
argument_list|()
argument_list|,
name|status
operator|.
name|getAction
argument_list|(
name|this
operator|.
name|frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|actions
operator|.
name|put
argument_list|(
literal|"togglePreview"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|boolean
name|enabled
init|=
operator|!
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"previewEnabled"
argument_list|)
decl_stmt|;
name|Globals
operator|.
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"previewEnabled"
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
name|frame
operator|.
name|setPreviewActive
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
name|frame
operator|.
name|previewToggle
operator|.
name|setSelected
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"toggleHighlightGroupsMatchingAny"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|boolean
name|enabled
init|=
operator|!
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"highlightGroupsMatchingAny"
argument_list|)
decl_stmt|;
name|Globals
operator|.
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"highlightGroupsMatchingAny"
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
name|frame
operator|.
name|highlightAny
operator|.
name|setSelected
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|enabled
condition|)
block|{
name|frame
operator|.
name|highlightAll
operator|.
name|setSelected
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|Globals
operator|.
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"highlightGroupsMatchingAll"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// ping the listener so it updates:
name|groupsHighlightListener
operator|.
name|listChanged
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"toggleHighlightGroupsMatchingAll"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|boolean
name|enabled
init|=
operator|!
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"highlightGroupsMatchingAll"
argument_list|)
decl_stmt|;
name|Globals
operator|.
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"highlightGroupsMatchingAll"
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
name|frame
operator|.
name|highlightAll
operator|.
name|setSelected
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|enabled
condition|)
block|{
name|frame
operator|.
name|highlightAny
operator|.
name|setSelected
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|Globals
operator|.
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"highlightGroupsMatchingAny"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// ping the listener so it updates:
name|groupsHighlightListener
operator|.
name|listChanged
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"switchPreview"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|selectionListener
operator|.
name|switchPreview
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"manageSelectors"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
block|{
name|ContentSelectorDialog2
name|csd
init|=
operator|new
name|ContentSelectorDialog2
argument_list|(
name|frame
argument_list|,
name|frame
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|,
literal|false
argument_list|,
name|metaData
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Util
operator|.
name|placeDialog
argument_list|(
name|csd
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|csd
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"exportToClipboard"
argument_list|,
operator|new
name|ExportToClipboardAction
argument_list|(
name|frame
argument_list|,
name|database
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"sendAsEmail"
argument_list|,
operator|new
name|SendAsEMailAction
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"writeXMP"
argument_list|,
operator|new
name|WriteXMPAction
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"abbreviateIso"
argument_list|,
operator|new
name|AbbreviateAction
argument_list|(
name|this
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"abbreviateMedline"
argument_list|,
operator|new
name|AbbreviateAction
argument_list|(
name|this
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"unabbreviate"
argument_list|,
operator|new
name|UnabbreviateAction
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"autoSetPdf"
argument_list|,
operator|new
name|AutoSetExternalFileForEntries
argument_list|(
name|this
argument_list|,
literal|"pdf"
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"autoSetPs"
argument_list|,
operator|new
name|AutoSetExternalFileForEntries
argument_list|(
name|this
argument_list|,
literal|"ps"
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"autoSetFile"
argument_list|,
operator|new
name|SynchronizeFileField
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"back"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
throws|throws
name|Throwable
block|{
name|back
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"forward"
argument_list|,
operator|new
name|BaseAction
argument_list|()
block|{
specifier|public
name|void
name|action
parameter_list|()
throws|throws
name|Throwable
block|{
name|forward
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"resolveDuplicateKeys"
argument_list|,
operator|new
name|SearchFixDuplicateLabels
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"addToGroup"
argument_list|,
operator|new
name|GroupAddRemoveDialog
argument_list|(
name|this
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"removeFromGroup"
argument_list|,
operator|new
name|GroupAddRemoveDialog
argument_list|(
name|this
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|.
name|put
argument_list|(
literal|"moveToGroup"
argument_list|,
operator|new
name|GroupAddRemoveDialog
argument_list|(
name|this
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|//actions.put("downloadFullText", new FindFullTextAction(this));
block|}
comment|/**      * This method is called from JabRefFrame is a database specific      * action is requested by the user. Runs the command if it is      * defined, or prints an error message to the standard error      * stream.      *      * @param _command The name of the command to run.      */
DECL|method|runCommand (String _command)
specifier|public
name|void
name|runCommand
parameter_list|(
name|String
name|_command
parameter_list|)
block|{
specifier|final
name|String
name|command
init|=
name|_command
decl_stmt|;
comment|//(new Thread() {
comment|//  public void run() {
if|if
condition|(
name|actions
operator|.
name|get
argument_list|(
name|command
argument_list|)
operator|==
literal|null
condition|)
name|Util
operator|.
name|pr
argument_list|(
literal|"No action defined for '"
operator|+
name|command
operator|+
literal|"'"
argument_list|)
expr_stmt|;
else|else
block|{
name|Object
name|o
init|=
name|actions
operator|.
name|get
argument_list|(
name|command
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|o
operator|instanceof
name|BaseAction
condition|)
operator|(
operator|(
name|BaseAction
operator|)
name|o
operator|)
operator|.
name|action
argument_list|()
expr_stmt|;
else|else
block|{
comment|// This part uses Spin's features:
name|Worker
name|wrk
init|=
operator|(
operator|(
name|AbstractWorker
operator|)
name|o
operator|)
operator|.
name|getWorker
argument_list|()
decl_stmt|;
comment|// The Worker returned by getWorker() has been wrapped
comment|// by Spin.off(), which makes its methods be run in
comment|// a different thread from the EDT.
name|CallBack
name|clb
init|=
operator|(
operator|(
name|AbstractWorker
operator|)
name|o
operator|)
operator|.
name|getCallBack
argument_list|()
decl_stmt|;
operator|(
operator|(
name|AbstractWorker
operator|)
name|o
operator|)
operator|.
name|init
argument_list|()
expr_stmt|;
comment|// This method runs in this same thread, the EDT.
comment|// Useful for initial GUI actions, like printing a message.
comment|// The CallBack returned by getCallBack() has been wrapped
comment|// by Spin.over(), which makes its methods be run on
comment|// the EDT.
name|wrk
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// Runs the potentially time-consuming action
comment|// without freezing the GUI. The magic is that THIS line
comment|// of execution will not continue until run() is finished.
name|clb
operator|.
name|update
argument_list|()
expr_stmt|;
comment|// Runs the update() method on the EDT.
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
comment|// If the action has blocked the JabRefFrame before crashing, we need to unblock it.
comment|// The call to unblock will simply hide the glasspane, so there is no harm in calling
comment|// it even if the frame hasn't been blocked.
name|frame
operator|.
name|unblock
argument_list|()
expr_stmt|;
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|//  }
comment|//}).start();
block|}
DECL|method|saveDatabase (File file, boolean selectedOnly, String encoding, FileActions.DatabaseSaveType saveType)
specifier|private
name|boolean
name|saveDatabase
parameter_list|(
name|File
name|file
parameter_list|,
name|boolean
name|selectedOnly
parameter_list|,
name|String
name|encoding
parameter_list|,
name|FileActions
operator|.
name|DatabaseSaveType
name|saveType
parameter_list|)
throws|throws
name|SaveException
block|{
name|SaveSession
name|session
decl_stmt|;
name|frame
operator|.
name|block
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|selectedOnly
condition|)
name|session
operator|=
name|FileActions
operator|.
name|saveDatabase
argument_list|(
name|database
argument_list|,
name|metaData
argument_list|,
name|file
argument_list|,
name|Globals
operator|.
name|prefs
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|encoding
argument_list|,
literal|false
argument_list|)
expr_stmt|;
else|else
name|session
operator|=
name|FileActions
operator|.
name|savePartOfDatabase
argument_list|(
name|database
argument_list|,
name|metaData
argument_list|,
name|file
argument_list|,
name|Globals
operator|.
name|prefs
argument_list|,
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
argument_list|,
name|encoding
argument_list|,
name|saveType
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedCharsetException
name|ex2
parameter_list|)
block|{
name|JOptionPane
operator|.
name|showMessageDialog
argument_list|(
name|frame
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Could not save file. "
operator|+
literal|"Character encoding '%0' is not supported."
argument_list|,
name|encoding
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Save database"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|ERROR_MESSAGE
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SaveException
argument_list|(
literal|"rt"
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|SaveException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|.
name|specificEntry
argument_list|()
condition|)
block|{
comment|// Error occured during processing of
comment|// be. Highlight it:
name|int
name|row
init|=
name|mainTable
operator|.
name|findEntry
argument_list|(
name|ex
operator|.
name|getEntry
argument_list|()
argument_list|)
decl_stmt|,
name|topShow
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|row
operator|-
literal|3
argument_list|)
decl_stmt|;
name|mainTable
operator|.
name|setRowSelectionInterval
argument_list|(
name|row
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|scrollTo
argument_list|(
name|topShow
argument_list|)
expr_stmt|;
name|showEntry
argument_list|(
name|ex
operator|.
name|getEntry
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|JOptionPane
operator|.
name|showMessageDialog
argument_list|(
name|frame
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Could not save file"
argument_list|)
operator|+
literal|".\n"
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Save database"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|ERROR_MESSAGE
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SaveException
argument_list|(
literal|"rt"
argument_list|)
throw|;
block|}
finally|finally
block|{
name|frame
operator|.
name|unblock
argument_list|()
expr_stmt|;
block|}
name|boolean
name|commit
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|session
operator|.
name|getWriter
argument_list|()
operator|.
name|couldEncodeAll
argument_list|()
condition|)
block|{
name|DefaultFormBuilder
name|builder
init|=
operator|new
name|DefaultFormBuilder
argument_list|(
operator|new
name|FormLayout
argument_list|(
literal|"left:pref, 4dlu, fill:pref"
argument_list|,
literal|""
argument_list|)
argument_list|)
decl_stmt|;
name|JTextArea
name|ta
init|=
operator|new
name|JTextArea
argument_list|(
name|session
operator|.
name|getWriter
argument_list|()
operator|.
name|getProblemCharacters
argument_list|()
argument_list|)
decl_stmt|;
name|ta
operator|.
name|setEditable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"The chosen encoding '%0' could not encode the following characters: "
argument_list|,
name|session
operator|.
name|getEncoding
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|ta
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"What do you want to do?"
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|tryDiff
init|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Try different encoding"
argument_list|)
decl_stmt|;
name|int
name|answer
init|=
name|JOptionPane
operator|.
name|showOptionDialog
argument_list|(
name|frame
argument_list|,
name|builder
operator|.
name|getPanel
argument_list|()
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Save database"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_CANCEL_OPTION
argument_list|,
name|JOptionPane
operator|.
name|WARNING_MESSAGE
argument_list|,
literal|null
argument_list|,
operator|new
name|String
index|[]
block|{
name|Globals
operator|.
name|lang
argument_list|(
literal|"Save"
argument_list|)
block|,
name|tryDiff
block|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Cancel"
argument_list|)
block|}
argument_list|,
name|tryDiff
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|==
name|JOptionPane
operator|.
name|NO_OPTION
condition|)
block|{
comment|// The user wants to use another encoding.
name|Object
name|choice
init|=
name|JOptionPane
operator|.
name|showInputDialog
argument_list|(
name|frame
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Select encoding"
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Save database"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|QUESTION_MESSAGE
argument_list|,
literal|null
argument_list|,
name|Globals
operator|.
name|ENCODINGS
argument_list|,
name|encoding
argument_list|)
decl_stmt|;
if|if
condition|(
name|choice
operator|!=
literal|null
condition|)
block|{
name|String
name|newEncoding
init|=
operator|(
name|String
operator|)
name|choice
decl_stmt|;
return|return
name|saveDatabase
argument_list|(
name|file
argument_list|,
name|selectedOnly
argument_list|,
name|newEncoding
argument_list|,
name|saveType
argument_list|)
return|;
block|}
else|else
name|commit
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|answer
operator|==
name|JOptionPane
operator|.
name|CANCEL_OPTION
condition|)
name|commit
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|commit
condition|)
block|{
name|session
operator|.
name|commit
argument_list|()
expr_stmt|;
name|this
operator|.
name|encoding
operator|=
name|encoding
expr_stmt|;
comment|// Make sure to remember which encoding we used.
block|}
else|else
name|session
operator|.
name|cancel
argument_list|()
expr_stmt|;
return|return
name|commit
return|;
block|}
comment|/**      * This method is called from JabRefFrame when the user wants to      * create a new entry. If the argument is null, the user is      * prompted for an entry type.      *      * @param type The type of the entry to create.      * @return The newly created BibtexEntry or null the operation was canceled by the user.      */
DECL|method|newEntry (BibtexEntryType type)
specifier|public
name|BibtexEntry
name|newEntry
parameter_list|(
name|BibtexEntryType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
comment|// Find out what type is wanted.
name|EntryTypeDialog
name|etd
init|=
operator|new
name|EntryTypeDialog
argument_list|(
name|frame
argument_list|)
decl_stmt|;
comment|// We want to center the dialog, to make it look nicer.
name|Util
operator|.
name|placeDialog
argument_list|(
name|etd
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|etd
operator|.
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|type
operator|=
name|etd
operator|.
name|getChoice
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
comment|// Only if the dialog was not cancelled.
name|String
name|id
init|=
name|Util
operator|.
name|createNeutralId
argument_list|()
decl_stmt|;
specifier|final
name|BibtexEntry
name|be
init|=
operator|new
name|BibtexEntry
argument_list|(
name|id
argument_list|,
name|type
argument_list|)
decl_stmt|;
try|try
block|{
name|database
operator|.
name|insertEntry
argument_list|(
name|be
argument_list|)
expr_stmt|;
comment|// Set owner/timestamp if options are enabled:
name|ArrayList
argument_list|<
name|BibtexEntry
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|()
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|be
argument_list|)
expr_stmt|;
name|Util
operator|.
name|setAutomaticFields
argument_list|(
name|list
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Create an UndoableInsertEntry object.
name|undoManager
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableInsertEntry
argument_list|(
name|database
argument_list|,
name|be
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Added new"
argument_list|)
operator|+
literal|" '"
operator|+
name|type
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"' "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
comment|// We are going to select the new entry. Before that, make sure that we are in
comment|// show-entry mode. If we aren't already in that mode, enter the WILL_SHOW_EDITOR
comment|// mode which makes sure the selection will trigger display of the entry editor
comment|// and adjustment of the splitter.
if|if
condition|(
name|mode
operator|!=
name|SHOWING_EDITOR
condition|)
block|{
name|mode
operator|=
name|WILL_SHOW_EDITOR
expr_stmt|;
block|}
name|int
name|row
init|=
name|mainTable
operator|.
name|findEntry
argument_list|(
name|be
argument_list|)
decl_stmt|;
if|if
condition|(
name|row
operator|>=
literal|0
condition|)
name|highlightEntry
argument_list|(
name|be
argument_list|)
expr_stmt|;
comment|// Selects the entry. The selection listener will open the editor.
else|else
block|{
comment|// The entry is not visible in the table, perhaps due to a filtering search
comment|// or group selection. Show the entry editor anyway:
name|showEntry
argument_list|(
name|be
argument_list|)
expr_stmt|;
block|}
name|markBaseChanged
argument_list|()
expr_stmt|;
comment|// The database just changed.
operator|new
name|FocusRequester
argument_list|(
name|getEntryEditor
argument_list|(
name|be
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|be
return|;
block|}
catch|catch
parameter_list|(
name|KeyCollisionException
name|ex
parameter_list|)
block|{
name|Util
operator|.
name|pr
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * This listener is used to add a new entry to a group (or a set of groups)      * in case the Group View is selected and one or more groups are marked      */
DECL|class|GroupTreeUpdater
specifier|private
class|class
name|GroupTreeUpdater
implements|implements
name|DatabaseChangeListener
block|{
DECL|method|databaseChanged (DatabaseChangeEvent e)
specifier|public
name|void
name|databaseChanged
parameter_list|(
name|DatabaseChangeEvent
name|e
parameter_list|)
block|{
if|if
condition|(
operator|(
name|e
operator|.
name|getType
argument_list|()
operator|==
name|ChangeType
operator|.
name|ADDED_ENTRY
operator|)
operator|&&
operator|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"autoAssignGroup"
argument_list|)
operator|)
operator|&&
operator|(
name|frame
operator|.
name|groupToggle
operator|.
name|isSelected
argument_list|()
operator|)
condition|)
block|{
name|BibtexEntry
index|[]
name|entries
init|=
block|{
name|e
operator|.
name|getEntry
argument_list|()
block|}
decl_stmt|;
name|TreePath
index|[]
name|selection
init|=
name|frame
operator|.
name|groupSelector
operator|.
name|getGroupsTree
argument_list|()
operator|.
name|getSelectionPaths
argument_list|()
decl_stmt|;
if|if
condition|(
name|selection
operator|!=
literal|null
condition|)
block|{
comment|// it is possible that the user selected nothing. Therefore, checked for "!= null"
for|for
control|(
name|TreePath
name|tree
range|:
name|selection
control|)
block|{
operator|(
call|(
name|GroupTreeNode
call|)
argument_list|(
name|tree
operator|.
name|getLastPathComponent
argument_list|()
argument_list|)
operator|)
operator|.
name|addToGroup
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
block|}
comment|//BasePanel.this.updateEntryEditorIfShowing(); // doesn't seem to be necessary
name|SwingUtilities
operator|.
name|invokeLater
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|BasePanel
operator|.
name|this
operator|.
name|getGroupSelector
argument_list|()
operator|.
name|valueChanged
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Ensures that the search auto completer is up to date when entries are changed      * AKA Let the auto completer, if any, harvest words from the entry      */
DECL|class|SearchAutoCompleterUpdater
specifier|private
class|class
name|SearchAutoCompleterUpdater
implements|implements
name|DatabaseChangeListener
block|{
DECL|method|databaseChanged (DatabaseChangeEvent e)
specifier|public
name|void
name|databaseChanged
parameter_list|(
name|DatabaseChangeEvent
name|e
parameter_list|)
block|{
if|if
condition|(
operator|(
name|e
operator|.
name|getType
argument_list|()
operator|==
name|ChangeType
operator|.
name|CHANGED_ENTRY
operator|)
operator|||
operator|(
name|e
operator|.
name|getType
argument_list|()
operator|==
name|ChangeType
operator|.
name|ADDED_ENTRY
operator|)
condition|)
block|{
name|Util
operator|.
name|updateCompletersForEntry
argument_list|(
name|BasePanel
operator|.
name|this
operator|.
name|searchAutoCompleterHM
argument_list|,
name|e
operator|.
name|getEntry
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Ensures that auto completers are up to date when entries are changed      * AKA Let the auto completer, if any, harvest words from the entry      */
DECL|class|AutoCompletersUpdater
specifier|private
class|class
name|AutoCompletersUpdater
implements|implements
name|DatabaseChangeListener
block|{
DECL|method|databaseChanged (DatabaseChangeEvent e)
specifier|public
name|void
name|databaseChanged
parameter_list|(
name|DatabaseChangeEvent
name|e
parameter_list|)
block|{
if|if
condition|(
operator|(
name|e
operator|.
name|getType
argument_list|()
operator|==
name|ChangeType
operator|.
name|CHANGED_ENTRY
operator|)
operator|||
operator|(
name|e
operator|.
name|getType
argument_list|()
operator|==
name|ChangeType
operator|.
name|ADDED_ENTRY
operator|)
condition|)
block|{
name|Util
operator|.
name|updateCompletersForEntry
argument_list|(
name|BasePanel
operator|.
name|this
operator|.
name|getAutoCompleters
argument_list|()
argument_list|,
name|e
operator|.
name|getEntry
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * This method is called from JabRefFrame when the user wants to      * create a new entry.      * @param bibEntry The new entry.      */
DECL|method|insertEntry (BibtexEntry bibEntry)
specifier|public
name|void
name|insertEntry
parameter_list|(
name|BibtexEntry
name|bibEntry
parameter_list|)
block|{
if|if
condition|(
name|bibEntry
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|database
operator|.
name|insertEntry
argument_list|(
name|bibEntry
argument_list|)
expr_stmt|;
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"useOwner"
argument_list|)
condition|)
comment|// Set owner field to default value
name|Util
operator|.
name|setAutomaticFields
argument_list|(
name|bibEntry
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Create an UndoableInsertEntry object.
name|undoManager
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableInsertEntry
argument_list|(
name|database
argument_list|,
name|bibEntry
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Added new"
argument_list|)
operator|+
literal|" '"
operator|+
name|bibEntry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"' "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
comment|// The database just changed.
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"autoOpenForm"
argument_list|)
condition|)
block|{
name|selectionListener
operator|.
name|editSignalled
argument_list|(
name|bibEntry
argument_list|)
expr_stmt|;
block|}
name|highlightEntry
argument_list|(
name|bibEntry
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeyCollisionException
name|ex
parameter_list|)
block|{
name|Util
operator|.
name|pr
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|updateTableFont ()
specifier|public
name|void
name|updateTableFont
parameter_list|()
block|{
name|mainTable
operator|.
name|updateFont
argument_list|()
expr_stmt|;
block|}
DECL|method|createMainTable ()
specifier|public
name|void
name|createMainTable
parameter_list|()
block|{
comment|//Comparator comp = new FieldComparator("author");
name|GlazedEntrySorter
name|eventList
init|=
operator|new
name|GlazedEntrySorter
argument_list|(
name|database
operator|.
name|getEntryMap
argument_list|()
argument_list|)
decl_stmt|;
comment|// Must initialize sort columns somehow:
name|database
operator|.
name|addDatabaseChangeListener
argument_list|(
name|eventList
argument_list|)
expr_stmt|;
name|database
operator|.
name|addDatabaseChangeListener
argument_list|(
name|SpecialFieldDatabaseChangeListener
operator|.
name|getInstance
argument_list|()
argument_list|)
expr_stmt|;
name|groupFilterList
operator|=
operator|new
name|FilterList
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|(
name|eventList
operator|.
name|getTheList
argument_list|()
argument_list|,
name|NoSearchMatcher
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|searchFilterList
operator|=
operator|new
name|FilterList
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|(
name|groupFilterList
argument_list|,
name|NoSearchMatcher
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
comment|//final SortedList sortedList = new SortedList(searchFilterList, null);
name|tableFormat
operator|=
operator|new
name|MainTableFormat
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|tableFormat
operator|.
name|updateTableFormat
argument_list|()
expr_stmt|;
comment|//EventTableModel tableModel = new EventTableModel(sortedList, tableFormat);
name|mainTable
operator|=
operator|new
name|MainTable
argument_list|(
name|tableFormat
argument_list|,
name|searchFilterList
argument_list|,
name|frame
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|selectionListener
operator|=
operator|new
name|MainTableSelectionListener
argument_list|(
name|this
argument_list|,
name|mainTable
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|updateFont
argument_list|()
expr_stmt|;
name|mainTable
operator|.
name|addSelectionListener
argument_list|(
name|selectionListener
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|addMouseListener
argument_list|(
name|selectionListener
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|addKeyListener
argument_list|(
name|selectionListener
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|addFocusListener
argument_list|(
name|selectionListener
argument_list|)
expr_stmt|;
comment|// Add the listener that will take care of highlighting groups as the selection changes:
name|groupsHighlightListener
operator|=
operator|new
name|ListEventListener
argument_list|<
name|BibtexEntry
argument_list|>
argument_list|()
block|{
specifier|public
name|void
name|listChanged
parameter_list|(
name|ListEvent
argument_list|<
name|BibtexEntry
argument_list|>
name|listEvent
parameter_list|)
block|{
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"highlightGroupsMatchingAny"
argument_list|)
condition|)
name|getGroupSelector
argument_list|()
operator|.
name|showMatchingGroups
argument_list|(
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"highlightGroupsMatchingAll"
argument_list|)
condition|)
name|getGroupSelector
argument_list|()
operator|.
name|showMatchingGroups
argument_list|(
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
else|else
comment|// no highlight
name|getGroupSelector
argument_list|()
operator|.
name|showMatchingGroups
argument_list|(
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
expr_stmt|;
name|mainTable
operator|.
name|addSelectionListener
argument_list|(
name|groupsHighlightListener
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|getActionMap
argument_list|()
operator|.
name|put
argument_list|(
literal|"cut"
argument_list|,
operator|new
name|AbstractAction
argument_list|()
block|{
specifier|public
name|void
name|actionPerformed
parameter_list|(
name|ActionEvent
name|e
parameter_list|)
block|{
try|try
block|{
name|runCommand
argument_list|(
literal|"cut"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|getActionMap
argument_list|()
operator|.
name|put
argument_list|(
literal|"copy"
argument_list|,
operator|new
name|AbstractAction
argument_list|()
block|{
specifier|public
name|void
name|actionPerformed
parameter_list|(
name|ActionEvent
name|e
parameter_list|)
block|{
try|try
block|{
name|runCommand
argument_list|(
literal|"copy"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|getActionMap
argument_list|()
operator|.
name|put
argument_list|(
literal|"paste"
argument_list|,
operator|new
name|AbstractAction
argument_list|()
block|{
specifier|public
name|void
name|actionPerformed
parameter_list|(
name|ActionEvent
name|e
parameter_list|)
block|{
try|try
block|{
name|runCommand
argument_list|(
literal|"paste"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|addKeyListener
argument_list|(
operator|new
name|KeyAdapter
argument_list|()
block|{
specifier|public
name|void
name|keyPressed
parameter_list|(
name|KeyEvent
name|e
parameter_list|)
block|{
specifier|final
name|int
name|keyCode
init|=
name|e
operator|.
name|getKeyCode
argument_list|()
decl_stmt|;
specifier|final
name|TreePath
name|path
init|=
name|frame
operator|.
name|groupSelector
operator|.
name|getSelectionPath
argument_list|()
decl_stmt|;
specifier|final
name|GroupTreeNode
name|node
init|=
name|path
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|GroupTreeNode
operator|)
name|path
operator|.
name|getLastPathComponent
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|isControlDown
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|keyCode
condition|)
block|{
comment|// The up/down/left/rightkeystrokes are displayed in the
comment|// GroupSelector's popup menu, so if they are to be changed,
comment|// edit GroupSelector.java accordingly!
case|case
name|KeyEvent
operator|.
name|VK_UP
case|:
name|e
operator|.
name|consume
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
name|frame
operator|.
name|groupSelector
operator|.
name|moveNodeUp
argument_list|(
name|node
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|KeyEvent
operator|.
name|VK_DOWN
case|:
name|e
operator|.
name|consume
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
name|frame
operator|.
name|groupSelector
operator|.
name|moveNodeDown
argument_list|(
name|node
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|KeyEvent
operator|.
name|VK_LEFT
case|:
name|e
operator|.
name|consume
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
name|frame
operator|.
name|groupSelector
operator|.
name|moveNodeLeft
argument_list|(
name|node
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|KeyEvent
operator|.
name|VK_RIGHT
case|:
name|e
operator|.
name|consume
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
name|frame
operator|.
name|groupSelector
operator|.
name|moveNodeRight
argument_list|(
name|node
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|KeyEvent
operator|.
name|VK_PAGE_DOWN
case|:
name|frame
operator|.
name|nextTab
operator|.
name|actionPerformed
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|e
operator|.
name|consume
argument_list|()
expr_stmt|;
break|break;
case|case
name|KeyEvent
operator|.
name|VK_PAGE_UP
case|:
name|frame
operator|.
name|prevTab
operator|.
name|actionPerformed
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|e
operator|.
name|consume
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|keyCode
operator|==
name|KeyEvent
operator|.
name|VK_ENTER
condition|)
block|{
name|e
operator|.
name|consume
argument_list|()
expr_stmt|;
try|try
block|{
name|runCommand
argument_list|(
literal|"edit"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|setupMainPanel ()
specifier|public
name|void
name|setupMainPanel
parameter_list|()
block|{
comment|//System.out.println("setupMainPanel");
comment|//splitPane = new com.jgoodies.uif_lite.component.UIFSplitPane(JSplitPane.VERTICAL_SPLIT);
name|splitPane
operator|=
operator|new
name|JSplitPane
argument_list|(
name|JSplitPane
operator|.
name|VERTICAL_SPLIT
argument_list|)
expr_stmt|;
name|splitPane
operator|.
name|setDividerSize
argument_list|(
name|GUIGlobals
operator|.
name|SPLIT_PANE_DIVIDER_SIZE
argument_list|)
expr_stmt|;
comment|// We replace the default FocusTraversalPolicy with a subclass
comment|// that only allows FieldEditor components to gain keyboard focus,
comment|// if there is an entry editor open.
comment|/*splitPane.setFocusTraversalPolicy(new LayoutFocusTraversalPolicy() {                 protected boolean accept(Component c) {                     Util.pr("jaa");                     if (showing == null)                         return super.accept(c);                     else                         return (super.accept(c)&&                                 (c instanceof FieldEditor));                 }                 });*/
name|createMainTable
argument_list|()
expr_stmt|;
for|for
control|(
name|EntryEditor
name|ee
range|:
name|entryEditors
operator|.
name|values
argument_list|()
control|)
block|{
name|ee
operator|.
name|validateAllFields
argument_list|()
expr_stmt|;
block|}
name|splitPane
operator|.
name|setTopComponent
argument_list|(
name|mainTable
operator|.
name|getPane
argument_list|()
argument_list|)
expr_stmt|;
comment|// Remove borders
name|splitPane
operator|.
name|setBorder
argument_list|(
name|BorderFactory
operator|.
name|createEmptyBorder
argument_list|()
argument_list|)
expr_stmt|;
name|setBorder
argument_list|(
name|BorderFactory
operator|.
name|createEmptyBorder
argument_list|()
argument_list|)
expr_stmt|;
comment|//setupTable();
comment|// If an entry is currently being shown, make sure it stays shown,
comment|// otherwise set the bottom component to null.
if|if
condition|(
name|mode
operator|==
name|SHOWING_PREVIEW
condition|)
block|{
name|mode
operator|=
name|SHOWING_NOTHING
expr_stmt|;
name|int
name|row
init|=
name|mainTable
operator|.
name|findEntry
argument_list|(
name|currentPreview
operator|.
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|row
operator|>=
literal|0
condition|)
name|mainTable
operator|.
name|setRowSelectionInterval
argument_list|(
name|row
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|SHOWING_EDITOR
condition|)
block|{
name|mode
operator|=
name|SHOWING_NOTHING
expr_stmt|;
comment|/*int row = mainTable.findEntry(currentEditor.entry);             if (row>= 0)                 mainTable.setRowSelectionInterval(row, row);             */
comment|//showEntryEditor(currentEditor);
block|}
else|else
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|setLayout
argument_list|(
operator|new
name|BorderLayout
argument_list|()
argument_list|)
expr_stmt|;
name|removeAll
argument_list|()
expr_stmt|;
name|add
argument_list|(
name|splitPane
argument_list|,
name|BorderLayout
operator|.
name|CENTER
argument_list|)
expr_stmt|;
comment|// Set up name autocompleter for search:
comment|//if (!Globals.prefs.getBoolean("searchAutoComplete")) {
name|instantiateSearchAutoCompleter
argument_list|()
expr_stmt|;
name|this
operator|.
name|getDatabase
argument_list|()
operator|.
name|addDatabaseChangeListener
argument_list|(
operator|new
name|SearchAutoCompleterUpdater
argument_list|()
argument_list|)
expr_stmt|;
comment|// Set up AutoCompleters for this panel:
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"autoComplete"
argument_list|)
condition|)
block|{
name|instantiateAutoCompleters
argument_list|()
expr_stmt|;
comment|// ensure that the autocompleters are in sync with entries
name|this
operator|.
name|getDatabase
argument_list|()
operator|.
name|addDatabaseChangeListener
argument_list|(
operator|new
name|AutoCompletersUpdater
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|splitPane
operator|.
name|revalidate
argument_list|()
expr_stmt|;
name|revalidate
argument_list|()
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
block|}
DECL|method|updateSearchManager ()
specifier|public
name|void
name|updateSearchManager
parameter_list|()
block|{
name|frame
operator|.
name|getSearchManager
argument_list|()
operator|.
name|setAutoCompleteListener
argument_list|(
name|searchCompleteListener
argument_list|)
expr_stmt|;
block|}
DECL|method|getAutoCompleters ()
specifier|public
name|HashMap
argument_list|<
name|String
argument_list|,
name|AbstractAutoCompleter
argument_list|>
name|getAutoCompleters
parameter_list|()
block|{
return|return
name|autoCompleters
return|;
block|}
DECL|method|getAutoCompleter (String fieldName)
specifier|public
name|AbstractAutoCompleter
name|getAutoCompleter
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
name|autoCompleters
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
DECL|method|instantiateSearchAutoCompleter ()
specifier|private
name|void
name|instantiateSearchAutoCompleter
parameter_list|()
block|{
name|searchCompleter
operator|=
operator|new
name|NameFieldAutoCompleter
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"author"
block|,
literal|"editor"
block|}
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|searchAutoCompleterHM
operator|.
name|put
argument_list|(
literal|"x"
argument_list|,
name|searchCompleter
argument_list|)
expr_stmt|;
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|database
operator|.
name|getEntries
argument_list|()
control|)
block|{
name|Util
operator|.
name|updateCompletersForEntry
argument_list|(
name|searchAutoCompleterHM
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|searchCompleteListener
operator|=
operator|new
name|AutoCompleteListener
argument_list|(
name|searchCompleter
argument_list|)
expr_stmt|;
name|searchCompleteListener
operator|.
name|setConsumeEnterKey
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// So you don't have to press Enter twice
block|}
DECL|method|instantiateAutoCompleters ()
specifier|private
name|void
name|instantiateAutoCompleters
parameter_list|()
block|{
name|autoCompleters
operator|.
name|clear
argument_list|()
expr_stmt|;
name|String
index|[]
name|completeFields
init|=
name|Globals
operator|.
name|prefs
operator|.
name|getStringArray
argument_list|(
literal|"autoCompleteFields"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|completeFields
control|)
block|{
name|AbstractAutoCompleter
name|autoCompleter
init|=
name|AutoCompleterFactory
operator|.
name|getFor
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|autoCompleters
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|autoCompleter
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BibtexEntry
name|entry
range|:
name|database
operator|.
name|getEntries
argument_list|()
control|)
block|{
name|Util
operator|.
name|updateCompletersForEntry
argument_list|(
name|autoCompleters
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|addJournalListToAutoCompleter
argument_list|()
expr_stmt|;
name|addContentSelectorValuesToAutoCompleters
argument_list|()
expr_stmt|;
block|}
comment|/**      * For all fields with both autocompletion and content selector, add content selector      * values to the autocompleter list:      */
DECL|method|addContentSelectorValuesToAutoCompleters ()
specifier|public
name|void
name|addContentSelectorValuesToAutoCompleters
parameter_list|()
block|{
for|for
control|(
name|String
name|field
range|:
name|autoCompleters
operator|.
name|keySet
argument_list|()
control|)
block|{
name|AbstractAutoCompleter
name|ac
init|=
name|autoCompleters
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|metaData
operator|.
name|getData
argument_list|(
name|Globals
operator|.
name|SELECTOR_META_PREFIX
operator|+
name|field
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|Vector
argument_list|<
name|String
argument_list|>
name|items
init|=
name|metaData
operator|.
name|getData
argument_list|(
name|Globals
operator|.
name|SELECTOR_META_PREFIX
operator|+
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|items
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|item
range|:
name|items
control|)
name|ac
operator|.
name|addWordToIndex
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * If an autocompleter exists for the "journal" field, add all      * journal names in the journal abbreviation list to this autocompleter.      */
DECL|method|addJournalListToAutoCompleter ()
specifier|public
name|void
name|addJournalListToAutoCompleter
parameter_list|()
block|{
if|if
condition|(
name|autoCompleters
operator|.
name|containsKey
argument_list|(
literal|"journal"
argument_list|)
condition|)
block|{
name|AbstractAutoCompleter
name|ac
init|=
name|autoCompleters
operator|.
name|get
argument_list|(
literal|"journal"
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|journals
init|=
name|Globals
operator|.
name|journalAbbrev
operator|.
name|getJournals
argument_list|()
operator|.
name|keySet
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|journal
range|:
name|journals
control|)
name|ac
operator|.
name|addWordToIndex
argument_list|(
name|journal
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*     public void refreshTable() {         //System.out.println("hiding="+hidingNonHits+"\tlastHits="+lastSearchHits);         // This method is called by EntryTypeForm when a field value is         // stored. The table is scheduled for repaint.         entryTable.assureNotEditing();         //entryTable.invalidate();         BibtexEntry[] bes = entryTable.getSelectedEntries();     if (hidingNonHits)         tableModel.update(lastSearchHits);     else         tableModel.update();     //tableModel.remap();         if ((bes != null)&& (bes.length> 0))             selectEntries(bes, 0);      //long toc = System.currentTimeMillis();     //	Util.pr("Refresh took: "+(toc-tic)+" ms");     } */
DECL|method|updatePreamble ()
specifier|public
name|void
name|updatePreamble
parameter_list|()
block|{
if|if
condition|(
name|preambleEditor
operator|!=
literal|null
condition|)
name|preambleEditor
operator|.
name|updatePreamble
argument_list|()
expr_stmt|;
block|}
DECL|method|assureStringDialogNotEditing ()
specifier|public
name|void
name|assureStringDialogNotEditing
parameter_list|()
block|{
if|if
condition|(
name|stringDialog
operator|!=
literal|null
condition|)
name|stringDialog
operator|.
name|assureNotEditing
argument_list|()
expr_stmt|;
block|}
DECL|method|updateStringDialog ()
specifier|public
name|void
name|updateStringDialog
parameter_list|()
block|{
if|if
condition|(
name|stringDialog
operator|!=
literal|null
condition|)
name|stringDialog
operator|.
name|refreshTable
argument_list|()
expr_stmt|;
block|}
DECL|method|updateEntryPreviewToRow (BibtexEntry e)
specifier|public
name|void
name|updateEntryPreviewToRow
parameter_list|(
name|BibtexEntry
name|e
parameter_list|)
block|{      }
DECL|method|adjustSplitter ()
specifier|public
name|void
name|adjustSplitter
parameter_list|()
block|{
name|int
name|mode
init|=
name|getMode
argument_list|()
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|SHOWING_PREVIEW
condition|)
block|{
name|splitPane
operator|.
name|setDividerLocation
argument_list|(
name|splitPane
operator|.
name|getHeight
argument_list|()
operator|-
name|Globals
operator|.
name|prefs
operator|.
name|getInt
argument_list|(
literal|"previewPanelHeight"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|splitPane
operator|.
name|setDividerLocation
argument_list|(
name|splitPane
operator|.
name|getHeight
argument_list|()
operator|-
name|Globals
operator|.
name|prefs
operator|.
name|getInt
argument_list|(
literal|"entryEditorHeight"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Stores the source view in the entry editor, if one is open, has the source view      * selected and the source has been edited.      * @return boolean false if there is a validation error in the source panel, true otherwise.      */
DECL|method|entryEditorAllowsChange ()
specifier|public
name|boolean
name|entryEditorAllowsChange
parameter_list|()
block|{
name|Component
name|c
init|=
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|c
operator|instanceof
name|EntryEditor
operator|)
condition|)
block|{
return|return
operator|(
operator|(
name|EntryEditor
operator|)
name|c
operator|)
operator|.
name|lastSourceAccepted
argument_list|()
return|;
block|}
else|else
return|return
literal|true
return|;
block|}
DECL|method|moveFocusToEntryEditor ()
specifier|public
name|void
name|moveFocusToEntryEditor
parameter_list|()
block|{
name|Component
name|c
init|=
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|c
operator|instanceof
name|EntryEditor
operator|)
condition|)
block|{
operator|new
name|FocusRequester
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|isShowingEditor ()
specifier|public
name|boolean
name|isShowingEditor
parameter_list|()
block|{
return|return
operator|(
operator|(
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|instanceof
name|EntryEditor
operator|)
operator|)
return|;
block|}
DECL|method|showEntry (final BibtexEntry be)
specifier|public
name|void
name|showEntry
parameter_list|(
specifier|final
name|BibtexEntry
name|be
parameter_list|)
block|{
if|if
condition|(
name|getShowing
argument_list|()
operator|==
name|be
condition|)
block|{
if|if
condition|(
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// This is the special occasion when showing is set to an
comment|// entry, but no entry editor is in fact shown. This happens
comment|// after Preferences dialog is closed, and it means that we
comment|// must make sure the same entry is shown again. We do this by
comment|// setting showing to null, and recursively calling this method.
name|newEntryShowing
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|showEntry
argument_list|(
name|be
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The correct entry is already being shown. Make sure the editor
comment|// is updated.
operator|(
operator|(
name|EntryEditor
operator|)
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|)
operator|.
name|updateAllFields
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
name|EntryEditor
name|form
decl_stmt|;
name|int
name|divLoc
init|=
operator|-
literal|1
decl_stmt|;
name|String
name|visName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|getShowing
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|isShowingEditor
argument_list|()
condition|)
block|{
name|visName
operator|=
operator|(
operator|(
name|EntryEditor
operator|)
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|)
operator|.
name|getVisiblePanelName
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|getShowing
argument_list|()
operator|!=
literal|null
condition|)
name|divLoc
operator|=
name|splitPane
operator|.
name|getDividerLocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|entryEditors
operator|.
name|containsKey
argument_list|(
name|be
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
comment|// We already have an editor for this entry type.
name|form
operator|=
name|entryEditors
operator|.
name|get
argument_list|(
operator|(
name|be
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|form
operator|.
name|switchTo
argument_list|(
name|be
argument_list|)
expr_stmt|;
if|if
condition|(
name|visName
operator|!=
literal|null
condition|)
name|form
operator|.
name|setVisiblePanel
argument_list|(
name|visName
argument_list|)
expr_stmt|;
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
name|form
argument_list|)
expr_stmt|;
comment|//highlightEntry(be);
block|}
else|else
block|{
comment|// We must instantiate a new editor for this type.
name|form
operator|=
operator|new
name|EntryEditor
argument_list|(
name|frame
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|,
name|be
argument_list|)
expr_stmt|;
if|if
condition|(
name|visName
operator|!=
literal|null
condition|)
name|form
operator|.
name|setVisiblePanel
argument_list|(
name|visName
argument_list|)
expr_stmt|;
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
name|form
argument_list|)
expr_stmt|;
comment|//highlightEntry(be);
name|entryEditors
operator|.
name|put
argument_list|(
name|be
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|form
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|divLoc
operator|>
literal|0
condition|)
block|{
name|splitPane
operator|.
name|setDividerLocation
argument_list|(
name|divLoc
argument_list|)
expr_stmt|;
block|}
else|else
name|splitPane
operator|.
name|setDividerLocation
argument_list|(
name|splitPane
operator|.
name|getHeight
argument_list|()
operator|-
name|Globals
operator|.
name|prefs
operator|.
name|getInt
argument_list|(
literal|"entryEditorHeight"
argument_list|)
argument_list|)
expr_stmt|;
comment|//new FocusRequester(form);
comment|//form.requestFocus();
name|newEntryShowing
argument_list|(
name|be
argument_list|)
expr_stmt|;
name|setEntryEditorEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Make sure it is enabled.
block|}
comment|/**      * Get an entry editor ready to edit the given entry. If an appropriate editor is already      * cached, it will be updated and returned.      * @param entry The entry to be edited.      * @return A suitable entry editor.      */
DECL|method|getEntryEditor (BibtexEntry entry)
specifier|public
name|EntryEditor
name|getEntryEditor
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|)
block|{
name|EntryEditor
name|form
decl_stmt|;
if|if
condition|(
name|entryEditors
operator|.
name|containsKey
argument_list|(
name|entry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|EntryEditor
name|visibleNow
init|=
name|currentEditor
decl_stmt|;
comment|// We already have an editor for this entry type.
name|form
operator|=
name|entryEditors
operator|.
name|get
argument_list|(
operator|(
name|entry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|)
argument_list|)
expr_stmt|;
comment|// If the cached editor is not the same as the currently shown one,
comment|// make sure the current one stores its current edit:
if|if
condition|(
operator|(
name|visibleNow
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|form
operator|!=
name|visibleNow
operator|)
condition|)
block|{
name|visibleNow
operator|.
name|storeCurrentEdit
argument_list|()
expr_stmt|;
block|}
name|form
operator|.
name|switchTo
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|//if (visName != null)
comment|//    form.setVisiblePanel(visName);
block|}
else|else
block|{
comment|// We must instantiate a new editor for this type. First make sure the old one
comment|// stores its last edit:
name|storeCurrentEdit
argument_list|()
expr_stmt|;
comment|// Then start the new one:
name|form
operator|=
operator|new
name|EntryEditor
argument_list|(
name|frame
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|//if (visName != null)
comment|//    form.setVisiblePanel(visName);
name|entryEditors
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|form
argument_list|)
expr_stmt|;
block|}
return|return
name|form
return|;
block|}
DECL|method|getCurrentEditor ()
specifier|public
name|EntryEditor
name|getCurrentEditor
parameter_list|()
block|{
return|return
name|currentEditor
return|;
block|}
comment|/**      * Sets the given entry editor as the bottom component in the split pane. If an entry editor already      * was shown, makes sure that the divider doesn't move.      * Updates the mode to SHOWING_EDITOR.      * @param editor The entry editor to add.      */
DECL|method|showEntryEditor (EntryEditor editor)
specifier|public
name|void
name|showEntryEditor
parameter_list|(
name|EntryEditor
name|editor
parameter_list|)
block|{
name|int
name|oldSplitterLocation
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|SHOWING_EDITOR
condition|)
name|Globals
operator|.
name|prefs
operator|.
name|putInt
argument_list|(
literal|"entryEditorHeight"
argument_list|,
name|splitPane
operator|.
name|getHeight
argument_list|()
operator|-
name|splitPane
operator|.
name|getDividerLocation
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|SHOWING_PREVIEW
condition|)
name|Globals
operator|.
name|prefs
operator|.
name|putInt
argument_list|(
literal|"previewPanelHeight"
argument_list|,
name|splitPane
operator|.
name|getHeight
argument_list|()
operator|-
name|splitPane
operator|.
name|getDividerLocation
argument_list|()
argument_list|)
expr_stmt|;
name|mode
operator|=
name|SHOWING_EDITOR
expr_stmt|;
name|currentEditor
operator|=
name|editor
expr_stmt|;
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
name|editor
argument_list|)
expr_stmt|;
if|if
condition|(
name|editor
operator|.
name|getEntry
argument_list|()
operator|!=
name|getShowing
argument_list|()
condition|)
name|newEntryShowing
argument_list|(
name|editor
operator|.
name|getEntry
argument_list|()
argument_list|)
expr_stmt|;
name|adjustSplitter
argument_list|()
expr_stmt|;
block|}
comment|/**      * Sets the given preview panel as the bottom component in the split panel.      * Updates the mode to SHOWING_PREVIEW.      * @param preview The preview to show.      */
DECL|method|showPreview (PreviewPanel preview)
specifier|public
name|void
name|showPreview
parameter_list|(
name|PreviewPanel
name|preview
parameter_list|)
block|{
name|mode
operator|=
name|SHOWING_PREVIEW
expr_stmt|;
name|currentPreview
operator|=
name|preview
expr_stmt|;
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
name|preview
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes the bottom component.      */
DECL|method|hideBottomComponent ()
specifier|public
name|void
name|hideBottomComponent
parameter_list|()
block|{
name|mode
operator|=
name|SHOWING_NOTHING
expr_stmt|;
name|splitPane
operator|.
name|setBottomComponent
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method selects the given entry, and scrolls it into view in the table.      * If an entryEditor is shown, it is given focus afterwards.      */
DECL|method|highlightEntry (final BibtexEntry be)
specifier|public
name|void
name|highlightEntry
parameter_list|(
specifier|final
name|BibtexEntry
name|be
parameter_list|)
block|{
comment|//SwingUtilities.invokeLater(new Thread() {
comment|//     public void run() {
specifier|final
name|int
name|row
init|=
name|mainTable
operator|.
name|findEntry
argument_list|(
name|be
argument_list|)
decl_stmt|;
if|if
condition|(
name|row
operator|>=
literal|0
condition|)
block|{
name|mainTable
operator|.
name|setRowSelectionInterval
argument_list|(
name|row
argument_list|,
name|row
argument_list|)
expr_stmt|;
comment|//entryTable.setActiveRow(row);
name|mainTable
operator|.
name|ensureVisible
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
comment|//     }
comment|//});
block|}
comment|/**      * This method is called from an EntryEditor when it should be closed. We relay      * to the selection listener, which takes care of the rest.      * @param editor The entry editor to close.      */
DECL|method|entryEditorClosing (EntryEditor editor)
specifier|public
name|void
name|entryEditorClosing
parameter_list|(
name|EntryEditor
name|editor
parameter_list|)
block|{
comment|// Store divider location for next time:
name|Globals
operator|.
name|prefs
operator|.
name|putInt
argument_list|(
literal|"entryEditorHeight"
argument_list|,
name|splitPane
operator|.
name|getHeight
argument_list|()
operator|-
name|splitPane
operator|.
name|getDividerLocation
argument_list|()
argument_list|)
expr_stmt|;
name|selectionListener
operator|.
name|entryEditorClosing
argument_list|(
name|editor
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method selects the given enties.      * If an entryEditor is shown, it is given focus afterwards.      */
comment|/*public void selectEntries(final BibtexEntry[] bes, final int toScrollTo) {          SwingUtilities.invokeLater(new Thread() {              public void run() {                  int rowToScrollTo = 0;                  entryTable.revalidate();                  entryTable.clearSelection();                  loop: for (int i=0; i<bes.length; i++) {                     if (bes[i] == null)                         continue loop;                     int row = tableModel.getNumberFromName(bes[i].getId());                     if (i==toScrollTo)                     rowToScrollTo = row;                     if (row>= 0)                         entryTable.addRowSelectionIntervalQuietly(row, row);                  }                  entryTable.ensureVisible(rowToScrollTo);                  Component comp = splitPane.getBottomComponent();                  //if (comp instanceof EntryEditor)                  //    comp.requestFocus();              }         });     } */
comment|/**      * Closes the entry editor if it is showing the given entry.      *      * @param be a<code>BibtexEntry</code> value      */
DECL|method|ensureNotShowing (BibtexEntry be)
specifier|public
name|void
name|ensureNotShowing
parameter_list|(
name|BibtexEntry
name|be
parameter_list|)
block|{
if|if
condition|(
operator|(
name|mode
operator|==
name|SHOWING_EDITOR
operator|)
operator|&&
operator|(
name|currentEditor
operator|.
name|getEntry
argument_list|()
operator|==
name|be
operator|)
condition|)
block|{
name|selectionListener
operator|.
name|entryEditorClosing
argument_list|(
name|currentEditor
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateEntryEditorIfShowing ()
specifier|public
name|void
name|updateEntryEditorIfShowing
parameter_list|()
block|{
if|if
condition|(
name|mode
operator|==
name|SHOWING_EDITOR
condition|)
block|{
if|if
condition|(
name|currentEditor
operator|.
name|getType
argument_list|()
operator|!=
name|currentEditor
operator|.
name|getEntry
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
comment|// The entry has changed type, so we must get a new editor.
name|newEntryShowing
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|EntryEditor
name|newEditor
init|=
name|getEntryEditor
argument_list|(
name|currentEditor
operator|.
name|getEntry
argument_list|()
argument_list|)
decl_stmt|;
name|showEntryEditor
argument_list|(
name|newEditor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|currentEditor
operator|.
name|updateAllFields
argument_list|()
expr_stmt|;
name|currentEditor
operator|.
name|updateSource
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * If an entry editor is showing, make sure its currently focused field      * stores its changes, if any.      */
DECL|method|storeCurrentEdit ()
specifier|public
name|void
name|storeCurrentEdit
parameter_list|()
block|{
if|if
condition|(
name|isShowingEditor
argument_list|()
condition|)
block|{
name|EntryEditor
name|editor
init|=
operator|(
name|EntryEditor
operator|)
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
decl_stmt|;
name|editor
operator|.
name|storeCurrentEdit
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * This method iterates through all existing entry editors in this      * BasePanel, telling each to update all its instances of      * FieldContentSelector. This is done to ensure that the list of words      * in each selector is up-to-date after the user has made changes in      * the Manage dialog.      */
DECL|method|updateAllContentSelectors ()
specifier|public
name|void
name|updateAllContentSelectors
parameter_list|()
block|{
for|for
control|(
name|String
name|s
range|:
name|entryEditors
operator|.
name|keySet
argument_list|()
control|)
block|{
name|EntryEditor
name|ed
init|=
name|entryEditors
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|ed
operator|.
name|updateAllContentSelectors
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|rebuildAllEntryEditors ()
specifier|public
name|void
name|rebuildAllEntryEditors
parameter_list|()
block|{
for|for
control|(
name|String
name|s
range|:
name|entryEditors
operator|.
name|keySet
argument_list|()
control|)
block|{
name|EntryEditor
name|ed
init|=
name|entryEditors
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|ed
operator|.
name|rebuildPanels
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|markBaseChanged ()
specifier|public
name|void
name|markBaseChanged
parameter_list|()
block|{
name|baseChanged
operator|=
literal|true
expr_stmt|;
comment|// Put an asterix behind the file name to indicate the
comment|// database has changed.
name|String
name|oldTitle
init|=
name|frame
operator|.
name|getTabTitle
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|oldTitle
operator|.
name|endsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|frame
operator|.
name|setTabTitle
argument_list|(
name|this
argument_list|,
name|oldTitle
operator|+
literal|"*"
argument_list|,
name|frame
operator|.
name|getTabTooltip
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|.
name|setWindowTitle
argument_list|()
expr_stmt|;
block|}
comment|// If the status line states that the base has been saved, we
comment|// remove this message, since it is no longer relevant. If a
comment|// different message is shown, we leave it.
if|if
condition|(
name|frame
operator|.
name|statusLine
operator|.
name|getText
argument_list|()
operator|.
name|startsWith
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Saved database"
argument_list|)
argument_list|)
condition|)
empty_stmt|;
name|frame
operator|.
name|output
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
DECL|method|markNonUndoableBaseChanged ()
specifier|public
name|void
name|markNonUndoableBaseChanged
parameter_list|()
block|{
name|nonUndoableChange
operator|=
literal|true
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
block|}
DECL|method|markChangedOrUnChanged ()
specifier|public
specifier|synchronized
name|void
name|markChangedOrUnChanged
parameter_list|()
block|{
if|if
condition|(
name|undoManager
operator|.
name|hasChanged
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|baseChanged
condition|)
block|{
name|markBaseChanged
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|baseChanged
operator|&&
operator|!
name|nonUndoableChange
condition|)
block|{
name|baseChanged
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|getFile
argument_list|()
operator|!=
literal|null
condition|)
name|frame
operator|.
name|setTabTitle
argument_list|(
name|BasePanel
operator|.
name|this
argument_list|,
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|getFile
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|frame
operator|.
name|setTabTitle
argument_list|(
name|BasePanel
operator|.
name|this
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"untitled"
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|frame
operator|.
name|setWindowTitle
argument_list|()
expr_stmt|;
block|}
comment|/**      * Selects a single entry, and scrolls the table to center it.      *      * @param pos Current position of entry to select.      *      */
DECL|method|selectSingleEntry (int pos)
specifier|public
name|void
name|selectSingleEntry
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|mainTable
operator|.
name|clearSelection
argument_list|()
expr_stmt|;
name|mainTable
operator|.
name|addRowSelectionInterval
argument_list|(
name|pos
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|mainTable
operator|.
name|scrollToCenter
argument_list|(
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* *      * Selects all entries with a non-zero value in the field      * @param field<code>String</code> field name.      */
comment|/*    public void selectResults(String field) {           LinkedList intervals = new LinkedList();           int prevStart = -1, prevToSel = 0;           // First we build a list of intervals to select, without touching the table.           for (int i = 0; i< entryTable.getRowCount(); i++) {             String value = (String) (database.getEntryById                                      (tableModel.getIdForRow(i)))                 .getField(field);             if ( (value != null)&& !value.equals("0")) {               if (prevStart< 0)                 prevStart = i;               prevToSel = i;             }             else if (prevStart>= 0) {               intervals.add(new int[] {prevStart, prevToSel});               prevStart = -1;             }           }           // Then select those intervals, if any.           if (intervals.size()> 0) {             entryTable.setSelectionListenerEnabled(false);             entryTable.clearSelection();             for (Iterator i=intervals.iterator(); i.hasNext();) {               int[] interval = (int[])i.next();               entryTable.addRowSelectionInterval(interval[0], interval[1]);             }             entryTable.setSelectionListenerEnabled(true);           }       */
DECL|method|setSearchMatcher (SearchMatcher matcher)
specifier|public
name|void
name|setSearchMatcher
parameter_list|(
name|SearchMatcher
name|matcher
parameter_list|)
block|{
name|searchFilterList
operator|.
name|setMatcher
argument_list|(
name|matcher
argument_list|)
expr_stmt|;
name|showingSearch
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|setGroupMatcher (Matcher<BibtexEntry> matcher)
specifier|public
name|void
name|setGroupMatcher
parameter_list|(
name|Matcher
argument_list|<
name|BibtexEntry
argument_list|>
name|matcher
parameter_list|)
block|{
name|groupFilterList
operator|.
name|setMatcher
argument_list|(
name|matcher
argument_list|)
expr_stmt|;
name|showingGroup
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|stopShowingSearchResults ()
specifier|public
name|void
name|stopShowingSearchResults
parameter_list|()
block|{
name|searchFilterList
operator|.
name|setMatcher
argument_list|(
name|NoSearchMatcher
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|showingSearch
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|stopShowingGroup ()
specifier|public
name|void
name|stopShowingGroup
parameter_list|()
block|{
name|groupFilterList
operator|.
name|setMatcher
argument_list|(
name|NoSearchMatcher
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|showingGroup
operator|=
literal|false
expr_stmt|;
block|}
comment|/**      * Query whether this BasePanel is in the mode where a float search result is shown.      * @return true if showing float search, false otherwise.      */
DECL|method|isShowingFloatSearch ()
specifier|public
name|boolean
name|isShowingFloatSearch
parameter_list|()
block|{
return|return
name|mainTable
operator|.
name|isShowingFloatSearch
argument_list|()
return|;
block|}
comment|/**      * Query whether this BasePanel is in the mode where a filter search result is shown.      * @return true if showing filter search, false otherwise.      */
DECL|method|isShowingFilterSearch ()
specifier|public
name|boolean
name|isShowingFilterSearch
parameter_list|()
block|{
return|return
name|showingSearch
return|;
block|}
DECL|method|getDatabase ()
specifier|public
name|BibtexDatabase
name|getDatabase
parameter_list|()
block|{
return|return
name|database
return|;
block|}
DECL|method|preambleEditorClosing ()
specifier|public
name|void
name|preambleEditorClosing
parameter_list|()
block|{
name|preambleEditor
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|stringsClosing ()
specifier|public
name|void
name|stringsClosing
parameter_list|()
block|{
name|stringDialog
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|changeType (BibtexEntry entry, BibtexEntryType type)
specifier|public
name|void
name|changeType
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexEntryType
name|type
parameter_list|)
block|{
name|changeType
argument_list|(
operator|new
name|BibtexEntry
index|[]
block|{
name|entry
block|}
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
DECL|method|changeType (BibtexEntryType type)
specifier|public
name|void
name|changeType
parameter_list|(
name|BibtexEntryType
name|type
parameter_list|)
block|{
name|BibtexEntry
index|[]
name|bes
init|=
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
decl_stmt|;
name|changeType
argument_list|(
name|bes
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
DECL|method|changeType (BibtexEntry[] bes, BibtexEntryType type)
specifier|public
name|void
name|changeType
parameter_list|(
name|BibtexEntry
index|[]
name|bes
parameter_list|,
name|BibtexEntryType
name|type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|bes
operator|==
literal|null
operator|)
operator|||
operator|(
name|bes
operator|.
name|length
operator|==
literal|0
operator|)
condition|)
block|{
name|output
argument_list|(
literal|"First select the entries you wish to change type "
operator|+
literal|"for."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bes
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|int
name|choice
init|=
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|this
argument_list|,
literal|"Multiple entries selected. Do you want to change"
operator|+
literal|"\nthe type of all these to '"
operator|+
name|type
operator|.
name|getName
argument_list|()
operator|+
literal|"'?"
argument_list|,
literal|"Change type"
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_OPTION
argument_list|,
name|JOptionPane
operator|.
name|WARNING_MESSAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|choice
operator|==
name|JOptionPane
operator|.
name|NO_OPTION
condition|)
return|return;
block|}
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"change type"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|be
range|:
name|bes
control|)
block|{
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableChangeType
argument_list|(
name|be
argument_list|,
name|be
operator|.
name|getType
argument_list|()
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|be
operator|.
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Changed type to"
argument_list|)
operator|+
literal|" '"
operator|+
name|type
operator|.
name|getName
argument_list|()
operator|+
literal|"' "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"for"
argument_list|)
operator|+
literal|" "
operator|+
name|bes
operator|.
name|length
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|updateEntryEditorIfShowing
argument_list|()
expr_stmt|;
block|}
DECL|method|showDeleteConfirmationDialog (int numberOfEntries)
specifier|public
name|boolean
name|showDeleteConfirmationDialog
parameter_list|(
name|int
name|numberOfEntries
parameter_list|)
block|{
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"confirmDelete"
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Really delete the selected"
argument_list|)
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entry"
argument_list|)
operator|+
literal|"?"
decl_stmt|,
name|title
init|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Delete entry"
argument_list|)
decl_stmt|;
if|if
condition|(
name|numberOfEntries
operator|>
literal|1
condition|)
block|{
name|msg
operator|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Really delete the selected"
argument_list|)
operator|+
literal|" "
operator|+
name|numberOfEntries
operator|+
literal|" "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"entries"
argument_list|)
operator|+
literal|"?"
expr_stmt|;
name|title
operator|=
name|Globals
operator|.
name|lang
argument_list|(
literal|"Delete multiple entries"
argument_list|)
expr_stmt|;
block|}
name|CheckBoxMessage
name|cb
init|=
operator|new
name|CheckBoxMessage
argument_list|(
name|msg
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Disable this confirmation dialog"
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|answer
init|=
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|frame
argument_list|,
name|cb
argument_list|,
name|title
argument_list|,
name|JOptionPane
operator|.
name|YES_NO_OPTION
argument_list|,
name|JOptionPane
operator|.
name|QUESTION_MESSAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|cb
operator|.
name|isSelected
argument_list|()
condition|)
name|Globals
operator|.
name|prefs
operator|.
name|putBoolean
argument_list|(
literal|"confirmDelete"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|answer
operator|==
name|JOptionPane
operator|.
name|YES_OPTION
operator|)
return|;
block|}
else|else
return|return
literal|true
return|;
block|}
comment|/**      * If the relevant option is set, autogenerate keys for all entries that are      * lacking keys.      */
DECL|method|autoGenerateKeysBeforeSaving ()
specifier|public
name|void
name|autoGenerateKeysBeforeSaving
parameter_list|()
block|{
if|if
condition|(
name|Globals
operator|.
name|prefs
operator|.
name|getBoolean
argument_list|(
literal|"generateKeysBeforeSaving"
argument_list|)
condition|)
block|{
name|NamedCompound
name|ce
init|=
operator|new
name|NamedCompound
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"autogenerate keys"
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|any
init|=
literal|false
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|bes
range|:
name|database
operator|.
name|getEntries
argument_list|()
control|)
block|{
name|String
name|oldKey
init|=
name|bes
operator|.
name|getCiteKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|oldKey
operator|==
literal|null
operator|)
operator|||
operator|(
name|oldKey
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|)
condition|)
block|{
name|LabelPatternUtil
operator|.
name|makeLabel
argument_list|(
name|metaData
argument_list|,
name|database
argument_list|,
name|bes
argument_list|)
expr_stmt|;
name|ce
operator|.
name|addEdit
argument_list|(
operator|new
name|UndoableKeyChange
argument_list|(
name|database
argument_list|,
name|bes
operator|.
name|getId
argument_list|()
argument_list|,
literal|null
argument_list|,
name|bes
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|any
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Store undo information, if any:
if|if
condition|(
name|any
condition|)
block|{
name|ce
operator|.
name|end
argument_list|()
expr_stmt|;
name|undoManager
operator|.
name|addEdit
argument_list|(
name|ce
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Activates or deactivates the entry preview, depending on the argument.      * When deactivating, makes sure that any visible preview is hidden.      * @param enabled      */
DECL|method|setPreviewActive (boolean enabled)
specifier|public
name|void
name|setPreviewActive
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
name|selectionListener
operator|.
name|setPreviewActive
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
block|}
DECL|method|setSelectionListenerEnabled (boolean enabled)
specifier|public
name|void
name|setSelectionListenerEnabled
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
name|selectionListener
operator|.
name|setEnabled
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
block|}
comment|/**      * Depending on whether a preview or an entry editor is showing, save the current      * divider location in the correct preference setting.      */
DECL|method|saveDividerLocation ()
specifier|public
name|void
name|saveDividerLocation
parameter_list|()
block|{
if|if
condition|(
name|mode
operator|==
name|SHOWING_PREVIEW
condition|)
name|Globals
operator|.
name|prefs
operator|.
name|putInt
argument_list|(
literal|"previewPanelHeight"
argument_list|,
name|splitPane
operator|.
name|getHeight
argument_list|()
operator|-
name|splitPane
operator|.
name|getDividerLocation
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|SHOWING_EDITOR
condition|)
name|Globals
operator|.
name|prefs
operator|.
name|putInt
argument_list|(
literal|"entryEditorHeight"
argument_list|,
name|splitPane
operator|.
name|getHeight
argument_list|()
operator|-
name|splitPane
operator|.
name|getDividerLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|class|UndoAction
class|class
name|UndoAction
extends|extends
name|BaseAction
block|{
DECL|method|action ()
specifier|public
name|void
name|action
parameter_list|()
block|{
try|try
block|{
name|JComponent
name|focused
init|=
name|Globals
operator|.
name|focusListener
operator|.
name|getFocused
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|focused
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|focused
operator|instanceof
name|FieldEditor
operator|)
operator|&&
operator|(
name|focused
operator|.
name|hasFocus
argument_list|()
operator|)
condition|)
block|{
comment|// User is currently editing a field:
comment|// Check if it is the preamble:
if|if
condition|(
operator|(
name|preambleEditor
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|focused
operator|==
name|preambleEditor
operator|.
name|getFieldEditor
argument_list|()
operator|)
condition|)
block|{
name|preambleEditor
operator|.
name|storeCurrentEdit
argument_list|()
expr_stmt|;
block|}
else|else
name|storeCurrentEdit
argument_list|()
expr_stmt|;
block|}
name|String
name|name
init|=
name|undoManager
operator|.
name|getUndoPresentationName
argument_list|()
decl_stmt|;
name|undoManager
operator|.
name|undo
argument_list|()
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|frame
operator|.
name|output
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CannotUndoException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Nothing to undo"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
comment|// After everything, enable/disable the undo/redo actions
comment|// appropriately.
comment|//updateUndoState();
comment|//redoAction.updateRedoState();
name|markChangedOrUnChanged
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|RedoAction
class|class
name|RedoAction
extends|extends
name|BaseAction
block|{
DECL|method|action ()
specifier|public
name|void
name|action
parameter_list|()
block|{
try|try
block|{
name|JComponent
name|focused
init|=
name|Globals
operator|.
name|focusListener
operator|.
name|getFocused
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|focused
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|focused
operator|instanceof
name|FieldEditor
operator|)
operator|&&
operator|(
name|focused
operator|.
name|hasFocus
argument_list|()
operator|)
condition|)
block|{
comment|// User is currently editing a field:
name|storeCurrentEdit
argument_list|()
expr_stmt|;
block|}
name|String
name|name
init|=
name|undoManager
operator|.
name|getRedoPresentationName
argument_list|()
decl_stmt|;
name|undoManager
operator|.
name|redo
argument_list|()
expr_stmt|;
name|markBaseChanged
argument_list|()
expr_stmt|;
name|frame
operator|.
name|output
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CannotRedoException
name|ex
parameter_list|)
block|{
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Nothing to redo"
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
comment|// After everything, enable/disable the undo/redo actions
comment|// appropriately.
comment|//updateRedoState();
comment|//undoAction.updateUndoState();
name|markChangedOrUnChanged
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Method pertaining to the ClipboardOwner interface.
DECL|method|lostOwnership (Clipboard clipboard, Transferable contents)
specifier|public
name|void
name|lostOwnership
parameter_list|(
name|Clipboard
name|clipboard
parameter_list|,
name|Transferable
name|contents
parameter_list|)
block|{     }
DECL|method|setEntryEditorEnabled (boolean enabled)
specifier|public
name|void
name|setEntryEditorEnabled
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
if|if
condition|(
operator|(
name|getShowing
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
operator|instanceof
name|EntryEditor
operator|)
condition|)
block|{
name|EntryEditor
name|ed
init|=
operator|(
name|EntryEditor
operator|)
name|splitPane
operator|.
name|getBottomComponent
argument_list|()
decl_stmt|;
if|if
condition|(
name|ed
operator|.
name|isEnabled
argument_list|()
operator|!=
name|enabled
condition|)
name|ed
operator|.
name|setEnabled
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|fileMonitorHandle ()
specifier|public
name|String
name|fileMonitorHandle
parameter_list|()
block|{
return|return
name|fileMonitorHandle
return|;
block|}
DECL|method|fileUpdated ()
specifier|public
name|void
name|fileUpdated
parameter_list|()
block|{
if|if
condition|(
name|saving
condition|)
return|return;
comment|// We are just saving the file, so this message is most likely due
comment|//if (updatedExternally) {
comment|//  return;
comment|//}
comment|// to bad timing. If not, we'll handle it on the next polling.
comment|//Util.pr("File '"+file.getPath()+"' has been modified.");
name|updatedExternally
operator|=
literal|true
expr_stmt|;
specifier|final
name|ChangeScanner
name|scanner
init|=
operator|new
name|ChangeScanner
argument_list|(
name|frame
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|,
name|BasePanel
operator|.
name|this
operator|.
name|getFile
argument_list|()
argument_list|)
decl_stmt|;
comment|// Adding the sidepane component is Swing work, so we must do this in the Swing
comment|// thread:
name|Runnable
name|t
init|=
operator|new
name|Runnable
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// Check if there is already a notification about external
comment|// changes:
name|boolean
name|hasAlready
init|=
name|sidePaneManager
operator|.
name|hasComponent
argument_list|(
name|FileUpdatePanel
operator|.
name|NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|hasAlready
condition|)
block|{
name|sidePaneManager
operator|.
name|hideComponent
argument_list|(
name|FileUpdatePanel
operator|.
name|NAME
argument_list|)
expr_stmt|;
name|sidePaneManager
operator|.
name|unregisterComponent
argument_list|(
name|FileUpdatePanel
operator|.
name|NAME
argument_list|)
expr_stmt|;
block|}
name|FileUpdatePanel
name|pan
init|=
operator|new
name|FileUpdatePanel
argument_list|(
name|frame
argument_list|,
name|BasePanel
operator|.
name|this
argument_list|,
name|sidePaneManager
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|scanner
argument_list|)
decl_stmt|;
name|sidePaneManager
operator|.
name|register
argument_list|(
name|FileUpdatePanel
operator|.
name|NAME
argument_list|,
name|pan
argument_list|)
expr_stmt|;
name|sidePaneManager
operator|.
name|show
argument_list|(
name|FileUpdatePanel
operator|.
name|NAME
argument_list|)
expr_stmt|;
comment|//setUpdatedExternally(false);
comment|//scanner.displayResult();
block|}
block|}
decl_stmt|;
comment|// Test: running scan automatically in background
if|if
condition|(
operator|(
name|BasePanel
operator|.
name|this
operator|.
name|getFile
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|Util
operator|.
name|waitForFileLock
argument_list|(
name|BasePanel
operator|.
name|this
operator|.
name|getFile
argument_list|()
argument_list|,
literal|10
argument_list|)
condition|)
block|{
comment|// The file is locked even after the maximum wait. Do nothing.
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"File updated externally, but change scan failed because the file is locked."
argument_list|)
expr_stmt|;
comment|// Perturb the stored timestamp so successive checks are made:
name|Globals
operator|.
name|fileUpdateMonitor
operator|.
name|perturbTimestamp
argument_list|(
name|getFileMonitorHandle
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|JabRefExecutorService
operator|.
name|INSTANCE
operator|.
name|executeWithLowPriorityInOwnThreadAndWait
argument_list|(
name|scanner
argument_list|)
expr_stmt|;
if|if
condition|(
name|scanner
operator|.
name|changesFound
argument_list|()
condition|)
block|{
name|SwingUtilities
operator|.
name|invokeLater
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setUpdatedExternally
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|//System.out.println("No changes found.");
block|}
block|}
DECL|method|fileRemoved ()
specifier|public
name|void
name|fileRemoved
parameter_list|()
block|{
name|Util
operator|.
name|pr
argument_list|(
literal|"File '"
operator|+
name|getFile
argument_list|()
operator|.
name|getPath
argument_list|()
operator|+
literal|"' has been deleted."
argument_list|)
expr_stmt|;
block|}
comment|/**      * Perform necessary cleanup when this BasePanel is closed.      */
DECL|method|cleanUp ()
specifier|public
name|void
name|cleanUp
parameter_list|()
block|{
if|if
condition|(
name|fileMonitorHandle
operator|!=
literal|null
condition|)
name|Globals
operator|.
name|fileUpdateMonitor
operator|.
name|removeUpdateListener
argument_list|(
name|fileMonitorHandle
argument_list|)
expr_stmt|;
comment|// Check if there is a FileUpdatePanel for this BasePanel being shown. If so,
comment|// remove it:
if|if
condition|(
name|sidePaneManager
operator|.
name|hasComponent
argument_list|(
literal|"fileUpdate"
argument_list|)
condition|)
block|{
name|FileUpdatePanel
name|fup
init|=
operator|(
name|FileUpdatePanel
operator|)
name|sidePaneManager
operator|.
name|getComponent
argument_list|(
literal|"fileUpdate"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fup
operator|.
name|getPanel
argument_list|()
operator|==
name|this
condition|)
block|{
name|sidePaneManager
operator|.
name|hideComponent
argument_list|(
literal|"fileUpdate"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|setUpdatedExternally (boolean b)
specifier|public
name|void
name|setUpdatedExternally
parameter_list|(
name|boolean
name|b
parameter_list|)
block|{
name|updatedExternally
operator|=
name|b
expr_stmt|;
block|}
comment|/**      * Get an array containing the currently selected entries.      * The array is stable and not changed if the selection changes      *      * @return An array containing the selected entries. Is never null.      */
DECL|method|getSelectedEntries ()
specifier|public
name|BibtexEntry
index|[]
name|getSelectedEntries
parameter_list|()
block|{
return|return
name|mainTable
operator|.
name|getSelectedEntries
argument_list|()
return|;
block|}
comment|/**      * Get the file where this database was last saved to or loaded from, if any.      *      * @return The relevant File, or null if none is defined.      */
DECL|method|getFile ()
specifier|public
name|File
name|getFile
parameter_list|()
block|{
return|return
name|metaData
operator|.
name|getFile
argument_list|()
return|;
block|}
comment|/**      * Get a String containing a comma-separated list of the bibtex keys      * of the selected entries.      *      * @return A comma-separated list of the keys of the selected entries.      */
DECL|method|getKeysForSelection ()
specifier|public
name|String
name|getKeysForSelection
parameter_list|()
block|{
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|String
name|citeKey
decl_stmt|;
comment|//, message = "";
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|BibtexEntry
name|bes
range|:
name|mainTable
operator|.
name|getSelected
argument_list|()
control|)
block|{
name|citeKey
operator|=
name|bes
operator|.
name|getField
argument_list|(
name|BibtexFields
operator|.
name|KEY_FIELD
argument_list|)
expr_stmt|;
comment|// if the key is empty we give a warning and ignore this entry
if|if
condition|(
name|citeKey
operator|==
literal|null
operator|||
name|citeKey
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|first
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|citeKey
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|append
argument_list|(
literal|","
argument_list|)
operator|.
name|append
argument_list|(
name|citeKey
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|getGroupSelector ()
specifier|public
name|GroupSelector
name|getGroupSelector
parameter_list|()
block|{
return|return
name|frame
operator|.
name|groupSelector
return|;
block|}
DECL|method|isUpdatedExternally ()
specifier|public
name|boolean
name|isUpdatedExternally
parameter_list|()
block|{
return|return
name|updatedExternally
return|;
block|}
DECL|method|getFileMonitorHandle ()
specifier|public
name|String
name|getFileMonitorHandle
parameter_list|()
block|{
return|return
name|fileMonitorHandle
return|;
block|}
DECL|method|setFileMonitorHandle (String fileMonitorHandle)
specifier|public
name|void
name|setFileMonitorHandle
parameter_list|(
name|String
name|fileMonitorHandle
parameter_list|)
block|{
name|this
operator|.
name|fileMonitorHandle
operator|=
name|fileMonitorHandle
expr_stmt|;
block|}
DECL|method|getSidePaneManager ()
specifier|public
name|SidePaneManager
name|getSidePaneManager
parameter_list|()
block|{
return|return
name|sidePaneManager
return|;
block|}
DECL|method|setNonUndoableChange (boolean nonUndoableChange)
specifier|public
name|void
name|setNonUndoableChange
parameter_list|(
name|boolean
name|nonUndoableChange
parameter_list|)
block|{
name|this
operator|.
name|nonUndoableChange
operator|=
name|nonUndoableChange
expr_stmt|;
block|}
DECL|method|setBaseChanged (boolean baseChanged)
specifier|public
name|void
name|setBaseChanged
parameter_list|(
name|boolean
name|baseChanged
parameter_list|)
block|{
name|this
operator|.
name|baseChanged
operator|=
name|baseChanged
expr_stmt|;
block|}
DECL|method|setSaving (boolean saving)
specifier|public
name|void
name|setSaving
parameter_list|(
name|boolean
name|saving
parameter_list|)
block|{
name|this
operator|.
name|saving
operator|=
name|saving
expr_stmt|;
block|}
DECL|method|isSaving ()
specifier|public
name|boolean
name|isSaving
parameter_list|()
block|{
return|return
name|saving
return|;
block|}
DECL|method|getShowing ()
specifier|public
name|BibtexEntry
name|getShowing
parameter_list|()
block|{
return|return
name|showing
return|;
block|}
comment|/**      * Update the pointer to the currently shown entry in all cases where the user has      * moved to a new entry, except when using Back and Forward commands. Also updates      * history for Back command, and clears history for Forward command.      * @param entry The entry that is now to be shown.      */
DECL|method|newEntryShowing (BibtexEntry entry)
specifier|public
name|void
name|newEntryShowing
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|)
block|{
comment|// If this call is the result of a Back or Forward operation, we must take
comment|// care not to make any history changes, since the necessary changes will
comment|// already have been done in the back() or forward() method:
if|if
condition|(
name|backOrForwardInProgress
condition|)
block|{
name|showing
operator|=
name|entry
expr_stmt|;
name|backOrForwardInProgress
operator|=
literal|false
expr_stmt|;
name|setBackAndForwardEnabledState
argument_list|()
expr_stmt|;
return|return;
block|}
name|nextEntries
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|showing
condition|)
block|{
comment|// Add the entry we are leaving to the history:
if|if
condition|(
name|showing
operator|!=
literal|null
condition|)
block|{
name|previousEntries
operator|.
name|add
argument_list|(
name|showing
argument_list|)
expr_stmt|;
if|if
condition|(
name|previousEntries
operator|.
name|size
argument_list|()
operator|>
name|GUIGlobals
operator|.
name|MAX_BACK_HISTORY_SIZE
condition|)
name|previousEntries
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|showing
operator|=
name|entry
expr_stmt|;
name|setBackAndForwardEnabledState
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Go back (if there is any recorded history) and update the histories for      * the Back and Forward commands.      */
DECL|method|back ()
specifier|private
name|void
name|back
parameter_list|()
block|{
if|if
condition|(
name|previousEntries
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|BibtexEntry
name|toShow
init|=
name|previousEntries
operator|.
name|get
argument_list|(
name|previousEntries
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|previousEntries
operator|.
name|remove
argument_list|(
name|previousEntries
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Add the entry we are going back from to the Forward history:
if|if
condition|(
name|showing
operator|!=
literal|null
condition|)
name|nextEntries
operator|.
name|add
argument_list|(
name|showing
argument_list|)
expr_stmt|;
name|backOrForwardInProgress
operator|=
literal|true
expr_stmt|;
comment|// to avoid the history getting updated erroneously
comment|//showEntry(toShow);
name|highlightEntry
argument_list|(
name|toShow
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|forward ()
specifier|private
name|void
name|forward
parameter_list|()
block|{
if|if
condition|(
name|nextEntries
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|BibtexEntry
name|toShow
init|=
name|nextEntries
operator|.
name|get
argument_list|(
name|nextEntries
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|nextEntries
operator|.
name|remove
argument_list|(
name|nextEntries
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Add the entry we are going forward from to the Back history:
if|if
condition|(
name|showing
operator|!=
literal|null
condition|)
name|previousEntries
operator|.
name|add
argument_list|(
name|showing
argument_list|)
expr_stmt|;
name|backOrForwardInProgress
operator|=
literal|true
expr_stmt|;
comment|// to avoid the history getting updated erroneously
comment|//showEntry(toShow);
name|highlightEntry
argument_list|(
name|toShow
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setBackAndForwardEnabledState ()
specifier|public
name|void
name|setBackAndForwardEnabledState
parameter_list|()
block|{
name|frame
operator|.
name|back
operator|.
name|setEnabled
argument_list|(
name|previousEntries
operator|.
name|size
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|frame
operator|.
name|forward
operator|.
name|setEnabled
argument_list|(
name|nextEntries
operator|.
name|size
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|class|SaveSelectedAction
specifier|private
class|class
name|SaveSelectedAction
extends|extends
name|BaseAction
block|{
DECL|field|saveType
specifier|private
specifier|final
name|DatabaseSaveType
name|saveType
decl_stmt|;
DECL|method|SaveSelectedAction (DatabaseSaveType saveType)
specifier|public
name|SaveSelectedAction
parameter_list|(
name|DatabaseSaveType
name|saveType
parameter_list|)
block|{
name|this
operator|.
name|saveType
operator|=
name|saveType
expr_stmt|;
block|}
DECL|method|action ()
specifier|public
name|void
name|action
parameter_list|()
throws|throws
name|Throwable
block|{
name|String
name|chosenFile
init|=
name|FileDialogs
operator|.
name|getNewFile
argument_list|(
name|frame
argument_list|,
operator|new
name|File
argument_list|(
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"workingDirectory"
argument_list|)
argument_list|)
argument_list|,
literal|".bib"
argument_list|,
name|JFileChooser
operator|.
name|SAVE_DIALOG
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|chosenFile
operator|!=
literal|null
condition|)
block|{
name|File
name|expFile
init|=
operator|new
name|File
argument_list|(
name|chosenFile
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|expFile
operator|.
name|exists
argument_list|()
operator|||
operator|(
name|JOptionPane
operator|.
name|showConfirmDialog
argument_list|(
name|frame
argument_list|,
literal|"'"
operator|+
name|expFile
operator|.
name|getName
argument_list|()
operator|+
literal|"' "
operator|+
name|Globals
operator|.
name|lang
argument_list|(
literal|"exists. Overwrite file?"
argument_list|)
argument_list|,
name|Globals
operator|.
name|lang
argument_list|(
literal|"Save database"
argument_list|)
argument_list|,
name|JOptionPane
operator|.
name|OK_CANCEL_OPTION
argument_list|)
operator|==
name|JOptionPane
operator|.
name|OK_OPTION
operator|)
condition|)
block|{
name|saveDatabase
argument_list|(
name|expFile
argument_list|,
literal|true
argument_list|,
name|Globals
operator|.
name|prefs
operator|.
name|get
argument_list|(
literal|"defaultEncoding"
argument_list|)
argument_list|,
name|saveType
argument_list|)
expr_stmt|;
comment|//runCommand("save");
name|frame
operator|.
name|getFileHistory
argument_list|()
operator|.
name|newFile
argument_list|(
name|expFile
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|frame
operator|.
name|output
argument_list|(
name|Globals
operator|.
name|lang
argument_list|(
literal|"Saved selected to"
argument_list|)
operator|+
literal|" '"
operator|+
name|expFile
operator|.
name|getPath
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

