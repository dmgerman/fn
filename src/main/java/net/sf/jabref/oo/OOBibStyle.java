begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 2003-2011 JabRef contributors.     This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License along     with this program; if not, write to the Free Software Foundation, Inc.,     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */
end_comment

begin_package
DECL|package|net.sf.jabref.oo
package|package
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|oo
package|;
end_package

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|AuthorList
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexDatabase
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|BibtexEntry
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|Globals
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|Layout
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|LayoutFormatter
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|jabref
operator|.
name|export
operator|.
name|layout
operator|.
name|LayoutHelper
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_comment
comment|/**  * This class embodies a bibliography formatting for OpenOffice, which is composed  * of the following elements:  *  * 1) Each OO bib entry type must have a formatting. A formatting is an array of elements, each  *    of which is either a piece of constant text, an entry field value, or a tab. Each element has  *    a character format associated with it.  *  * 2) Many field values (e.g. author) need to be formatted before input to OpenOffice. The style  *    has the responsibility of formatting all field values. Formatting is handled by 0-n  *    JabRef LayoutFormatter classes.  *  * 3) If the entries are not numbered, a citation marker must be produced for each entry. This  *    operation is performed for each JabRef BibtexEntry.  */
end_comment

begin_class
DECL|class|OOBibStyle
class|class
name|OOBibStyle
implements|implements
name|Comparable
argument_list|<
name|OOBibStyle
argument_list|>
block|{
DECL|field|UNDEFINED_CITATION_MARKER
specifier|public
specifier|static
specifier|final
name|String
name|UNDEFINED_CITATION_MARKER
init|=
literal|"??"
decl_stmt|;
DECL|field|name
specifier|private
name|String
name|name
init|=
literal|null
decl_stmt|;
DECL|field|journals
specifier|private
specifier|final
name|SortedSet
argument_list|<
name|String
argument_list|>
name|journals
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Formatter to be run on fields before they are used as part of citation marker:
DECL|field|fieldFormatter
specifier|private
specifier|final
name|LayoutFormatter
name|fieldFormatter
init|=
operator|new
name|OOPreFormatter
argument_list|()
decl_stmt|;
DECL|field|defaultBibLayout
specifier|private
name|Layout
name|defaultBibLayout
decl_stmt|;
comment|// reference layout mapped from entry type number:
DECL|field|bibLayout
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|Layout
argument_list|>
name|bibLayout
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Layout
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|properties
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|properties
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|citProperties
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|citProperties
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|numPattern
specifier|private
specifier|final
name|Pattern
name|numPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"-?\\d+"
argument_list|)
decl_stmt|;
DECL|field|valid
specifier|private
name|boolean
name|valid
init|=
literal|false
decl_stmt|;
DECL|field|NONE
specifier|private
specifier|final
specifier|static
name|int
name|NONE
init|=
literal|0
decl_stmt|;
DECL|field|LAYOUT
specifier|private
specifier|final
specifier|static
name|int
name|LAYOUT
init|=
literal|1
decl_stmt|;
DECL|field|PROPERTIES
specifier|private
specifier|final
specifier|static
name|int
name|PROPERTIES
init|=
literal|2
decl_stmt|;
DECL|field|CITATION
specifier|private
specifier|final
specifier|static
name|int
name|CITATION
init|=
literal|3
decl_stmt|;
DECL|field|NAME
specifier|private
specifier|final
specifier|static
name|int
name|NAME
init|=
literal|4
decl_stmt|;
DECL|field|JOURNALS
specifier|private
specifier|final
specifier|static
name|int
name|JOURNALS
init|=
literal|5
decl_stmt|;
DECL|field|LAYOUT_MRK
specifier|private
specifier|final
specifier|static
name|String
name|LAYOUT_MRK
init|=
literal|"LAYOUT"
decl_stmt|;
DECL|field|PROPERTIES_MARK
specifier|private
specifier|final
specifier|static
name|String
name|PROPERTIES_MARK
init|=
literal|"PROPERTIES"
decl_stmt|;
DECL|field|CITATION_MARK
specifier|private
specifier|final
specifier|static
name|String
name|CITATION_MARK
init|=
literal|"CITATION"
decl_stmt|;
DECL|field|NAME_MARK
specifier|private
specifier|final
specifier|static
name|String
name|NAME_MARK
init|=
literal|"NAME"
decl_stmt|;
DECL|field|JOURNALS_MARK
specifier|private
specifier|final
specifier|static
name|String
name|JOURNALS_MARK
init|=
literal|"JOURNALS"
decl_stmt|;
DECL|field|DEFAULT_MARK
specifier|private
specifier|final
specifier|static
name|String
name|DEFAULT_MARK
init|=
literal|"default"
decl_stmt|;
DECL|field|styleFile
specifier|private
name|File
name|styleFile
init|=
literal|null
decl_stmt|;
DECL|field|styleFileModificationTime
specifier|private
specifier|static
name|long
name|styleFileModificationTime
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
DECL|field|COMBINED_ENTRIES_SEPARATOR
specifier|private
specifier|final
name|String
name|COMBINED_ENTRIES_SEPARATOR
init|=
literal|"-"
decl_stmt|;
comment|//private Pattern quoted = Pattern.compile("\".*^\\\\\"");
DECL|field|quoted
specifier|private
specifier|final
name|Pattern
name|quoted
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\".*\""
argument_list|)
decl_stmt|;
DECL|method|OOBibStyle (File styleFile)
specifier|public
name|OOBibStyle
parameter_list|(
name|File
name|styleFile
parameter_list|)
throws|throws
name|Exception
block|{
name|this
argument_list|(
operator|new
name|FileReader
argument_list|(
name|styleFile
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|styleFile
operator|=
name|styleFile
expr_stmt|;
name|OOBibStyle
operator|.
name|styleFileModificationTime
operator|=
operator|(
name|styleFile
operator|)
operator|.
name|lastModified
argument_list|()
expr_stmt|;
block|}
DECL|method|OOBibStyle (Reader in)
specifier|public
name|OOBibStyle
parameter_list|(
name|Reader
name|in
parameter_list|)
throws|throws
name|Exception
block|{
comment|// Set default property values:
name|properties
operator|.
name|put
argument_list|(
literal|"Title"
argument_list|,
literal|"Bibliography"
argument_list|)
expr_stmt|;
name|properties
operator|.
name|put
argument_list|(
literal|"SortAlgorithm"
argument_list|,
literal|"alphanumeric"
argument_list|)
expr_stmt|;
name|properties
operator|.
name|put
argument_list|(
literal|"IsSortByPosition"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|properties
operator|.
name|put
argument_list|(
literal|"IsNumberEntries"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|properties
operator|.
name|put
argument_list|(
literal|"BracketBefore"
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
name|properties
operator|.
name|put
argument_list|(
literal|"BracketAfter"
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
name|properties
operator|.
name|put
argument_list|(
literal|"ReferenceParagraphFormat"
argument_list|,
literal|"Default"
argument_list|)
expr_stmt|;
name|properties
operator|.
name|put
argument_list|(
literal|"ReferenceHeaderParagraphFormat"
argument_list|,
literal|"Heading 1"
argument_list|)
expr_stmt|;
comment|// Set default properties for the citation marker:
name|citProperties
operator|.
name|put
argument_list|(
literal|"AuthorField"
argument_list|,
literal|"author/editor"
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"YearField"
argument_list|,
literal|"year"
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"MaxAuthors"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"MaxAuthorsFirst"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"AuthorSeparator"
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"AuthorLastSeparator"
argument_list|,
literal|"& "
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"AuthorLastSeparatorInText"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"EtAlString"
argument_list|,
literal|" et al."
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"YearSeparator"
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"InTextYearSeparator"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"BracketBefore"
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"BracketAfter"
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"CitationSeparator"
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"PageInfoSeparator"
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"GroupedNumbersSeparator"
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"MinimumGroupingCount"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"FormatCitations"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"CitationCharacterFormat"
argument_list|,
literal|"Default"
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"ItalicCitations"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"BoldCitations"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"SuperscriptCitations"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"SubscriptCitations"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"MultiCiteChronological"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"BibtexKeyCitations"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|citProperties
operator|.
name|put
argument_list|(
literal|"ItalicEtAl"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|initialize
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|method|getFile ()
specifier|public
name|File
name|getFile
parameter_list|()
block|{
return|return
name|styleFile
return|;
block|}
DECL|method|getJournals ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getJournals
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|journals
argument_list|)
return|;
block|}
DECL|method|initialize (Reader in)
specifier|private
name|void
name|initialize
parameter_list|(
name|Reader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|name
operator|=
literal|null
expr_stmt|;
name|readFormatFile
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
comment|/**      * If this style was initialized from a file on disk, reload the style      * if the file has been modified since it was read.      * @throws Exception      */
DECL|method|ensureUpToDate ()
specifier|public
name|void
name|ensureUpToDate
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|isUpToDate
argument_list|()
condition|)
block|{
name|reload
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * If this style was initialized from a file on disk, reload the style      * information.      * @throws Exception      */
DECL|method|reload ()
specifier|private
name|void
name|reload
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|styleFile
operator|!=
literal|null
condition|)
block|{
name|OOBibStyle
operator|.
name|styleFileModificationTime
operator|=
operator|(
name|styleFile
operator|)
operator|.
name|lastModified
argument_list|()
expr_stmt|;
name|initialize
argument_list|(
operator|new
name|FileReader
argument_list|(
name|styleFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * If this style was initialized from a file on disk, check whether the file      * is unmodified since initialization.      * @return true if the file has not been modified, false otherwise.      */
DECL|method|isUpToDate ()
specifier|private
name|boolean
name|isUpToDate
parameter_list|()
block|{
if|if
condition|(
name|styleFile
operator|!=
literal|null
condition|)
block|{
return|return
name|styleFile
operator|.
name|lastModified
argument_list|()
operator|==
name|OOBibStyle
operator|.
name|styleFileModificationTime
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
DECL|method|readFormatFile (Reader in)
specifier|private
name|void
name|readFormatFile
parameter_list|(
name|Reader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|// First read all the contents of the file:
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|in
operator|.
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
comment|// Break into separate lines:
name|String
index|[]
name|lines
init|=
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|"\n"
argument_list|)
decl_stmt|;
name|int
name|mode
init|=
name|OOBibStyle
operator|.
name|NONE
decl_stmt|;
for|for
control|(
name|String
name|line1
range|:
name|lines
control|)
block|{
name|String
name|line
init|=
name|line1
decl_stmt|;
if|if
condition|(
operator|(
name|line
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|line
operator|.
name|charAt
argument_list|(
name|line
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'\r'
operator|)
condition|)
block|{
name|line
operator|=
name|line
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|line
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Check for empty line or comment:
if|if
condition|(
operator|(
name|line
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
operator|||
operator|(
name|line
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'#'
operator|)
condition|)
block|{
continue|continue;
block|}
comment|// Check if we should change mode:
if|if
condition|(
name|line
operator|.
name|equals
argument_list|(
name|OOBibStyle
operator|.
name|NAME_MARK
argument_list|)
condition|)
block|{
name|mode
operator|=
name|OOBibStyle
operator|.
name|NAME
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|equals
argument_list|(
name|OOBibStyle
operator|.
name|LAYOUT_MRK
argument_list|)
condition|)
block|{
name|mode
operator|=
name|OOBibStyle
operator|.
name|LAYOUT
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|equals
argument_list|(
name|OOBibStyle
operator|.
name|PROPERTIES_MARK
argument_list|)
condition|)
block|{
name|mode
operator|=
name|OOBibStyle
operator|.
name|PROPERTIES
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|equals
argument_list|(
name|OOBibStyle
operator|.
name|CITATION_MARK
argument_list|)
condition|)
block|{
name|mode
operator|=
name|OOBibStyle
operator|.
name|CITATION
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|equals
argument_list|(
name|OOBibStyle
operator|.
name|JOURNALS_MARK
argument_list|)
condition|)
block|{
name|mode
operator|=
name|OOBibStyle
operator|.
name|JOURNALS
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|NAME
case|:
if|if
condition|(
name|line
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|name
operator|=
name|line
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
case|case
name|LAYOUT
case|:
name|handleStructureLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROPERTIES
case|:
name|handlePropertiesLine
argument_list|(
name|line
argument_list|,
name|properties
argument_list|)
expr_stmt|;
break|break;
case|case
name|CITATION
case|:
name|handlePropertiesLine
argument_list|(
name|line
argument_list|,
name|citProperties
argument_list|)
expr_stmt|;
break|break;
case|case
name|JOURNALS
case|:
name|handleJournalsLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Set validity boolean based on whether we found anything interesting
comment|// in the file:
if|if
condition|(
name|mode
operator|!=
name|OOBibStyle
operator|.
name|NONE
condition|)
block|{
name|valid
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**      * After initalizing this style from a file, this method can be used to check      * whether the file appeared to be a proper style file.      * @return true if the file could be parsed as a style file, false otherwise.      */
DECL|method|isValid ()
specifier|public
name|boolean
name|isValid
parameter_list|()
block|{
return|return
name|valid
return|;
block|}
comment|/**      * Parse a line providing bibliography structure information for an entry type.      * @param line The string containing the structure description.      * @throws IOException      */
DECL|method|handleStructureLine (String line)
specifier|private
name|void
name|handleStructureLine
parameter_list|(
name|String
name|line
parameter_list|)
block|{
name|int
name|index
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|"="
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|index
operator|>
literal|0
operator|)
operator|&&
operator|(
name|index
operator|<
operator|(
name|line
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|String
name|formatString
init|=
name|line
operator|.
name|substring
argument_list|(
name|index
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|//System.out.println("'"+line.substring(0, index)+"' : '"+formatString+"'");
name|boolean
name|setDefault
init|=
name|line
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
operator|.
name|equals
argument_list|(
name|OOBibStyle
operator|.
name|DEFAULT_MARK
argument_list|)
decl_stmt|;
name|String
name|type
init|=
name|line
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|Short
name|typeS
decl_stmt|;
try|try
block|{
comment|/*typeS = new Short(Short.parseShort(type));                 OOBibFormatParser parser = new OOBibFormatParser(new StringReader(formatString));                 PropertyValue[][] layout = parser.parse();*/
name|Layout
name|layout
init|=
operator|new
name|LayoutHelper
argument_list|(
operator|new
name|StringReader
argument_list|(
name|formatString
argument_list|)
argument_list|)
operator|.
name|getLayoutFromText
argument_list|(
name|Globals
operator|.
name|FORMATTER_PACKAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|setDefault
condition|)
block|{
name|defaultBibLayout
operator|=
name|layout
expr_stmt|;
block|}
else|else
block|{
name|bibLayout
operator|.
name|put
argument_list|(
name|type
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|layout
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Parse a line providing a property name and value.      * @param line The line containing the formatter names.      * @throws IOException      */
DECL|method|handlePropertiesLine (String line, HashMap<String, Object> map)
specifier|private
name|void
name|handlePropertiesLine
parameter_list|(
name|String
name|line
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
parameter_list|)
block|{
name|int
name|index
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|"="
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|index
operator|>
literal|0
operator|)
operator|&&
operator|(
name|index
operator|<=
operator|(
name|line
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|String
name|propertyName
init|=
name|line
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
name|value
init|=
name|line
operator|.
name|substring
argument_list|(
name|index
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|value
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|2
operator|)
operator|&&
name|quoted
operator|.
name|matcher
argument_list|(
name|value
operator|.
name|trim
argument_list|()
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|value
operator|=
name|value
operator|.
name|trim
argument_list|()
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|value
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|Object
name|toSet
init|=
name|value
decl_stmt|;
if|if
condition|(
name|numPattern
operator|.
name|matcher
argument_list|(
name|value
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|toSet
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|toLowerCase
argument_list|()
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|toSet
operator|=
name|Boolean
operator|.
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|toLowerCase
argument_list|()
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|toSet
operator|=
name|Boolean
operator|.
name|FALSE
expr_stmt|;
block|}
name|map
operator|.
name|put
argument_list|(
name|propertyName
argument_list|,
name|toSet
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Parse a line providing a journal name for which this style is valid.      * @param line      * @throws IOException      */
DECL|method|handleJournalsLine (String line)
specifier|private
name|void
name|handleJournalsLine
parameter_list|(
name|String
name|line
parameter_list|)
block|{
if|if
condition|(
name|line
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|journals
operator|.
name|add
argument_list|(
name|line
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getReferenceFormat (String type)
specifier|public
name|Layout
name|getReferenceFormat
parameter_list|(
name|String
name|type
parameter_list|)
block|{
name|Layout
name|l
init|=
name|bibLayout
operator|.
name|get
argument_list|(
name|type
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|!=
literal|null
condition|)
block|{
return|return
name|l
return|;
block|}
else|else
block|{
return|return
name|defaultBibLayout
return|;
block|}
block|}
comment|/**      * Get the array of elements composing the reference for a given entry type.      * @param bibType The OO type number.      * @return The format definition.      public PropertyValue[][] getReferenceFormat(short bibType) {         Object o = bibLayout.get(new Short(bibType));         if (o != null)             return (PropertyValue[][])o;         else             return defaultBibLayout;     }*/
comment|/**      * Format a number-based citation marker for the given number.      * @param number The citation numbers.      * @return The text for the citation.      */
DECL|method|getNumCitationMarker (int[] number, int minGroupingCount, boolean inList)
specifier|public
name|String
name|getNumCitationMarker
parameter_list|(
name|int
index|[]
name|number
parameter_list|,
name|int
name|minGroupingCount
parameter_list|,
name|boolean
name|inList
parameter_list|)
block|{
name|String
name|bracketBefore
init|=
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"BracketBefore"
argument_list|)
decl_stmt|;
if|if
condition|(
name|inList
operator|&&
operator|(
name|citProperties
operator|.
name|get
argument_list|(
literal|"BracketBeforeInList"
argument_list|)
operator|!=
literal|null
operator|)
condition|)
block|{
name|bracketBefore
operator|=
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"BracketBeforeInList"
argument_list|)
expr_stmt|;
block|}
name|String
name|bracketAfter
init|=
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"BracketAfter"
argument_list|)
decl_stmt|;
if|if
condition|(
name|inList
operator|&&
operator|(
name|citProperties
operator|.
name|get
argument_list|(
literal|"BracketAfterInList"
argument_list|)
operator|!=
literal|null
operator|)
condition|)
block|{
name|bracketAfter
operator|=
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"BracketAfterInList"
argument_list|)
expr_stmt|;
block|}
comment|// Sort the numbers:
name|int
index|[]
name|lNum
init|=
operator|new
name|int
index|[
name|number
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|number
argument_list|,
literal|0
argument_list|,
name|lNum
argument_list|,
literal|0
argument_list|,
name|lNum
operator|.
name|length
argument_list|)
expr_stmt|;
comment|//Arrays.copyOf(number, number.length);
name|Arrays
operator|.
name|sort
argument_list|(
name|lNum
argument_list|)
expr_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|bracketBefore
argument_list|)
decl_stmt|;
name|int
name|combineFrom
init|=
operator|-
literal|1
decl_stmt|,
name|written
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lNum
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|i1
init|=
name|lNum
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|combineFrom
operator|<
literal|0
condition|)
block|{
comment|// Check if next entry is the next in the ref list:
if|if
condition|(
operator|(
name|i
operator|<
operator|(
name|lNum
operator|.
name|length
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|lNum
index|[
name|i
operator|+
literal|1
index|]
operator|==
operator|(
name|i1
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
name|combineFrom
operator|=
name|i1
expr_stmt|;
block|}
else|else
block|{
comment|// Add single entry:
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"CitationSeparator"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|lNum
index|[
name|i
index|]
operator|>
literal|0
condition|?
name|String
operator|.
name|valueOf
argument_list|(
name|lNum
index|[
name|i
index|]
argument_list|)
else|:
name|OOBibStyle
operator|.
name|UNDEFINED_CITATION_MARKER
argument_list|)
expr_stmt|;
name|written
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// We are building a list of combined entries.
comment|// Check if it ends here:
if|if
condition|(
operator|(
name|i
operator|==
operator|(
name|lNum
operator|.
name|length
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|lNum
index|[
name|i
operator|+
literal|1
index|]
operator|!=
operator|(
name|i1
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|written
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"CitationSeparator"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|minGroupingCount
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|i1
operator|+
literal|1
operator|)
operator|-
name|combineFrom
operator|)
operator|>=
name|minGroupingCount
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|combineFrom
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"GroupedNumbersSeparator"
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|i1
argument_list|)
expr_stmt|;
name|written
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// Either we should never group, or there aren't enough
comment|// entries in this case to group. Output all:
for|for
control|(
name|int
name|jj
init|=
name|combineFrom
init|;
name|jj
operator|<=
name|i1
condition|;
name|jj
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|jj
argument_list|)
expr_stmt|;
if|if
condition|(
name|jj
operator|<
name|i1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"CitationSeparator"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|written
operator|++
expr_stmt|;
block|}
block|}
name|combineFrom
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|// If it doesn't end here, just keep iterating.
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
name|bracketAfter
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Format the marker for the in-text citation according to this bib style.      *      * @param entry The JabRef BibtexEntry providing the data.      * @param inParenthesis Signals whether a parenthesized citation or an in-text citation is wanted.      * @param uniquefier String to add behind the year in case it's needed to separate similar      *   entries.      * @return The formatted citation.      */
DECL|method|getCitationMarker (BibtexEntry entry, BibtexDatabase database, boolean inParenthesis, String uniquefier, int unlimAuthors)
specifier|public
name|String
name|getCitationMarker
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|,
name|boolean
name|inParenthesis
parameter_list|,
name|String
name|uniquefier
parameter_list|,
name|int
name|unlimAuthors
parameter_list|)
block|{
return|return
name|getCitationMarker
argument_list|(
operator|new
name|BibtexEntry
index|[]
block|{
name|entry
block|}
argument_list|,
name|database
argument_list|,
name|inParenthesis
argument_list|,
operator|new
name|String
index|[]
block|{
name|uniquefier
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
name|unlimAuthors
block|}
argument_list|)
return|;
block|}
comment|/**      * Format the marker for the in-text citation according to this bib style. Uniquefier letters are added as      * provided by the uniquefiers argument. If successive entries within the citation are uniquefied from each other,      * this method will perform a grouping of these entries.      *      * @param entries The array of JabRef BibtexEntry providing the data.      * @param inParenthesis Signals whether a parenthesized citation or an in-text citation is wanted.      * @param uniquefiers Strings to add behind the year for each entry in case it's needed to separate similar      *   entries.      * @param unlimAuthors Boolean for each entry. If true, we should not use "et al" formatting regardless      *   of the number of authors. Can be null to indicate that no entries should have unlimited names.      * @return The formatted citation.      */
DECL|method|getCitationMarker (BibtexEntry[] entries, BibtexDatabase database, boolean inParenthesis, String[] uniquefiers, int[] unlimAuthors)
specifier|public
name|String
name|getCitationMarker
parameter_list|(
name|BibtexEntry
index|[]
name|entries
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|,
name|boolean
name|inParenthesis
parameter_list|,
name|String
index|[]
name|uniquefiers
parameter_list|,
name|int
index|[]
name|unlimAuthors
parameter_list|)
block|{
comment|// Look for groups of uniquefied entries that should be combined in the output.
comment|// E.g. (Olsen, 2005a, b) should be output instead of (Olsen, 2005a; Olsen, 2005b).
name|int
name|piv
init|=
operator|-
literal|1
decl_stmt|;
name|String
name|tmpMarker
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|uniquefiers
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|uniquefiers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|uniquefiers
index|[
name|i
index|]
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|uniquefiers
index|[
name|i
index|]
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|String
name|authorField
init|=
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"AuthorField"
argument_list|)
decl_stmt|;
name|int
name|maxAuthors
init|=
operator|(
name|Integer
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"MaxAuthors"
argument_list|)
decl_stmt|;
if|if
condition|(
name|piv
operator|==
operator|-
literal|1
condition|)
block|{
name|piv
operator|=
name|i
expr_stmt|;
name|tmpMarker
operator|=
name|getAuthorYearParenthesisMarker
argument_list|(
operator|new
name|BibtexEntry
index|[]
block|{
name|entries
index|[
name|i
index|]
block|}
argument_list|,
name|database
argument_list|,
name|authorField
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"YearField"
argument_list|)
argument_list|,
name|maxAuthors
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"AuthorSeparator"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"AuthorLastSeparator"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"EtAlString"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"YearSeparator"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"BracketBefore"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"BracketAfter"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"CitationSeparator"
argument_list|)
argument_list|,
literal|null
argument_list|,
name|unlimAuthors
argument_list|)
expr_stmt|;
comment|//System.out.println("piv="+piv+" tmpMarker='"+tmpMarker+"'");
block|}
else|else
block|{
comment|// See if this entry can go into a group with the previous one:
name|String
name|thisMarker
init|=
name|getAuthorYearParenthesisMarker
argument_list|(
operator|new
name|BibtexEntry
index|[]
block|{
name|entries
index|[
name|i
index|]
block|}
argument_list|,
name|database
argument_list|,
name|authorField
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"YearField"
argument_list|)
argument_list|,
name|maxAuthors
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"AuthorSeparator"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"AuthorLastSeparator"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"EtAlString"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"YearSeparator"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"BracketBefore"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"BracketAfter"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"CitationSeparator"
argument_list|)
argument_list|,
literal|null
argument_list|,
name|unlimAuthors
argument_list|)
decl_stmt|;
name|String
name|author
init|=
name|getCitationMarkerField
argument_list|(
name|entries
index|[
name|i
index|]
argument_list|,
name|database
argument_list|,
name|authorField
argument_list|)
decl_stmt|;
name|AuthorList
name|al
init|=
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|author
argument_list|)
decl_stmt|;
comment|//System.out.println("i="+i+" thisMarker='"+thisMarker+"'");
name|int
name|prevALim
init|=
name|i
operator|>
literal|0
condition|?
name|unlimAuthors
index|[
name|i
operator|-
literal|1
index|]
else|:
name|unlimAuthors
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|thisMarker
operator|.
name|equals
argument_list|(
name|tmpMarker
argument_list|)
operator|||
operator|(
operator|(
name|al
operator|.
name|size
argument_list|()
operator|>
name|maxAuthors
operator|)
operator|&&
operator|(
name|unlimAuthors
index|[
name|i
index|]
operator|!=
name|prevALim
operator|)
operator|)
condition|)
block|{
comment|// No match. Update piv to exclude the previous entry. But first check if the
comment|// previous entry was part of a group:
if|if
condition|(
operator|(
name|piv
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|(
name|i
operator|>
operator|(
name|piv
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
comment|// Do the grouping:
name|group
argument_list|(
name|entries
argument_list|,
name|uniquefiers
argument_list|,
name|piv
argument_list|,
name|i
operator|-
literal|1
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"UniquefierSeparator"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tmpMarker
operator|=
name|thisMarker
expr_stmt|;
name|piv
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// This entry has no uniquefier.
comment|// Check if we just passed a group of more than one entry with uniquefier:
if|if
condition|(
operator|(
name|piv
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|(
name|i
operator|>
operator|(
name|piv
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
comment|// Do the grouping:
name|group
argument_list|(
name|entries
argument_list|,
name|uniquefiers
argument_list|,
name|piv
argument_list|,
name|i
operator|-
literal|1
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"UniquefierSeparator"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|piv
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|// Finished with the loop. See if the last entries form a group:
if|if
condition|(
name|piv
operator|>=
literal|0
condition|)
block|{
comment|// Do the grouping:
name|group
argument_list|(
name|entries
argument_list|,
name|uniquefiers
argument_list|,
name|piv
argument_list|,
name|uniquefiers
operator|.
name|length
operator|-
literal|1
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"UniquefierSeparator"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|inParenthesis
condition|)
block|{
return|return
name|getAuthorYearParenthesisMarker
argument_list|(
name|entries
argument_list|,
name|database
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"AuthorField"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"YearField"
argument_list|)
argument_list|,
operator|(
name|Integer
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"MaxAuthors"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"AuthorSeparator"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"AuthorLastSeparator"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"EtAlString"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"YearSeparator"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"BracketBefore"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"BracketAfter"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"CitationSeparator"
argument_list|)
argument_list|,
name|uniquefiers
argument_list|,
name|unlimAuthors
argument_list|)
return|;
block|}
else|else
block|{
name|String
name|authorLastSeparator
init|=
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"AuthorLastSeparator"
argument_list|)
decl_stmt|;
name|String
name|alsInText
init|=
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"AuthorLastSeparatorInText"
argument_list|)
decl_stmt|;
if|if
condition|(
name|alsInText
operator|!=
literal|null
condition|)
block|{
name|authorLastSeparator
operator|=
name|alsInText
expr_stmt|;
block|}
return|return
name|getAuthorYearInTextMarker
argument_list|(
name|entries
argument_list|,
name|database
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"AuthorField"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"YearField"
argument_list|)
argument_list|,
operator|(
name|Integer
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"MaxAuthors"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"AuthorSeparator"
argument_list|)
argument_list|,
name|authorLastSeparator
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"EtAlString"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"InTextYearSeparator"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"BracketBefore"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"BracketAfter"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"CitationSeparator"
argument_list|)
argument_list|,
name|uniquefiers
argument_list|,
name|unlimAuthors
argument_list|)
return|;
block|}
block|}
comment|/**      * Modify entry and uniqiefier arrays to facilitate a grouped presentation of uniqiefied entries.      * @param entries The entry array.      * @param uniquefiers The uniquefier array.      * @param from The first index to group (inclusive)      * @param to The last index to group (inclusive)      * @param separator The separator for the uniquefier letters.      */
DECL|method|group (BibtexEntry[] entries, String[] uniquefiers, int from, int to, String separator)
specifier|private
name|void
name|group
parameter_list|(
name|BibtexEntry
index|[]
name|entries
parameter_list|,
name|String
index|[]
name|uniquefiers
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|String
name|separator
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|uniquefiers
index|[
name|from
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|from
operator|+
literal|1
init|;
name|i
operator|<=
name|to
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|separator
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|uniquefiers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|entries
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
name|uniquefiers
index|[
name|from
index|]
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
comment|/**      * This method produces (Author, year) style citation strings in many different forms.      *      * @param entries The array of BibtexEntry to get fields from.      * @param authorField The bibtex field providing author names, e.g. "author" or "editor".      * @param yearField The bibtex field providing the year, e.g. "year".      * @param maxA The maximum number of authors to write out in full without using etal. Set to      *              -1 to always write out all authors.      * @param authorSep The String to add between author names except the last two, e.g. ", ".      * @param andString The String to add between the two last author names, e.g. "& ".      * @param etAlString The String to represent authors that are not mentioned, e.g. " et al."      * @param yearSep The String to separate authors from year, e.g. "; ".      * @param startBrace The opening parenthesis.      * @param endBrace The closing parenthesis.      * @param citationSeparator The String to separate citations from each other.      * @param uniquifiers Optional parameter to separate similar citations. Elements can be null if not needed.      * @return The formatted citation.      */
DECL|method|getAuthorYearParenthesisMarker (BibtexEntry[] entries, BibtexDatabase database, String authorField, String yearField, int maxA, String authorSep, String andString, String etAlString, String yearSep, String startBrace, String endBrace, String citationSeparator, String[] uniquifiers, int[] unlimAuthors)
specifier|private
name|String
name|getAuthorYearParenthesisMarker
parameter_list|(
name|BibtexEntry
index|[]
name|entries
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|,
name|String
name|authorField
parameter_list|,
name|String
name|yearField
parameter_list|,
name|int
name|maxA
parameter_list|,
name|String
name|authorSep
parameter_list|,
name|String
name|andString
parameter_list|,
name|String
name|etAlString
parameter_list|,
name|String
name|yearSep
parameter_list|,
name|String
name|startBrace
parameter_list|,
name|String
name|endBrace
parameter_list|,
name|String
name|citationSeparator
parameter_list|,
name|String
index|[]
name|uniquifiers
parameter_list|,
name|int
index|[]
name|unlimAuthors
parameter_list|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|(
name|startBrace
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|entries
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|int
name|unlimA
init|=
operator|(
name|unlimAuthors
operator|!=
literal|null
condition|?
name|unlimAuthors
index|[
name|j
index|]
else|:
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|maxAuthors
init|=
name|unlimA
operator|>
literal|0
condition|?
name|unlimA
else|:
name|maxA
decl_stmt|;
name|BibtexEntry
name|entry
init|=
name|entries
index|[
name|j
index|]
decl_stmt|;
comment|// Check if this entry has been nulled due to grouping with the previous entry(ies):
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|citationSeparator
argument_list|)
expr_stmt|;
block|}
name|String
name|author
init|=
name|getCitationMarkerField
argument_list|(
name|entry
argument_list|,
name|database
argument_list|,
name|authorField
argument_list|)
decl_stmt|;
if|if
condition|(
name|author
operator|!=
literal|null
condition|)
block|{
name|AuthorList
name|al
init|=
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|author
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getAuthorLastName
argument_list|(
name|al
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|al
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|(
name|al
operator|.
name|size
argument_list|()
operator|<=
name|maxAuthors
operator|)
operator|||
operator|(
name|maxAuthors
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
operator|(
name|al
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|authorSep
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getAuthorLastName
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|andString
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getAuthorLastName
argument_list|(
name|al
argument_list|,
name|al
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|al
operator|.
name|size
argument_list|()
operator|>
name|maxAuthors
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|etAlString
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|yearSep
argument_list|)
expr_stmt|;
block|}
name|String
name|year
init|=
name|getCitationMarkerField
argument_list|(
name|entry
argument_list|,
name|database
argument_list|,
name|yearField
argument_list|)
decl_stmt|;
if|if
condition|(
name|year
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|year
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|uniquifiers
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|uniquifiers
index|[
name|j
index|]
operator|!=
literal|null
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|uniquifiers
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
name|endBrace
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This method produces "Author (year)" style citation strings in many different forms.      *      * @param entries The array of BibtexEntry to get fields from.      * @param authorField The bibtex field providing author names, e.g. "author" or "editor".      * @param yearField The bibtex field providing the year, e.g. "year".      * @param maxA The maximum number of authors to write out in full without using etal. Set to      *              -1 to always write out all authors.      * @param authorSep The String to add between author names except the last two, e.g. ", ".      * @param andString The String to add between the two last author names, e.g. "& ".      * @param etAlString The String to represent authors that are not mentioned, e.g. " et al."      * @param yearSep The String to separate authors from year, e.g. "; ".      * @param startBrace The opening parenthesis.      * @param endBrace The closing parenthesis.      * @param uniquefiers Optional parameters to separate similar citations. Can be null if not needed.      * @return The formatted citation.      */
DECL|method|getAuthorYearInTextMarker (BibtexEntry[] entries, BibtexDatabase database, String authorField, String yearField, int maxA, String authorSep, String andString, String etAlString, String yearSep, String startBrace, String endBrace, String citationSeparator, String[] uniquefiers, int[] unlimAuthors)
specifier|private
name|String
name|getAuthorYearInTextMarker
parameter_list|(
name|BibtexEntry
index|[]
name|entries
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|,
name|String
name|authorField
parameter_list|,
name|String
name|yearField
parameter_list|,
name|int
name|maxA
parameter_list|,
name|String
name|authorSep
parameter_list|,
name|String
name|andString
parameter_list|,
name|String
name|etAlString
parameter_list|,
name|String
name|yearSep
parameter_list|,
name|String
name|startBrace
parameter_list|,
name|String
name|endBrace
parameter_list|,
name|String
name|citationSeparator
parameter_list|,
name|String
index|[]
name|uniquefiers
parameter_list|,
name|int
index|[]
name|unlimAuthors
parameter_list|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|entries
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|unlimA
init|=
operator|(
name|unlimAuthors
operator|!=
literal|null
condition|?
name|unlimAuthors
index|[
name|i
index|]
else|:
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|maxAuthors
init|=
name|unlimA
operator|>
literal|0
condition|?
name|unlimA
else|:
name|maxA
decl_stmt|;
comment|// Check if this entry has been nulled due to grouping with the previous entry(ies):
if|if
condition|(
name|entries
index|[
name|i
index|]
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|citationSeparator
argument_list|)
expr_stmt|;
block|}
name|String
name|author
init|=
name|getCitationMarkerField
argument_list|(
name|entries
index|[
name|i
index|]
argument_list|,
name|database
argument_list|,
name|authorField
argument_list|)
decl_stmt|;
if|if
condition|(
name|author
operator|!=
literal|null
condition|)
block|{
name|AuthorList
name|al
init|=
name|AuthorList
operator|.
name|getAuthorList
argument_list|(
name|author
argument_list|)
decl_stmt|;
if|if
condition|(
name|al
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|getAuthorLastName
argument_list|(
name|al
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|al
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|(
name|al
operator|.
name|size
argument_list|()
operator|<=
name|maxAuthors
operator|)
operator|||
operator|(
name|maxAuthors
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|int
name|j
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|j
operator|<
operator|(
name|al
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|authorSep
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getAuthorLastName
argument_list|(
name|al
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|andString
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getAuthorLastName
argument_list|(
name|al
argument_list|,
name|al
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|al
operator|.
name|size
argument_list|()
operator|>
name|maxAuthors
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|etAlString
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|yearSep
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|startBrace
argument_list|)
expr_stmt|;
name|String
name|year
init|=
name|getCitationMarkerField
argument_list|(
name|entries
index|[
name|i
index|]
argument_list|,
name|database
argument_list|,
name|yearField
argument_list|)
decl_stmt|;
if|if
condition|(
name|year
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|year
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|uniquefiers
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|uniquefiers
index|[
name|i
index|]
operator|!=
literal|null
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|uniquefiers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|endBrace
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This method looks up a field for en entry in a database. Any number of backup fields can be used      * if the primary field is empty.      * @param entry The entry.      * @param database The database the entry belongs to.      * @param field The field, or succession of fields, to look up. If backup fields are needed, separate      *   field names by /. E.g. to use "author" with "editor" as backup, specify "author/editor".      * @return The resolved field content, or an empty string if the field(s) were empty.      */
DECL|method|getCitationMarkerField (BibtexEntry entry, BibtexDatabase database, String field)
specifier|private
name|String
name|getCitationMarkerField
parameter_list|(
name|BibtexEntry
name|entry
parameter_list|,
name|BibtexDatabase
name|database
parameter_list|,
name|String
name|field
parameter_list|)
block|{
name|String
index|[]
name|fields
init|=
name|field
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|fields
control|)
block|{
name|String
name|content
init|=
name|BibtexDatabase
operator|.
name|getResolvedField
argument_list|(
name|s
argument_list|,
name|entry
argument_list|,
name|database
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|content
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|content
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|fieldFormatter
operator|!=
literal|null
condition|)
block|{
name|content
operator|=
name|fieldFormatter
operator|.
name|format
argument_list|(
name|content
argument_list|)
expr_stmt|;
block|}
return|return
name|content
return|;
block|}
block|}
comment|// No luck? Return an empty string:
return|return
literal|""
return|;
block|}
comment|/**      * Look up the nth author and return the proper last name for citation markers.      * @param al The author list.      * @param number The number of the author to return.      * @return The author name, or an empty String if inapplicable.      */
DECL|method|getAuthorLastName (AuthorList al, int number)
specifier|private
name|String
name|getAuthorLastName
parameter_list|(
name|AuthorList
name|al
parameter_list|,
name|int
name|number
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|al
operator|.
name|size
argument_list|()
operator|>
name|number
condition|)
block|{
name|AuthorList
operator|.
name|Author
name|a
init|=
name|al
operator|.
name|getAuthor
argument_list|(
name|number
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|.
name|getVon
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|a
operator|.
name|getVon
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|String
name|von
init|=
name|a
operator|.
name|getVon
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|von
argument_list|)
expr_stmt|;
comment|/*sb.append(von.substring(0, 1).toUpperCase());                 if (von.length()> 1)                     sb.append(von.substring(1));*/
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|a
operator|.
name|getLast
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Take a finished citation and insert a string at the end (but inside the end bracket)      * separated by "PageInfoSeparator"      * @param citation      * @param pageInfo      * @return      */
DECL|method|insertPageInfo (String citation, String pageInfo)
specifier|public
name|String
name|insertPageInfo
parameter_list|(
name|String
name|citation
parameter_list|,
name|String
name|pageInfo
parameter_list|)
block|{
name|String
name|bracketAfter
init|=
name|getStringCitProperty
argument_list|(
literal|"BracketAfter"
argument_list|)
decl_stmt|;
if|if
condition|(
name|citation
operator|.
name|endsWith
argument_list|(
name|bracketAfter
argument_list|)
condition|)
block|{
name|String
name|first
init|=
name|citation
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|citation
operator|.
name|length
argument_list|()
operator|-
name|bracketAfter
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|first
operator|+
name|getStringCitProperty
argument_list|(
literal|"PageInfoSeparator"
argument_list|)
operator|+
name|pageInfo
operator|+
name|bracketAfter
return|;
block|}
else|else
block|{
return|return
name|citation
operator|+
name|getStringCitProperty
argument_list|(
literal|"PageInfoSeparator"
argument_list|)
operator|+
name|pageInfo
return|;
block|}
block|}
comment|/**      * Convenience method for checking the property for whether we use number citations or      * author-year citations.      * @return true if we use numbered citations, false otherwise.      */
DECL|method|isNumberEntries ()
specifier|public
name|boolean
name|isNumberEntries
parameter_list|()
block|{
return|return
operator|(
name|Boolean
operator|)
name|getProperty
argument_list|(
literal|"IsNumberEntries"
argument_list|)
return|;
block|}
comment|/**      * Convenience method for checking the property for whether we sort the bibliography      * according to their order of appearance in the text.      * @return true to sort by appearance, false to sort alphabetically.      */
DECL|method|isSortByPosition ()
specifier|public
name|boolean
name|isSortByPosition
parameter_list|()
block|{
return|return
operator|(
name|Boolean
operator|)
name|getProperty
argument_list|(
literal|"IsSortByPosition"
argument_list|)
return|;
block|}
comment|/**      * Convenience method for checking whether citation markers should be italicised.      * Will only be relevant if isFormatCitations() returns true.      * @return true to indicate that citations should be in italics.      */
DECL|method|isItalicCitations ()
specifier|public
name|boolean
name|isItalicCitations
parameter_list|()
block|{
return|return
operator|(
name|Boolean
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"ItalicCitations"
argument_list|)
return|;
block|}
comment|/**      * Convenience method for checking whether citation markers should be bold.      * Will only be relevant if isFormatCitations() returns true.      * @return true to indicate that citations should be in bold.      */
DECL|method|isBoldCitations ()
specifier|public
name|boolean
name|isBoldCitations
parameter_list|()
block|{
return|return
operator|(
name|Boolean
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"BoldCitations"
argument_list|)
return|;
block|}
comment|/**      * Convenience method for checking whether citation markers formatted      * according to the results of the isItalicCitations() and      * isBoldCitations() methods.      * @return true to indicate that citations should be in italics.      */
DECL|method|isFormatCitations ()
specifier|public
name|boolean
name|isFormatCitations
parameter_list|()
block|{
return|return
operator|(
name|Boolean
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"FormatCitations"
argument_list|)
return|;
block|}
DECL|method|isBibtexKeyCiteMarkers ()
specifier|public
name|boolean
name|isBibtexKeyCiteMarkers
parameter_list|()
block|{
return|return
operator|(
name|Boolean
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"BibtexKeyCitations"
argument_list|)
return|;
block|}
comment|/**      * Get boolean property.      * @param key The property key      * @return the value      */
DECL|method|getBooleanCitProperty (String key)
specifier|public
name|boolean
name|getBooleanCitProperty
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
operator|(
name|Boolean
operator|)
name|citProperties
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|getIntCitProperty (String key)
specifier|public
name|int
name|getIntCitProperty
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
operator|(
name|Integer
operator|)
name|citProperties
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|getStringCitProperty (String key)
specifier|public
name|String
name|getStringCitProperty
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|getCitationCharacterFormat ()
specifier|public
name|String
name|getCitationCharacterFormat
parameter_list|()
block|{
return|return
operator|(
name|String
operator|)
name|citProperties
operator|.
name|get
argument_list|(
literal|"CitationCharacterFormat"
argument_list|)
return|;
block|}
comment|/**      * Get a style property.      * @param name The property name.      * @return The property value, or null if it doesn't exist.      */
DECL|method|getProperty (String name)
specifier|public
name|Object
name|getProperty
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|properties
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|compareTo (OOBibStyle other)
specifier|public
name|int
name|compareTo
parameter_list|(
name|OOBibStyle
name|other
parameter_list|)
block|{
return|return
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|other
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|styleFile
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|OOBibStyle
operator|)
name|o
operator|)
operator|.
name|styleFile
argument_list|)
return|;
block|}
block|}
end_class

end_unit

